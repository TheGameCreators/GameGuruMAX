//
// VS2017 (32bit) having trouble with large GridEdit.cpp file, so split into two
//

// Includes 
#include "stdafx.h"
#include "gameguru.h"
#include "M-WelcomeSystem.h"
#include "M-Widget.h"
#include "GGVR.h"
#include "M-GridEditB.h"

#include <algorithm>
#include <string>
#include <time.h>
#include <wininet.h>
#include <mmsystem.h>
#include "ShlObj.h"
#include "sha1.h"
#include "sha2.h"
#include "miniz.h"
#include "Nlohmann JSON/json.hpp"

#include "M-RPG.h"
#include "M-Workshop.h"

//#define PETESTING
#ifdef PETESTING
#include "..\Imgui\imgui_demo.cpp"
#endif

// Globals
#ifndef PRODUCTCLASSIC
extern int iGenralWindowsFlags ;
extern bool bBoostIconColors;
#endif

// Namespaces
#ifdef WICKEDENGINE
#include "shellapi.h"
#include ".\\..\..\\Guru-WickedMAX\\GPUParticles.h"
using namespace GPUParticles;
#include "GGTerrain/GGTerrain.h"
using namespace GGTerrain;
#include "GGTerrain/GGTrees.h"
using namespace GGTrees;
#include "GGTerrain/GGGrass.h"
using namespace GGGrass;
using namespace wiScene;
#endif

#ifdef STORYBOARD
#include "..\..\GameGuru\Imgui\imnodes.h"
#include "..\..\GameGuru\Imgui\imnodes_internal.h"
extern ImNodesContext* GImNodes;
#endif

#ifdef OPTICK_ENABLE
#include "optick.h"
#endif

// Externs
extern int grideleprof_uniqui_id;
#define MAXTEXTINPUT 1024
extern float g_Storyboard_header_height;
extern char cTmpInput[MAXTEXTINPUT + 1];
extern int g_Storyboard_First_Level_Node;
extern int g_Storyboard_Current_Level;
extern char g_Storyboard_First_fpm[256];
extern char g_Storyboard_Current_fpm[256];
extern char g_Storyboard_Current_lua[256];
extern char g_Storyboard_Current_Loading_Page[256];
extern std::vector<std::string> projectbank_list;
extern std::vector<std::string> projectbank_image;
extern std::vector<int> projectbank_imageid;
extern StoryboardStruct Storyboard;
extern StoryboardStruct checkproject;
StoryboardStruct tempProjectData;
extern std::vector< std::pair<ImFont*, std::string>> StoryboardFonts;
extern bool bScreen_Editor_Window;
extern int iScreen_Editor_Node;
extern int iStoryboardExecuteKey;
extern bool bTriggerSaveAs;
extern bool bTriggerOpenProject;
extern int iDelayTriggerOpenProject;
extern bool bTriggerSaveAsAfterNewLevel;
extern char SaveProjectAsName[256];
extern char SaveProjectAsError[256];
extern bool bTriggerWhatsNewInStoryboard;
extern bool bAddWhatNewToMenu;
extern bool bOpenProjectsFromWelcome;
extern cstr TriggerLoadGameProject;
extern bool bStoryboardFirstRunSetInitPos;
extern bool bStoryboardInitNodes;
extern bool bJustRederedScreenEditor;
extern bool g_bUpdateAppAvailable;
extern bool g_bAdjustPlaneXZUsingSurfaceXZ;
extern bool g_bResetPlaneAfterXZAdjust;
extern bool g_bHoldGridEntityPosWhenManaged;
extern float g_fHoldGridEntityPosX;
extern float g_fHoldGridEntityPosY;
extern float g_fHoldGridEntityPosZ;
extern float g_fLocalTurnRotationForSmartMode ;
extern int g_iStackToSurfaceMode;
extern int g_iOrientToSurfaceMode;
extern sObject* g_selected_editor_object;
extern int g_selected_editor_objectID;
extern XMFLOAT4 g_selected_editor_color;
//extern bool bEditorGridFitObjectSize;
extern int iEditorGridSizeX;
extern int iEditorGridSizeZ;
extern bool bRenderTabTab;
extern bool bRenderNextFrame;
extern bool bNeedImGuiInput;
extern bool bProfilerEnable;
extern int iExtractMode;
extern float fExtractYValue, fExtractFixedYValue;
extern bool bExtractFixPivot;
extern bool g_bStandaloneSinglePlayer;
extern bool g_bStandaloneMultiPlayer;
extern bool g_bStandaloneVRMode;
extern bool g_bPreviewLighting;
extern int iLastOpenHeader;
extern int iExecuteCTRLkey;
extern int iExecuteALTkey;
extern int iIncludeLeftIconSet;
extern uint64_t g_hovered_dot_entity;
extern sObject* g_hovered_dot_pobject;
extern sObject* g_destination_dot_pobject;
extern sObject* g_source_dot_pobject;
extern sObject* g_selected_middle_dot_pobject;
extern bool bDotMiddleWindow;
extern ImVec2 vDotMiddleWindowPos;
#define MAXDOTMIDDLE 1000
#define DOTOBJECTIDADD 40000
#define DOTCURSOROBJECTID (70001+40000+20000)
#define DOTMIDDLEOBJECTID (70001+40000+20001)
#define MAXDOTARCSOBJECTS 20000
#define DOTARCSOBJECTID (70001+40000+20001+MAXDOTMIDDLE+1000000)
#define RELATIONOBJECTID (70001+40000+20001+MAXDOTMIDDLE)
#define RELATIONOBJECTMAX 1000
extern int iLargestDotObjectID;
extern int iLargestDotCount;
extern bool bDotObjectDragging;
extern int iDotMiddleInfoSource[MAXDOTMIDDLE];
extern int iDotMiddleInfoDestination[MAXDOTMIDDLE];
extern int iDotMiddleColor[MAXDOTMIDDLE];
extern int iDotArceColor[MAXDOTARCSOBJECTS];
extern int iDotMiddleInfoSourceType[MAXDOTMIDDLE];
extern int iDotMiddleInfoDestinationType[MAXDOTMIDDLE];
extern float fLastHitPosition[4];
extern int iCursorDotObject;
extern bool bFactionWindow[16];
extern float fDrawDotCircleTimer;
extern bool bDrawDotCircle;
extern float fDrawDotCircleRadius;
extern int fDrawDotCircleFrom;
extern bool g_bDotsAreVisible;
#define BACKBUFFERIMAGE (g.perentitypromptimageoffset+9000)
extern int BackBufferObjectID;
extern bool BackBufferSnapShotMode;
extern bool BackBufferGrabGameScreen;
extern bool BackBufferParticlesMode;
extern int iBackBufferParticlesTrigger;
extern int BackBufferParticleEmitter;
extern bool bFullScreenBackbuffer;
extern bool bSnapShotModeUseCamera;
extern bool bSnapShotModeUse2D;
extern float fSnapShotModeCameraX, fSnapShotModeCameraY, fSnapShotModeCameraZ;
extern float fSnapShotModeCameraAngX, fSnapShotModeCameraAngY, fSnapShotModeCameraAngZ;
extern cstr g_LastGroupSaved_s;
extern bool g_bBehaviorEditorActive;
extern bool library_createbehavior;
extern char library_newbehaviorname[256];
extern bool BackBufferIsGroup;
extern int BackBufferEntityID;
extern int BackBufferImageID;
extern int BackBufferSizeX;
extern int BackBufferSizeY;
extern float BackBufferRotateY, RestoreBackBufferRotateY;
extern float BackBufferRotateX, RestoreBackBufferRotateX;
extern float BackBufferRotateZ, RestoreBackBufferRotateZ;
extern float BackBufferZoom, RestoreBackBufferZoom;
extern float BackBufferCamMove;
extern float BackBufferCamLeft, RestoreBackBufferCamLeft;
extern float BackBufferCamUp, RestoreBackBufferCamUp;
extern bool bBackBufferAnimated;
extern bool bBackBufferRestoreCamera;
extern bool bEditorInFreeFlightMode;
extern bool bLoopBackBuffer;
extern bool bLoopFullFPS;
extern bool bRotateBackBuffer;
extern cstr BackBufferCacheName;
extern cstr ProjectCacheName;
extern cstr BackBufferSaveCacheName;
extern std::vector<sImageList> g_imageList;
static std::vector<sImageList> g_TempimageList;
extern int iRestoreEntidMaster;
extern int fpe_current_loaded_script;
extern int fpe_current_loaded_script_image;
extern int fpe_current_loaded_script_image_count;

extern bool bReadyToDropEntity;
extern bool bWaitOnMouseRelease;
extern bool bDraggingActive;
extern bool bDraggingActiveInitial;
extern int iDragDropActive;
#define HITPOINTYSTARTPOS GGORIGIN_Y
extern float fHitPointX, fHitPointY, fHitPointZ;
extern float fHitOffsetX, fHitOffsetY, fHitOffsetZ;
extern float fHitRayFrom, fLastHitY;
extern sObject* g_hovered_pobject;
extern bool bTriggerVisibleWidget;
extern bool bMouseInputSystemUsed;
extern int iLastHitObjectID;
extern int iStartMouseX, iStartMouseY;
extern int iObjectMoveMode;
extern int iObjectMoveModeDropSystem;
extern int iObjectMoveModeDropSystemUsing;
extern bool bObjectAllowOverlapping;
extern float fDebug, fDebug1, fDebug2, fDebug3;
extern int i_switch_group_tab;
extern int current_selected_group;
extern bool group_editing_on;
extern bool bCreateNewGroupOnNextDrop;
extern int iLastEntityOnCursor;
extern float fLastRubberBandX1;
extern float fLastRubberBandX2;
extern float fLastRubberBandY1;
extern float fLastRubberBandY2;
extern bool bDetectTerrainOnly;
extern bool bRubberBandCreated;
extern bool bDragCameraActive;
extern bool g_bThumbBankCopyMode;
extern bool g_bRefreshRotationValuesFromObjectOnce;
extern bool g_bLightProbeScaleChanged;
extern int iReusePickObjectID;
extern int iReusePickEntityID;
extern float fReusePickHitX, fReusePickHitY, fReusePickHitZ;
extern sObject* pReusePickObject;
extern std::vector<sLibraryList> g_LibraryFileList;
extern cStr cLastProjectList;
extern cstr cCurrentBackDropImageFile;
extern bool bUseBackDropImage;
extern cstr cUseBackbufferCubemap;
extern bool bBackbufferCubemapActive;
extern int iLastSelectedEntityGroup;
extern int iLastSelectedEntity;
extern int iSetSettingsFocusTab;
extern bool bStoryboardWindow;
extern bool bStoryboardWindowOpenLoad;
extern bool bMarketplace_Window;
extern bool bTriggerCloseEntityWindow;
extern bool bMarketplace_Init;
extern cstr sDefaultImportPath;
extern bool bResetObjectLibrarySize;
extern bool bWelcomeScreen_Window;
extern bool bWelcomeNoBackButton;
extern bool bWelcomeScreen_Init;
extern std::map<std::string, int> selected_library_fpe;
extern bool bProceduralLevel;
extern bool bProceduralLevelFromStoryboard;
extern int iBlackoutForFrames;
extern int iQuitProceduralLevel;
extern bool bProceduralLevelStartup;
extern int g_iUniqueGroupID;
extern cstr sGotoPreviewWithFile;
extern int iGotoPreviewType;
extern int init_Left_Categories_Column_Width;
extern int g_iDevToolsOpen;
extern bool bInvulnerableMode;
extern bool bStartInvulnerableMode;
extern int iWelcomeHeaderType;
extern int iAboutLogoType;
//#endif //WICKEDENGINE
extern bool bTrashcanIconActive, bTrashcanIconActive2;
extern int current_sort_order;
extern int iWidgetSelection;
extern bool bRotScaleAlreadyUpdated;
//extern float fEditorGridOffsetX;
//extern float fEditorGridOffsetY;
//extern float fEditorGridOffsetZ;
//extern float fEditorGridSizeX;
//extern float fEditorGridSizeY;
//extern float fEditorGridSizeZ;
extern int old_iMSAASampleCount;
extern int old_iFSRMode;
extern int old_iMSAO;
extern float old_fMSAOPower;
extern int old_iShadowSpotCascadeResolution;
extern int old_iShadowSpotResolution;
extern int old_iShadowPointResolution;
extern bool bForceRefreshLightCount;
extern int iUpdateOcean;
extern bool bEditorLight;
extern cStr sNextLevelToLoad;
#ifdef WICKEDENGINE
extern float fMouseWheelZoomFactor;
extern bool g_bResetCameraToFreeFlightOnNewLevel;
extern float fLocalMax;
#else
extern float fMouseWheelZoomFactor;
#endif
extern bool g_occluderf9Mode;
extern bool g_bSkipTerrainRender;
extern bool g_bBlackListRemovedSomeEntities;
extern bool gbWelcomeSystemActive;
extern int g_iWelcomeLoopPage;
extern int g_trialStampDaysLeft;
extern int g_tstoreprojectmodifiedstatic;
extern preferences pref;
extern cFolderItem MainEntityList;
extern bool g_occluderf9Mode;
extern bool g_bBlackListRemovedSomeEntities;
extern bool gbWelcomeSystemActive;
extern int g_iWelcomeLoopPage;
extern int g_trialStampDaysLeft;
extern int g_tstoreprojectmodifiedstatic;
#ifdef VRTECH
extern bool g_bCharacterCreatorPlusActivated;
extern bool g_bDisableQuitFlag;
extern bool bEnableWeather;
extern char cImGuiDebug[2048];
extern bool bForceKey;
extern int iForceScancode;
extern cstr csForceKey;
extern bool bForceKey2;
extern cstr csForceKey2;
extern bool bForceUndo;
extern bool bForceRedo;
extern int iLaunchAfterSync;
extern int iLaunchAfterSyncAction;
extern bool bLaunchTestGameAfterLoad;
extern bool bLaunchSaveStandalonefterLoad;
extern bool bCloseStoryboardAfterLoad;
extern int iLevelEditorFromStoryboardID;
extern char pLaunchAfterSyncPreSelectModel[MAX_PATH];
extern char pLaunchAfterSyncLastImportedModel[MAX_PATH];
extern int iOldLaunchAfterSync;
extern int iSkibFramesBeforeLaunch;
extern DWORD gWindowSizeXOld;
extern DWORD gWindowSizeYOld;
extern DWORD gWindowSizeAddY;
extern DWORD gWindowSizeAddX;
extern DWORD gWindowVisibleOld;
extern DWORD gWindowPosXOld;
extern DWORD gWindowPosYOld;
extern DWORD gWindowMaximized;
extern int xmouseold, ymouseold;
#ifdef ENABLEIMGUI
extern bool bImGuiInTestGame;
extern bool bBlockImGuiUntilNewFrame;
extern bool bImGuiRenderWithNoCustomTextures;
extern bool bImGuiFrameState;
extern bool bImGuiReadyToRender;
extern bool bImGuiInitDone;
extern ImVec2 OldrenderTargetSize;
extern ImVec2 OldrenderTargetPos;
extern ImVec2 renderTargetAreaPos;
extern ImVec2 renderTargetAreaSize;
extern bool bImGuiRenderTargetFocus;
extern bool bImGuiGotFocus;
extern bool g_bCascadeQuitFlag;
extern int ImGuiStatusBar_Size;
extern char defaultWriteFolder[260];
extern bool bEntityGotFocus;
extern char cDirectOpen[260];
extern bool imgui_is_running;
extern int refresh_gui_docking;
extern ImGuiID dock_main_tabs, dock_tools_windows;
extern cstr RedockNextWindow;
extern ImGuiViewport* viewport;
extern int toolbar_size;
extern bool g_bInTutorialMode;
extern int g_iCountdownToAlphaBetaMessage;
extern ImVec4 drawCol_toogle;
extern int g_EntityClipboardAnchorEntityIndex;
extern std::vector<int> g_EntityClipboard;
extern preferences pref;
//extern cFolderItem MainEntityList;
extern bool bExport_Standalone_Window;
extern bool bExport_SaveToGameCloud_Window;
extern bool bExternal_Entities_Window;
extern int iDisplayLibraryType;
extern int iDisplayLibrarySubType;
extern int iLastDisplayLibraryType;
extern cstr sStartLibrarySearchString;
extern cstr sTriggerCategorySelect;
extern int iLibraryStingReturnToID;
extern int iSelectedLibraryStingReturnID;
extern cstr sMakeDefaultSelecting;
extern cstr sSelectedLibrarySting;
extern bool bSelectLibraryViewAll;
extern bool bExternal_Entities_Init;
extern bool bEntity_Properties_Window;
extern bool bProperties_Window_Block_Mouse;
extern bool bCheckForClosing;
extern bool bCheckForClosingForce;
extern bool bBuilder_Properties_Window;
extern bool bBuilder_Left_Window;
extern bool bTerrain_Tools_Window;
extern bool bWaypoint_Window;
extern bool bDownloadStore_Window;
extern bool bImporter_Window;
extern bool bHelpVideo_Window;
extern bool bHelp_Window;
extern char cForceTutorialName[1024];
extern bool bHelp_Menu_Image_Window;
extern bool bAbout_Window;
extern bool bCredits_Window;
extern bool bBug_Reporting_Window;
extern bool bBug_RefreshBugList;
extern bool bAbout_Window_First_Run;
extern bool bCredits_Window_First_Run;
extern bool bAbout_Init;
extern bool Entity_Tools_Window;
extern bool bInfo_Window;
extern bool bInfo_Reload;
extern bool bInfo_Window_First_Run;
extern cstr cInfoMessage;
extern cstr cInfoImage, cInfoImageLast;
extern int iInfoUniqueId;
extern int g_iActiveMonitors;

#ifdef WICKEDENGINE
extern bool Visuals_Tools_Window;
extern bool Weather_Tools_Window;
extern int iRestoreLastWindow;
extern std::vector<sRubberBandType> vEntityLockedList;
#define MAXGROUPSLISTS 100
extern cstr sEntityGroupListName[MAXGROUPSLISTS];
extern std::vector<sRubberBandType> vEntityGroupList[MAXGROUPSLISTS];
extern int iEntityGroupListImage[MAXGROUPSLISTS];
extern bool bPreferences_Window;
extern char cPreferencesMessage[MAX_PATH];
extern bool Shooter_Tools_Window; 
extern bool Puzzle_Tools_Window;
extern bool RPG_Tools_Window;
extern char cNextWindowFocus[256];
extern bool bEditGameSettings;
#endif
extern int media_icon_size_leftpanel;
extern int iColumnsWidth_leftpanel;
extern int iColumns_leftpanel;
extern bool bDisplayText_leftpanel;
extern float fFontSize_leftpanel;
extern cFolderItem::sFolderFiles *pDragDropFile;
extern int iOldgridentity;
extern float fPropertiesColoumWidth;
extern bool bTriggerMessage;
extern int iTriggerMessageDelay;
extern int iTriggerMessageY;
extern char cTriggerMessage[MAX_PATH];
extern int iMessageTimer;
extern ImVec4 drawCol_back;
extern ImVec4 drawCol_normal;
extern ImVec4 drawCol_hover;
extern ImVec4 drawCol_Down;
extern ImVec4 drawCol_black;
extern ISpObjectToken* CCP_SelectedToken;
extern LPSTR pCCPVoiceSet;
extern char CCP_SpeakText[1024];
extern wchar_t CCP_SpeakText_w[1024];
extern int CCP_Speak_Rate;
extern std::vector<cstr> tutorial_list;
extern std::map<std::string, std::string> tutorial_files;
extern std::map<std::string, std::string> tutorial_videos;
extern std::map<std::string, std::string> tutorial_description;
extern std::vector<cstr> about_text;
extern bool bTutorial_Init;
extern int current_tutorial;
extern int selected_tutorial;
extern bool bVideoPlayerMaximized;
extern bool bSmallVideoPlayerMaximized;
extern bool bLastSmallVideoPlayerMaximized;
extern bool bVideoResumePossible;
extern bool bVideoPerccentStart;
extern int iVideoFindFirstFrame;
extern int iVideoDelayExecute;
extern bool bTutorialCheckAction;
extern int bDelayedTutorialCheckAction;
extern int iDelayedCameraRestore;
#define TUTORIALMAXTEXT 1024
#define TUTORIALMAXSTEPS 20
extern char cForceTutorialName[1024];
extern char cTutorialName[TUTORIALMAXTEXT];
extern cstr cVideoDescription;
extern ActiveTutorial tut;
extern bool bTutorialRendered;
extern bool bSmallVideoFrameStart;
extern bool bSetTutorialSectionLeft;
extern int iLastTooltipSelection;
extern int iTooltipTimer;
extern int iTooltipHoveredTimer;
extern int iTooltipLastObjectId;
extern bool iTooltipAlreadyLoaded;
extern bool iTooltipObjectReady;
extern float lastKeyTime;
extern char cHelpMenuImage[MAX_PATH];
extern bool bLostFocus;
extern bool bRenderTargetModalMode;
extern int iStartupTime;
extern cstr CurrentWinTitle;
extern int speech_ids[5];
extern bool bWaypointDrawmode;
extern float custom_back_color[4];
extern bool bUpdateVeg;
extern int iLastUpdateVeg;
#endif
#endif
extern int iTriggerWelcomeSystemStuff;
extern int iCountDownToShowQuickStartDialog;
#ifdef WICKEDENGINE
extern ImVec2 back_renderTargetAreaPos;
extern ImVec2 back_renderTargetAreaSize;
#endif
extern int back_iLastResolutionWidth;
extern int back_iLastResolutionHeight;
extern bool bFakeStandaloneTest;
extern int iTriggerGrassTreeUpdate;
extern bool Shooter_Tools_Window_Active;

typedef std::map<std::string, ISpObjectToken *> VoiceMap_t;
extern VoiceMap_t VoiceMap;
extern std::vector <cstr> g_voiceList_s;
extern std::vector <ISpObjectToken *> g_voicetoken;

extern std::vector<std::string> readoutTitles;
extern std::vector<STORYBOARD_WIDGET_> readoutWidgetTypes;
extern std::vector<ReadoutLayers> readoutLayers;
extern std::vector<ReadoutTypes> readoutTypes;
extern std::vector<std::function<void()>> readoutCallbacks;

extern int g_iAbortedAsEntityIsGroupFileModeStubOnly;
extern int g_iAbortedAsEntityIsGroupCreate;

bool bDigAHoleToHWND = false;
bool g_bSelectedMapImageTypeSpecialHelp = false;
bool bSortProjects = true;
bool bResetProjectThumbnails = true;
int g_iCheckExistingFilesModifiedDelayed = 0;
ImRect g_rStealMonitorArea;

std::vector<cstr> lutImages_s;

// helps track myglobals and use them in dropdowns for storyboard screen editor
bool g_bRefreshGlobalList = false;
std::vector<int> g_gameGlobalListNodeId;
std::vector<int> g_gameGlobalListIndex;
std::vector<int> g_gameGlobalListValue;

// storyboard screen animation control
int g_iStoryboardScreenVideoID = 0;

#ifdef ENABLEIMGUI
void imgui_set_openproperty_flags(int iMasterID)
{
	//  Open property window
	t.editorinterfaceactive = t.e;

	//  Setup usage flags
	t.tsimplecharview = 0;
	t.tflaglives = 0; t.tflaglight = 0; t.tflagobjective = 0; t.tflagtdecal = 0; t.tflagdecalparticle = 0; t.tflagspawn = 0; t.tflagifused = 0;
	t.tflagnewparticle = 0;
	t.tflagvis = 0; t.tflagchar = 0; t.tflagweap = 0; t.tflagammo = 0; t.tflagai = 1; t.tflagsound = 0; t.tflagsoundset = 0; t.tflagnosecond = 0;
	t.tflagmobile = 0; t.tflaghurtfall = 0; t.tflaghasweapon = 0; t.tflagammoclip = 0; t.tflagstats = 0; t.tflagquantity = 0;
	t.tflagvideo = 0;
	t.tflagplayersettings = 0;
	t.tflagusekey = 0;
	t.tflagteamfield = 0;
	int tflagtext = 0;
	int tflagimage = 0;

	//  If its static and arena mode, only do optional visuals, ignore rest
	t.tstatic = 0;

	// 070510 - simplified character properties
	if (g.gsimplifiedcharacterediting == 1 && t.entityprofile[iMasterID].ischaracter == 1)
	{
		//  flag the simple character properties layout (FPGC)
		t.tsimplecharview = 1;
	}
	else
	{
		//  FPGC - 260310 - new entitylight indicated with new flag
		if (t.entityprofile[iMasterID].islightmarker == 1)
		{
			t.tflaglight = 1;
		}
		else
		{
			if (t.entityprofile[iMasterID].ismarker == 0)
			{
				t.tflagvis = 1; t.tflagmobile = 1; t.tflagobjective = 1; t.tflagsound = 1; t.tflagstats = 1; t.tflagspawn = 1;
				// 070115 - removed until UBER character (multiweapon) is ready for action
				// t.entityprofile[iMasterID].ischaracter>0 then t.tflagchar = 1  ) ; t.tflaghasweapon = 1 ; t.tflagsoundset = 1 ; t.tflagsound = 0
				if (t.entityprofile[iMasterID].ischaracter > 0) { t.tflagchar = 1; t.tflagsoundset = 1; t.tflagsound = 0; }
				if (Len(t.entityprofile[iMasterID].isweapon_s.Get()) > 2) { t.tflagweap = 1; t.tflagammoclip = 1; t.tflagsound = 0; }
				if (t.entityprofile[iMasterID].isammo > 0) { t.tflagammo = 1; t.tflagobjective = 0; t.tflagsound = 0; }
				t.tflagusekey = 1;
			}
			else
			{
				if (t.entityprofile[iMasterID].ismarker == 1)
				{
					t.tflagai = 0;
					//  FPGC - 160909 - filtered fpgcgenre=1 is shooter genre
					if (g.fpgcgenre == 1)
					{
						//  Shooter legacy properties for player start
						if (t.entityprofile[iMasterID].lives > 0)
						{
							t.tflagstats = 1; t.tflaglives = 1; t.tflagsoundset = 1; t.tflaghurtfall = 1; t.tflaghasweapon = 1; t.tflagquantity = 1;
							t.tflagplayersettings = 1;
							t.tflagnosecond = 1;
						}
						else
						{
							t.tflagsound = 1; t.tflagnosecond = 1;
						}
					}
					else
					{
						//  Other genre's have no ammo quantity and weapon is renamed as equipment
						if (t.entityprofile[iMasterID].lives == -1)
						{
							//  checkpint marker is type 1
							t.tflagsound = 1; t.tflagnosecond = 1;
						}
						else
						{
							t.tflagstats = 1; t.tflaglives = 1; t.tflagsoundset = 1; t.tflaghurtfall = 1; t.tflaghasweapon = 1;
						}
					}
				}
				if (t.entityprofile[iMasterID].ismarker == 3 || t.entityprofile[iMasterID].ismarker == 6 || t.entityprofile[iMasterID].ismarker == 8)
				{
					t.tflagnosecond = 1; t.tflagifused = 1;
				}
				if (t.entityprofile[iMasterID].ismarker == 4) { t.tflagtdecal = 1; t.tflagdecalparticle = 1; }
				#ifdef WICKEDENGINE
				// handled next to Behavior component for MAX
				#else
				if (t.entityprofile[iMasterID].ismarker == 10) { t.tflagnewparticle = 1; }
				#endif
				if (t.entityprofile[iMasterID].ismarker == 3)
				{
					if (t.entityprofile[iMasterID].markerindex <= 1)
					{
						if (t.entityprofile[iMasterID].markerindex == 1)
						{
							// video
							t.tflagvideo = 1;
						}
						else
						{
							// sound
							t.tflagsound = 1;
						}
					}
					else
					{
						if (t.entityprofile[iMasterID].markerindex == 2) tflagtext = 1;
						if (t.entityprofile[iMasterID].markerindex == 3) tflagimage = 1;
					}
				}
				if (t.entityprofile[iMasterID].ismarker == 7)
				{
					//  multiplayer start marker
					t.tflagstats = 1;
					t.tflaghurtfall = 1;
					t.tflagplayersettings = 1;
					t.tflagteamfield = 1;
				}
				if (t.entityprofile[iMasterID].ismarker == 8)
				{
					// floor zone marker
					t.tflagsound = 0;
				}
				if (t.entityprofile[iMasterID].ismarker == 9)
				{
					// cover zone marker
					t.tflagifused = 1;
				}
			}
		}
	}

	// parental control removes weapons and violence properties
	if (g.quickparentalcontrolmode == 2)
	{
		t.tflagweap = 0;
		t.tflagammo = 0;
	}

	//PE: New flags check.
	// special VR mode can remove even more
	t.tflagnotionofhealth = 1;
	t.tflagsimpler = 0;
	//if ( bVRQ2ZeroViolenceMode == true )
	//{
	//	t.tflaglives=0; 
	//	t.tflaghurtfall=0; 
	//	t.tflaghasweapon=0; 
	//	t.tflagammoclip=0;
	//	t.tflagnotionofhealth=0;
	//	t.tflagsimpler = 1;
	//}


}
#endif

// 
//  PROPERTIES
// 

void interface_openpropertywindow ( void )
{
	//  Open proprty window
	#ifdef FPSEXCHANGE
	OpenFileMap (  1, "FPSEXCHANGE" );
	SetFileMapDWORD (  1, 978, 1 );
	SetFileMapDWORD (  1, 458, 0 );
	SetEventAndWait (  1 );
	t.editorinterfaceactive=t.e;

	//  open the entity file map
	OpenFileMap (  2, "FPSENTITY" );
	SetEventAndWait (  2 );

	//  wait until the entity window is read
	if (  GetFileMapDWORD( 2, ENTITY_SETUP )  ==  1 ) 
	{
		#ifdef VRTECH
		// special VRQ2 mode also hides concepts of lives, health, blood, violence (substitute health for strength)
		bool bVRQ2ZeroViolenceMode = false;
		if ( g.vrqcontrolmode != 0 ) bVRQ2ZeroViolenceMode = true;//if ( g.gvrmode == 3 ) bVRQ2ZeroViolenceMode = true;
		#endif

		//  Setup usage flags
		t.tsimplecharview=0;
		t.tflaglives=0 ; t.tflaglight=0 ; t.tflagobjective=0 ; t.tflagtdecal=0 ; t.tflagdecalparticle=0 ; t.tflagspawn=0 ; t.tflagifused=0;
		t.tflagnewparticle = 0;
		t.tflagvis=0 ; t.tflagchar=0 ; t.tflagweap=0 ; t.tflagammo=0 ; t.tflagai=1 ; t.tflagsound=0 ; t.tflagsoundset=0 ; t.tflagnosecond=0;
		t.tflagmobile=0 ; t.tflaghurtfall=0 ; t.tflaghasweapon=0 ; t.tflagammoclip=0 ; t.tflagstats=0 ; t.tflagquantity=0;
		t.tflagvideo=0;
		t.tflagplayersettings=0;
		t.tflagusekey=0;
		t.tflagteamfield=0;
		int tflagtext=0;
		int tflagimage=0;

		//  If its static and arena mode, only do optional visuals, ignore rest
		t.tstatic=0;

		// 070510 - simplified character properties
		if (  g.gsimplifiedcharacterediting == 1 && t.entityprofile[t.gridentity].ischaracter == 1 ) 
		{
			//  flag the simple character properties layout (FPGC)
			t.tsimplecharview=1;
		}
		else
		{
			//  FPGC - 260310 - new entitylight indicated with new flag
			if (  t.entityprofile[t.gridentity].islightmarker == 1 ) 
			{
				t.tflaglight=1;
			}
			else
			{
				if (  t.entityprofile[t.gridentity].ismarker == 0 ) 
				{
					t.tflagvis=1 ; t.tflagmobile=1 ; t.tflagobjective=1 ; t.tflagsound=1 ; t.tflagstats=1 ; t.tflagspawn=1;
					// 070115 - removed until UBER character (multiweapon) is ready for action
					// t.entityprofile[t.gridentity].ischaracter>0 then t.tflagchar = 1  ) ; t.tflaghasweapon = 1 ; t.tflagsoundset = 1 ; t.tflagsound = 0
					if (  t.entityprofile[t.gridentity].ischaracter>0 ) { t.tflagchar = 1  ; t.tflagsoundset = 1 ; t.tflagsound = 0; }
					if (  Len(t.entityprofile[t.gridentity].isweapon_s.Get())>2 ) { t.tflagweap = 1  ; t.tflagammoclip = 1 ; t.tflagsound = 0; }
					if (  t.entityprofile[t.gridentity].isammo>0 ) { t.tflagammo = 1  ; t.tflagobjective = 0 ; t.tflagsound = 0; }
					t.tflagusekey=1;
				}
				else
				{
					if (  t.entityprofile[t.gridentity].ismarker == 1 ) 
					{
						t.tflagai=0;
						//  FPGC - 160909 - filtered fpgcgenre=1 is shooter genre
						if (  g.fpgcgenre == 1 ) 
						{
							//  Shooter legacy properties for player start
							if (  t.entityprofile[t.gridentity].lives>0 ) 
							{
								t.tflagstats=1 ; t.tflaglives=1 ; t.tflagsoundset=1 ; t.tflaghurtfall=1 ; t.tflaghasweapon=1 ; t.tflagquantity=1;
								t.tflagplayersettings=1;
								t.tflagnosecond=1;
							}
							else
							{
								t.tflagsound=1 ; t.tflagnosecond=1;
							}
						}
						else
						{
							//  Other genre's have no ammo quantity and weapon is renamed as equipment
							if (  t.entityprofile[t.gridentity].lives == -1 ) 
							{
								//  checkpint marker is type 1
								t.tflagsound=1 ; t.tflagnosecond=1;
							}
							else
							{
								t.tflagstats=1 ; t.tflaglives=1 ; t.tflagsoundset=1 ; t.tflaghurtfall=1 ; t.tflaghasweapon=1;
							}
						}
					}
					if (  t.entityprofile[t.gridentity].ismarker == 3 || t.entityprofile[t.gridentity].ismarker == 6 || t.entityprofile[t.gridentity].ismarker == 8 ) 
					{
						t.tflagnosecond=1 ; t.tflagifused=1;
						#ifdef VRTECH
						#else
						t.tflagsound=1;
						#endif
					}
					if (  t.entityprofile[t.gridentity].ismarker == 4 ) { t.tflagtdecal = 1  ; t.tflagdecalparticle = 1; }
					#ifdef WICKEDENGINE
					// handled next to Behavior component for MAX
					#else
					if (  t.entityprofile[t.gridentity].ismarker == 10 ) { t.tflagnewparticle = 1; }
					#endif
					if (  t.entityprofile[t.gridentity].ismarker == 3 ) 
					{
						if (  t.entityprofile[t.gridentity].markerindex <= 1 ) 
						{
							if (  t.entityprofile[t.gridentity].markerindex == 1 ) 
							{
								// video
								t.tflagvideo=1;
							}
							else
							{
								// sound
								t.tflagsound=1;
							}
						}
						else
						{
							if ( t.entityprofile[t.gridentity].markerindex == 2 ) tflagtext=1;
							#ifdef VRTECH
							#else
							 if ( t.entityprofile[t.gridentity].markerindex == 3 ) tflagimage=1;
							#endif
						}
					}
					if (  t.entityprofile[t.gridentity].ismarker == 7 ) 
					{
						//  multiplayer start marker
						t.tflagstats=1;
						t.tflaghurtfall=1;
						t.tflagplayersettings=1;
						t.tflagteamfield=1;
					}
					if (  t.entityprofile[t.gridentity].ismarker == 8 ) 
					{
						// floor zone marker
						t.tflagsound=0;
					}
					if (  t.entityprofile[t.gridentity].ismarker == 9 ) 
					{
						// cover zone marker
						t.tflagifused = 1;
					}
				}
			}
		}

		// parental control removes weapons and violence properties
		if ( g.quickparentalcontrolmode == 2 )
		{
			t.tflagweap = 0;
			t.tflagammo = 0;
		}

		#ifdef VRTECH
		// special VR mode can remove even more
		t.tflagnotionofhealth = 1;
		t.tflagsimpler = 0;
		if ( bVRQ2ZeroViolenceMode == true )
		{
			t.tflaglives=0; 
			t.tflaghurtfall=0; 
			t.tflaghasweapon=0; 
			t.tflagammoclip=0;
			t.tflagnotionofhealth=0;
			t.tflagsimpler = 1;
		}
		#endif

		//  set array and counters to track scope of contents of each group
		Dim (  t.propfield,16  );
		for ( t.t = 0 ; t.t <= 16 ; t.t++ ) t.propfield[t.t]=0 ; 

		//  set the window title
		setpropertybase(ENTITY_WINDOW_TITLE,t.strarr_s[411].Get());

		//  FPGC - 070510 - open entity properties filemap and wait for signal to write
		OpenFileMap ( 3, "ENTITYPROPERTIES" );
		g.g_filemapoffset = 8;
		if ( DLLExist(1) == 0 )  DLLLoad (  "Kernel32.dll", 1 );
		while (  GetFileMapDWORD(3,0)  ==  1 ) 
		{
			CallDLL (  1,"Sleep",10 );
		}

		if (  t.tsimplecharview == 1 ) 
		{
			//  Wizard (simplified) property editing
			t.group=0 ; startgroup("Character Info") ; t.controlindex=0;
			#ifdef VRTECH
			setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[413].Get(),"Choose a unique name for this character") ; ++t.controlindex;
			#else
			setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[478].Get(),"Choose a unique name for this character") ; ++t.controlindex;
			#endif
			setpropertylist2(t.group,t.controlindex,t.grideleprof.aimain_s.Get(),"Behaviour","Select a behaviour for this character",11) ; ++t.controlindex;
			setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),"Voiceover","Select t.a WAV or OGG file this character will use during their behavior","audiobank\\") ; ++t.controlindex;
			setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),"If Used","Sometimes used to specify the name of an entity to be activated") ; ++t.controlindex;
		}
		else
		{
			//  Name
			t.group=0 ; startgroup(t.strarr_s[412].Get()) ; t.controlindex=0;
			#ifdef VRTECH
			if ( t.entityprofile[t.gridentity].ischaracter > 0 )
			{
				setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[478].Get(),t.strarr_s[204].Get());
			}
			else
			{
				if ( t.entityprofile[t.gridentity].ismarker > 0 )
				{
					if ( t.entityprofile[t.gridentity].islightmarker > 0 )
						setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[483].Get(),t.strarr_s[204].Get());
					else
						setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[479].Get(),t.strarr_s[204].Get());
				}
				else
					setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[413].Get(),t.strarr_s[204].Get());
			}
			++t.controlindex;
			#else
			setpropertystring2(t.group,t.grideleprof.name_s.Get(),t.strarr_s[413].Get(),t.strarr_s[204].Get()) ; ++t.controlindex;
			#endif
			if (  t.entityprofile[t.gridentity].ismarker == 0 || t.entityprofile[t.gridentity].islightmarker == 1 ) 
			{
				if (  g.gentitytogglingoff == 0 ) 
				{
					t.tokay=1;
					if (  ObjectExist(g.entitybankoffset+t.gridentity) == 1 ) 
					{
						if (  GetNumberOfFrames(g.entitybankoffset+t.gridentity)>0 ) 
						{
							t.tokay=0;
						}
					}
					if (  t.tokay == 1 ) 
					{
						//PE: 414=Static Mode
						setpropertylist2(t.group,t.controlindex,Str(t.gridentitystaticmode),t.strarr_s[414].Get(),t.strarr_s[205].Get(),0) ; ++t.controlindex;
					}
				}
			}

			// 101016 - Additional General Parameters
			if ( t.tflagchar == 0 && t.tflagvis == 1 ) 
			{
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocluder),"Occluder","Set to YES makes this object an occluder",0) ; ++t.controlindex;
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocludee),"Occludee","Set to YES makes this object an occludee",0) ; ++t.controlindex;
				}
				#else
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocluder),"Occluder","Set to YES makes this entity an occluder",0) ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isocludee),"Occludee","Set to YES makes this entity an occludee",0) ; ++t.controlindex;
				#endif
				
				// these will be back when EBE needs doors and windows
				//setpropertystring2(t.group,Str(t.grideleprof.parententityindex),"Parent Index","Selects another entity element to be a parent") ; ++t.controlindex;
				//setpropertystring2(t.group,Str(t.grideleprof.parentlimbindex),"Parent Limb","Specifies the limb index of the parent to connect with") ; ++t.controlindex;
			}

			// 281116 - added Specular Control per entity
			if ( t.tflagvis == 1 ) 
			{
				if ( t.tflagsimpler == 0 )
				{
					//not used in MAX
					//setpropertystring2(t.group,Str(t.grideleprof.specularperc),"Specular","Set specular percentage to modulate object specular effect")  ; ++t.controlindex; 
				}
			}

			//  Basic AI
			if (  t.tflagai == 1 ) 
			{
				// can redirect to better folders if in g.quickparentalcontrolmode
				LPSTR pAIRoot = "scriptbank\\";
				if ( g.quickparentalcontrolmode == 2 )
				{
					if ( t.entityprofile[t.gridentity].ismarker == 0 ) 
					{
						if ( t.tflagchar == 1 )
							pAIRoot = "scriptbank\\people\\";
						else
							pAIRoot = "scriptbank\\objects\\";
					}
					else
					{
						pAIRoot = "scriptbank\\markers\\";
					}
				}

				t.propfield[t.group]=t.controlindex;
				#ifdef VRTECH
				++t.group ; startgroup(t.strarr_s[415].Get()) ; t.controlindex=0;
				#else
				++t.group ; startgroup("AI System") ; t.controlindex=0;
				#endif
				setpropertyfile2(t.group,t.grideleprof.aimain_s.Get(),t.strarr_s[417].Get(),t.strarr_s[207].Get(),pAIRoot) ; ++t.controlindex;
			}

			//  Has Weapon
			if (  t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2 ) 
			{
				setpropertylist2(t.group,t.controlindex,t.grideleprof.hasweapon_s.Get(),t.strarr_s[419].Get(),t.strarr_s[209].Get(),1) ; ++t.controlindex;
			}

			//  Is Weapon (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre)
			if (  t.tflagweap == 1 && g.fpgcgenre == 1 ) 
			{
				setpropertystring2(t.group,Str(t.grideleprof.damage),t.strarr_s[420].Get(),t.strarr_s[210].Get()) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.accuracy),t.strarr_s[421].Get(),"Increases the inaccuracy of conical distribution by 1/100th of t.a degree") ; ++t.controlindex;
				if (  t.grideleprof.weaponisammo == 0 ) 
				{
					setpropertystring2(t.group,Str(t.grideleprof.reloadqty),t.strarr_s[422].Get(),t.strarr_s[212].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.fireiterations),t.strarr_s[423].Get(),t.strarr_s[213].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.range),"Range","Maximum range of bullet travel") ; ++t.controlindex;
					setpropertystring2(t.group, Str(t.grideleprof.dropoff), "Dropoff", "Amount in inches of vertical dropoff per 100 feet of bullet travel"); ++t.controlindex;
					setpropertystring2(t.group, Str(t.grideleprof.clipcapacity), "Clip Capacity", "The total maximum number of clips the player can carry for this weapon"); ++t.controlindex;
					//int weaponpropres1;
					//int weaponpropres2;
				}
				else
				{
					setpropertystring2(t.group,Str(t.grideleprof.lifespan),t.strarr_s[424].Get(),t.strarr_s[214].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.throwspeed),t.strarr_s[425].Get(),t.strarr_s[215].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.throwangle),t.strarr_s[426].Get(),t.strarr_s[216].Get()) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.bounceqty),t.strarr_s[427].Get(),t.strarr_s[217].Get()) ; ++t.controlindex;
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.explodeonhit),t.strarr_s[428].Get(),t.strarr_s[218].Get(),0) ; ++t.controlindex;
				}
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.usespotlighting),"Spot Lighting","Set whether emits dynamic spot lighting",0) ; ++t.controlindex;
				}
				#else
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.usespotlighting),"Spot Lighting","Set whether emits dynamic spot lighting",0) ; ++t.controlindex;
				#endif
			}

			//  Is Character
			if (  t.tflagchar == 1 ) 
			{
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					// 020316 - special check to avoid offering can take weapon if no HUD.X
					t.tfile_s = cstr("gamecore\\guns\\") + t.grideleprof.hasweapon_s + cstr("\\HUD.X");
					if ( FileExist(t.tfile_s.Get()) == 1 ) 
					{
						setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.cantakeweapon),t.strarr_s[429].Get(),t.strarr_s[219].Get(),0) ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[430].Get(),t.strarr_s[220].Get()) ; ++t.controlindex;
					}
					setpropertystring2(t.group,Str(t.grideleprof.rateoffire),t.strarr_s[431].Get(),t.strarr_s[221].Get()) ; ++t.controlindex;
				}
				#else
				// 020316 - special check to avoid offering can take weapon if no HUD.X
				t.tfile_s = cstr("gamecore\\guns\\") + t.grideleprof.hasweapon_s + cstr("\\HUD.X");
				if ( FileExist(t.tfile_s.Get()) == 1 ) 
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.cantakeweapon),t.strarr_s[429].Get(),t.strarr_s[219].Get(),0) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[430].Get(),t.strarr_s[220].Get()) ; ++t.controlindex;
				}
				setpropertystring2(t.group,Str(t.grideleprof.rateoffire),t.strarr_s[431].Get(),t.strarr_s[221].Get()) ; ++t.controlindex;
				#endif
			}
			if ( t.tflagquantity == 1 && g.quickparentalcontrolmode != 2 ) 
			{ 
				setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[432].Get(),t.strarr_s[222].Get())  ; ++t.controlindex; 
			}

			//  AI Extra
			if (  t.tflagvis == 1 && t.tflagai == 1 ) 
			{
				if (  t.tflagchar == 1 ) 
				{
					setpropertystring2(t.group,Str(t.grideleprof.coneangle),t.strarr_s[434].Get(),t.strarr_s[224].Get()) ; ++t.controlindex;
					#ifdef VRTECH
					setpropertystring2(t.group,Str(t.grideleprof.conerange),t.strarr_s[476].Get(),"The range within which the AI may see the player. Zero triggers the characters default range.") ; ++t.controlindex;
					#else
					setpropertystring2(t.group,Str(t.grideleprof.conerange),"View Range","The range within which the AI may see the player. Zero triggers the characters default range.") ; ++t.controlindex;
					#endif
					setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[226].Get()) ; ++t.controlindex;
					if ( g.quickparentalcontrolmode != 2 )
					{
						setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isviolent),"Blood Effects","Sets whether blood and screams should be used",0) ; ++t.controlindex;
					}
					#ifdef VRTECH
					if ( t.tflagsimpler == 0 )
					{
						setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.colondeath),"End Collision","Set to NO switches off collision when die",0) ; ++t.controlindex;
					}
					#else
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.colondeath),"End Collision","Set to NO switches off collision when die",0) ; ++t.controlindex;
					#endif
				}
				else
				{
					if (  t.tflagweap == 0 && t.tflagammo == 0 ) 
					{
						t.propfield[t.group]=t.controlindex;
						++t.group ; startgroup(t.strarr_s[435].Get()) ; t.controlindex=0;
						setpropertystring2(t.group,t.grideleprof.usekey_s.Get(),t.strarr_s[436].Get(),t.strarr_s[225].Get()) ; ++t.controlindex;
						#ifdef VRTECH
						if ( t.tflagsimpler != 0 & t.entityprofile[t.gridentity].ismarker == 3 && t.entityprofile[t.gridentity].trigger.stylecolor == 1 )
						{
							// only one level - no winzone chain option
						}
						else
						{
							setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[226].Get()) ; ++t.controlindex;
						}
						#else
						setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[226].Get()) ; ++t.controlindex;
						#endif
					}
				}
			}
			if (  t.tflagifused == 1 ) 
			{
				if (  t.tflagusekey == 1 ) 
				{
					setpropertystring2(t.group,t.grideleprof.usekey_s.Get(),t.strarr_s[436].Get(),t.strarr_s[225].Get()) ; ++t.controlindex;
				}
				#ifdef VRTECH
				if ( t.tflagsimpler != 0 & t.entityprofile[t.gridentity].ismarker == 3 && t.entityprofile[t.gridentity].trigger.stylecolor == 1 )
				{
					// only one level - no winzone chain option
				}
				else
				{
					setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[227].Get()) ; ++t.controlindex;
				}
				#else
				setpropertystring2(t.group,t.grideleprof.ifused_s.Get(),t.strarr_s[437].Get(),t.strarr_s[227].Get()) ; ++t.controlindex;
				#endif
			}

			//  Spawn Settings
			if (  t.tflagspawn == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[439].Get()) ; t.controlindex=0;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.spawnatstart),t.strarr_s[562].Get(),t.strarr_s[563].Get(),0) ; ++t.controlindex;
				//     `setpropertystring2(group,Str(grideleprof.spawnmax),strarr$(440),strarr$(231)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnupto),strarr$(441),strarr$(232)) ; inc controlindex
				//     `setpropertylist2(group,controlindex,Str(grideleprof.spawnafterdelay),strarr$(442),strarr$(233),0) ; inc controlindex
				//     `setpropertylist2(group,controlindex,Str(grideleprof.spawnwhendead),strarr$(443),strarr$(234),0) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawndelay),strarr$(444),strarr$(235)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawndelayrandom),strarr$(564),strarr$(565)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnqty),strarr$(445),strarr$(236)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnqtyrandom),strarr$(566),strarr$(567)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnvel),strarr$(568),strarr$(569)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnvelrandom),strarr$(570),strarr$(571)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnangle),strarr$(572),strarr$(573)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnanglerandom),strarr$(574),strarr$(575)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.spawnlife),strarr$(576),strarr$(577)) ; inc controlindex
			}

			//  Visual
			//    `if tflagvis=1
			//     `propfield(group)=controlindex
			//     `inc group ; startgroup(strarr$(446)) ; controlindex=0
			//     `setpropertyfile2(group,grideleprof.texd$,strarr$(447),strarr$(237),"") ; inc controlindex
			//     `setpropertyfile2(group,grideleprof.texaltd$,strarr$(448),strarr$(238),"") ; inc controlindex
			//     `setpropertyfile2(group,grideleprof.effect$,strarr$(578),strarr$(579),"effectbank\\") ; inc controlindex
			//     `setpropertystring2(group,Str(grideleprof.transparency),strarr$(449),strarr$(240)) ; inc controlindex
			//     `setpropertystring2(group,Str(grideleprof.reducetexture),strarr$(450),strarr$(241)) ; inc controlindex
			//    `endif
			//if ( t.tflagvis == 1 ) // more engine needs improving to allow on the spot changes to shader!
			//{
			//	setpropertyfile2(t.group,t.grideleprof.effect_s.Get(),t.strarr_s[578].Get(),t.strarr_s[579].Get(),"effectbank\\"); ++t.controlindex;
			//	setpropertystring2(t.group,Str(t.grideleprof.transparency),t.strarr_s[449].Get(),t.strarr_s[240].Get()); ++t.controlindex;
			//}

			//  Statistics
			if (  (t.tflagvis == 1 || t.tflagobjective == 1 || t.tflaglives == 1 || t.tflagstats == 1) && t.tflagweap == 0 && t.tflagammo == 0 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[451].Get()) ; t.controlindex=0;
				#ifdef VRTECH
				#else
				 if (  t.tflaglives == 1 ) { setpropertystring2(t.group,Str(t.grideleprof.lives),t.strarr_s[452].Get(),t.strarr_s[242].Get())  ; ++t.controlindex; }
				 if (  t.tflagvis == 1 || t.tflagstats == 1 ) 
				 {
					if (  t.tflaglives == 1 ) 
					{
						setpropertystring2(t.group,Str(t.grideleprof.strength),t.strarr_s[453].Get(),t.strarr_s[243].Get()) ; ++t.controlindex;
					}
					else
					{
						#ifdef VRTECH
						if ( t.tflagnotionofhealth == 1 )
						{
							setpropertystring2(t.group,Str(t.grideleprof.strength),t.strarr_s[454].Get(),t.strarr_s[244].Get()) ; ++t.controlindex;
						}
						#else
						setpropertystring2(t.group,Str(t.grideleprof.strength),t.strarr_s[454].Get(),t.strarr_s[244].Get()) ; ++t.controlindex;
						#endif
					}
					if (  t.tflagplayersettings == 1 ) 
					{
						if ( g.quickparentalcontrolmode != 2 )
						{
							setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isviolent),"Blood Effects","Sets whether blood and screams should be used",0) ; ++t.controlindex;
						}
						#ifdef VRTECH
						if ( t.tflagnotionofhealth == 1 )
						{
							setpropertystring2(t.group,Str(t.playercontrol.regenrate),"Regeneration Rate","Sets the increase value at which the players health will restore")  ; ++t.controlindex;
							setpropertystring2(t.group,Str(t.playercontrol.regenspeed),"Regeneration Speed","Sets the speed in milliseconds at which the players health will regenerate") ; ++t.controlindex;
							setpropertystring2(t.group,Str(t.playercontrol.regendelay),"Regeneration Delay","Sets the delay in milliseconds after last damage hit before health starts regenerating") ; ++t.controlindex;
						}
						#else
						setpropertystring2(t.group,Str(t.playercontrol.regenrate),"Regeneration Rate","Sets the increase value at which the players health will restore")  ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.regenspeed),"Regeneration Speed","Sets the speed in milliseconds at which the players health will regenerate") ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.regendelay),"Regeneration Delay","Sets the delay in milliseconds after last damage hit before health starts regenerating") ; ++t.controlindex;
						#endif
					}
					setpropertystring2(t.group,Str(t.grideleprof.speed),t.strarr_s[455].Get(),t.strarr_s[245].Get()) ; ++t.controlindex;
					//PE: we cant do this , as t.playercontrol.thirdperson.enabled is a global and will trigger for ALL objects.
					//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/310
//					if (  t.playercontrol.thirdperson.enabled == 1 ) 
//					{
//						t.tanimspeed_f=t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
//					}
//					else
//					{
						t.tanimspeed_f=t.grideleprof.animspeed;
//					}
					#ifdef VRTECH
					setpropertystring2(t.group,Str(t.tanimspeed_f),t.strarr_s[477].Get(),"Sets the default speed of any animation associated with this entity"); ++t.controlindex;
					#else
					setpropertystring2(t.group,Str(t.tanimspeed_f),"Anim Speed","Sets the default speed of any animation associated with this entity"); ++t.controlindex;
					#endif
				 }
				 if (  t.tflaghurtfall == 1 ) { setpropertystring2(t.group,Str(t.grideleprof.hurtfall),t.strarr_s[456].Get(),t.strarr_s[246].Get())  ; ++t.controlindex; }
				#endif
				if (  t.tflagplayersettings == 1 ) 
				{
					setpropertystring2(t.group,Str(t.playercontrol.jumpmax_f),"Jump Speed","Sets the jump speed of the player which controls overall jump height") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.playercontrol.gravity_f),"Gravity","Sets the modified force percentage of the players own gravity") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.playercontrol.fallspeed_f),"Fall Speed","Sets the maximum speed percentage at which the player will fall") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.playercontrol.climbangle_f),"Climb Angle","Sets the maximum angle permitted for the player to ascend a slope") ; ++t.controlindex;
					if (  t.playercontrol.thirdperson.enabled == 0 ) 
					{
						setpropertystring2(t.group,Str(t.playercontrol.wobblespeed_f),"Wobble Speed","Sets the rate of motion applied to the camera when moving") ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.wobbleheight_f*100),"Wobble Height","Sets the degree of motion applied to the camera when moving") ; ++t.controlindex;
						setpropertystring2(t.group,Str(t.playercontrol.footfallpace_f*100),"Footfall Pace","Sets the rate at which the footfall sound is played when moving") ; ++t.controlindex;
					}
					setpropertystring2(t.group,Str(t.playercontrol.accel_f*100),"Acceleration","Sets the acceleration curve used when t.moving from t.a stood position") ; ++t.controlindex;
				}
				if ( t.tflagmobile == 1 ) { setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.isimmobile),t.strarr_s[457].Get(),t.strarr_s[247].Get(),0); ++t.controlindex; }
				if ( t.tflagmobile == 1 ) 
				{ 
					#ifdef VRTECH
					if ( t.tflagsimpler == 0 )
					{
						setpropertystring2(t.group,Str(t.grideleprof.lodmodifier),"LOD Modifier","Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect.") ; ++t.controlindex; 
					}
					#else
					setpropertystring2(t.group,Str(t.grideleprof.lodmodifier),"LOD Modifier","Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect.") ; ++t.controlindex; 
					#endif
				}
			}

			//  Team field
			#ifdef PHOTONMP
			#else
			if (  t.tflagteamfield == 1 ) 
			{
				setpropertylist3(t.group,t.controlindex,Str(t.grideleprof.teamfield),"Team","Specifies any team affiliation for multiplayer start marker",0) ; ++t.controlindex;
			}
			#endif

			//  Physics Data (non-multiplayer)
			if (  t.entityprofile[t.gridentity].ismarker == 0 && t.entityprofile[t.gridentity].islightmarker == 0 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[596].Get()) ; t.controlindex=0;
				if (  t.grideleprof.physics != 1  )  t.grideleprof.physics = 0;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.physics),t.strarr_s[580].Get(),t.strarr_s[581].Get(),0) ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.phyalways),t.strarr_s[582].Get(),t.strarr_s[583].Get(),0) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.phyweight),t.strarr_s[584].Get(),t.strarr_s[585].Get()) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.phyfriction),t.strarr_s[586].Get(),t.strarr_s[587].Get()) ; ++t.controlindex;
				//     `setpropertystring2(group,Str(grideleprof.phyforcedamage),strarr$(588),strarr$(589)) ; inc controlindex
				//     `setpropertystring2(group,Str(grideleprof.rotatethrow),strarr$(590),strarr$(591)) ; inc controlindex
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.explodable),t.strarr_s[592].Get(),t.strarr_s[593].Get(),0) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.explodedamage),t.strarr_s[594].Get(),t.strarr_s[595].Get()) ; ++t.controlindex;
				}
				#else
				setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.explodable),t.strarr_s[592].Get(),t.strarr_s[593].Get(),0) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.grideleprof.explodedamage),t.strarr_s[594].Get(),t.strarr_s[595].Get()) ; ++t.controlindex;
				#endif
			}

			//  Ammo data (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
			if (  g.fpgcgenre == 1 ) 
			{
				if (  t.tflagammo == 1 || t.tflagammoclip == 1 ) 
				{
					t.propfield[t.group]=t.controlindex;
					++t.group ; startgroup(t.strarr_s[459].Get()) ; t.controlindex=0;
					setpropertystring2(t.group,Str(t.grideleprof.quantity),t.strarr_s[460].Get(),t.strarr_s[249].Get()) ; ++t.controlindex;
				}
			}

			//  Light data
			if (  t.tflaglight == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[461].Get()) ; t.controlindex=0; //PE: 461=Light
				setpropertystring2(t.group,Str(t.grideleprof.light.range),t.strarr_s[462].Get(),t.strarr_s[250].Get()) ; ++t.controlindex; //PE: 462=Light Range
				setpropertycolor2(t.group,t.grideleprof.light.color,t.strarr_s[463].Get(),t.strarr_s[251].Get()) ; ++t.controlindex; //PE: 463=Light Color
				#ifdef VRTECH
				if ( t.tflagsimpler == 0 )
				{
					setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0); ++t.controlindex;
				}
				#else
				setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0); ++t.controlindex;
				#endif
			}

			//  Decal data
			if (  t.tflagtdecal == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;

				//  FPGC - 300710 - could never change base decal, so comment out this property (entity denotes decal choice)
				//     `inc group ; startgroup(strarr$(464)) ; controlindex=0
				//     `setpropertyfile2(group,grideleprof.basedecal$,strarr$(465),strarr$(252),"gamecore\\decals\\") ; inc controlindex

				//  Decal Particle data
				if (  t.tflagdecalparticle == 1 ) 
				{
					++t.group ; startgroup("Decal Particle") ; t.controlindex=0;
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.particleoverride),"Custom Settings","Whether you wish to override default settings",0) ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.offsety),"OffsetY","Vertical adjustment of start position") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.scale),"Scale","A value from 0 to 100, denoting size of particle") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randomstartx),"Random Start X","Random start area") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randomstarty),"Random Start Y","Random start area") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randomstartz),"Random Start Z","Random start area") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.linearmotionx),"Linear Motion X","Constant motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.linearmotiony),"Linear Motion Y","Constant motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.linearmotionz),"Linear Motion Z","Constant motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randommotionx),"Random Motion X","Random motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randommotiony),"Random Motion Y","Random motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.randommotionz),"Random Motion Z","Random motion direction") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.mirrormode),"Mirror Mode","Set to one to reverse the particle") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.camerazshift),"Camera Z Shift","Shift t.particle towards camera") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.scaleonlyx),"Scale Only X","Percentage X over Y scale") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.lifeincrement),"Life Increment","Control lifespan of particle") ; ++t.controlindex;
					setpropertystring2(t.group,Str(t.grideleprof.particle.alphaintensity),"Alpha Intensity","Control alpha percentage of particle") ; ++t.controlindex;
					//  V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
					setpropertylist2(t.group,t.controlindex,Str(t.grideleprof.particle.animated),"Animated Text (  ( ure","Sets whether the t.particle t.decal Texture is animated or static.", 0)  ; ++t.controlindex;
				}
			}

			// Sound
			if ( t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ;
				if ( tflagtext == 1 || tflagimage == 1 )
				{
					if ( tflagtext == 1 ) startgroup("Text");
					if ( tflagimage == 1 ) startgroup("Image");
				}
				else
				{
					startgroup("Media");
				}
				t.controlindex=0;
				if ( g.fpgcgenre == 1 ) 
				{
					if ( g.vrqcontrolmode != 0 )
					{
						#ifdef VRTECH
						if ( t.tflagsound == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[253].Get(),"audiobank\\")  ; ++t.controlindex; }
						#else
						if ( t.tflagsound == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),"Audio",t.strarr_s[253].Get(),"audiobank\\")  ; ++t.controlindex; }
						#endif
					}
					else
					{
						if ( t.tflagsound == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[467].Get(),t.strarr_s[253].Get(),"audiobank\\")  ; ++t.controlindex; }
					}
					if ( t.tflagsoundset == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[255].Get(),"audiobank\\voices\\")  ; ++t.controlindex; }
					if ( tflagtext == 1 ) { setpropertystring2(t.group,t.grideleprof.soundset_s.Get(),"Text to Appear","Enter text to appear in-level") ; ++t.controlindex; }
					if ( tflagimage == 1 ) { setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),"Image File","Select image to appear in-level","scriptbank\\images\\imagesinzone\\") ; ++t.controlindex; }
					if ( t.tflagnosecond == 0 ) 
					{
						if ( t.tflagsound == 1 || t.tflagsoundset == 1 )
						{ 
							setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),t.strarr_s[468].Get(),t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group,t.grideleprof.soundset2_s.Get(),t.strarr_s[480].Get(),t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group,t.grideleprof.soundset3_s.Get(),t.strarr_s[481].Get(),t.strarr_s[254].Get(),"audiobank\\")  ; ++t.controlindex; 
							setpropertyfile2(t.group, t.grideleprof.soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\"); ++t.controlindex;
							setpropertyfile2(t.group, t.grideleprof.soundset6_s.Get(), "Sound5", t.strarr_s[254].Get(), "audiobank\\"); ++t.controlindex;
						}
					}
				}
				else
				{
					if ( t.tflagsoundset == 1 ) 
					{
						setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[255].Get(),"audiobank\\voices\\") ; ++t.controlindex;
					}
					else
					{
						setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[467].Get(),t.strarr_s[253].Get(),"audiobank\\") ; ++t.controlindex;
					}
					setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),t.strarr_s[468].Get(),t.strarr_s[254].Get(),"audiobank\\") ; ++t.controlindex;
				}
			}

			// Video
			if ( t.tflagvideo == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup(t.strarr_s[597].Get()) ; t.controlindex=0;
				setpropertyfile2(t.group,t.grideleprof.soundset_s.Get(),t.strarr_s[469].Get(),t.strarr_s[599].Get(),"audiobank\\") ; ++t.controlindex;
				setpropertyfile2(t.group,t.grideleprof.soundset1_s.Get(),"Video Slot",t.strarr_s[601].Get(),"videobank\\") ; ++t.controlindex;
			}

			//  Third person settings
			if (  t.tflagplayersettings == 1 && t.playercontrol.thirdperson.enabled == 1 ) 
			{
				t.propfield[t.group]=t.controlindex;
				++t.group ; startgroup("Third Person") ; t.controlindex=0;
				t.livegroupforthirdperson=t.group;
				setpropertylist2(t.group,t.controlindex,Str(t.playercontrol.thirdperson.cameralocked),"Camera Locked","Fixes camera height and angle for third person view",0) ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.cameradistance),"Camera Distance","Sets the distance of the third person camera") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.camerashoulder),"Camera X Offset","Sets the distance to shift the camera over shoulder") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.cameraheight),"Camera Y Offset","Sets the vertical height of the third person camera. If more than twice the camera distance, camera collision disables") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.camerafocus),"Camera Focus","Sets the camera X angle offset to align focus of the third person camera") ; ++t.controlindex;
				setpropertystring2(t.group,Str(t.playercontrol.thirdperson.cameraspeed),"Camera Speed","Sets the retraction speed percentage of the third person camera") ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.playercontrol.thirdperson.camerafollow),"Run Mode","If set to yes, protagonist uses WASD t.movement mode",0) ; ++t.controlindex;
				setpropertylist2(t.group,t.controlindex,Str(t.playercontrol.thirdperson.camerareticle),"Show Reticle","Show the third person 'crosshair' reticle Dot ( ",0)  ; ++t.controlindex;
			}

		}

		//  End of data
		t.propfield[t.group]=t.controlindex;
		t.propfieldgroupmax=t.group;

		//  FPGC - 070510 - finish bulk entity properties population
		SetFileMapDWORD (  3,g.g_filemapoffset,0  ); g.g_filemapoffset += 4;
		SetFileMapDWORD (  3,0,1 );

	}

	//  FPGC - 070510 - close bulk file map
	SetEventAndWait ( 2 );
	#endif
}

void interface_copydatatoentity ( void )
{
	//  go through all active fields
	for ( t.iGroup = 0 ; t.iGroup<=  t.propfieldgroupmax; t.iGroup++ )
	{
		for ( t.iControl = 0 ; t.iControl<=  t.propfield[t.iGroup]-1; t.iControl++ )
		{

			//  Get data
			t.tfield_s = getpropertyfield(t.iGroup,t.iControl);
			t.tdata_s = getpropertydata(t.iGroup,t.iControl);

			//  If tdata$ was absolute file, truncate to remove first part
			if ( t.tdata_s.Get()[1] == ':' )
			{
				t.chopthis_s=g.rootdir_s;
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[413].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				#ifdef VRTECH
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[478].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[479].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				#endif
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[416].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[561].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[417].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[418].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[433].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"scriptbank\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[464].Get()) ) == 0 )  t.chopthis_s = t.chopthis_s+"gamecore\\decals\\";
				LPSTR pPreferredFolder = "audiobank\\voices\\";
				if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  
				{
					// 151016 - determine if data points to voices folder
					if ( strnicmp ( t.tdata_s.Get() + strlen(t.chopthis_s.Get()), pPreferredFolder, strlen(pPreferredFolder) ) == NULL )
					{
						// default soundset entry into voices folder
						t.chopthis_s = t.chopthis_s + "audiobank\\voices\\";
					}
					else
					{
						// allow normal WAV sounds to be placed in character SoundSet slot (zombies)
						t.chopthis_s = t.chopthis_s;
						pPreferredFolder = NULL;
					}
				}
				t.tdata_s=Right(t.tdata_s.Get(),Len(t.tdata_s.Get())-Len(t.chopthis_s.Get()));
				if ( cstr(Lower(t.tfield_s.Get())) == cstr(Lower(t.strarr_s[464].Get())) 
				||	(cstr(Lower(t.tfield_s.Get())) == cstr(Lower(t.strarr_s[469].Get())) && pPreferredFolder != NULL) ) 
				{
					//  get path (folder name) only
					t.tdata_s=getpath(t.tdata_s.Get()) ; t.tdata_s=Left(t.tdata_s.Get(),Len(t.tdata_s.Get())-1);
				}
			}

			//  All YES and NO strings are auto converted if value expected
			t.tokay=1;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[413].Get()) ) == 0 )  t.tokay = 0;
			#ifdef VRTECH
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[478].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[479].Get()) ) == 0 )  t.tokay = 0;
			#endif
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[436].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[437].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[464].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.tokay = 0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.tokay = 0;
			if (  t.tokay == 1 ) 
			{
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower(t.strarr_s[470].Get()) ) == 0 )  t.tdata_s = "1";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower(t.strarr_s[471].Get()) ) == 0 )  t.tdata_s = "0";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower("no") ) == 0 )  t.tdata_s = "0";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower("a") ) == 0 )  t.tdata_s = "1";
				if (  strcmp ( Lower(t.tdata_s.Get()) , Lower("b") ) == 0 )  t.tdata_s = "2";
			}

			//  FPGC - 070510 - add behaviour folder back, along with FPI (from combo friendly name to script filename)
			if (  cstr(Lower(t.tfield_s.Get())) == "behaviour" ) 
			{
				t.tdata_s = ""; t.tdata_s=t.tdata_s+"behaviours\\"+t.tdata_s+".fpi";
			}

			//  Clipped alternative
			t.tdataclipped_s=Left(t.tdata_s.Get(),63);

			//  get field data
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[413].Get()) ) == 0 )  t.grideleprof.name_s = t.tdataclipped_s;
			#ifdef VRTECH
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[478].Get()) ) == 0 )  t.grideleprof.name_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[479].Get()) ) == 0 )  t.grideleprof.name_s = t.tdataclipped_s;
			#endif
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[414].Get()) ) == 0 )  t.gridentitystaticmode = ValF(t.tdata_s.Get());
			// if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[561].Get()) ) == 0 )  t.grideleprof.aiinit_s = t.tdataclipped_s; //PE: Not used anymore.
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[417].Get()) ) == 0 )  t.grideleprof.aimain_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , "behaviour" ) == 0 )  t.grideleprof.aimain_s = t.tdataclipped_s;
			//if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[418].Get()) ) == 0 )  t.grideleprof.aidestroy_s = t.tdataclipped_s;  //PE: Not used anymore.
			//if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[433].Get()) ) == 0 )  t.grideleprof.aishoot_s = t.tdataclipped_s; //PE: Not used anymore.
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[434].Get()) ) == 0 )  t.grideleprof.coneangle = ValF(t.tdata_s.Get());
			#ifdef VRTECH
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[476].Get()) ) == 0 )  t.grideleprof.conerange = ValF(t.tdata_s.Get());
			#else
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("View Range") ) == 0 )  t.grideleprof.conerange = ValF(t.tdata_s.Get());
			#endif
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[419].Get()) ) == 0 )  t.grideleprof.hasweapon_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[436].Get()) ) == 0 )  t.grideleprof.usekey_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[437].Get()) ) == 0 )  t.grideleprof.ifused_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[562].Get()) ) == 0 )  t.grideleprof.spawnatstart = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[440].Get()) ) == 0 )  t.grideleprof.spawnmax = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[441].Get()) ) == 0 )  t.grideleprof.spawnupto = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[442].Get()) ) == 0 )  t.grideleprof.spawnafterdelay = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[443].Get()) ) == 0 )  t.grideleprof.spawnwhendead = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[444].Get()) ) == 0 )  t.grideleprof.spawndelay = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[445].Get()) ) == 0 )  t.grideleprof.spawnqty = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[564].Get()) ) == 0 )  t.grideleprof.spawndelayrandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[566].Get()) ) == 0 )  t.grideleprof.spawnqtyrandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[568].Get()) ) == 0 )  t.grideleprof.spawnvel = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[570].Get()) ) == 0 )  t.grideleprof.spawnvelrandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[572].Get()) ) == 0 )  t.grideleprof.spawnangle = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[574].Get()) ) == 0 )  t.grideleprof.spawnanglerandom = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[576].Get()) ) == 0 )  t.grideleprof.spawnlife = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[447].Get()) ) == 0 )  t.grideleprof.texd_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[448].Get()) ) == 0 )  t.grideleprof.texaltd_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[578].Get()) ) == 0 )  t.grideleprof.effect_s = t.tdataclipped_s;
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[449].Get()) ) == 0 )  t.grideleprof.transparency = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[450].Get()) ) == 0 )  t.grideleprof.reducetexture = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[454].Get()) ) == 0 )  t.grideleprof.strength = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[453].Get()) ) == 0 )  t.grideleprof.strength = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[457].Get()) ) == 0 )  t.grideleprof.isimmobile = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("LOD Modifier") ) == 0 ) 
			{
				// 301115 - new LOD Modifie value for this entity parent, so propagate to ALL other entities of this parent
				t.grideleprof.lodmodifier = ValF(t.tdata_s.Get());
				int iThisBankIndex = t.gridentity;
				if ( t.entityprofile[iThisBankIndex].addhandlelimb==0 )
				{
					for ( int e=1; e<=g.entityelementlist; e++ )
					{
						if ( t.entityelement[e].bankindex==iThisBankIndex )
						{
							t.entityelement[e].eleprof.lodmodifier = t.grideleprof.lodmodifier;
							entity_calculateentityLODdistances ( iThisBankIndex, t.entityelement[e].obj, t.entityelement[e].eleprof.lodmodifier );
						}
					}
					int iParentSrcObj = g.entitybankoffset + iThisBankIndex;
					entity_calculateentityLODdistances ( iThisBankIndex, iParentSrcObj, t.grideleprof.lodmodifier );
				}
			}
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Occluder") ) == 0 )  t.grideleprof.isocluder = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Occludee") ) == 0 )  t.grideleprof.isocludee = ValF(t.tdata_s.Get());

			//not used in MAX
			//if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Specular") ) == 0 )  t.grideleprof.specularperc = ValF(t.tdata_s.Get());
			
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("End Collision") ) == 0 )  t.grideleprof.colondeath = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Parent Index") ) == 0 )  t.grideleprof.parententityindex = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Parent Limb") ) == 0 )  t.grideleprof.parentlimbindex = ValF(t.tdata_s.Get());

			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[429].Get()) ) == 0 )  t.grideleprof.cantakeweapon = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[430].Get()) ) == 0 )  t.grideleprof.quantity = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[431].Get()) ) == 0 )  t.grideleprof.rateoffire = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[420].Get()) ) == 0 )  t.grideleprof.damage = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[421].Get()) ) == 0 )  t.grideleprof.accuracy = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[422].Get()) ) == 0 )  t.grideleprof.reloadqty = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[423].Get()) ) == 0 )  t.grideleprof.fireiterations = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Range") ) == 0 )  t.grideleprof.range = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Dropoff") ) == 0 )  t.grideleprof.dropoff = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower("Spot Lighting") ) == 0 )  t.grideleprof.usespotlighting = ValF(t.tdata_s.Get());
			if (strcmp(Lower(t.tfield_s.Get()), Lower("Clip Capacity")) == 0)  t.grideleprof.clipcapacity = ValF(t.tdata_s.Get());
			//int weaponpropres1;
			//int weaponpropres2;

			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[424].Get()) ) == 0 )  t.grideleprof.lifespan = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[425].Get()) ) == 0 )  t.grideleprof.throwspeed = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[426].Get()) ) == 0 )  t.grideleprof.throwangle = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[427].Get()) ) == 0 )  t.grideleprof.bounceqty = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[428].Get()) ) == 0 )  t.grideleprof.explodeonhit = ValF(t.tdata_s.Get());
			if (  strcmp( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[455].Get()) ) == 0 )  t.grideleprof.speed = ValF(t.tdata_s.Get());
			#ifdef VRQUEST
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[477].Get()) ) == 0 ) 
			{
				if (  t.playercontrol.thirdperson.enabled == 1 ) 
				{
					t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed=ValF(t.tdata_s.Get());
				}
				else
				{
					t.grideleprof.animspeed=ValF(t.tdata_s.Get());
				}
			}
			#else
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Anim Speed") ) == 0 ) 
			{
				//PE: we cant do this , as t.playercontrol.thirdperson.enabled is a global and will trigger for ALL objects.
				//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/310
//				if (  t.playercontrol.thirdperson.enabled == 1 ) 
//				{
//					t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed=ValF(t.tdata_s.Get());
//				}
//				else
//				{
					t.grideleprof.animspeed=ValF(t.tdata_s.Get());
//				}
			}
			#endif
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[432].Get()) ) == 0 )  t.grideleprof.quantity = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[460].Get()) ) == 0 )  t.grideleprof.quantity = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[452].Get()) ) == 0 )  t.grideleprof.lives = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[456].Get()) ) == 0 )  t.grideleprof.hurtfall = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Blood Effects")  ) == 0 ) t.grideleprof.isviolent = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Regeneration Rate")  ) == 0 ) t.playercontrol.regenrate = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Regeneration Speed")  ) == 0 ) t.playercontrol.regenspeed = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Regeneration Delay")  ) == 0 ) t.playercontrol.regendelay = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Jump Speed")  ) == 0 ) t.playercontrol.jumpmax_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Gravity")  ) == 0 ) t.playercontrol.gravity_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Fall Speed")  ) == 0 ) t.playercontrol.fallspeed_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Climb Angle")  ) == 0 ) t.playercontrol.climbangle_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Wobble Speed")  ) == 0 ) t.playercontrol.wobblespeed_f = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Wobble Height")  ) == 0 ) t.playercontrol.wobbleheight_f = ValF(t.tdata_s.Get())/100.0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Footfall Pace")  ) == 0 ) t.playercontrol.footfallpace_f = ValF(t.tdata_s.Get())/100.0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Acceleration")  ) == 0 ) t.playercontrol.accel_f = ValF(t.tdata_s.Get())/100.0;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Locked")  ) == 0 ) t.playercontrol.thirdperson.cameralocked = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Distance")  ) == 0 ) t.playercontrol.thirdperson.cameradistance = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Y Offset")  ) == 0 ) t.playercontrol.thirdperson.cameraheight = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Focus")  ) == 0 ) t.playercontrol.thirdperson.camerafocus = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera Speed")  ) == 0 ) t.playercontrol.thirdperson.cameraspeed = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Camera X Offset")  ) == 0 ) t.playercontrol.thirdperson.camerashoulder = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Run Mode")  ) == 0 ) t.playercontrol.thirdperson.camerafollow = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Show Reticle")  ) == 0 ) t.playercontrol.thirdperson.camerareticle = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[458].Get()) ) == 0 )  t.grideleprof.isobjective = ValF(t.tdata_s.Get());
			// if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[464].Get()) ) == 0 )  t.grideleprof.basedecal_s = t.tdataclipped_s; //PE: Not used anymore.

			//  FPGC - 300710 - read data changes back into grideleprof
			if (  strcmp ( Lower(t.tfield_s.Get()) , "custom settings"  ) == 0 ) t.grideleprof.particleoverride = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "offsety"  ) == 0 )  t.grideleprof.particle.offsety = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "scale"  ) == 0 )  t.grideleprof.particle.scale = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random start x"  ) == 0 )  t.grideleprof.particle.randomstartx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random start y"  ) == 0 )  t.grideleprof.particle.randomstarty = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random start z"  ) == 0 )  t.grideleprof.particle.randomstartz = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "linear motion x"  ) == 0 )  t.grideleprof.particle.linearmotionx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "linear motion y"  ) == 0 )  t.grideleprof.particle.linearmotiony = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "linear motion z"  ) == 0 )  t.grideleprof.particle.linearmotionz = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random motion x"  ) == 0 )  t.grideleprof.particle.randommotionx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random motion y"  ) == 0 )  t.grideleprof.particle.randommotiony = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "random motion z"  ) == 0 )  t.grideleprof.particle.randommotionz = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "mirror mode"  ) == 0 )  t.grideleprof.particle.mirrormode = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "camera z shift"  ) == 0 )  t.grideleprof.particle.camerazshift = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "scale only x"  ) == 0 )  t.grideleprof.particle.scaleonlyx = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "life increment"  ) == 0 )  t.grideleprof.particle.lifeincrement = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "alpha intensity"  ) == 0 )  t.grideleprof.particle.alphaintensity = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , "animated texture"  ) == 0 )  t.grideleprof.particle.animated , ValF(t.tdata_s.Get()) ;

			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[467].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[468].Get()) ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[480].Get()) ) == 0 )  t.grideleprof.soundset2_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[481].Get()) ) == 0 )  t.grideleprof.soundset3_s = t.tdataclipped_s;
			//if (strcmp (Lower(t.tfield_s.Get()), Lower(t.strarr_s[482].Get())) == 0)		t.grideleprof.soundset5_s = t.tdataclipped_s;
			//if (strcmp (Lower(t.tfield_s.Get()), Lower("Sound5")) == 0)					t.grideleprof.soundset6_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Sound5")) == 0)					t.grideleprof.soundset5_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Sound6")) == 0)					t.grideleprof.soundset6_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[598].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[600].Get()) ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , "voiceover"  ) == 0 ) t.grideleprof.soundset1_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[462].Get()) ) == 0 )  t.grideleprof.light.range = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Text to Appear") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Image File") ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[469].Get()) ) == 0 )  t.grideleprof.soundset_s = t.tdataclipped_s;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("Video Slot") ) == 0 )  t.grideleprof.soundset1_s = t.tdataclipped_s;

			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[580].Get()) ) == 0 )  t.grideleprof.physics = ValF(t.tdata_s.Get());
			if (  t.grideleprof.physics != 1  )  t.grideleprof.physics = 2;
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[582].Get()) ) == 0 )  t.grideleprof.phyalways = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[584].Get()) ) == 0 )  t.grideleprof.phyweight = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[586].Get()) ) == 0 )  t.grideleprof.phyfriction = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[588].Get()) ) == 0 )  t.grideleprof.phyforcedamage = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[590].Get()) ) == 0 )  t.grideleprof.rotatethrow = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[592].Get()) ) == 0 )  t.grideleprof.explodable = ValF(t.tdata_s.Get());
			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[594].Get()) ) == 0 )  t.grideleprof.explodedamage = ValF(t.tdata_s.Get());
			
			//if (  strcmp ( Lower(t.tfield_s.Get()) , Lower("team")  ) == 0 )  t.grideleprof.teamfield = ValF(t.tdata_s.Get());

			if (  strcmp ( Lower(t.tfield_s.Get()) , Lower(t.strarr_s[463].Get()) ) == 0 ) 
			{
				t.tr_s=t.tdata_s;
				for ( t.t = 1 ; t.t<=  Len(t.tr_s.Get()); t.t++ )
				{
					if (  t.tr_s.Get()[t.t-1] == ' ' ) { t.tr_s = Left(t.tr_s.Get(),t.t) ; break; }
				}
				t.tdata_s=Right(t.tdata_s.Get(),(Len(t.tdata_s.Get())-Len(t.tr_s.Get())));
				t.tg_s=t.tdata_s;
				for ( t.t = 1 ; t.t<=  Len(t.tg_s.Get()); t.t++ )
				{
					if (  t.tg_s.Get()[t.t-1] == ' ' ) { t.tg_s = Left(t.tg_s.Get(),t.t)  ; break; }
				}
				t.tb_s=Right(t.tdata_s.Get(),(Len(t.tdata_s.Get())-Len(t.tg_s.Get())));
				t.grideleprof.light.color=Rgb(ValF(t.tr_s.Get()),ValF(t.tg_s.Get()),ValF(t.tb_s.Get()));
			}

		}
	}
}

void interface_closepropertywindow ( void )
{
	//  Close proprty window
	#ifdef FPSEXCHANGE
	if (  t.editorinterfaceactive>0 )
	{
		//  Close dialog
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1, 978, 2 );
		SetFileMapDWORD (  1, 462, 0 );
		SetEventAndWait (  1 );
		t.editorinterfaceactive=0;
	}
	#endif
}

void interface_handlepropertywindow ( void )
{
	#ifdef FPSEXCHANGE
	//  If interface active
	if (  t.editorinterfaceactive>0 ) 
	{
		//  Open for management
		OpenFileMap (  2, "FPSENTITY" );
		SetEventAndWait (  2 );

		//  if APPLY clicked, copy data to entity
		if (  GetFileMapDWORD( 2, 112 ) == 1 ) 
		{
			interface_copydatatoentity ( );
			SetFileMapDWORD (  2, 112, 0 );
			SetEventAndWait (  2 );
			t.editorinterfaceleave=1;
			t.interactive.applychangesused=1;
		}

		//  see if the user clicked on the close button
		if (  GetFileMapDWORD( 2, 108 )  ==  1 ) 
		{
			SetFileMapDWORD (  2, 108, 0 );
			SetEventAndWait (  2 );
			t.editorinterfaceleave=1;
		}

		//  see if the user clicked on the CANCEL button
		if (  GetFileMapDWORD( 2, 116 )  ==  1 ) 
		{
			SetFileMapDWORD (  2, 116, 0 );
			SetEventAndWait (  2 );
			t.editorinterfaceleave=1;
		}
	}
	#endif
}

void interface_live_updates(void)
{
	#ifdef FPSEXCHANGE
	//  constantly open access to properties values
	//  so can represent the values prior to using APPLY CHANGES
	if (Timer() > t.lastliveupdatestimer)
	{
		t.lastliveupdatestimer = Timer() + 200;
		OpenFileMap(2, "FPSENTITY");
		SetEventAndWait(2);
		t.iGroup = t.livegroupforthirdperson;
		t.iControl = 1; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera Distance"))  t.playercontrol.thirdperson.livecameradistance = ValF(t.tdata_s.Get());
		t.iControl = 2; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera X Offset"))  t.playercontrol.thirdperson.livecamerashoulder = ValF(t.tdata_s.Get());
		t.iControl = 3; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera Y Offset"))  t.playercontrol.thirdperson.livecameraheight = ValF(t.tdata_s.Get());
		t.iControl = 4; t.tfield_s = getpropertyfield(t.iGroup, t.iControl); t.tdata_s = getpropertydata(t.iGroup, t.iControl);
		if (cstr(Lower(t.tfield_s.Get())) == Lower("Camera Focus"))  t.playercontrol.thirdperson.livecamerafocus = ValF(t.tdata_s.Get());
		//CloseFileMap (  2 );
	}
	#endif
}

// 
//  Interface Properties Functions
// 

#ifdef ENABLEIMGUI
char* imgui_setpropertyfile2_ex_dlua(int group, char* data_s, char* field_s, char* desc_s, char* within_s, int* piEditedField, char* pButtonControlIfBlocked)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s, lwithin_s = within_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	if (cstr(within_s) == "" || !within_s)  lwithin_s = "";

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::Text(lfields_s.Get());
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		#ifndef WICKEDENGINE
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
		#endif
	}
	strcpy(cTmpInput, ldata_s.Get());

#ifdef WICKEDENGINE
	ImGui::PushItemWidth(-ImGui::CalcTextSize(lfields_s.Get()).x);

	// Display the filename only.
	char filename[MAX_PATH];
	int iCopyLocation = 0;
	for (int i = strlen(cTmpInput) - 1; i >= 0; i--)
	{
		if (cTmpInput[i] == '/' || cTmpInput[i] == '\\')
		{
			iCopyLocation = i+1;
			break;
		}
	}
	strcpy(filename, cTmpInput + iCopyLocation);
	ImGui::InputText(uniquiField.c_str(), &filename[0], MAXTEXTINPUT, ImGuiInputTextFlags_ReadOnly);
	#else
	ImGui::PushItemWidth(-10 - ((ImGui::GetFontSize()*2.0)*3.0) - 2); //-6 padding.
	ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT);
	#endif

	if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();
	ImGui::SameLine();

	uniquiField = "...";
	uniquiField = uniquiField + "##";
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

	bool bAudio = false;
	bool bImage = false;
	bool bVideo = false;
	bool bScript = false;
	bool bParticle = false;
	bool bUseNewAudioWindow = false;
#ifdef USENEWMEDIASELECTWINDOWS
	//bUseNewAudioWindow = true;
	if (pestrcasestr(lwithin_s.Get(), "audiobank"))
	{
		bUseNewAudioWindow = true;
		bAudio = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "\\imagesinzone"))
	{
		bUseNewAudioWindow = true;
		bImage = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "imagebank"))
	{
		bUseNewAudioWindow = true;
		bImage = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "videobank"))
	{
		bUseNewAudioWindow = true;
		bVideo = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
	{
		bUseNewAudioWindow = true;
		bScript = true;
	}
	if (pestrcasestr(lwithin_s.Get(), "particlesbank"))
	{
		bUseNewAudioWindow = true;
		bParticle = true;
	}

#endif

	if (bUseNewAudioWindow )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		bool bProceed = true;
		if (piEditedField)
		{
			if (*piEditedField == 2)
			{
				bProceed = false;
			}
		}
		if (!bProceed)
		{
			ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
			ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
		}
		if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)) || iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
		{
			if (bProceed == true)
			{
				cStr tOldDir = GetDir();
				if (iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
				{
					//Update selected var.
					//MessageBoxA(NULL, sSelectedLibrarySting.Get(), "ReturnVar", 0);

					char * cFileSelected = sSelectedLibrarySting.Get();

					SetDir(tOldDir.Get());

					if (cFileSelected && strlen(cFileSelected) > 0)
					{
						if (piEditedField) *piEditedField = 1;
						std::string relative = cFileSelected;
						std::string fullpath = tOldDir.Get();
						fullpath += "\\";
						if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
							fullpath += lwithin_s.Get();
						replaceAll(relative, fullpath, "");
						strcpy(cTmpInput, relative.c_str());
					}

					iSelectedLibraryStingReturnID = -1; //disable.
					sSelectedLibrarySting = "";
				}
				else
				{
					bExternal_Entities_Window = true;
					iDisplayLibraryType = 0;
					iDisplayLibrarySubType = 0;
					if (bAudio)
						iDisplayLibraryType = 1;
					if (bImage)
						iDisplayLibraryType = 2;
					if (bVideo)
						iDisplayLibraryType = 3;
					if (bScript)
						iDisplayLibraryType = 4;
					if (bParticle)
						iDisplayLibraryType = 5;

					iLibraryStingReturnToID = window->GetID(uniquiField.c_str());
					if (iDisplayLibraryType > 0)
					{
						if (strlen(cTmpInput) > 0)
							sMakeDefaultSelecting = cTmpInput;
					}

				}
			}
		}

		if (!bProceed)
		{
			ImGui::PopItemFlag();
			ImGui::PopStyleVar();
		}

	}
	else
	{
		if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)))
		{
			bool bProceed = true;
			if (piEditedField)
			{
				if (*piEditedField == 2)
				{
					MessageBoxA(NULL, pButtonControlIfBlocked, "Notification", MB_OK);
					bProceed = false;
				}
			}
			if (bProceed == true)
			{
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", lwithin_s.Get(), NULL);
				SetDir(tOldDir.Get());
				if (cFileSelected && strlen(cFileSelected) > 0)
				{
					if (piEditedField) *piEditedField = 1;
					std::string relative = cFileSelected;
					std::string fullpath = tOldDir.Get();
					fullpath += "\\";
					if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
						fullpath += lwithin_s.Get();
					replaceAll(relative, fullpath, "");
					strcpy(cTmpInput, relative.c_str());
				}
			}
		}
	}
	ImGui::PopItemWidth();

	return &cTmpInput[0];

}

char* imgui_setpropertyfile2_dlua(int group, char* data_s, char* field_s, char* desc_s, char* within_s)
{
	return imgui_setpropertyfile2_ex_dlua(group, data_s, field_s, desc_s, within_s, NULL, NULL);
}

char * imgui_setpropertyfile2(int group, char* data_s, char* field_s, char* desc_s, char* within_s)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s, lwithin_s = within_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	if (cstr(within_s) == "" || !within_s)  lwithin_s = "";

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::Text(lfields_s.Get());
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
	}
	strcpy(cTmpInput, ldata_s.Get());

	bool bSoundSet = false;
	if (pestrcasestr(lfields_s.Get(), "soundset") || lfields_s == "Type") {
		bSoundSet = true;
	}
	if (bSoundSet && t.entityprofile[t.gridentity].ischaracter > 0) {

		ImGui::PushItemWidth(-10);

		//Only displayt Male,FeMale selection.
		const char* items[] = { "Male", "Female" };
		int item_current_type_selection = 0; //Default Custom.
		if (pestrcasestr(cTmpInput, "Female")) {
			item_current_type_selection = 1;
		}
		if (ImGui::Combo(uniquiField.c_str(), &item_current_type_selection, items, IM_ARRAYSIZE(items))) {
			strcpy(cTmpInput, items[item_current_type_selection]);
		}
		if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());

		ImGui::PopItemWidth();
		return &cTmpInput[0];

	}

	ImGui::PushItemWidth( -10 - (ImGui::GetFontSize()*2.0) ); //-6 padding.

	ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT);
	if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();
	ImGui::SameLine();

	uniquiField = "...";
	uniquiField = uniquiField + "##";
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

	if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0))) { //ImVec2(ImGui::GetFontSize()*2.0,0)
		//PE: filedialogs change dir so.
		cStr tOldDir = GetDir();
		char * cFileSelected;
		//NOC_FILE_DIALOG_DIR
//		if(bSoundSet)
//			cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", lwithin_s.Get(), NULL);
//		else
			cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", lwithin_s.Get(), NULL);

		SetDir(tOldDir.Get());

		if (cFileSelected && strlen(cFileSelected) > 0) {
			std::string relative = cFileSelected;
			std::string fullpath = tOldDir.Get();
			fullpath += "\\";

			// scriptbank\  //
			if (bSoundSet || pestrcasestr(lwithin_s.Get(), "scriptbank")) {
				if( pestrcasestr(cFileSelected,".lua"))
					fullpath += "scriptbank\\"; //lwithin_s.Get(); PE: This can change in parent mode 2
			}

			replaceAll(relative, fullpath , "");
			strcpy(cTmpInput, relative.c_str() );

			if (bSoundSet) {
				char *found = (char *) pestrcasestr(cTmpInput, "\\");
				if (found)
					found[0] = 0;
				//Remove everything after \\

			}
		}
		//File Selector.
	}

	ImGui::PopItemWidth();

	return &cTmpInput[0];

}

char * imgui_setpropertystring2(int group, char* data_s, char* field_s, char* desc_s)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s , lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	std::string uniquiField = ""; //lfields_s.Get();
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField  = uniquiField+ std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::Text(lfields_s.Get());
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
	}
	ImGui::PushItemWidth(-10);

	int inputFlags = 0;
//	if (!ImGui::IsWindowHovered()) //Not needed input is already disabled in rendertarget.
//		inputFlags = ImGuiInputTextFlags_ReadOnly;

	strcpy(cTmpInput, ldata_s.Get());
	if (ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT, inputFlags)) {
		bImGuiGotFocus = true;
	}
	if (ImGui::IsItemHovered() && ldesc_s != "" ) ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();

	return &cTmpInput[0];
}

char * imgui_setpropertylist2c(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	int current_selection = atoi(ldata_s.Get());

	int listmax = 0;
	listmax = 0;
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweaponsQuick(false, true, true, false);
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) 
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) 
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 21)
	{
		listmax = fillgloballistwithcollectables();
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n])
			{
				current_selection = n;
				break;
			}
		}
	}

	const char* current_item = t.list_s[current_selection].Get();

	std::string uniquiField = ""; //lfields_s.Get()
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);


	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
	ImGui::Text(lfields_s.Get());
	ImGui::SameLine();
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
	ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));

	ImGui::PushItemWidth(-10);

	if (ImGui::BeginCombo(uniquiField.c_str() , current_item)) // The second parameter is the label previewed before opening the combo.
	{
		for (int n = 0; n <= listmax; n++)
		{
			bool is_selected = (current_item == t.list_s[n].Get()); // You can store your selection however you want, outside or inside your objects
			if (ImGui::Selectable(t.list_s[n].Get(), is_selected)) {
				current_selection = n;
				current_item = t.list_s[n].Get();
			}
			if (is_selected)
				ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
		}
		ImGui::EndCombo();
	}
	
	ImGui::PopItemWidth();
	return t.list_s[current_selection].Get();
}

int imgui_setpropertylist2(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	int current_selection = atoi(ldata_s.Get());


	int listmax = 0;

	listmax = 0;
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweapons();
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
	}
	if (listtype == 21)
	{
		listmax = fillgloballistwithcollectables();
	}

	const char* current_item = t.list_s[current_selection].Get();
	
	std::string uniquiField = ""; //lfields_s.Get()
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
	ImGui::Text(lfields_s.Get());
	ImGui::SameLine();
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
	ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));

	ImGui::PushItemWidth(-10);

	if (ImGui::BeginCombo(uniquiField.c_str() , current_item)) // The second parameter is the label previewed before opening the combo.
	{
		for (int n = 0; n <= listmax; n++)
		{
			bool is_selected = (current_item == t.list_s[n].Get() ); // You can store your selection however you want, outside or inside your objects
			if (ImGui::Selectable(t.list_s[n].Get(), is_selected)) {
				current_selection = n;
				current_item = t.list_s[n].Get();
			}
			if (is_selected)
				ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
		}
		ImGui::EndCombo();
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", ldesc_s.Get() );

	ImGui::PopItemWidth();
	return current_selection;
}
#endif

#ifdef FPSEXCHANGE

void startgroup ( char* s_s )
{
	if (  cstr(s_s) == ""  )  s_s = "";
	SetFileMapDWORD (  3,g.g_filemapoffset,2  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(s_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,s_s  ); g.g_filemapoffset += ((Len(s_s)+3)/4 )*4;
}

void endgroup ( void )
{
	SetFileMapDWORD (  3,g.g_filemapoffset,0  ); g.g_filemapoffset += 4;
}

void setpropertystring2 ( int group, char* data_s, char* field_s, char* desc_s )
{
	if (  cstr(data_s) == ""  )  data_s = "";
	SetFileMapDWORD (  3,g.g_filemapoffset,3  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
}

void setpropertycolor2 ( int group, int dataval, char* field_s, char* desc_s )
{
	cstr data_s =  "";
	data_s=data_s+Str(RgbR(dataval))+" "+Str(RgbG(dataval))+" "+Str(RgbB(dataval));
	SetFileMapDWORD (  3,g.g_filemapoffset,4  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  );  g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s.Get())  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s.Get()); g.g_filemapoffset += ((Len(data_s.Get())+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
//endfunction

}

void setpropertyfile2 ( int group, char* data_s, char* field_s, char* desc_s, char* within_s )
{
	cstr s_s =  "";
	if (  cstr(data_s) == ""  )  data_s = "";
	SetFileMapDWORD (  3,g.g_filemapoffset,5  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
	s_s = g.rootdir_s+within_s;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(s_s.Get())  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,s_s.Get()  ); g.g_filemapoffset += ((Len(s_s.Get())+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.strarr_s[321].Get())  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,t.strarr_s[321].Get() ); g.g_filemapoffset += ((Len(t.strarr_s[321].Get())+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.strarr_s[322].Get()) ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,t.strarr_s[322].Get() ); g.g_filemapoffset += ((Len(t.strarr_s[322].Get())+3)/4 )*4;
//endfunction

}

void setpropertylist2 ( int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype )
{
	int listmax = 0;
	if ( strcmp ( data_s , "" ) == 0  )  strcpy ( data_s , "" );
	if (  listtype == 0 ) 
	{
		//  yesno
		if (  strcmp ( data_s , "0" ) == 0  )  strcpy ( data_s , t.strarr_s[471].Get() );
		if (  strcmp ( data_s , "1" ) == 0  )  strcpy ( data_s , t.strarr_s[470].Get() );
	}
	if (  listtype == 11 ) 
	{
		//  behaviours (trim scriptbank behaviours and .fpi)
		strcpy ( data_s , Right(data_s,Len(data_s)-Len("behavioursx")) );
		strcpy ( data_s , Left(data_s,Len(data_s)-4) );
		t.strwork = "" ; t.strwork = t.strwork + Upper(Left(data_s,1))+Lower(Right(data_s,Len(data_s)-1));
		strcpy ( data_s , t.strwork.Get() );
	}
	SetFileMapDWORD (  3,g.g_filemapoffset,6  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,controlindex  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
	listmax=0;
	if (  listtype == 0 ) 
	{
		listmax=1;
		t.list_s[0]=t.strarr_s[471];
		t.list_s[1]=t.strarr_s[470];
	}
	if (  listtype == 1 ) 
	{
		listmax=fillgloballistwithweapons();
	}
	if (  listtype == 11 ) 
	{
		listmax=fillgloballistwithbehaviours();
	}
	SetFileMapDWORD (  3,g.g_filemapoffset,listmax  ); g.g_filemapoffset += 4;
	for ( int i = 0 ; i<=  listmax; i++ )
	{
		SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.list_s[ i ].Get())  ); g.g_filemapoffset += 4;
		SetFileMapString (  3,g.g_filemapoffset,t.list_s[ i ].Get()  ); g.g_filemapoffset += ((Len(t.list_s[ i ].Get())+3)/4 )*4;
	}
//endfunction

}

void setpropertylist3 ( int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype )
{
	int listmax = 0;
	if (  strcmp ( data_s , "" ) == 0  )  strcpy ( data_s , "" );
	if (  strcmp ( data_s , "0" ) == 0  )  strcpy ( data_s , "No" );
	if (  strcmp ( data_s , "1" ) == 0  )  strcpy ( data_s , "A" );
	if (  strcmp ( data_s , "2" ) == 0  )  strcpy ( data_s , "B" );
	SetFileMapDWORD (  3,g.g_filemapoffset,6  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,group  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,controlindex  ); g.g_filemapoffset += 4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(field_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,field_s  ); g.g_filemapoffset += ((Len(field_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(data_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,data_s  ); g.g_filemapoffset += ((Len(data_s)+3)/4 )*4;
	SetFileMapDWORD (  3,g.g_filemapoffset,Len(desc_s)  ); g.g_filemapoffset += 4;
	SetFileMapString (  3,g.g_filemapoffset,desc_s  ); g.g_filemapoffset += ((Len(desc_s)+3)/4 )*4;
	listmax=2;
	Dim (  t.list_s,2  );
	t.list_s[0]="No";
	t.list_s[1]="A";
	t.list_s[2]="B";
	SetFileMapDWORD (  3,g.g_filemapoffset,listmax  ); g.g_filemapoffset += 4;
	for ( int i = 0 ; i<=  listmax; i++ )
	{
		SetFileMapDWORD (  3,g.g_filemapoffset,Len(t.list_s[ i ].Get())  ); g.g_filemapoffset += 4;
		SetFileMapString (  3,g.g_filemapoffset,t.list_s[ i ].Get()  ); g.g_filemapoffset += ((Len(t.list_s[ i ].Get())+3)/4 )*4;
	}
//endfunction

}

void setpropertybase ( int code, char*  s_s )
{
	if ( strcmp ( s_s , "" ) == 0  )  strcpy ( s_s , "" );
	SetFileMapString (  2, STRING_A, s_s );
	SetFileMapString (  2, STRING_B, "" );
	SetFileMapString (  2, STRING_C, "" );
	SetFileMapDWORD (  2, code, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, code )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
//endfunction

}

void setpropertystring ( int group, char* data_s, char* field_s, char* desc_s )
{
	if (  strcmp ( data_s , "" )  )  strcpy ( data_s , "" );
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s );
	SetFileMapString (  2, STRING_C, desc_s );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_ADD_EDIT_BOX, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_EDIT_BOX )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
//endfunction

}

void setpropertycolor ( int group, int dataval, char* field_s, char* desc_s )
{
	cstr data_s =  "";
	data_s=data_s+Str(RgbR(dataval))+" "+Str(RgbG(dataval))+" "+Str(RgbB(dataval));
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s.Get() );
	SetFileMapString (  2, STRING_C, desc_s );
	SetFileMapDWORD (  2, ENTITY_ADD_COLOR_PICKER, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_COLOR_PICKER )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
//endfunction

}

void setpropertyfile ( int group, char* data_s, char* field_s, char* desc_s, char* within_s )
{
	if ( strcmp ( data_s , "" ) == 0 )  strcpy ( data_s , "" );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s );
	SetFileMapString (  2, STRING_C, desc_s );
	t.strwork = "" ; t.strwork = t.strwork + g.rootdir_s+within_s;
	SetFileMapString (  2, 2024, t.strwork.Get() );
	SetFileMapString (  2, 2280, t.strarr_s[321].Get() );
	SetFileMapString (  2, 2536, t.strarr_s[322].Get() );
	SetFileMapDWORD (  2, ENTITY_ADD_FILE_PICKER, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_FILE_PICKER )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
}
#endif

int FillWeaponList(std::vector<std::string>& labels)
{
	int listmax = fillgloballistwithweaponsQuick(true, true, true, false);
	int iWeaponListIndex = 0;

	labels.push_back("No Weapon");
	iWeaponListIndex++;
	for (int gunid = 1; gunid <= g.gunmax; gunid++)
	{
		cstr thisLabel = t.gun[gunid].name_s;
		if (strlen(thisLabel.Get()) == 0) thisLabel = "No Weapon";
		labels.push_back(thisLabel.Get());
		iWeaponListIndex++;
	}

	return(iWeaponListIndex);
}

int fillgloballistwithweaponsQuick(bool forcharacters, bool bForShooting, bool bForMelee, bool bIncludeSlotNotUsedChoice)
{
	int retvalue = 0;
	int gunid = 0;
	Dim(t.list_s, 1 + g.gunmax);

	// when shooting and melee both true, ALL weapons can be chosen (or none)
	bool bForAll = false;
	if (bForShooting == true && bForMelee == true)
		bForAll = true;

	// For drop down , so quick with no file checks.
	if (bForAll==false && forcharacters==true && bForShooting == true && g_bCharacterCreatorPlusActivated == false)
	{
		// when using shooting weapon cannot have No Weapon (use different behavior if want that)
		t.list_s[0] = "enhanced\\Mk19T"; // standard issue pistol
	}
	else
	{
		t.list_s[0] = "";
	}
	int iListCount = 0;
	for (gunid = 1; gunid <= g.gunmax; gunid++)
	{
		bool bIncludeThisWeapon = false;
		if (bForAll == true)
		{
			// all weapons should be listed
			bIncludeThisWeapon = true;
		}
		else
		{
			if (bForShooting == true)
			{
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\AK") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\AR") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\M29S") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Mk18") == NULL) bIncludeThisWeapon = true;
				if (forcharacters == true && bForShooting == true && g_bCharacterCreatorPlusActivated == false)
				{
					// already included above as the default
				}
				else
				{
					if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Mk19T") == NULL) bIncludeThisWeapon = true;
				}
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\R870") == NULL) bIncludeThisWeapon = true;
			}
			if (bForMelee == true)
			{
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\B810") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Gloves_Unarmed") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\SledgeHammer") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "aztec\\AztecAxe") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "aztec\\AztecDagger") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "aztec\\AztecSpear") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "tools\\Hammer") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "tools\\Handsaw") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "tools\\Shovel") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "wasteland\\tools\\Crowbar") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "wasteland\\tools\\LargeScrewdriver") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "wasteland\\tools\\LargeSpanner") == NULL) bIncludeThisWeapon = true;
				if (stricmp(t.gun[gunid].name_s.Get(), "wasteland\\tools\\LumpHammer") == NULL) bIncludeThisWeapon = true;
				if (strnicmp(t.gun[gunid].name_s.Get(), "wasteland\\weapons\\", 18) == NULL) bIncludeThisWeapon = true;
			}
			if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\M67") == NULL) bIncludeThisWeapon = false;
			if (forcharacters == true)
			{
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\B810") == NULL) bIncludeThisWeapon = false;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\Gloves_Unarmed") == NULL) bIncludeThisWeapon = false;
				if (stricmp(t.gun[gunid].name_s.Get(), "enhanced\\SledgeHammer") == NULL) bIncludeThisWeapon = false;
			}
			// any another category should be revealed for all cases (restrict later as new items come in - via gunspec!)
			if (strnicmp(t.gun[gunid].name_s.Get(), "enhanced\\", 9) != NULL && strnicmp(t.gun[gunid].name_s.Get(), "aztec\\", 6) != NULL
				&& strnicmp(t.gun[gunid].name_s.Get(), "wasteland\\", 10) != NULL && strnicmp(t.gun[gunid].name_s.Get(), "tools\\", 6) != NULL)
			{
				bIncludeThisWeapon = true;
			}
		}
		if (bIncludeThisWeapon == true)
		{
			if ( stricmp ( t.gun[gunid].name_s.Get(), "Slot Not Used" ) == NULL )
			{
				if (bIncludeSlotNotUsedChoice == true)
				{
					iListCount++;
					t.list_s[iListCount] = "00000Slot Not Used";
				}
			}
			else
			{
				iListCount++;
				t.list_s[iListCount] = t.gun[gunid].name_s;
			}
		}
	}

	// 190416 - sort weapons into alpha order
	for (int iSortA = 0; iSortA <= iListCount; iSortA++)
	{
		for (int iSortB = 0; iSortB <= iListCount; iSortB++)
		{
			if (iSortA != iSortB && strcmp(t.list_s[iSortA].Get(), t.list_s[iSortB].Get()) < 0)
			{
				// swap over for bubble sort
				cstr pStoreA = t.list_s[iSortA];
				t.list_s[iSortA] = t.list_s[iSortB];
				t.list_s[iSortB] = pStoreA;
			}
		}
	}

	// rename any  "Slot Not Used"
	for (int iFindA = 0; iFindA <= iListCount; iFindA++)
	{
		if(stricmp(t.list_s[iFindA].Get(), "00000Slot Not Used") == NULL)
		{
			t.list_s[iFindA] = "Slot Not Used";
			break;
		}
	}

	// return valid gun name count
	return iListCount;
}

std::vector<cstr> g_HandsList_s;

int fillgloballistwithHands(void)
{
	// initially populate from Hands folder
	if (g_HandsList_s.size() == 0)
	{
		cstr pOld = GetDir();
		SetDir(cstr(g.fpscrootdir_s+cstr("\\Files\\gamecore\\Hands\\")).Get());
		ChecklistForFiles();
		for (int c = 1; c <= ChecklistQuantity(); c++)
		{
			if (ChecklistValueA(c) != 0)
			{
				cstr folder = ChecklistString(c);
				if (folder != "." && folder != ".." && folder != "Animations")
				{
					g_HandsList_s.push_back(folder.Get());
				}
			}
		}
		SetDir(pOld.Get());
	}
	int iHandsCount = g_HandsList_s.size();
	Dim(t.list_s, iHandsCount);
	int iIndex = 0;
	t.list_s[iIndex++] = "No Preference";
	for (int i = 0; i < iHandsCount; i++)
	{
		t.list_s[iIndex++] = g_HandsList_s[i];
	}
	//t.list_s[iIndex++] = "Legacy Combat";
	//t.list_s[iIndex++] = "Male Light";
	//t.list_s[iIndex++] = "Male Dark";
	//t.list_s[iIndex++] = "Female Light";
	//t.list_s[iIndex++] = "Female Dark";
	return iIndex-1;
}

bool g_bCheckedBoosterAnims = false;
bool g_bDoWeHaveBoosterAnims = false;

int fillgloballistwithCharAnimSetsQuick(int iSpecialValue)
{
	// one time check to see if booster anims available
	if (g_bCheckedBoosterAnims == false)
	{
		if (FileExist("charactercreatorplus\\parts\\adult male\\default animations-pistol-lowered.dbo"))
		{
			g_bDoWeHaveBoosterAnims = true;
		}
		g_bCheckedBoosterAnims = true;
	}

	// create list of available animations for standard user dropdown
	Dim(t.list_s, 10);
	int iIndex = 0;
	t.list_s[iIndex] = "Default Animation";
	iIndex++; t.list_s[iIndex] = "Original Animation";
	if (iSpecialValue == 1)
	{
		// adult male soldier
		iIndex++; t.list_s[iIndex] = "Adult Male Pistol";
		iIndex++; t.list_s[iIndex] = "Adult Male Rifle";
		if (g_bDoWeHaveBoosterAnims)
		{
			iIndex++; t.list_s[iIndex] = "Adult Male Pistol Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Male Rifle Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Male Shotgun Lowered";
		}
	}
	if (iSpecialValue == 2)
	{
		// adult male melee
		iIndex++; t.list_s[iIndex] = "Adult Male Melee";
		iIndex++; t.list_s[iIndex] = "Adult Male Axe";
		iIndex++; t.list_s[iIndex] = "Adult Male Spear";
	}
	if (iSpecialValue == 3)
	{
		// adult female soldier
		iIndex++; t.list_s[iIndex] = "Adult Female Pistol";
		iIndex++; t.list_s[iIndex] = "Adult Female Rifle";
		if (g_bDoWeHaveBoosterAnims)
		{
			iIndex++; t.list_s[iIndex] = "Adult Female Pistol Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Female Rifle Lowered";
			iIndex++; t.list_s[iIndex] = "Adult Female Shotgun Lowered";
		}
	}
	if (iSpecialValue == 4)
	{
		// adult female melee
		iIndex++; t.list_s[iIndex] = "Adult Female Melee";
		iIndex++; t.list_s[iIndex] = "Adult Female Axe";
		iIndex++; t.list_s[iIndex] = "Adult Female Spear";
	}
	if (iSpecialValue == 5)
	{
		// zombie male
		iIndex++; t.list_s[iIndex] = "Zombie Male";
	}
	if (iSpecialValue == 6)
	{
		// zombie female
		iIndex++; t.list_s[iIndex] = "Zombie Female";
	}
	if (iSpecialValue == 7)
	{
		// low poly melee
		iIndex++; t.list_s[iIndex] = "Low Poly Melee";
		iIndex++; t.list_s[iIndex] = "Low Poly Axe";
		iIndex++; t.list_s[iIndex] = "Low Poly Spear";
	}
	// return count
	return iIndex;
}

int fillgloballistwithweapons ( void )
{
	int retvalue = 0;
	int gunid = 0;
	Dim (  t.list_s,1+g.gunmax  );
	t.list_s[0] = "";
	int iListCount = 0; // 020316 - v1.13b1 - list can exclude player weapons with no HUDs
	for ( gunid = 1; gunid <= g.gunmax; gunid++ )
	{
		// 020316 - v1.13b1 - quickly check the existence of the HUD.X file to see if we exclude (later change when weapon changes for characters)
		t.tfile_s = cstr("gamecore\\guns\\") + t.gun[gunid].name_s + cstr("\\HUD.X");
		if ( FileExist(t.tfile_s.Get()) == 1 ) 
		{
			iListCount++;
			t.list_s[iListCount] = t.gun[gunid].name_s;
		}
	}

	// 190416 - sort weapons into alpha order
	for ( int iSortA = 0; iSortA <= iListCount; iSortA++ )
	{
		for ( int iSortB = 0; iSortB <= iListCount; iSortB++ )
		{
			if ( iSortA != iSortB && strcmp ( t.list_s[iSortA].Get(), t.list_s[iSortB].Get() ) < 0 )
			{
				// swap over for bubble sort
				cstr pStoreA = t.list_s[iSortA];
				t.list_s[iSortA] = t.list_s[iSortB];
				t.list_s[iSortB] = pStoreA;
			}
		}
	}

	// return valid gun name count
	return iListCount;
}

int fillgloballistwithbehaviours_init ( void )
{
	cstr storedir_s =  "";
	int retvalue = 0;
	cstr file_s =  "";
	int c = 0;
	retvalue=0;
	t.strwork = "" ; t.strwork = t.strwork + g.rootdir_s+"scriptbank\\behaviours";
	if (  PathExist( t.strwork.Get() ) == 1 ) 
	{
		storedir_s=GetDir();
		SetDir (  t.strwork.Get() );
		ChecklistForFiles ();
		Dim (  t.behaviourlist_s,ChecklistQuantity( ) );
		for ( c = 1 ; c<=  ChecklistQuantity(); c++ )
		{
			file_s=ChecklistString(c);
			if (  strcmp ( Lower(Right(file_s.Get(),4)) , ".fpi" ) == 0 ) 
			{
				++retvalue;
				t.strwork = "" ; t.strwork=t.strwork+Left(file_s.Get(),Len(file_s.Get())-4);
				file_s = t.strwork;
				t.behaviourlist_s[retvalue] = ""; t.behaviourlist_s[retvalue]=t.behaviourlist_s[retvalue]+Upper(Left(file_s.Get(),1))+Lower(Right(file_s.Get(),Len(file_s.Get())-1));
			}
		}
		SetDir (  storedir_s.Get() );
	}
	return retvalue;
}

int fillgloballistwithbehaviours ( void )
{
	int behaviourlistmax = 0;
	int retvalue = 0;
	int n;
	retvalue=behaviourlistmax;
	Dim (  t.list_s,retvalue  );
	t.list_s[0]="";
	if (  retvalue>0 ) 
	{
		for ( n = 1 ; n<=  retvalue; n++ )
		{
			t.list_s[n-1]=t.behaviourlist_s[n];
		}
		retvalue=retvalue-1;
	}
	return retvalue;
}

int fillgloballistwithcollectables (void)
{
	Dim (t.list_s, g.entityelementlist);
	t.list_s[0] = "(Choose Collectible)";
	int retvalue = 1;
	for (int e = 1; e <= g.entityelementlist; e++)
	{
		if (t.entityelement[e].bankindex > 0)
		{
			if (t.entityelement[e].eleprof.iscollectable > 0)
			{
				t.list_s[retvalue] = t.entityelement[e].eleprof.name_s;
				retvalue++;
			}
		}
	}
	return retvalue;
}

void setpropertylist ( int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype )
{
	int listmax = 0;
	if ( strcmp ( data_s , "" ) == 0  )  strcpy ( data_s , "" );
	if (  listtype == 0 ) 
	{
		if (  strcmp ( data_s , "0" ) == 0  )  strcpy ( data_s , t.strarr_s[471].Get() );
		if (  strcmp ( data_s , "1" ) == 0  )  strcpy ( data_s , t.strarr_s[470].Get() );
	}
	SetFileMapString (  2, STRING_A, field_s );
	SetFileMapString (  2, STRING_B, data_s );
	SetFileMapString (  2, STRING_C, desc_s );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, controlindex );
	SetFileMapDWORD (  2, ENTITY_ADD_LIST_BOX, 1 );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_ADD_LIST_BOX )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
	listmax=0;
	if (  listtype == 0 ) 
	{
		t.list_s[0]=t.strarr_s[471];
		t.list_s[1]=t.strarr_s[470];
		listmax=1;
	}
	if (  listtype == 1 ) 
	{
		listmax=fillgloballistwithweapons();
	}
	if (  listtype == 11 ) 
	{
		listmax=fillgloballistwithbehaviours();
	}
	for ( int i = 0 ; i<=  listmax; i++ )
	{
		SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
		SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, controlindex );
		SetFileMapString (  2, STRING_A, t.list_s[ i ].Get() );
		SetFileMapDWORD (  2, ENTITY_ADD_ITEM_TO_LIST_BOX, 1 );
		SetEventAndWait (  2 );
		while (  GetFileMapDWORD( 2, ENTITY_ADD_ITEM_TO_LIST_BOX )  ==  1 ) 
		{
			SetEventAndWait (  2 );
		}
	}
//endfunction

}

// 
//  Interface Properties Expressions
// 

char* getpropertyfield ( int group, int iControl )
{
	cstr field_s =  "";
	SetFileMapDWORD (  2, ENTITY_GET_CONTROL_NAME, 1 );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, iControl );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_NAME )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
	field_s = GetFileMapString( 2, STRING_A );
//endfunction field$
	strcpy ( t.szreturn , field_s.Get() );
	return t.szreturn;
}

char* getpropertydata ( int group, int iControl )
{
	cstr data_s =  "";
	SetFileMapDWORD (  2, ENTITY_GET_CONTROL_CONTENTS, 1 );
	SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
	SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, iControl );
	SetEventAndWait (  2 );
	while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_CONTENTS )  ==  1 ) 
	{
		SetEventAndWait (  2 );
	}
	data_s = GetFileMapString( 2, STRING_B );
//endfunction data$
	strcpy ( t.szreturn , data_s.Get() );
	return t.szreturn;
;
}


//COMMON INTERFACE FUNCTIONS


void set_progress_position ( int  item, int  position )
{
			SetFileMapDWORD (  1, SET_PROGRESS_ITEM, item );
			SetFileMapDWORD (  1, SET_PROGRESS_POSITION, position );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_PROGRESS_ITEM ) ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

char* get_list_box ( int  item, int  index )
{
	cstr contents_s =  "";
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, SET_LIST_INDEX, index );
			SetFileMapDWORD (  1, GET_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, GET_LIST_ITEM )  ==  1 )
			{
				SetEventAndWait (  1 );
			}
			contents_s = GetFileMapString (  1, STRING_A );
//endfunction contents$
	strcpy ( t.szreturn , contents_s.Get() );
	return t.szreturn;
}

void set_radio_state ( int  item, int  state )
{
			if (  state == 0  )  state = 2;
			SetFileMapDWORD (  1, SET_RADIO_ITEM, item );
			SetFileMapDWORD (  1, SET_RADIO_STATE, state );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_RADIO_STATE ) > 0 )  
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

int get_radio_state ( int  item )
{
			int state = 0;
			SetFileMapDWORD (  1, SET_RADIO_ITEM, item );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_RADIO_ITEM ) > 0 ) 
			{
				SetEventAndWait (  1 );
			}
			state = GetFileMapDWORD ( 1, GET_RADIO_ITEM );
//endfunction state
	return state;
}

void set_edit_item ( int  item, char*  text_s )
{
			SetFileMapDWORD (  1, SET_EDIT_ITEM, item );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, SET_EDIT_TEXT, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, SET_EDIT_TEXT )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

char* get_edit_item ( int  item )
{
	cstr text_s =  "";
			SetFileMapDWORD (  1, SET_EDIT_ITEM, item );
			SetFileMapDWORD (  1, GET_EDIT_TEXT, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, GET_EDIT_TEXT )  ==  1 )
			{
				SetEventAndWait (  1 );
			}
			text_s = GetFileMapString ( 1, STRING_A );
//endfunction text$
	strcpy ( t.szreturn , text_s.Get() );
	return t.szreturn;
}

void browse ( char*  title_s, char*  directory_s, char*  filter_s )
{
			SetFileMapString (  1, STRING_A, title_s );
			SetFileMapString (  1, STRING_B, directory_s );
			SetFileMapString (  1, STRING_C, filter_s );
			SetFileMapDWORD (  1, BROWSE_DISPLAY, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, BROWSE_FILE_SELECTED ) ==  0 )
			{
				SetEventAndWait (  1 );
			}
			SetFileMapDWORD (  1, BROWSE_FILE_SELECTED, 0 );
			SetFileMapDWORD (  1, BUTTON_CLICKED, 0 );
//endfunction

}

char* browse_for_folder ( char*  directory_s )
{
			cstr text_s =  "";
			SetFileMapString (  1, STRING_A, directory_s );
			SetFileMapDWORD (  1, 200, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, 204 )  ==  0 )
			{
				SetEventAndWait (  1 );
			}
			SetFileMapDWORD (  1, 204, 0 );
			SetEventAndWait (  1 );
			text_s = GetFileMapString ( 1, STRING_A );
			SetFileMapDWORD (  1, BUTTON_CLICKED, 0 );
			SetEventAndWait (  1 );
//endfunction text$
	strcpy ( t.szreturn , text_s.Get() );
	return t.szreturn;
}

void add_list_item ( int  item, char*  text_s )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, ADD_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, ADD_LIST_ITEM )  ==  1 )
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

char* get_list_item ( int  item, int  index )
{
	cstr text_s =  "";
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, SET_LIST_INDEX, index );
			SetFileMapDWORD (  1, GET_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, GET_LIST_ITEM )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
			text_s = GetFileMapString ( 1, STRING_A );
//endfunction text$
	strcpy ( t.szreturn , text_s.Get() );
	return t.szreturn;
}

void delete_list_item ( int  item, int  index )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, SET_LIST_INDEX, index );
			SetFileMapDWORD (  1, DELETE_LIST_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (   1, DELETE_LIST_ITEM )  ==  1  ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

void clear_list ( int  item )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, LIST_CLEAR, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, LIST_CLEAR )  ==  1  ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

void select_list_item ( int  item, int  selectionindex )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, LIST_SELECT_ITEM_INDEX, selectionindex );
			SetFileMapDWORD (  1, LIST_SELECT_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, LIST_SELECT_ITEM )  ==  1  ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

int get_list_item_selection ( int  item )
{
			int selection = -1;
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, GET_LIST_SELECTION, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, GET_LIST_SELECTION )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
			selection = GetFileMapDWORD( 1, LIST_SELECTION );
//endfunction selection
	return selection
;
}

void insert_list_item ( int  item, int  position, char*  text_s )
{
			SetFileMapDWORD (  1, SET_LIST_ITEM, item );
			SetFileMapDWORD (  1, LIST_INSERT_POSITION, position );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, LIST_INSERT_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD (  1, LIST_INSERT_ITEM )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}

void add_combo_box ( int  item, char*  text_s )
{
			SetFileMapDWORD (  1, SET_COMBO_ITEM, item );
			SetFileMapString (  1, STRING_A, text_s );
			SetFileMapDWORD (  1, ADD_COMBO_ITEM, 1 );
			SetEventAndWait (  1 );
			while (  GetFileMapDWORD ( 1, ADD_COMBO_ITEM )  ==  1 ) 
			{
				SetEventAndWait (  1 );
			}
//endfunction

}


//Property Functions


void add_group ( char*  name_s )
{
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapDWORD (  2, ENTITY_ADD_GROUP, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_GROUP )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_edit_box ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_EDIT_BOX, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_EDIT_BOX )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_color_picker ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_COLOR_PICKER, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_COLOR_PICKER )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_file_picker_ex ( int  group, char*  name_s, char*  contents_s, char*  description_s, char*  dir_s, char*  filter_s, char*  title_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapString (  2, 2024, dir_s );
			if (  filter_s != "" ) 
			{
				SetFileMapString (  2, 2280, filter_s );
			}
			else
			{
				SetFileMapString (  2, 2280, t.strarr_s[323].Get() );
			}
			if (  cstr(title_s) != "" ) 
			{
				SetFileMapString (  2, 2536, title_s );
			}
			else
			{
				SetFileMapString (  2, 2536, t.strarr_s[324].Get() );
			}
			SetFileMapDWORD (  2, ENTITY_ADD_FILE_PICKER, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_FILE_PICKER )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_file_picker ( int  group, char*  name_s, char*  contents_s, char*  description_s, char*  dir_s )
{
	add_file_picker_ex( group, name_s, contents_s, description_s, dir_s, "", "" );
//endfunction

}

void add_font_picker ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_FONT_PICKER, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_FONT_PICKER )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_list_box ( int  group, char*  name_s, char*  contents_s, char*  description_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapString (  2, STRING_A, name_s );
			SetFileMapString (  2, STRING_B, contents_s );
			SetFileMapString (  2, STRING_C, description_s );
			SetFileMapDWORD (  2, ENTITY_ADD_LIST_BOX, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_LIST_BOX )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

void add_item_to_list_box ( int  group, int  control, char*  item_s )
{
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapString (  2, STRING_A, item_s );
			SetFileMapDWORD (  2, ENTITY_ADD_ITEM_TO_LIST_BOX, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_ADD_ITEM_TO_LIST_BOX )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
//endfunction

}

char* get_control_name ( int  group, int  control )
{
	cstr name_s =  "";
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapDWORD (  2, ENTITY_GET_CONTROL_NAME, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_NAME )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
			name_s =  GetFileMapString( 2, STRING_A );
//endfunction name$
	strcpy ( t.szreturn , name_s.Get() );
	return t.szreturn;
}

char* get_control_contents ( int  group, int  control )
{
	cstr contents_s =  "";
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapDWORD (  2, ENTITY_GET_CONTROL_CONTENTS, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_CONTENTS )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
			contents_s = GetFileMapString( 2, STRING_B );
//endfunction contents$
	strcpy ( t.szreturn , contents_s.Get() );
	return t.szreturn;
}

char* get_control_description ( int  group, int  control )
{
	cstr description_s =  "";
			SetFileMapDWORD (  2, ENTITY_SET_GROUP_INDEX, group );
			SetFileMapDWORD (  2, ENTITY_SET_CONTROL_INDEX, control );
			SetFileMapDWORD (  2, ENTITY_GET_CONTROL_DESCRIPTION, 1 );
			SetEventAndWait (  2 );
			while (  GetFileMapDWORD( 2, ENTITY_GET_CONTROL_DESCRIPTION )  ==  1 ) 
			{
				SetEventAndWait (  2 );
			}
			description_s = GetFileMapString( 2, STRING_C );
//endfunction description$
	strcpy ( t.szreturn , description_s.Get() );
	return t.szreturn;
}

//Memory check behaviour for MAP EDITOR / TEST GAME

void checkmemoryforgracefulexit ( void )
{
	int recoverdonotuseany3dreferences = 0;
	int ttogglebannertimer = 0;
	int tredscreencount = 0;
	int tsmemavailable = 0;
	int ttogglebanner = 0;
	int tokay = 0;

	//  if cannot create 100MB of contiguous memory, we're nearing the max fragmentation level
	if (  t.game.gameisexe == 0 && g.globals.memorydetector == 1 ) 
	{
	tsmemavailable=SMEMAvailable(1);
	if (  tsmemavailable>1600000 ) 
	{

		//  The Red Screen of Resurrection
		t.strwork = ""; t.strwork = t.strwork + "checkmemoryforgracefulexit - memory detector "+Str(tsmemavailable)+" Kb";
		timestampactivity(0, t.strwork.Get() );
		tredscreencount=Timer()+2000;
		ttogglebannertimer=Timer()+450;
		while (  Timer()<tredscreencount ) 
		{
			CLS (  Rgb(128,0,0) );
			if (  Timer()>ttogglebannertimer ) 
			{
				ttogglebannertimer=Timer()+450;
				ttogglebanner=1-ttogglebanner;
			}
			PasteImage (  g.editorimagesoffset+5+ttogglebanner,(GetDisplayWidth()-ImageWidth(g.editorimagesoffset+5))/2,(GetDisplayHeight()-ImageHeight(g.editorimagesoffset+5))/2 );
			Sync (  );
		}

		#ifdef FPSEXCHANGE
		//  close conmunication with editor
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1,974,2 );

		//  Before we 'BIN OUT', signal IDE that we wish to return to the IDE editor state
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1, 970, 1 );
		SetEventAndWait (  1 );

		//  message Box (  - resolution has been changed - must restart - save changes? )
		OpenFileMap (  1, "FPSEXCHANGE" );
		SetFileMapDWORD (  1, 900, 1 );
		SetFileMapString (  1, 1256, t.strarr_s[622].Get() );
		SetFileMapString (  1, 1000, t.strarr_s[623].Get() );
		SetEventAndWait (  1 );
		while (  GetFileMapDWORD(1, 900) == 1 ) 
		{
			SetEventAndWait (  1 );
		}
		tokay=GetFileMapDWORD(1, 904);
		#endif

		if (  tokay == 1 ) 
		{
			//  no references to 3D objects
			recoverdonotuseany3dreferences=1;
			//  save as now
			gridedit_saveas_map ( );
		}

		//  call a new map editor
		#ifdef FPSEXCHANGE
		OpenFileMap (  2, "FPSEXCHANGE" );
		SetFileMapString (  2, 1000, "Guru-MapEditor.exe" );
		SetFileMapString (  2, 1256, "-r" );
		SetFileMapDWORD (  2, 994, 0 );
		SetFileMapDWORD (  2, 924, 1 );
		SetEventAndWait (  2 );
		#endif

		//  Terminate fragmented EXE
		common_justbeforeend();
		ExitProcess ( 0 );
	}
	}
}

int get_cursor_scale_for_obj ( int tObj )
{
	t.tSizeX_f = ObjectSizeX(tObj,1);
	t.tSizeZ_f = ObjectSizeZ(tObj,1);
	t.tscale_f= Sqrt(t.tSizeX_f*t.tSizeX_f + t.tSizeZ_f*t.tSizeZ_f)*3.0;
	return t.tscale_f;
}

#ifdef ENABLEIMGUI
void AddPayLoad(ImGuiPayload* payload, bool addtocursor)
{
#ifdef WICKEDENGINE
	//PE: For this to work in wicked we need to shutdown ALL objects created in new enitylib.
	//PE: or g.entidmaster will get reset. and not display anything.
	bool bSetEntIDMaster = false;
	if ( g_TempimageList.size() > 0)
	{
		if(iRestoreEntidMaster >= 0)
			bSetEntIDMaster = true;
		FreeTempImageList();
	}

#endif
	extern cFolderItem::sFolderFiles *pDragDropFile;
	if (pDragDropFile) {

		IM_ASSERT(payload->DataSize == sizeof(cFolderItem::sFolderFiles *));
		cFolderItem::sFolderFiles * payload_n = (cFolderItem::sFolderFiles *) payload->Data;
		payload_n = payload_n->m_dropptr;
		if (payload_n) 
		{
			//Add the item.
			CloseDownEditorProperties();
			t.inputsys.constructselection = 0;
			#ifdef WICKEDENGINE
			iLastEntityOnCursor = 0;
			#endif

			t.addentityfile_s = payload_n->m_sFolder.Get();
			if (t.addentityfile_s != "")
			{
				entity_adduniqueentity(false);
				t.tasset = t.entid;
				if (t.talreadyloaded == 0)
				{
					editor_filllibrary();
				}
			}
			if (addtocursor) 
			{
				bool bNormalMasterAdd = true;
				#ifdef WICKEDENGINE
				if (payload_n->iAnimationFrom >= 200000)
				{
					//Special multiply object drag drop.
					g.entityrubberbandlist.clear();
					float centerx = GGORIGIN_X;
					float centery = GGORIGIN_Y;
					float centerz = GGORIGIN_Z;
					int iAnchorEntityIndex = -1;
					float higesty = -999999.0f, lowesty = 999999.0;
					int gridcol = sqrt(selected_library_fpe.size());
					if (gridcol < 1) gridcol = 1;
					int gridcolcount = 0;
					for (std::map<std::string, int>::iterator it = selected_library_fpe.begin(); it != selected_library_fpe.end(); ++it)
					{
						if (it->first.length() > 0)
						{
							//Add
							t.addentityfile_s = it->first.c_str();
							if (t.addentityfile_s != "")
							{
								entity_adduniqueentity(false);
								t.tasset = t.entid;
								if (t.talreadyloaded == 0)
								{
									editor_filllibrary();
								}
							}

							int masterobj = g.entitybankoffset + t.entid;

							// duplicate new entity as clone of relevant original clipboard entity
							bool bLowestFound = false;
							t.gridentity = t.entid;

							#define MINGRIDSIZE 20
							float gsx = ObjectSizeX(masterobj) / 2.0f;
							if (gsx < MINGRIDSIZE) gsx = MINGRIDSIZE;
							centerx += gsx * 1.05f;

							//PE: all t.gridentity... need to be set for this to work correctly.
							entity_fillgrideleproffromprofile();  // t.entid
							t.gridentitystaticmode = t.entityprofile[t.entid].defaultstatic;
							t.gridentityposx_f = centerx;
							t.gridentityposy_f = centery;
							t.gridentityposz_f = centerz;
							t.gridentityrotatex_f = ObjectAngleX(masterobj);
							t.gridentityrotatey_f = ObjectAngleY(masterobj);
							t.gridentityrotatez_f = ObjectAngleZ(masterobj);
							t.gridentityrotatequatmode = 0;
							t.gridentityrotatequatx_f = 0;
							t.gridentityrotatequaty_f = 0;
							t.gridentityrotatequatz_f = 0;
							t.gridentityrotatequatw_f = 1;
							t.gridentityscalex_f = ObjectScaleX(masterobj);
							t.gridentityscaley_f = ObjectScaleY(masterobj);
							t.gridentityscalez_f = ObjectScaleZ(masterobj);

							if (higesty < t.gridentityposy_f) higesty = t.gridentityposy_f;
							if (lowesty > t.gridentityposy_f)
							{
								lowesty = t.gridentityposy_f;
								bLowestFound = true;
							}

							#ifdef WICKEDENGINE
							//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
							extern bool bNextObjectMustBeClone;
							bNextObjectMustBeClone = true;
							#endif

							gridedit_addentitytomap(); //Add it to map set t.e

							#ifdef WICKEDENGINE
							bNextObjectMustBeClone = false;
							#endif

							if (iAnchorEntityIndex == -1 || bLowestFound) iAnchorEntityIndex = t.e;

							// and add to new rubber band group
							sRubberBandType rubberbandItem;
							rubberbandItem.e = t.e;
							rubberbandItem.x = t.entityelement[t.e].x;
							rubberbandItem.y = t.entityelement[t.e].y;
							rubberbandItem.z = t.entityelement[t.e].z;
							#ifdef WICKEDENGINE
							rubberbandItem.px = t.entityelement[t.e].x;
							rubberbandItem.py = t.entityelement[t.e].y;
							rubberbandItem.pz = t.entityelement[t.e].z;
							rubberbandItem.rx = t.entityelement[t.e].rx;
							rubberbandItem.ry = t.entityelement[t.e].ry;
							rubberbandItem.rz = t.entityelement[t.e].rz;						
							rubberbandItem.quatmode = t.entityelement[t.e].quatmode;
							rubberbandItem.quatx = t.entityelement[t.e].quatx;
							rubberbandItem.quaty = t.entityelement[t.e].quaty;
							rubberbandItem.quatz = t.entityelement[t.e].quatz;
							rubberbandItem.quatw = t.entityelement[t.e].quatw;
							rubberbandItem.scalex = t.entityelement[t.e].scalex;
							rubberbandItem.scaley = t.entityelement[t.e].scaley;
							rubberbandItem.scalez = t.entityelement[t.e].scalez;
							#endif
							g.entityrubberbandlist.push_back(rubberbandItem);

							/* grids shape not predictable, so lets go for a simple row
							//Make grid , perhaps wrap.
							#define MINGRIDSIZE 120
							float gsx = ObjectSizeX(masterobj);
							float gsz = ObjectSizeZ(masterobj);
							if (gsx < MINGRIDSIZE) gsx = MINGRIDSIZE;
							if (gsz < MINGRIDSIZE) gsz = MINGRIDSIZE;
							centerx += gsx * 1.25;
							if (++gridcolcount >= gridcol)
							{
								centerz += gsz * 1.25;
								centerx = GGORIGIN_X;
								gridcolcount = 0;
							}
							*/
							centerx += gsx * 1.05f;
						}
					}
					if (iAnchorEntityIndex != -1)
					{
						//Select and add first entity to cursor, along with the rubberband.
						AddEntityToCursor(iAnchorEntityIndex, false);

						//Change to just place under cursor.
						t.inputsys.dragoffsetx_f = 0;
						t.inputsys.dragoffsety_f = 0;
						fHitPointX = 0;
						fHitPointY = HITPOINTYSTARTPOS;
						fHitPointZ = 0;
						fHitOffsetX = 0;
						fHitOffsetY = 0;
						fHitOffsetZ = 0;

						g_bHoldGridEntityPosWhenManaged = true;
						g_fHoldGridEntityPosX = t.gridentityposx_f;
						g_fHoldGridEntityPosY = t.gridentityposy_f;
						g_fHoldGridEntityPosZ = t.gridentityposz_f;

						/*LB: not robust enough, and should not change modes without users permission
						//PE: Make sure cursor offset is set at bottom of selection list.
						float seletion_height = higesty - lowesty;
						if (seletion_height > 1.0f && seletion_height < 5000.0f)
						{
							fHitOffsetY = seletion_height;
						}
						//PE: Always start in horizontal mode.
						iObjectMoveMode = 0;
						*/
					}
					bNormalMasterAdd = false;
					t.onetimeentitypickup = 0;

					//When dragging in many objects, window is in the way , close it down.
					if (bExternal_Entities_Window && selected_library_fpe.size() > 2 )
						bCheckForClosing = true;
				}
				else if (payload_n->iAnimationFrom >= 100000)
				{
					int l = payload_n->iAnimationFrom - 100000;
					DuplicateFromListToCursor(vEntityGroupList[l]);
					bNormalMasterAdd = false;
					t.onetimeentitypickup = 0;
					//bCreateNewGroupOnNextDrop = true; //PE: Dont create a new group when drag/drop a group.
				}
				else if (payload_n->iAnimationFrom > 0 )
				{
					AddEntityToCursor(payload_n->iAnimationFrom,true);
					bNormalMasterAdd = false;
					t.onetimeentitypickup = 0;
				}
				#endif
				if (bNormalMasterAdd)
				{
					//PE: TODO check if t.entid is valid here.
					//Make sure we are in entty mode.
					bForceKey = true;
					csForceKey = "e";
					#ifdef WICKEDENGINE
					csForceKey = "o";
					iExtractMode = 0; //PE: Always start in find floor mode.
					t.inputsys.dragoffsetx_f = 0;
					t.inputsys.dragoffsety_f = 0;
					fHitPointX = 0;
					fHitPointY = HITPOINTYSTARTPOS;
					fHitPointZ = 0;
					fHitOffsetX = 0;
					fHitOffsetY = 0;
					fHitOffsetZ = 0;

					g_bHoldGridEntityPosWhenManaged = true;
					g_fHoldGridEntityPosX = t.gridentityposx_f;
					g_fHoldGridEntityPosY = t.gridentityposy_f;
					g_fHoldGridEntityPosZ = t.gridentityposz_f;

					#endif
					t.inputsys.constructselection = t.tasset;
					t.gridentity = t.entid;
					t.inputsys.constructselection = t.entid;
					t.inputsys.domodeentity = 1;
					t.grideditselect = 5;
					#ifdef WICKEDENGINE
					//Make sure we use a fresh t.grideleprof
					entity_fillgrideleproffromprofile();
					#endif
					editor_refresheditmarkers();
				}
				//PE: Removed in design "Keep window open when dragging in objects to level".
				//PE: Now always close window.
				//#ifndef WICKEDENGINE
				if(bExternal_Entities_Window)
					bCheckForClosing = true;
				//#endif
			}
		}
		pDragDropFile = NULL;
	}

	#ifdef WICKEDENGINE
	if (bSetEntIDMaster)
	{
		iRestoreEntidMaster = g.entidmaster;
	}
	#endif
}

bool TutorialNextAction(void)
{
	tut.iCurrent_Step++;
	return true;
}


//Check if we need to point in the game scene.
bool bReadyForMouseRelease = false;
bool CheckTutorialPlaceit(void)
{
	if (tut.bActive && t.inputsys.mclick == 0 && t.gridentity != 0 ) //
		return CheckTutorialAction("PLACEIT"); //Tutorial: check if we are waiting for this action
	if (tut.bActive && t.gridentity == 0) //terrain
	{
		if (CheckTutorialAction("PLACEIT")) {
			if (t.inputsys.mclick == 0) {
				if (bReadyForMouseRelease) {
					//released.
					TutorialNextAction();
					bReadyForMouseRelease = false;
				}
			}
			else {
				bReadyForMouseRelease = true;
			}
		}
		else bReadyForMouseRelease = false;
		return false;
	}
	else {
		bReadyForMouseRelease = false;
	}
	return false;
}

bool CheckTutorialAction(const char * action, float x_adder)
{
	g_bInTutorialMode = false;
	if (bHelp_Window && tutorial_files.size() >= selected_tutorial) 
	{
		if (tut.bActive) 
		{
			//Tutorial Active.
			g_bInTutorialMode = true;
			if (tut.iCurrent_Step >= 0 && tut.iCurrent_Step < TUTORIALMAXSTEPS) {
				if (pestrcasestr(tut.cStepAction[tut.iCurrent_Step], action)) {

					if (!bTutorialRendered && bImGuiFrameState && !bImGuiReadyToRender) {

						ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
						ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;

						//Display the pointer here.
						bTutorialRendered = true; //Make sure we only render one window.
		
						ImVec2 oldpos = ImGui::GetCursorPos();

						ImGuiStyle &st = ImGui::GetStyle();
						float oldborder = st.PopupBorderSize;

						static float sincounter = 0.0f;
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						ImVec2 pos = window->DC.CursorPos;

						//if ((pos.y-32.0f) > viewPortPos.y) //Dont allow it to display outside main viewport
						//{
							float icon_additional_size = 32.0f;
							st.PopupBorderSize = 0;
							pos.x += x_adder + 4;
							pos.x -= (icon_additional_size*0.60);
							//pos.y -= 80.0f;
							pos.y += 80.0f; // pointer points up now (could make this a toggle mode)
							pos.y -= icon_additional_size;
							pos.y += sin(sincounter) * 22.0f;
							sincounter = sincounter + (5.5f*t.ElapsedTime_f);
							if (sincounter >= 360.0f) sincounter -= 360.0f;

							if (strcmp(tut.cStepAction[tut.iCurrent_Step], "PLACEIT") == 0) {
								pos = OldrenderTargetPos + ImVec2((OldrenderTargetSize.x*0.5f) - 64.0f, 60 + (sin(sincounter) * 22.0f));
								pos += tut.vOffsetPointer[tut.iCurrent_Step];
								//ImGui::SetNextWindowPos(OldrenderTargetPos + ImVec2((OldrenderTargetSize.x*0.5f) - 64.0f, 80 + (sin(sincounter) * 22.0f)));
							}

							ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TUTORIAL_POINTERUP);
							if (lpTexture) 
							{
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								ImGui::GetForegroundDrawList()->AddImage((ImTextureID)lpTexture, pos , pos + ImVec2(64+icon_additional_size, 64+icon_additional_size), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
							}

							/*
							//This system will make non transparent window when outside main viewport. (has its own main window).
							ImGui::SetNextWindowPos(pos);
							ImGui::SetNextWindowBgAlpha(0.0f);
							ImGuiWindowFlags flags = ImGuiNextWindowDataFlags_HasBgAlpha | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDocking;
							ImGui::Begin("##TutorialPointerWindow", NULL, flags);
							ImGui::ImgBtn(TUTORIAL_POINTER, ImVec2(64, 64), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false);
							ImGui::End();
							*/
						//}
						st.PopupBorderSize = oldborder;
						ImGui::SetCursorPos(oldpos);
					}
					bTutorialCheckAction = true;
					return true;
				}
			}
		}
	}
	//selected_tutorial
	bTutorialCheckAction = false;
	return false;
}


float ApplyPivot(sObject* pObject, int iMode, GGVECTOR3 vecValue, float fValue)
{
	if (pObject->position.bApplyPivot)
	{
		GGVec3TransformCoord(&vecValue, &vecValue, &pObject->position.matPivot);

		if (iMode == 0) return vecValue.x;
		if (iMode == 1) return vecValue.y;
		if (iMode == 2) return vecValue.z;
	}

	return fValue;
}


void RenderToPreview(int displayobj)
{
	float oldx_f, oldy_f, oldz_f, oldangx_f, oldangy_f;
	int entid = displayobj - g.entitybankoffset;

	// prepare for thumb , set camera.
	oldx_f = t.editorfreeflight.c.x_f;
	oldy_f = t.editorfreeflight.c.y_f;
	oldz_f = t.editorfreeflight.c.z_f;
	oldangx_f = t.editorfreeflight.c.angx_f;
	oldangy_f = t.editorfreeflight.c.angy_f;

	float fLargestY = ObjectSizeY(displayobj,1); // Also add scale (,1)
	float fLargestX = ObjectSizeX(displayobj,1);
	float fLargestZ = ObjectSizeZ(displayobj,1);

	float fOffsetX = 0.0f,fOffsetZ = 0.0f;

	float terrain_height = BT_GetGroundHeight(t.terrain.TerrainID, GGORIGIN_X, GGORIGIN_Z, 1);

	sObject* pObject = g_ObjectList[displayobj];
	if (pObject && t.entityprofile[entid].ischaracter != 1) {
		float fAdjustScaleX = 1.0, fAdjustScaleZ = 1.0;
		if (pObject->pInstanceOfObject)
		{
			fAdjustScaleX = pObject->position.vecScale[0];
			fAdjustScaleZ = pObject->position.vecScale[2];
			pObject = pObject->pInstanceOfObject;
		}
		float fValue = (pObject->collision.vecMax[0] + pObject->collision.vecMin[0]);
		fValue = ApplyPivot(pObject, 0, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
		fValue = fValue * pObject->position.vecScale[0] * fAdjustScaleX;
		fOffsetX = fValue * 0.5f;

		fValue = (pObject->collision.vecMax[2] + pObject->collision.vecMin[2]);
		fValue = ApplyPivot(pObject, 2, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
		fValue = fValue * pObject->position.vecScale[2] * fAdjustScaleZ;
		fOffsetZ = fValue * 0.5f;
	}
	float fLargest = fLargestX;

	if (fLargestZ > fLargest)
		fLargest = fLargestZ;
	
	fLargest += (fLargestY * 0.2);
	//Prevent camera for getting to far away.
	if (fLargest >= 1500) fLargest = 1500;
	if (fLargestY >= 1500) fLargestY = 1500;

	t.editorfreeflight.c.x_f = 25650 + (fLargest*2.4);
	if(fLargestY < 10.0f)
		t.editorfreeflight.c.y_f = terrain_height + 80 + (fLargestY*1.85);
	else
		t.editorfreeflight.c.y_f = terrain_height + 50 + (fLargestY*1.85);
	t.editorfreeflight.c.z_f = 25550 - (fLargest*2.4);
	t.editorfreeflight.c.angx_f = 13;
	t.editorfreeflight.c.angy_f = -180;
	t.editorfreeflight.s = t.editorfreeflight.c;

	//Preview object could be reused so store old pos.
	float fOldObjPosX = ObjectPositionX(displayobj), fOldObjPosY = ObjectPositionY(displayobj), fOldObjPosZ = ObjectPositionZ(displayobj);
	bool bDisplayObjVisible = false;
	bool bWaterVisible = false;

	if (g_ObjectList[t.terrain.objectstartindex + 2] && g_ObjectList[t.terrain.objectstartindex + 2]->bVisible)
		bWaterVisible = true;

	if (g_ObjectList[displayobj] && g_ObjectList[displayobj]->bVisible)
		bDisplayObjVisible = true;

	//custom clear color.
	custom_back_color[0] = 119.0f/255.0f; custom_back_color[1] = 154.0f / 255.0f; custom_back_color[2] = 181.0f / 255.0f; custom_back_color[3] = 1.0f;

	//Hide everything.
	widget_hide();
	ebe_hide();
	terrain_paintselector_hide();
	#ifdef WICKEDENGINE
	t.geditorhighlightingtentityID = 0;
	#endif

	editor_restoreentityhighlightobj();
	gridedit_clearentityrubberbandlist();
	waypoint_hideall();

	//  "hide" all entities in map by moving them out the way
	for (t.tcce = 1; t.tcce <= g.entityelementlist; t.tcce++)
	{
		t.tccentid = t.entityelement[t.tcce].bankindex;
		if (t.tccentid > 0)
		{
			t.tccsourceobj = t.entityelement[t.tcce].obj;
			if (ObjectExist(t.tccsourceobj) == 1)
			{
				PositionObject(t.tccsourceobj, 0, 0, 0);
			}
		}
	}


	PositionCamera(t.editorfreeflight.c.x_f, t.editorfreeflight.c.y_f, t.editorfreeflight.c.z_f);
	RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);
	PointCamera(GGORIGIN_X + fOffsetX, terrain_height, GGORIGIN_Z + fOffsetZ);
	
	if(fLargestY > 1000.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 9.0f; //6.0
	else if (fLargestY > 500.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 8.0f; //6.0
	else if (fLargestY > 150.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 7.0f; //6.0
	else if (fLargestY > 100.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 6.0f; //6.0
	else if (fLargestY > 50.0f)
		t.editorfreeflight.c.angx_f = CameraAngleX() - 5.0f; //6.0
	else
		t.editorfreeflight.c.angx_f = CameraAngleX() - 4.0f; //6.0
	t.editorfreeflight.c.angy_f = CameraAngleY();
	RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);

	PositionObject(displayobj, GGORIGIN_X, terrain_height, GGORIGIN_Z);

	HideObject(t.terrain.objectstartindex + 2); //hide water

	if (t.entityprofile[entid].ismarker != 0 || t.entityprofile[entid].zdepth == 0)
	{
		SetObjectMask(displayobj, 1);
	}
	else
	{
		SetObjectMask(displayobj, 1 + (1 << 31));
	}

	ShowObject(displayobj);
	
	visuals_justshaderupdate();

	if (t.terrain.TerrainID > 0)
	{
		if (g.globals.riftmode > 0)
		{
		}
		else
		{
			terrain_renderonly();
		}
	}

	bImGuiInTestGame = true; //just reuse this to prevent imgui rendering.
	FastSync();
	bImGuiInTestGame = false;

	if(bWaterVisible)
		ShowObject(t.terrain.objectstartindex + 2);
	if( bDisplayObjVisible )
		ShowObject(displayobj);
	else
		HideObject(displayobj);



	PositionObject(displayobj, fOldObjPosX, fOldObjPosY, fOldObjPosZ);
	
	// delete previous thumbnail
	if (GetImageExistEx(g.importermenuimageoffset + 50))
	{
		image_setlegacyimageloading(true);
		DeleteImage(g.importermenuimageoffset + 50);
		image_setlegacyimageloading(false);
	}

	// we can't grab from the backbuffer when we use a camera image.
	extern DBPRO_GLOBAL CCameraManager m_CameraManager;
	DBPRO_GLOBAL tagCameraData* m_mycam;
	m_mycam = m_CameraManager.GetData(0);
	float thumbnail_dimension = 512;
	if (m_mycam)
	{
		extern GlobStruct* g_pGlob;
		LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
		g_pGlob->pCurrentBitmapSurface = m_mycam->pCameraToImageSurface;

		ImVec2 grab = ImVec2((m_mycam->viewPort3D.Width*0.5) - (thumbnail_dimension*0.5) , (m_mycam->viewPort3D.Height*0.5) - (thumbnail_dimension*0.5) );

		GrabImage(g.importermenuimageoffset + 50, grab.x, grab.y, grab.x+thumbnail_dimension, grab.y + thumbnail_dimension, 0);
		g_pGlob->pCurrentBitmapSurface = pTmpSurface;
	}


	//Restore camera.
	t.editorfreeflight.c.x_f = oldx_f;
	t.editorfreeflight.c.y_f = oldy_f;
	t.editorfreeflight.c.z_f = oldz_f;
	t.editorfreeflight.c.angx_f = oldangx_f;
	t.editorfreeflight.c.angy_f = oldangy_f;
	PositionCamera(t.editorfreeflight.c.x_f, t.editorfreeflight.c.y_f, t.editorfreeflight.c.z_f);
	RotateCamera(t.editorfreeflight.c.angx_f, t.editorfreeflight.c.angy_f, 0);


	//Display everything again.
	t.inputsys.dowaypointview = 0;
	
	//Restore.
	waypoint_restore();
	t.gridentityhidemarkers = 0;
	editor_updatemarkervisibility();
	editor_refresheditmarkers();

	//  put all entities back where they were
	for (t.tcce = 1; t.tcce <= g.entityelementlist; t.tcce++)
	{
		t.tccentid = t.entityelement[t.tcce].bankindex;
		if (t.tccentid > 0)
		{
			t.tccsourceobj = t.entityelement[t.tcce].obj;
			if (ObjectExist(t.tccsourceobj) == 1)
			{
				PositionObject(t.tccsourceobj, t.entityelement[t.tcce].x, t.entityelement[t.tcce].y, t.entityelement[t.tcce].z);
			}
		}
	}

	//Turn off custom clear color.
	custom_back_color[0] = 0.0f; custom_back_color[1] = 0.0f; custom_back_color[2] = 0.0f; custom_back_color[3] = 0.0f;

	bImGuiInTestGame = true;
	FastSync();
	bImGuiInTestGame = false;

}


void CheckTooltipObjectDelete(void)
{
	if (!iTooltipAlreadyLoaded) {

		t.tentitytoselect = iTooltipLastObjectId;
		t.entobj = g.entitybankoffset + iTooltipLastObjectId;
		//entity_deleteentityfrommap(); //We dont actually have a entityelement
		if (ObjectExist(g.entitybankoffset + iTooltipLastObjectId)) {
			DeleteObject(g.entitybankoffset + iTooltipLastObjectId);
		}
		iTooltipLastObjectId = 0;
	}
}

void get_tutorials(void)
{
	cStr tOldDir = GetDir();

	tutorial_files.clear();
	tutorial_videos.clear();
	tutorial_description.clear();

	//PE: Add introduction video by hand.
	cstr cIntroVideo = "9901 - Introduction Video";
	tutorial_files.insert(std::make_pair(cIntroVideo.Get(), "tutorialbank\\9901-introduction-video.tut"));
	tutorial_videos.insert(std::make_pair(cIntroVideo.Get(), "tutorialbank\\9901-introduction-video.mp4"));
	tutorial_description.insert(std::make_pair(cIntroVideo.Get(), "Introduction Video"));

	SetDir("tutorialbank");

	ChecklistForFiles();
	for (int i = 1; i <= ChecklistQuantity(); i++)
	{
		if (ChecklistValueA(i) == 0)
		{
			cstr file_s = ChecklistString(i);
			if (cstr(Left(file_s.Get(), 1)) != ".")
			{
				cstr ext = Lower(Right(file_s.Get(), 4));
				if (ext == ".tut") 
				{
					//Read file and get tut: entry.
					//Read in TUT: entrie.
					FILE* fTut = GG_fopen(file_s.Get(), "r");
					if (fTut)
					{
						bool bVideoAdded = false;
						bool bTutorialAdded = false;
						bool bDescriptionAdded = false;
						char ctmp[TUTORIALMAXTEXT];
						char cVideoPath[MAX_PATH] = "\0";
						char cTutorialSet[TUTORIALMAXTEXT] = "\0";
						char cTutorialDescription[TUTORIALMAXTEXT] = "\0";
						while (!feof(fTut))
						{
							fgets(ctmp, TUTORIALMAXTEXT - 1, fTut);
							if (strlen(ctmp) > 0 && ctmp[strlen(ctmp) - 1] == '\n')
								ctmp[strlen(ctmp) - 1] = 0;

							if (strncmp(ctmp, "TUT:", 4) == 0)
							{
								if (!strlen(cTutorialName) > 0)
									strcpy(cTutorialName, &ctmp[5]);

								strcpy(cTutorialSet, &ctmp[5]);
								cstr path = "tutorialbank\\";
								path += file_s;
								tutorial_files.insert(std::make_pair(&ctmp[5], path.Get()));
								bTutorialAdded = true;
							}
							if (strncmp(ctmp, "DESC:", 5) == 0)
							{
								bDescriptionAdded = true;
								strcpy(cTutorialDescription, &ctmp[6]);
								std::string clean_string = cTutorialDescription;
								replaceAll(clean_string, "", "'"); //Replace UTF8. 0xE2 0x90 0x99
								strcpy(cTutorialDescription, clean_string.c_str());
							}
							if (strncmp(ctmp, "VIDEO:", 6) == 0)
							{
								strcpy(cVideoPath, &ctmp[7]);
								SetDir(tOldDir.Get());
								char resolved[MAX_PATH];
								int retval = GetFullPathNameA(cVideoPath, MAX_PATH, resolved, NULL);
								if (retval > 0) {
									strcpy(cVideoPath, resolved);
								}
								SetDir("tutorialbank");
								bVideoAdded = true;
							}
							if (bTutorialAdded && bVideoAdded && bDescriptionAdded)
								break;

						}
						fclose(fTut);
						if (bTutorialAdded && bVideoAdded) {
							tutorial_videos.insert(std::make_pair(cTutorialSet, cVideoPath));
						}
						if (bTutorialAdded && bDescriptionAdded) {
							tutorial_description.insert(std::make_pair(cTutorialSet, cTutorialDescription));
						}
						if (bTutorialAdded && !bDescriptionAdded) {
							//If no desc , just add title.
							tutorial_description.insert(std::make_pair(cTutorialSet, cTutorialSet));
						}

						if (bTutorialAdded && !bVideoAdded) {
							//Add default video path. must always be the same as tutorial_files
							tutorial_videos.insert(std::make_pair(cTutorialSet, ""));
						}
					}
				}
			}
		}
	}
	SetDir(tOldDir.Get());

}
#endif

void generic_preloadfiles(void)
{
	//PE: We might have to edit this list when we have the final media to use.
	timestampactivity(0, "preload generic textures early");
	image_preload_files_start();
	image_preload_files_add("effectbank\\explosion\\animatedspark.dds");
	image_preload_files_add("effectbank\\particles\\flare.dds");
	image_preload_files_add("effectbank\\particles\\64smoke2.dds");
	image_preload_files_add("effectbank\\particles\\flame.dds");

	image_preload_files_add("editors\\gfx\\cursor.dds");

	//PNG Test.
	image_preload_files_add("languagebank\\english\\artwork\\quick-start-testlevel-prompt.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\quick-help.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\testgamelayout-vr.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\testgamelayout-noweapons.png",1);

	image_preload_files_add("languagebank\\english\\artwork\\gurumeditation.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\gurumeditationoff.png",1);

	image_preload_files_add("editors\\gfx\\memorymeter.png",1);
	#ifdef WICKEDENGINE
	image_preload_files_add("editors\\gfx\\4.png",1);
	image_preload_files_add("editors\\gfx\\5.png",1);
	image_preload_files_add("editors\\gfx\\13.png",1);
	image_preload_files_add("editors\\gfx\\26.png",1);
	#else
	image_preload_files_add("editors\\gfx\\4.bmp",1);
	image_preload_files_add("editors\\gfx\\5.bmp",1);
	image_preload_files_add("editors\\gfx\\13.bmp",1);
	image_preload_files_add("editors\\gfx\\26.bmp",1);
	#endif

	image_preload_files_add("editors\\gfx\\9.png",1);
	image_preload_files_add("editors\\gfx\\14.png",1);
	#ifdef WICKEDENGINE
	#else
	image_preload_files_add("editors\\gfx\\18.png",1);
	#endif

	image_preload_files_add("languagebank\\english\\artwork\\f9-help-terrain.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\f9-help-entity.png",1);
	image_preload_files_add("languagebank\\english\\artwork\\f9-help-conkit.png",1);

	///image_preload_files_add("languagebank\\neutral\\gamecore\\huds\\interactive\\close-highlight.png",1);

	image_preload_files_add("editors\\gfx\\resources.png",1);
	image_preload_files_add("editors\\gfx\\resourceslow.png",1);

	image_preload_files_add("editors\\gfx\\resourcesgone.png",1);
	image_preload_files_add("editors\\gfx\\resourcesworking.png",1);


	image_preload_files_finish();
}

#ifdef VRTECH
void CloseDownEditorProperties(void)
{
	if (t.gridentityinzoomview > 0) 
	{
		t.tpressedtoleavezoommode = 2; //Exit zoom and save.
		int olges = t.grideditselect;
		//Make sure to exit fast. and restore cursor object.
		int igridentity = t.gridentity;
		if (iOldgridentity != t.gridentity && iOldgridentity > -1)
			t.gridentity = iOldgridentity;

		t.grideditselect = 4;
		editor_viewfunctionality();
		t.grideditselect = olges;
		t.gridentity = igridentity;
	}
}

void FormatTTS(LPSTR pFormattedTTS, LPSTR pFormattedTTSOut)
{
	memset(pFormattedTTSOut, 0, 1000);
	int nout = 0;
	for (int n = 0; n < strlen(pFormattedTTS); n++)
	{
		if ( pFormattedTTS[n] >= 32 && pFormattedTTS[n] <= 255 )
			pFormattedTTSOut[nout++] = pFormattedTTS[n];
	}
	pFormattedTTSOut[nout] = 0;
}

bool g_bVoiceSettingsChanged = false;
int g_iVoiceSettingsUpdateSpeechID = 0;

void SpeechControls(int speech_entries, bool bUpdateMainString, entityeleproftype *edit_grideleprof)
{
	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	//LB: Solve intend and incorrect component inclusion inside FPE (behavior area)
	ImGui::TextCenter("Speech Control");
	//if (ImGui::StyleCollapsingHeader("Speech Control", ImGuiTreeNodeFlags_DefaultOpen)) 
	{
		bool sapi_available = false;
		if (g_voiceList_s.size() > 0)
			sapi_available = true;

		ImGui::Indent(10);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

		if (sapi_available) 
		{
			ImGui::Text("Voice");
			ImGui::SameLine();
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
			//Combo
			ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
			ImGui::PushItemWidth(-10);
			if (ImGui::BeginCombo("##SelectVoiceCCP", pCCPVoiceSet)) // The second parameter is the label previewed before opening the combo.
			{
				int size = g_voiceList_s.size();
				for (int vloop = 0; vloop < size; vloop++) {

					bool is_selected = false;
					if (strcmp(g_voiceList_s[vloop].Get(), pCCPVoiceSet) == 0)
						is_selected = true;

					if (ImGui::Selectable(g_voiceList_s[vloop].Get(), is_selected)) 
					{
						//Change Voice set
						pCCPVoiceSet = g_voiceList_s[vloop].Get();
						CCP_SelectedToken = g_voicetoken[vloop];
						edit_grideleprof->voiceset_s = pCCPVoiceSet;
						if (g_bVoiceSettingsChanged == false)
						{
							g_bVoiceSettingsChanged = true;
							g_iVoiceSettingsUpdateSpeechID = 0;
						}
					}
					if (is_selected)
						ImGui::SetItemDefaultFocus();
				}
				ImGui::EndCombo();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Voice to Use For Speak");

			ImGui::PopItemWidth();

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
			ImGui::Text("Rate");
			ImGui::SameLine();
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));

			ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
			ImGui::PushItemWidth(-10);
			int iOldRate = CCP_Speak_Rate;
			ImGui::SliderInt("##speakrate", &CCP_Speak_Rate, -5, 5);
			if (CCP_Speak_Rate != iOldRate)
			{
				edit_grideleprof->voicerate = CCP_Speak_Rate;
				if (g_bVoiceSettingsChanged == false)
				{
					g_bVoiceSettingsChanged = true;
					g_iVoiceSettingsUpdateSpeechID = 0;
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Speak Rate");

			ImGui::PopItemWidth();

		}
		//LOOP speech_entries
		//Use unique IDs

		// monitor lip sync generator
		bool bLipSyncGenerationBusy = false;
		float fProgressOfGeneration = GetWAVtoLIPProgress();
		if (fProgressOfGeneration > 0.0f && fProgressOfGeneration < 1.0f)
			bLipSyncGenerationBusy = true;

		for (int SpeechLoop = 0; SpeechLoop < speech_entries; SpeechLoop++)
		{
			if (speech_ids[SpeechLoop] >= 0)
			{
				cstr tmpvar = edit_grideleprof->PropertiesVariable.Variable[speech_ids[SpeechLoop]];
				tmpvar = tmpvar.Lower();

				//Display soundset file entry.
				int iButtonControlAndState = 0; // 0-can edit button, 1-buttom used, 2-background task in progress (so should not press button until done)
				if ( bLipSyncGenerationBusy == true ) iButtonControlAndState = 2;
				LPSTR pButtonControlIfBlocked = "Still Generating Lip Sync Data";
				cstr used_soundset;
				if (tmpvar == "speech1" || tmpvar == "speech 1") 
				{
					edit_grideleprof->soundset1_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset1_s.Get(), "SPEECH 1", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset1_s;
				}
				else if (tmpvar == "speech2" || tmpvar == "speech 2") 
				{
					edit_grideleprof->soundset2_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset2_s.Get(), "SPEECH 2", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset2_s;
				}
				else if (tmpvar == "speech3" || tmpvar == "speech 3") 
				{
					edit_grideleprof->soundset3_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset3_s.Get(), "SPEECH 3", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset3_s;
				}
				else if (tmpvar == "speech0" || tmpvar == "speech 0") 
				{
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset_s.Get(), "SPEECH", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset_s;
				}
				else 
				{
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_ex_dlua(t.group, edit_grideleprof->soundset_s.Get(), "SPEECH 4", t.strarr_s[254].Get(), "audiobank\\", &iButtonControlAndState, pButtonControlIfBlocked );
					used_soundset = edit_grideleprof->soundset_s;
				}
				if (iButtonControlAndState == 1)
				{
					// user changed one of the speech fields, so generate LIP file for it
					ConvertWAVtoLIP(used_soundset.Get());
				}

				std::string uniquiField = ">";
				uniquiField = uniquiField + "##";
				uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);
				#ifdef WICKEDENGINE
				#else
				ImGui::SameLine();
				#endif
				ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

				int iButImageSize = 16;
				ImGui::PushID(grideleprof_uniqui_id++);

			#ifdef WICKEDENGINE
				ImGui::Indent(-10);
				if (ImGui::StyleButton("Play back current voiceover", ImVec2(ImGui::GetContentRegionAvail().x - 10, ImGui::GetFontSize()*1.5)))
				{
					// the sound we will use for the preview
					bool bJustStopped = false;
						int iFreeSoundID = g.temppreviewsoundoffset;
						if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
						{
							// stop currently playing preview
							StopSound(iFreeSoundID);
								bJustStopped = true;
						}
					if (used_soundset.Len() > 0)
					{
						// play custom wav file directly.
						if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
						if (FileExist(used_soundset.Get()) == 1 && bJustStopped == false)
						{
							LoadSound(used_soundset.Get(), iFreeSoundID, 0, 1);
							if (SoundExist(iFreeSoundID) == 1)
								PlaySound(iFreeSoundID);
						}
					}
				}
				ImGui::PopID();

				static bool g_bRecordingSound = false;
				static cstr g_recordingFile_s;
				uniquiField = "o";
				uniquiField = uniquiField + "##";
				uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);
				//ImGui::SameLine();
				//ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);
				ImGui::PushID(grideleprof_uniqui_id++);
				//ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() - 6.0, ImGui::GetCursorPosY()));
				int iRecordBtnImg = MEDIA_RECORD;
				if (g_bRecordingSound == true) iRecordBtnImg = MEDIA_RECORDING;
				if (bLipSyncGenerationBusy == true) iRecordBtnImg = MEDIA_RECORDPROCESSING;
				if(ImGui::StyleButton("Record a new voiceover", ImVec2(ImGui::GetContentRegionAvail().x - 10, ImGui::GetFontSize()*1.5)))
				{
					if (g_bRecordingSound == false)
					{
						// can only start recording once any lip sync progress has finished
						if (bLipSyncGenerationBusy == true)
						{
							MessageBoxA(NULL, "Cannot start recording until lip sync generation finished", "Notification", MB_OK);
						}
						else
						{
							// choose a unique recording name
							int iRecordingNum = 1;
							while (iRecordingNum < 9999)
							{
								// find a free recording WAV filename
								g_recordingFile_s = cstr("audiobank\\recordings\\Recording-") + cstr(iRecordingNum) + ".wav";
								if (FileExist(g_recordingFile_s.Get()) == 0)
									break;
								iRecordingNum++;
							}

							// start recording
							cstr absWAVPath_s = g.fpscrootdir_s + "\\Files\\" + g_recordingFile_s;
							char pRealAbsWAVForRecording[MAX_PATH];
							strcpy(pRealAbsWAVForRecording, absWAVPath_s.Get());
							GG_GetRealPath(pRealAbsWAVForRecording, 1);
							RecordWAV(pRealAbsWAVForRecording);
							g_bRecordingSound = true;
						}
					}
				}
				ImGui::PopID();
				ImGui::Indent(10);
				ImGui::PopItemWidth();
				ImGui::Spacing();
			#else
				if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(iButImageSize, iButImageSize), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
				{
					// the sound we will use for the preview
					bool bJustStopped = false;
					int iFreeSoundID = g.temppreviewsoundoffset;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
						bJustStopped = true;
					}
					if (used_soundset.Len() > 0) 
					{
						// play custom wav file directly.
						if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
						if (FileExist(used_soundset.Get()) == 1 && bJustStopped==false )
						{
							LoadSound(used_soundset.Get(), iFreeSoundID, 0, 1);
							if ( SoundExist(iFreeSoundID)==1 )
								PlaySound(iFreeSoundID);
						}
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

				ImGui::PopItemWidth();
				ImGui::PopID();

				// Recording button
				static bool g_bRecordingSound = false;
				static cstr g_recordingFile_s;
				uniquiField = "o";
				uniquiField = uniquiField + "##";
				uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);
				ImGui::SameLine();
				ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);
				ImGui::PushID(grideleprof_uniqui_id++);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() - 6.0, ImGui::GetCursorPosY()));
				int iRecordBtnImg = MEDIA_RECORD;
				if (g_bRecordingSound == true) iRecordBtnImg = MEDIA_RECORDING;
				if (bLipSyncGenerationBusy == true) iRecordBtnImg = MEDIA_RECORDPROCESSING;
				if (ImGui::ImgBtn(iRecordBtnImg, ImVec2(iButImageSize, iButImageSize), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, true))
				{
					if (g_bRecordingSound == false)
					{
						// can only start recording once any lip sync progress has finished
						if (bLipSyncGenerationBusy == true)
						{
							MessageBoxA(NULL, "Cannot start recording until lip sync generation finished", "Notification", MB_OK);
						}
						else
						{
							// choose a unique recording name
							int iRecordingNum = 1;
							while (iRecordingNum < 9999)
							{
								// find a free recording WAV filename
								g_recordingFile_s = cstr("audiobank\\recordings\\Recording-") + cstr(iRecordingNum) + ".wav";
								if (FileExist(g_recordingFile_s.Get()) == 0)
									break;
								iRecordingNum++;
							}

							// start recording
							cstr absWAVPath_s = g.fpscrootdir_s + "\\Files\\" + g_recordingFile_s;
							char pRealAbsWAVForRecording[MAX_PATH];
							strcpy(pRealAbsWAVForRecording, absWAVPath_s.Get());
							GG_GetRealPath(pRealAbsWAVForRecording, 1);
							RecordWAV(pRealAbsWAVForRecording);
							g_bRecordingSound = true;
						}
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Record");
				ImGui::PopItemWidth();
				ImGui::PopID();
			#endif
				
				if (g_bRecordingSound == true)
				{
					if ( RecordWAVProgress() >= 1.0f && bLipSyncGenerationBusy == false )
					{
						// end recording mode
						g_bRecordingSound = false;

						// stop recording and save
						if (tmpvar == "speech1" || tmpvar == "speech 1") edit_grideleprof->soundset1_s = g_recordingFile_s;
						if (tmpvar == "speech2" || tmpvar == "speech 2") edit_grideleprof->soundset2_s = g_recordingFile_s;
						if (tmpvar == "speech3" || tmpvar == "speech 3") edit_grideleprof->soundset3_s = g_recordingFile_s;
						if (tmpvar == "speech0" || tmpvar == "speech 0") edit_grideleprof->soundset_s = g_recordingFile_s;

						// generate LIP file from recording
						cstr absWAVPath_s = g.fpscrootdir_s + "\\Files\\" + g_recordingFile_s;
						ConvertWAVtoLIP(absWAVPath_s.Get());
						bLipSyncGenerationBusy = true;
					}
				}

				if (sapi_available) 
				{
					//The edit_grideleprof->soundset_s to use is already known so:
					//Store the actual text entered in the DLUA value fields.
					ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
					ImGui::PushItemWidth(-10);

					ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());

					uniquiField = "";
					uniquiField = uniquiField + "##speakTTStext";
					uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

					// detect any editing of TTS text
					static bool bDetectWhenFinishedEditingTTSText = false;
					if (ImGui::InputTextMultiline(uniquiField.c_str(), &edit_grideleprof->PropertiesVariable.VariableValue[speech_ids[SpeechLoop]][0], 1024, ImVec2(0, ImGui::GetFontSize()*3.0f)))
					{
						// flagged any time TTS text changes
						bDetectWhenFinishedEditingTTSText = true;
					}
					if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

					// can also trigger regeneration of text when Voice Settings changed
					if (g_bVoiceSettingsChanged == true)
					{
						// go through all speeches and regeneate them one by one
						float fProgressOfGeneration = GetWAVtoLIPProgress();
						if (fProgressOfGeneration > 0.0f && fProgressOfGeneration < 1.0f)
						{
							// but if lip sync busy, we wait until free!
						}
						else
						{
							// when speech loop comes around to the next speech to refresh, trigger it now
							if (g_iVoiceSettingsUpdateSpeechID == SpeechLoop)
							{
								// regenerate this speech TTS
								bDetectWhenFinishedEditingTTSText = true;
								g_iVoiceSettingsUpdateSpeechID++;
								if (g_iVoiceSettingsUpdateSpeechID >= speech_entries)
								{
									// when no more speeches to refresh, finish voice settings cascade refresh
									g_bVoiceSettingsChanged = false;
								}
							}
						}
					}
					// only proceed when LIP sync not busy
					bool bLipSyncBusy = false;
					float fProgressOfGeneration = GetWAVtoLIPProgress();
					if (fProgressOfGeneration > 0.0f && fProgressOfGeneration < 1.0f) bLipSyncBusy = true;
					if (ImGui::IsItemActive() == false && bDetectWhenFinishedEditingTTSText==true && bLipSyncBusy==false)
					{
						// and reset as we are now doing the conversion and LIP file creation below
						bDetectWhenFinishedEditingTTSText = false;

						// this is the text we want to turn into WAV
						cstr TTSText_s = edit_grideleprof->PropertiesVariable.VariableValue[speech_ids[SpeechLoop]];

						// first, create a location to store the level-based TTS recordings
						// which will be in levelbank\ttsfiles\*.wav (keeps them local to FPM and transportable to Players)
						cstr pOldDir = GetDir();
						char pRealRoot[MAX_PATH];
						strcpy(pRealRoot, g.fpscrootdir_s.Get());
						strcat(pRealRoot, "\\Files\\levelbank\\");
						GG_GetRealPath(pRealRoot, 1);
						SetDir(pRealRoot);
						if (PathExist("testmap") == 0) MakeDirectory("testmap");
						SetDir("testmap");
						if (PathExist("ttsfiles") == 0) MakeDirectory("ttsfiles");
						SetDir("ttsfiles");

						// format typed text into something we can store as a reference in the TTS table below
						char pFormattedTTS[1000];
						int iInputTextMax = TTSText_s.Len();
						if (iInputTextMax > 999) iInputTextMax = 999;
						memcpy(pFormattedTTS, TTSText_s.Get(), iInputTextMax);
						pFormattedTTS[iInputTextMax] = 0;
						strcat(pFormattedTTS, pCCPVoiceSet);
						strcat(pFormattedTTS, cstr('A'+CCP_Speak_Rate).Get());
						char pFormattedTTSOut_Keeper[1000];
						FormatTTS(pFormattedTTS, pFormattedTTSOut_Keeper);

						// prepare two absolute paths for later
						char pRelLocationOfWAV[MAX_PATH];
						strcpy(pRelLocationOfWAV, "levelbank\\testmap\\ttsfiles\\"); // WAV added below

						// load in TTS table to see what TTS text we already have recordings for
						bool bIsTTSUnique = true;
						int iTTSTableMax = 0;
						std::vector <cstr> tempLines_s;
						Dim ( tempLines_s, 9999 );
						LPSTR pTTSTableFile = "ttstable.txt";
						if (FileExist(pTTSTableFile) == 1)
						{
							OpenToRead(1,pTTSTableFile);
							while (FileEnd(1) == 0)
							{
								tempLines_s[iTTSTableMax] = ReadString(1);
								iTTSTableMax++;
							}
							iTTSTableMax--;
							CloseFile(1);
						}
						if (iTTSTableMax > 0)
						{
							for (int line = 0; line < iTTSTableMax; line++)
							{
								// get the ref part of this line (and the WAV part for later)
								char pWAVItem[1001];
								char pRefItem[1001];
								strcpy(pWAVItem, "");
								strcpy(pRefItem, tempLines_s[line].Get());
								for (int n = 0; n < strlen(pRefItem); n++)
								{
									if (pRefItem[n] == 9)
									{
										strcpy(pWAVItem, pRefItem+n+1);
										pRefItem[n] = 0;
										break;
									}
								}

								// does it match what we are looking to add in
								if (stricmp(pRefItem, pFormattedTTSOut_Keeper) == NULL)
								{
									// yes, found the TTS we want already in the table
									if (FileExist(pWAVItem) == 1)
									{
										strcat(pRelLocationOfWAV, pWAVItem);
										bIsTTSUnique = false;
										break;
									}
								}
							}
						}

						// determine if what we have is unique
						if ( bIsTTSUnique == true )
						{
							// if so, create a unique file name entry for this one
							cstr pTTSFile;
							int iTTSNum = 1;
							while (iTTSNum < 9999)
							{
								pTTSFile = cstr("TTS") + cstr(iTTSNum) + ".wav";
								if (FileExist(pTTSFile.Get()) == 0)
									break;
								else
									iTTSNum++;
							}
							if (iTTSNum <= 9999)
							{
								// complete path new TTS WAV
								strcat(pRelLocationOfWAV, pTTSFile.Get());

								// add to table for future reference and potential use
								LPSTR pTTSTableFile = "ttstable.txt";
								if (FileExist(pTTSTableFile) == 1) DeleteFileA(pTTSTableFile);
								OpenToWrite(1,pTTSTableFile);
								for ( int i = 0; i<iTTSTableMax; i++ )
								{
									WriteString(1, tempLines_s[i].Get());
								}
								char pNewLine[1000];
								strcpy(pNewLine, pFormattedTTSOut_Keeper);
								pNewLine[strlen(pFormattedTTSOut_Keeper)+0] = 9;
								pNewLine[strlen(pFormattedTTSOut_Keeper)+1] = 0;
								strcat(pNewLine, pTTSFile.Get());
								WriteString(1,pNewLine);
								CloseFile(1);

								// need to be back in Files\\ folder for conversion to work properly
								SetDir(pOldDir.Get());

								// turn TEXT into WAV, store in this folder
								LPSTR pWAVFilename = pRelLocationOfWAV;
								if (FileExist(pWAVFilename)) DeleteFileA(pWAVFilename);
								LPSTR pWhatToSay = TTSText_s.Get();
								CComPtr<ISpVoice> spVoice;
								HRESULT hr = spVoice.CoCreateInstance(CLSID_SpVoice);
								if (SUCCEEDED(hr))
								{
									hr = spVoice->SetVoice(CCP_SelectedToken);
									if (SUCCEEDED(hr))
									{
										char pFinalWAVFilename[MAX_PATH];
										strcpy(pFinalWAVFilename, pWAVFilename);
										#ifdef WICKEDENGINE
										GG_GetRealPath(pFinalWAVFilename, 1);
										#endif
										ConvertTXTtoWAVMeatyPart(spVoice, CCP_SelectedToken, CCP_Speak_Rate, pWhatToSay, pFinalWAVFilename);
									}
								}
							}
						}
						else
						{
							// if not, the 'pRelLocationOfWAV' carries the previous WAV we can use from the TTS table
						}

						// change field of SPEECH X to [use text speech] - indicating its using the internal TTS wav created
						if (tmpvar == "speech1" || tmpvar == "speech 1") edit_grideleprof->soundset1_s = pRelLocationOfWAV;
						if (tmpvar == "speech2" || tmpvar == "speech 2") edit_grideleprof->soundset2_s = pRelLocationOfWAV;
						if (tmpvar == "speech3" || tmpvar == "speech 3") edit_grideleprof->soundset3_s = pRelLocationOfWAV;
						if (tmpvar == "speech0" || tmpvar == "speech 0") edit_grideleprof->soundset_s = pRelLocationOfWAV;

						// restore original folder for LIP file creation
						SetDir(pOldDir.Get());

						// can begin the WAV to LIP file now as we have the WAV file created
						ConvertWAVtoLIP(pRelLocationOfWAV);

						// and before we leave, take the opportunity to scan ALL entities and see if there are
						// any entries in the TTS table (and associated WAVs) that are not needed (probably due to recent change above)
						char pRealTTSFilesFolder[MAX_PATH];
						strcpy(pRealTTSFilesFolder, g.fpscrootdir_s.Get());
						strcat(pRealTTSFilesFolder, "\\Files\\levelbank\\testmap\\");
						SetDir(pRealTTSFilesFolder);
						if (PathExist("ttsfiles") == 0) MakeDirectory("ttsfiles");
						SetDir("ttsfiles");

						// load in latest TTS (given above activity of possible addition of new one)
						std::vector <cstr> tempRefs_s;
						Dim ( tempRefs_s, 9999 );
						iTTSTableMax = 0;
						pTTSTableFile = "ttstable.txt";
						if (FileExist(pTTSTableFile) == 1)
						{
							OpenToRead(1,pTTSTableFile);
							while (FileEnd(1) == 0)
							{
								char pRefItem[1001];
								tempLines_s[iTTSTableMax] = ReadString(1);
								strcpy ( pRefItem, tempLines_s[iTTSTableMax].Get() );
								for (int n = 0; n < strlen(pRefItem); n++)
								{
									if (pRefItem[n] == 9)
									{
										pRefItem[n] = 0;
										break;
									}
								}
								tempRefs_s[iTTSTableMax] = pRefItem;
								iTTSTableMax++;
							}
							iTTSTableMax--;
							CloseFile(1);
						}

						// start an array to hold flag as to whether to keep TTS table entry
						// and go through to auto-accept the one we've just added above (so it does not get deleted)
						bool* pbKeepInTable = new bool[iTTSTableMax+1];
						for (int iTTS = 0; iTTS < iTTSTableMax; iTTS++)
						{
							pbKeepInTable[iTTS] = false;
							if (stricmp(pFormattedTTSOut_Keeper, tempRefs_s[iTTS].Get()) == NULL)
								pbKeepInTable[iTTS] = true;
						}

						// go through ALL entities in current level (and all speech TTS texts buried in each one)
						for ( int e2 = 1; e2 <= g.entityelementlist; e2++ )
						{
							// need voice and speak rate from this entity
							LPSTR pVoiceSet2 = t.entityelement[e2].eleprof.voiceset_s.Get();
							int iSpeakRate2 = t.entityelement[e2].eleprof.voicerate;
							if (strlen(pVoiceSet2) == 0)
							{
								// default to first voice at startard rate
								pVoiceSet2 = g_voiceList_s[0].Get();
								iSpeakRate2 = 0;
							}

							int speech_ids2[5];
							for ( int n2 = 0; n2 < 5; n2++ ) speech_ids2[n2] = -1;
							int speech_entries2 = 0;
							for (int i2 = 0; i2 < t.entityelement[e2].eleprof.PropertiesVariable.iVariables; i2++)
							{
								cstr tmpvar = t.entityelement[e2].eleprof.PropertiesVariable.Variable[i2];
								tmpvar = tmpvar.Lower();
								if (speech_entries2 <= 3)
								{
									if (tmpvar == "speech1" || tmpvar == "speech 1") speech_ids2[speech_entries2++] = i2;
									if (tmpvar == "speech2" || tmpvar == "speech 2") speech_ids2[speech_entries2++] = i2;
									if (tmpvar == "speech3" || tmpvar == "speech 3") speech_ids2[speech_entries2++] = i2;
									if (tmpvar == "speech0" || tmpvar == "speech 0") speech_ids2[speech_entries2++] = i2;
								}
							}
							for (int iSpeechLoop2 = 0; iSpeechLoop2 < 4; iSpeechLoop2++)
							{
								LPSTR pSpeechItem = NULL;
								if (speech_ids2[iSpeechLoop2] != -1)
								{
									if (iSpeechLoop2 == 0) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (iSpeechLoop2 == 1) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (iSpeechLoop2 == 2) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (iSpeechLoop2 == 3) pSpeechItem = t.entityelement[e2].eleprof.PropertiesVariable.VariableValue[speech_ids2[iSpeechLoop2]];
									if (pSpeechItem)
									{
										// ensure the TTS string is formatted so can be matched against table (who's refs are formatted) [nice to do a hash here?]
										char pSpeechItemFormatted[1000];
										strcpy(pSpeechItemFormatted, pSpeechItem);
										strcat(pSpeechItemFormatted, pVoiceSet2);
										strcat(pSpeechItemFormatted, cstr('A'+iSpeakRate2).Get());
										char pSpeechItemFormattedOut[1000];
										FormatTTS(pSpeechItemFormatted, pSpeechItemFormattedOut);

										// a TTS text in one of the entity sound slots
										for (int iTTS = 0; iTTS < iTTSTableMax; iTTS++)
										{
											// compare the table entry with this entities TTS
											if (stricmp(pSpeechItemFormattedOut, tempRefs_s[iTTS].Get()) == NULL)
											{
												// found a match, flag this table entry as a keeper
												pbKeepInTable[iTTS] = true;
											}
										}
									}
								}
							}
						}
						// finally create a new table of only the keepers
						if (iTTSTableMax > 0)
						{
							// before table creation, check for duplicates (can happen when editing an entity over and over)
							for (int i1 = 0; i1 < iTTSTableMax; i1++)
							{
								if (pbKeepInTable[i1] == true)
								{
									for (int i2 = 0; i2 < iTTSTableMax; i2++)
									{
										if (i1 != i2)
										{
											if (pbKeepInTable[i2] == true)
											{
												// comparing two entries, both valid and not same index
												// ensure primary (i) survives at expense of any identical entries (i2)
												LPSTR i1Ref = tempRefs_s[i1].Get();
												LPSTR i2Ref = tempRefs_s[i2].Get();
												if (stricmp(i1Ref, i2Ref) == NULL)
												{
													// remove duplicate
													pbKeepInTable[i2] = false;

													// also delete WAV and LIP files associated with this duplicate
													char pWAVItem[1001];
													strcpy(pWAVItem, "");
													char pRefItem[1001];
													strcpy(pRefItem, tempLines_s[i2].Get());
													for (int n = 0; n < strlen(pRefItem); n++)
													{
														if (pRefItem[n] == 9)
														{
															strcpy(pWAVItem, pRefItem+n+1);
															break;
														}
													}
													if (FileExist(pWAVItem) == 1) DeleteFileA(pWAVItem);
													char pLIPItem[1001];
													strcpy(pLIPItem, pWAVItem); 
													pLIPItem[strlen(pLIPItem) - 4] = 0;
													strcat(pLIPItem, ".lip");
													if (FileExist(pLIPItem) == 1) DeleteFileA(pLIPItem);

													// and finally reroute entities that used this WAV to the primary one
													for (int e2 = 1; e2 <= g.entityelementlist; e2++)
													{
														for (int s2 = 0; s2 < 4; s2++)
														{
															LPSTR pThisSlotsWAV = NULL;
															if (s2 == 0) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset_s.Get();
															if (s2 == 1) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset1_s.Get();
															if (s2 == 2) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset2_s.Get();
															if (s2 == 3) pThisSlotsWAV = t.entityelement[e2].eleprof.soundset3_s.Get();
															if (pThisSlotsWAV)
															{
																if (stricmp(pThisSlotsWAV, pWAVItem) == NULL)
																{
																	cstr newWAV_s = (LPSTR)tempLines_s[i1].Get()+strlen(tempRefs_s[i1].Get());
																	if (s2 == 0) t.entityelement[e2].eleprof.soundset_s = newWAV_s;
																	if (s2 == 1) t.entityelement[e2].eleprof.soundset1_s = newWAV_s;
																	if (s2 == 2) t.entityelement[e2].eleprof.soundset2_s = newWAV_s;
																	if (s2 == 3) t.entityelement[e2].eleprof.soundset3_s = newWAV_s;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}

							// final creation of table
							LPSTR pTTSTableFile = "ttstable.txt";
							if (FileExist(pTTSTableFile) == 1) DeleteFileA(pTTSTableFile);
							OpenToWrite(1, pTTSTableFile);
							for (int i = 0; i < iTTSTableMax; i++)
							{
								if (pbKeepInTable[i] == true)
								{
									// keep this in table
									WriteString(1, tempLines_s[i].Get());
								}
								else
								{
									// remove from table - and also delete the associated WAV file
									char pWAVItem[1001];
									strcpy(pWAVItem, "");
									char pRefItem[1001];
									strcpy(pRefItem, tempLines_s[i].Get());
									for (int n = 0; n < strlen(pRefItem); n++)
									{
										if (pRefItem[n] == 9)
										{
											strcpy(pWAVItem, pRefItem+n+1);
											break;
										}
									}
									if (FileExist(pWAVItem) == 1) DeleteFileA(pWAVItem);
									char pLIPItem[1001];
									strcpy(pLIPItem, pWAVItem); 
									pLIPItem[strlen(pLIPItem) - 4] = 0;
									strcat(pLIPItem, ".lip");
									if (FileExist(pLIPItem) == 1) DeleteFileA(pLIPItem);
								}
							}
							CloseFile(1);
						}

						// and free resources
						SAFE_DELETE(pbKeepInTable);

						// restore original folder when finished
						SetDir(pOldDir.Get());

						// trigger a main string update
						bUpdateMainString = true;
					}

					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enter Text to Speak");

					ImGui::PopItemWidth();

				}
			}
		}

		//Update DLUA if changed. this is stored in soundset4_s.
		//Update soundset4_s when we have changes.
		entityeleproftype *tmpeleprof = edit_grideleprof;
		if (bUpdateMainString) 
		{
			cstr sLuaScriptName = tmpeleprof->PropertiesVariable.VariableScript;
			sLuaScriptName += "_properties(";
			//Check if we need to update with new default values.
			if (tmpeleprof->PropertiesVariable.iVariables > 0) 
			{
				tmpeleprof->soundset4_s = sLuaScriptName;
				//Add varables.
				for (int i = 0; i < tmpeleprof->PropertiesVariable.iVariables; i++) 
				{

					char val[3];
					val[0] = tmpeleprof->PropertiesVariable.VariableType[i] + '0';
					val[1] = 0;

					tmpeleprof->soundset4_s += val;
					tmpeleprof->soundset4_s += "\"";
					std::string clean_string = tmpeleprof->PropertiesVariable.VariableValue[i];
					replaceAll(clean_string, "\"", ""); //cant use "
					tmpeleprof->soundset4_s += (char *) clean_string.c_str();
					//tmpeleprof->soundset4_s += tmpeleprof->PropertiesVariable.VariableValue[i];
					tmpeleprof->soundset4_s += "\"";
					if (i < tmpeleprof->PropertiesVariable.iVariables - 1)
						tmpeleprof->soundset4_s += ",";
				}
				tmpeleprof->soundset4_s += ")";
			}
		}

		ImGui::Indent(-10);
	}
}

void RedockWindow(char *name)
{
	if (refresh_gui_docking >= 4 ) {

		ImGuiID dockspace_id;

		//dock it.
		int winNodeId = ImGui::GetWindowDockID();
		dockspace_id = ImGui::GetID("MyDockspace");
		ImGui::DockBuilderDockWindow(name, dock_tools_windows);
		int winNodeId2 = ImGui::GetWindowDockID();
		if (winNodeId != 0 && winNodeId2 != 0 && winNodeId != winNodeId2) {
			//Somthing wrong we cant rebuild.
			//Change window size to normal and undock:
			//m_editor->resizewindownext = true;
		}
		else {
			ImGui::DockBuilderFinish(dockspace_id);
		}
	}
}

int pehuntingbug = 0;
void CheckMinimumDockSpaceSize(float minsize)
{
	//Only make these change when not resizing/moving ...
	int mcursor = ImGui::GetMouseCursor();
	if (mcursor == 0 || !ImGui::IsAnyMouseDown() ) {
		if (ImGui::IsWindowDocked()) {
			int winNodeId = ImGui::GetWindowDockID();
			ImGuiDockNode* testnode = ImGui::DockBuilderGetNode(winNodeId);
			if (testnode->Size.x < minsize && testnode->Size.y > 80.0f ) {
				//Something wrong , adjust.
				if (minsize == 50.0f) {
					//PE: Found it this happens when you use minimize :) , just need to check for that.

					//PE: Bug left panel get small. add breakpoint here to check.
					pehuntingbug = 1;
				}
				//PE: When i got it this was the values ? 12,32
				//PE: testnode->SizeRef was the correct values.
				if (testnode->Size.x != 12 && testnode->Size.x != 13 && testnode->Size.y != 32) {
					testnode->Size.x = minsize;
					testnode->SizeRef.x = minsize;
				}
				//ImGui::DockNodeTreeUpdatePosSize(testnode, testnode->Pos, testnode->Size,false);
			}
			if (testnode->Size.y < 20.0f) {
				//Something wrong , adjust.
				if (minsize == 50.0f) {
					//PE: Bug left panel get small. add breakpoint here to check.
					pehuntingbug = 2;
				}
				if (testnode->Size.x != 12 && testnode->Size.x != 13 && testnode->Size.y != 32) {
					testnode->Size.y = 50.0f;
					testnode->SizeRef.y = 50.0f;
				}
				//ImGui::DockNodeTreeUpdatePosSize(testnode, host_window->Pos, host_window->Size);
			}
		}
	}
}
#endif


#ifdef WICKEDENGINE
#define TABPAGEWEATHER 1

#include "..\..\Guru-WickedMAX\master.h"
#include <direct.h>

extern wiECS::Entity g_weatherEntityID;
extern MasterRenderer * master_renderer;

//Visuals
void tab_tab_Column_text(char *text,float fColumn)
{
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
	ImGui::Text(text);
	ImGui::SameLine();
	ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
	ImGui::SetCursorPos(ImVec2(fColumn, ImGui::GetCursorPosY()));
}



static void DisplayPerformanceData(bool* p_open)
{
	const float DISTANCE = 10.0f;
	static int corner = 0;
	ImGuiIO& io = ImGui::GetIO();
	if (corner != -1)
	{
		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImVec2 window_pos = ImVec2((corner & 1) ? (viewport->Pos.x + viewport->Size.x - DISTANCE) : (viewport->Pos.x + DISTANCE), (corner & 2) ? (viewport->Pos.y + viewport->Size.y - DISTANCE) : (viewport->Pos.y + DISTANCE));
		ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);
		ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
		//ImGui::SetNextWindowViewport(viewport->ID); //PE: Always main viewport.
	}
	ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
	if (ImGui::Begin("##DisplayPerformanceData", p_open, (corner != -1 ? ImGuiWindowFlags_NoMove : 0) | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav))
	{
		ImGui::Text("Performance data\n");
		ImGui::Separator();

		int dc = wiProfiler::GetDrawCalls();
		int dcs = wiProfiler::GetDrawCallsShadows();
		int dct = wiProfiler::GetDrawCallsTransparent();

		int tris = wiProfiler::GetPolygons();
		int trisShadow = wiProfiler::GetPolygonsShadows();
		int trisTransparent = wiProfiler::GetPolygonsTransparent();
		
		ImGui::Text("FPS: %.1f - Draw Calls: %5d, %5d, %5d", ImGui::GetIO().Framerate, dc, dcs, dct);
		ImGui::Text("Triangles: %7d, %7d, %7d", tris, trisShadow, trisTransparent);
		//ImGui::Text("Draw Calls Objects: %d", dc - dcs);
		//ImGui::Text("Draw Calls Shadows: %d", dcs);

		ImGui::Separator();

		std::string profiler_data = wiProfiler::GetProfilerData();
		ImGui::Text(profiler_data.c_str());

		ImGui::Separator();
	}
	ImGui::End();
}

void imgui_Customize_Water(int mode);

// build up data structure we need
struct sLeafNode
{
	int iInstructionIndex;
	int iUniqueSignatureCode;
	int iState;
	int iCondition;
	char pConditionParam1[250];
	char pConditionParam2[250];
	int iAction;
	char pActionParam1[250];
	char pActionParam2[250];
	sLeafNode* pGoToInstruction;
	ImVec2 vReturnPointPos;
	float fWidthRequired;
	sLeafNode* pParent;
	sLeafNode* pAlso;
	sLeafNode* pElse;
};

struct sStateNode
{
	char pName[250];
	int iStateIndex;
	sLeafNode* instruction_root;
	bool bAllowInterupt;
	bool bRecalcRightMost;
	float fRightMostX;
};
std::vector<sStateNode> instruction_state_list;

bool instruction_createstate = false;
char instruction_newstatename[256];
int instruction_deletestate = -1;

float instruction_block_width;
float instruction_block_height;
float instruction_vertical_gap;
float instruction_border;
float instruction_centerline;
float instruction_centerline_absolutex;
ImVec2 instruction_furthestcursor;
bool instruction_regenerateinstructionindices = false;
sLeafNode* instruction_deletethis = NULL;
sStateNode* instruction_deleteinthisstate = NULL;
int instruction_pickstateorinstruction = 0;
sLeafNode* instruction_pickaninstruction = NULL;
sLeafNode* instruction_hoveringover = NULL;
int instruction_picknewendnode = 0;
sLeafNode* instruction_pickanewnode = NULL;
std::vector<sLeafNode*> instruction_singlelist;
bool instruction_freezewheneditingbehavior = false;
int instruction_running_e = 0;
int instruction_running_index = 0;
char instruction_objectscriptbeingedited[256] = { 0 };
bool instruction_recreatebehaviorlist = true;

void gridedit_restartanybehaviorediting()
{
	strcpy (instruction_objectscriptbeingedited, "");
	instruction_recreatebehaviorlist = true;
}

void gridedit_refreshallinstructionindices ( int iStateIndex, sLeafNode* pThis, int* piInstructionCount)
{
	pThis->iState = iStateIndex;
	pThis->iInstructionIndex = *piInstructionCount;
	instruction_singlelist.push_back(pThis);
	*piInstructionCount = *piInstructionCount + 1;
	if (pThis->pAlso) gridedit_refreshallinstructionindices(iStateIndex, pThis->pAlso, piInstructionCount);
	if (pThis->pElse) gridedit_refreshallinstructionindices(iStateIndex, pThis->pElse, piInstructionCount);
}

int gridedit_generateuniqueinstructionindices ( void )
{
	// build single list of all instructions from above nodes
	instruction_singlelist.clear();

	// also, go through all states, re-order instruction indices
	int iInstructionCount = 1;
	for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
	{
		gridedit_refreshallinstructionindices(1+iStateIndex, instruction_state_list[iStateIndex].instruction_root, &iInstructionCount);
	}

	// return number of instructions
	return iInstructionCount - 1;
}

bool gridedit_instruction_inthisstate_rec (sLeafNode* pinstruction)
{
	bool bResult = false;
	if (pinstruction->iInstructionIndex == 1 + instruction_running_index)
	{
		// the instruction is in THIS state
		return true;
	}
	else
	{
		// keep looking
		bool bResult = false;
		if (pinstruction->pAlso) bResult = gridedit_instruction_inthisstate_rec(pinstruction->pAlso);
		if (pinstruction->pElse && bResult==false) bResult = gridedit_instruction_inthisstate_rec(pinstruction->pElse);
		return bResult;
	}
}

float gridedit_instruction_calculatewidth_rec (sLeafNode* pinstruction)
{
	float fTotalWidthNeededForChildren = 0.0f;
	if (pinstruction->pAlso==NULL && pinstruction->pElse==NULL)
	{
		// leaf node
		fTotalWidthNeededForChildren += 0.55f + 0.05f;
	}
	else
	{
		// new system needed, this is a little hard to navigate when have LARGE behaviors!!
		//if (pinstruction->pAlso) fTotalWidthNeededForChildren += 0.05f + gridedit_instruction_calculatewidth_rec(pinstruction->pAlso);
		//if (pinstruction->pElse) fTotalWidthNeededForChildren += 0.1f + gridedit_instruction_calculatewidth_rec(pinstruction->pElse);
		if (pinstruction->pAlso) fTotalWidthNeededForChildren += gridedit_instruction_calculatewidth_rec(pinstruction->pAlso);
		if (pinstruction->pElse) fTotalWidthNeededForChildren += gridedit_instruction_calculatewidth_rec(pinstruction->pElse);
		// works but is massively wide!!
		// parent node
		//float fLeftSide = 0.0f; if (pinstruction->pAlso) fLeftSide = gridedit_instruction_calculatewidth_rec(pinstruction->pAlso);
		//float fRightSide = 0.0f; if (pinstruction->pElse) fRightSide = gridedit_instruction_calculatewidth_rec(pinstruction->pElse);
		/// taker largest child width and make it symetrical
		//fTotalWidthNeededForChildren = fLeftSide;
		//if (fRightSide > fTotalWidthNeededForChildren) fTotalWidthNeededForChildren = fRightSide;
		//fTotalWidthNeededForChildren *= 2;
	}
	pinstruction->fWidthRequired = fTotalWidthNeededForChildren;
	return fTotalWidthNeededForChildren;
}

struct sCondActTable
{
	int iID;
	cstr sLabel;
	cstr sTip;
};
std::vector<sCondActTable> g_ConditionsTable;
std::vector<sCondActTable> g_ActionsTable;
char** combo_conditions = NULL;
int* combo_conditions_lookup = NULL;
char** combo_actions = NULL;
int* combo_actions_lookup = NULL;
int combo_animations_count = 0;
char** combo_animations = NULL;

void gridedit_instruction_parseandpopulateinstructions (void)
{
	// free any previous list
	if (combo_conditions)
	{
		for (int i = 0; i < g_ConditionsTable.size(); i++)
		{
			delete combo_conditions[i];
		}
		delete[] combo_conditions;
		delete[] combo_conditions_lookup;
	}
	if (combo_actions)
	{
		for (int i = 0; i < g_ActionsTable.size(); i++)
		{
			delete combo_actions[i];
		}
		delete[] combo_actions;
		delete[] combo_actions_lookup;
	}

	// clear lists
	g_ConditionsTable.clear();
	g_ActionsTable.clear();

	// condition list has extra ability
	sCondActTable deleteitem;
	deleteitem.iID = 0;
	deleteitem.sLabel = "(delete instruction)";
	deleteitem.sTip = "Select this to delete the current instruction block";
	g_ConditionsTable.push_back(deleteitem);
	sCondActTable moveitem;
	moveitem.iID = 1;
	moveitem.sLabel = "(move instruction)";
	moveitem.sTip = "Select this to move the current instruction block chain to a new position in the state flow";
	g_ConditionsTable.push_back(moveitem);

	// parse 'masterinterpreter.lua' and extract condition and action ordinals, labels and tooltips
	char pMasterInterpreterFile[MAX_PATH];
	sprintf(pMasterInterpreterFile, "scriptbank\\masterinterpreter.lua");
	OpenToRead(1, pMasterInterpreterFile);
	while (FileEnd(1) == 0)
	{
		// get line by line
		cstr line_s = ReadString(1);
		LPSTR pLine = line_s.Get();

		// extract conditions and actions
		int iParseThisLine = 0;
		LPSTR pFind = "g_masterinterpreter_cond_"; if (strnicmp (pLine, pFind, strlen(pFind)) == NULL) iParseThisLine = 1;
		pFind = "g_masterinterpreter_act_"; if (strnicmp (pLine, pFind, strlen(pFind)) == NULL) iParseThisLine = 2;
		if (iParseThisLine > 0)
		{
			LPSTR pEndOfCondActVar = strstr(pLine, " = ");
			if (pEndOfCondActVar)
			{
				LPSTR pStartOfLabel = strstr(pEndOfCondActVar, "-- ");
				if (pStartOfLabel)
				{
					LPSTR pOpenBracket = strstr(pStartOfLabel, "(");
					if (pOpenBracket)
					{
						LPSTR pCloseBracket = strstr(pOpenBracket, ")");
						if (pCloseBracket)
						{
							// line is valid, parse into entries
							char pValue[32];
							memset(pValue, 0, 32);
							pEndOfCondActVar += 3;
							memcpy(pValue, pEndOfCondActVar, pStartOfLabel - pEndOfCondActVar);
							char pLabel[256];
							memset(pLabel, 0, 256);
							pStartOfLabel += 3;
							memcpy(pLabel, pStartOfLabel, pOpenBracket - pStartOfLabel);
							char pTip[1024];
							memset(pTip, 0, 1024);
							pOpenBracket += 1;
							memcpy(pTip, pOpenBracket, pCloseBracket - pOpenBracket);

							// create item
							sCondActTable item;
							item.iID = atoi(pValue);
							item.sLabel = pLabel;
							item.sTip = pTip;

							// add to list
							if (iParseThisLine == 1) g_ConditionsTable.push_back(item);
							if (iParseThisLine == 2) g_ActionsTable.push_back(item);
						}
					}
				}
			}
		}
	}
	CloseFile(1);

	// create new lists
	combo_conditions_lookup = new int[g_ConditionsTable.size()];
	combo_conditions = new char*[g_ConditionsTable.size()];
	for (int i = 0; i < g_ConditionsTable.size(); i++)
	{
		combo_conditions_lookup[i] = g_ConditionsTable[i].iID;
		combo_conditions[i] = new char[256];
		strcpy (combo_conditions[i], g_ConditionsTable[i].sLabel.Get());
	}
	combo_actions_lookup = new int[g_ActionsTable.size()];
	combo_actions = new char*[g_ActionsTable.size()];
	for (int i = 0; i < g_ActionsTable.size(); i++)
	{
		combo_actions_lookup[i] = g_ActionsTable[i].iID;
		combo_actions[i] = new char[256];
		strcpy (combo_actions[i], g_ActionsTable[i].sLabel.Get());
	}
}

void gridedit_instruction_populateanimationlist ( int iObj )
{
	// free any previous animation list
	if (combo_animations)
	{
		for (int i = 0; i < combo_animations_count; i++)
		{
			delete combo_animations[i];
		}
		delete[] combo_animations;
		combo_animations = NULL;
	}

	// create animation list
	combo_animations_count = 0;
	if (iObj > 0)
	{
		sObject* pObject = GetObjectData(iObj);
		sAnimationSet* pAnimSet = pObject->pAnimationSet;
		while (pAnimSet)
		{
			combo_animations_count++;
			pAnimSet = pAnimSet->pNext;
		}
		combo_animations = new char*[combo_animations_count];
		combo_animations_count = 0;
		pAnimSet = pObject->pAnimationSet;
		while (pAnimSet)
		{
			combo_animations[combo_animations_count] = new char[256];
			strcpy (combo_animations[combo_animations_count], pAnimSet->szName);
			combo_animations_count++;
			pAnimSet = pAnimSet->pNext;
		}
	}
}

void gridedit_instruction_block_rec ( sStateNode* pState, ImVec2 vTopCenterPos, LPSTR pStateName, sLeafNode* pinstruction, float fMargin, int iRowIndex)
{
	// Insert instruction block
	float fAbsInstructionLeftX = vTopCenterPos.x;// -(instruction_block_width / 2);
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, vTopCenterPos.y));
	ImVec2 vInstructionPos = ImGui::GetCurrentWindow()->DC.CursorPos;
	ImVec2 vOutline = vInstructionPos - ImVec2(instruction_border, instruction_border);
	const ImRect instruction_bb(vOutline.x, vOutline.y, vOutline.x + instruction_block_width + (instruction_border * 2), vOutline.y + instruction_block_height + (instruction_border * 2));
	pinstruction->vReturnPointPos = ImVec2(vOutline.x, vOutline.y + (instruction_block_height / 2));

	// record left-most block (so can shift whole state to the left for more room)
	if (pState->bRecalcRightMost == true)
	{
		float fRightSideOfBlock = fAbsInstructionLeftX + instruction_block_width;
		if (pState->fRightMostX < fRightSideOfBlock) pState->fRightMostX = fRightSideOfBlock;
	}

	// In instruction pick mode, subdue colors
	ImGuiIO& io = ImGui::GetIO();
	ImVec4 block_col = ImVec4(1.0f, 1.0f, 1.0f, 0.2f);
	ImVec4 block_col_border = ImVec4(1.0f, 1.0f, 1.0f, 0.75f);
	if (instruction_pickaninstruction != NULL)
	{
		block_col = ImVec4(0.6f, 0.6f, 0.6f, 0.1f);
		block_col_border = ImVec4(0.6f, 0.6f, 0.6f, 0.5f);
		bool bHoveringOver = false;
		if (io.MousePos.x > instruction_bb.Min.x && io.MousePos.x < instruction_bb.Max.x && io.MousePos.y > instruction_bb.Min.y && io.MousePos.y < instruction_bb.Max.y)
		{
			if (instruction_pickstateorinstruction == 1)
			{
				// pick anything from any other state
				if (instruction_pickaninstruction->iState != pinstruction->iState)
				{
					block_col = ImVec4(1.0f, 1.0f, 1.0f, 0.4f);
					block_col_border = ImVec4(1.0f, 1.0f, 1.0f, 0.9f);
					instruction_hoveringover = pinstruction;
					bHoveringOver = true;
				}
			}
			if (instruction_pickstateorinstruction == 2)
			{
				// pick an instruction in same state
				if (instruction_pickaninstruction->iState == pinstruction->iState)
				{
					block_col = ImVec4(1.0f, 1.0f, 1.0f, 0.4f);
					block_col_border = ImVec4(1.0f, 1.0f, 1.0f, 0.9f);
					instruction_hoveringover = pinstruction;
					bHoveringOver = true;
				}
			}
		}
	}
	else
	{
		// when logic running, can highlight currently active instruction
		if (instruction_freezewheneditingbehavior == false)
		{
			if (instruction_running_e > 0)
			{
				if (instruction_running_index > 0)
				{
					if (pinstruction->iInstructionIndex == 1 + instruction_running_index)
					{
						block_col = ImVec4(1.0f, 1.0f, 0.6f, 0.6f);
						block_col_border = ImVec4(1.0f, 1.0f, 0.6f, 0.9f);
					}
				}
			}
		}
	}

	// Draw outline of instruction block
	ImGui::GetCurrentWindow()->DrawList->AddRectFilled(instruction_bb.Min, instruction_bb.Max, ImGui::GetColorU32(block_col), 0.0f, 15);
	ImGui::GetCurrentWindow()->DrawList->AddRect(instruction_bb.Min, instruction_bb.Max, ImGui::GetColorU32(block_col_border), 0.0f, 15, 2.0f);

	// condition combo
	char pInstructionDisplay[1024];
	sprintf(pInstructionDisplay, "##BehaviorEditorCondition%s%d", pStateName, pinstruction->iInstructionIndex);
	ImGui::PushItemWidth(instruction_block_width);
	int iPreviousConditionValue = pinstruction->iCondition;
	int iConditionListIndex = 0;
	for (int iFind = 0; iFind < g_ConditionsTable.size(); iFind++)
	{
		if (combo_conditions_lookup[iFind] == pinstruction->iCondition) iConditionListIndex = iFind;
	}
	if (ImGui::Combo(pInstructionDisplay, &iConditionListIndex, combo_conditions, g_ConditionsTable.size()))
	{
		pinstruction->iCondition = combo_conditions_lookup[iConditionListIndex];
		if (pinstruction->iCondition == 0)
		{
			// special case - until newer UI idea comes along, delete this instruction
			instruction_deletethis = pinstruction;
			instruction_deleteinthisstate = pState;
			pinstruction->iCondition = iPreviousConditionValue;
		}
		if (pinstruction->iCondition == 1)
		{
			// special case - select a new location for this instruction to be connected to
			instruction_picknewendnode = 1;
			instruction_pickanewnode = pinstruction;
			pinstruction->iCondition = iPreviousConditionValue;
		}
		instruction_freezewheneditingbehavior = true;
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip(combo_conditions[iConditionListIndex]);
	// optional condition param
	sprintf(pInstructionDisplay, "##BehaviorEditorConditionParam1%s%d", pStateName, pinstruction->iInstructionIndex);
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
	if (ImGui::InputText(pInstructionDisplay, &pinstruction->pConditionParam1[0], 250, ImGuiInputTextFlags_None))
	{
		instruction_freezewheneditingbehavior = true;
	}
	// action combo
	sprintf(pInstructionDisplay, "##BehaviorEditorAction%s%d", pStateName, pinstruction->iInstructionIndex);
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
	int iPreviousActionValue = pinstruction->iAction;
	int iActionListIndex = 0;
	for (int iFind = 0; iFind < g_ActionsTable.size(); iFind++)
	{
		if (combo_actions_lookup[iFind] == pinstruction->iAction) iActionListIndex = iFind;
	}
	if (ImGui::Combo(pInstructionDisplay, &iActionListIndex, combo_actions, g_ActionsTable.size()))
	{
		pinstruction->iAction = combo_actions_lookup[iActionListIndex];

		// special instruction index change
		if (pinstruction->iAction == 0 || pinstruction->iAction == 1)
		{
			// can only change instruction block if no instructions in ALSO
			if (pinstruction->pAlso == NULL)
			{
				if (pinstruction->iAction == 0)
				{
					// special case - go to state
					instruction_pickstateorinstruction = 1;
					instruction_pickaninstruction = pinstruction;
				}
				if (pinstruction->iAction == 1)
				{
					// special case - go to instruction
					instruction_pickstateorinstruction = 2;
					instruction_pickaninstruction = pinstruction;
				}
			}
			else
			{
				pinstruction->iAction = iPreviousActionValue;
			}
		}
		else
		{
			// regular action
			pinstruction->pGoToInstruction = NULL;
		}
		instruction_freezewheneditingbehavior = true;
	}
	if (g_ActionsTable.size() > 0)
	{
		if (ImGui::IsItemHovered()) ImGui::SetTooltip(combo_actions[iActionListIndex]);
	}
	// optional action param
	if (pinstruction->iAction == 12 || pinstruction->iAction == 13 || pinstruction->iAction == 66 || pinstruction->iAction == 67)
	{
		// play and loop shows animation list for this object
		sprintf(pInstructionDisplay, "##BehaviorEditorActionParam1Combo%s%d", pStateName, pinstruction->iInstructionIndex);
		ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
		int iAnimationListIndex = 0;
		for (int iFind = 0; iFind < combo_animations_count; iFind++)
		{
			if ( stricmp (combo_animations[iFind], pinstruction->pActionParam1)==NULL) iAnimationListIndex = iFind;
		}
		if (ImGui::Combo(pInstructionDisplay, &iAnimationListIndex, combo_animations, combo_animations_count))
		{
			strcpy ( pinstruction->pActionParam1, combo_animations[iAnimationListIndex]);
		}
	}
	else
	{
		// regular text field
		sprintf(pInstructionDisplay, "##BehaviorEditorActionParam1%s%d", pStateName, pinstruction->iInstructionIndex);
		ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y));
		if (ImGui::InputText(pInstructionDisplay, &pinstruction->pActionParam1[0], 250, ImGuiInputTextFlags_None))
		{
			instruction_freezewheneditingbehavior = true;
		}
	}
	// labels
	ImVec2 vCursorPos = ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y);
	ImGui::SetCursorPos(vCursorPos + ImVec2(5.0f, 0));
	ImGui::Text("True");
	if (pinstruction->iCondition != 11)
	{
		ImGui::SameLine();
		ImGui::SetCursorPos(vCursorPos + ImVec2(instruction_block_width - 35.0f, 0));
		ImGui::Text("False");
	}
	// lines and add buttons
	float fLineVertGap = ImGui::GetFontSize() / 2.0f;
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y+fLineVertGap));
	float fHalfInstructionWidth = instruction_block_width / 2;
	float fAddButtonWidth = instruction_block_width / 3.0f;
	float fButtonMargin = (fHalfInstructionWidth - fAddButtonWidth) / 2.0f;
	float fButtonPosY = ImGui::GetCursorPos().y;
	float fLeftALSOBranchX = 0.0f;
	float fRightELSEBranchX = 0.0f;
	float fVertYPosToNextInstruction = instruction_block_height + 46.0f;
	int buttoncount = 2;
	if ( pinstruction->iCondition == 11) buttoncount = 1;
	for (int buttonindex = 0; buttonindex < buttoncount; buttonindex++)
	{
		float fWhichHalf = buttonindex * fHalfInstructionWidth;
		bool bHaveAnotherInstruction = false;
		if (buttonindex == 0)
		{
			if (pinstruction->pAlso) bHaveAnotherInstruction = true;
		}
		else
		{
			if (pinstruction->pElse) bHaveAnotherInstruction = true;
		}
		float fDestinationAdjustmentX = 0.0f;
		float fDestinationAdjustmentForButtonX = 0.0f;
		if (buttonindex == 0 && pinstruction->pAlso && pinstruction->pElse)
		{
			// going to keep left aligned, and expand right
		}
		if (buttonindex == 1 && pinstruction->pElse)
		{
			if (pinstruction->iAction == 0 || pinstruction->iAction == 1)
			{
				// Go To State and Go To Instruction has no block
			}
			else
			{
				if(pinstruction->pAlso) fDestinationAdjustmentX += ((pinstruction->pAlso->fWidthRequired) * instruction_block_width) * 2.0f;
				fDestinationAdjustmentForButtonX += 10;
			}
		}
		ImVec2 vLineFrom = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4), instruction_block_height + instruction_border);
		ImVec2 vLineTo = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4) + fDestinationAdjustmentForButtonX, instruction_block_height + instruction_border + 10);

		bool bFirstLineIsInstructionJump = false;
		if (buttonindex == 0 && pinstruction->pGoToInstruction) bFirstLineIsInstructionJump = true;
		if (bFirstLineIsInstructionJump == true)
		{
			// return to start and goto instruction have shorter vert line to 'miss' the regular line (if on right - phewy)
			vLineTo.y -= 5.0f;
		}

		// line from instruction block to button
		ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);

		if (buttonindex == 0)
			fLeftALSOBranchX = fDestinationAdjustmentX;
		else
			fRightELSEBranchX = fDestinationAdjustmentX;
		if (bFirstLineIsInstructionJump == true)
		{
			// if 'go to' instruction block, protrude a line leftward
			vLineFrom = vLineTo;

			// left side or right side
			ImVec2 vShiftToSide = vInstructionPos - ImVec2(8.0f,0);
			ImVec2 vConnectTo = pinstruction->pGoToInstruction->vReturnPointPos;
			float fDecidingXPos = vLineFrom.x;
			if (buttonindex == 0) fDecidingXPos += instruction_block_width;
			if (fDecidingXPos > instruction_centerline_absolutex)
			{
				vConnectTo.x += instruction_block_width + (instruction_border/2);
			}

			// only complete connection to instruction if within state
			if (pinstruction->iAction == 0)
			{
				// when jump to new state, no connecting line to the new state component (yet)
				vLineTo.x = vShiftToSide.x;
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.45f)), 2.0f);

				// mark state jump with square
				ImVec2 vEndOfLine = vLineTo;
				vLineFrom = ImVec2(vEndOfLine.x - 5.0f, vEndOfLine.y - 2.5f);
				vLineTo = ImVec2(vEndOfLine.x, vEndOfLine.y + 2.5f);
				ImGui::GetCurrentWindow()->DrawList->AddRect(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.45f)), 2.0f);
			}
			if (pinstruction->iAction == 1)
			{
				// if 'go to' instruction block, protrude a line left/rightward
				vLineTo.x = vShiftToSide.x;
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.45f)), 2.0f);

				// then draw a line up or down to destination Y pos
				ImVec2 vLevelWith = ImVec2(vLineTo.x, vConnectTo.y);
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineTo, vLevelWith, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.45f)), 2.0f);

				// and to destination
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLevelWith, vConnectTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.45f)), 2.0f);
			}
		}
		else
		{
			if (bHaveAnotherInstruction == true)
			{
				// insert an instruction at this point
				sprintf(pInstructionDisplay, "+##BehaviorEditorInsert%s%d%d", pStateName, buttonindex, pinstruction->iInstructionIndex);

				// and a line dropping down from [+] button to instruction below
				vLineFrom = vInstructionPos + ImVec2(fWhichHalf + (instruction_block_width / 4) + fDestinationAdjustmentForButtonX, instruction_block_height + instruction_border + 10 + 10);
				vLineTo = vInstructionPos + ImVec2((instruction_block_width / 2) + fDestinationAdjustmentX, fVertYPosToNextInstruction + instruction_border);
				ImGui::GetCurrentWindow()->DrawList->AddLine(vLineFrom, vLineTo, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 0.75f)), 2.0f);
			}
			else
			{
				// add a new instruction button
				if (buttonindex == 0)
					sprintf(pInstructionDisplay, "T##BehaviorEditorAdd%s%d%d", pStateName, buttonindex, pinstruction->iInstructionIndex);
				else
					sprintf(pInstructionDisplay, "F##BehaviorEditorAdd%s%d%d", pStateName, buttonindex, pinstruction->iInstructionIndex);
			}
			ImGui::SetCursorPos(ImVec2(fButtonMargin + fWhichHalf + fAbsInstructionLeftX + fDestinationAdjustmentForButtonX, fButtonPosY));
			if (ImGui::Button(pInstructionDisplay, ImVec2(fAddButtonWidth, 0)))
			{
				// check if special case with user selecting node to connect instruction to
				if (instruction_picknewendnode == 1)
				{
					// detatch old instruction chain from current connection
					sLeafNode* pOldParent = instruction_pickanewnode->pParent;
					if (pOldParent->pAlso == instruction_pickanewnode) pOldParent->pAlso = NULL;
					if (pOldParent->pElse == instruction_pickanewnode) pOldParent->pElse = NULL;
					instruction_pickanewnode->pParent = NULL;

					// attach instruction chain to new node location
					if (buttonindex == 0)
						pinstruction->pAlso = instruction_pickanewnode;
					else
						pinstruction->pElse = instruction_pickanewnode;
					instruction_pickanewnode->pParent = pinstruction;

					// finished moving instruction chain
					instruction_picknewendnode = 0;
				}
				else
				{
					// create new instruction
					sLeafNode* pNewInstruction = new sLeafNode();
					memset(pNewInstruction, 0, sizeof(sLeafNode));
					pNewInstruction->iUniqueSignatureCode = rand() % 999999;
					pNewInstruction->pParent = pinstruction;
					pNewInstruction->iInstructionIndex = -1;
					pNewInstruction->iState = 1;
					pNewInstruction->iCondition = 11;
					pNewInstruction->iAction = 11;
					if (bHaveAnotherInstruction == true)
					{
						// insert
						if (buttonindex == 0)
						{
							sLeafNode* pExisting = pinstruction->pAlso;
							pinstruction->pAlso = pNewInstruction;
							pNewInstruction->pAlso = pExisting;
							pExisting->pParent = pNewInstruction;
						}
						else
						{
							sLeafNode* pExisting = pinstruction->pElse;
							pinstruction->pElse = pNewInstruction;
							pNewInstruction->pAlso = pExisting;
							pExisting->pParent = pNewInstruction;
						}
					}
					else
					{
						// add
						if (buttonindex == 0)
							pinstruction->pAlso = pNewInstruction;
						else
							pinstruction->pElse = pNewInstruction;
					}
				}

				// when add instruction, old instruction indices now invalid
				instruction_regenerateinstructionindices = true;
				instruction_freezewheneditingbehavior = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select this to add a new instruction to the state.");
		}
	}
	ImGui::SetCursorPos(ImVec2(fAbsInstructionLeftX, ImGui::GetCursorPos().y + fLineVertGap));

	// finished instruction block
	ImGui::PopItemWidth();

	// Follow down tree of instructions
	ImVec2 vShiftPos;
	if (pinstruction->pAlso)
	{
		vShiftPos = ImVec2(fLeftALSOBranchX, fVertYPosToNextInstruction + (instruction_border*2));
		gridedit_instruction_block_rec (pState, vTopCenterPos + vShiftPos, pStateName, pinstruction->pAlso, fMargin, iRowIndex+1);
	}
	if (pinstruction->pElse)
	{
		vShiftPos = ImVec2(fRightELSEBranchX, fVertYPosToNextInstruction + (instruction_border*2));
		gridedit_instruction_block_rec (pState, vTopCenterPos + vShiftPos, pStateName, pinstruction->pElse, fMargin, iRowIndex+1);
	}

	// record deepest Y position as recursion can end on instruction blocks further up
	vCursorPos = ImGui::GetCursorPos();
	if (vCursorPos.y > instruction_furthestcursor.y)
	{
		instruction_furthestcursor = vCursorPos;
	}
}

void gridedit_savebehavior ( LPSTR pByteFilename )
{
	// re-number instruction indices, and create single instruction list
	int iInstructionCount = gridedit_generateuniqueinstructionindices();

	// get real path to script BYC file
	char pByteCodeFile[MAX_PATH];
	strcpy (pByteCodeFile, pByteFilename);
	GG_GetRealPath(pByteCodeFile, 1);
	if (FileExist(pByteCodeFile) == 1) DeleteFileA(pByteCodeFile);

	// latest version for saving
	int iVersionNumber = 102;

	// write new BYC file
	OpenToWrite(1, pByteCodeFile);
	WriteString(1, "42"); // magic number

	// write version number
	char pVersionNumber[250];
	sprintf (pVersionNumber, "%d", iVersionNumber);
	WriteString(1, pVersionNumber); // version number

	// find largest state index in all instructions
	int iStateCount = 0;
	for (int index = 0; index < iInstructionCount; index++)
	{
		int iThisStateIndex = instruction_singlelist[index]->iState;
		if (iThisStateIndex > iStateCount) iStateCount = iThisStateIndex;
	}

	// write state count
	char pStateCount[32];
	sprintf(pStateCount, "%d", iStateCount);
	WriteString(1, pStateCount);

	// write instruction count
	char pInstructionCount[32];
	sprintf(pInstructionCount, "%d", iInstructionCount);
	WriteString(1, pInstructionCount); // instruction count

	// version 101
	char pLine[2048];
	if (iVersionNumber >= 101)
	{
		// all states
		for (int iStateIndex = 0; iStateIndex < iStateCount; iStateIndex++)
		{
			sStateNode* pState = &instruction_state_list[iStateIndex];
			sprintf(pLine, "%s", pState->pName); WriteString(1, pLine);
			sprintf(pLine, "%d", (int)pState->bAllowInterupt); WriteString(1, pLine);
		}
		WriteString(1, "---"); // separator
		// all instuctions
		for (int index = 0; index < iInstructionCount; index++)
		{
			sLeafNode* pThis = instruction_singlelist[index];
			sprintf(pLine, "%d", pThis->iUniqueSignatureCode); WriteString(1, pLine); // UniqueSignatureCode
			sprintf(pLine, "%d", pThis->iState); WriteString(1, pLine); // state
			sprintf(pLine, "%d", pThis->iCondition); WriteString(1, pLine); // condition
			sprintf(pLine, "%s", pThis->pConditionParam1); WriteString(1, pLine); // condition param1
			sprintf(pLine, "%s", pThis->pConditionParam2); WriteString(1, pLine); // condition param2
			sprintf(pLine, "%d", pThis->iAction); WriteString(1, pLine); // action
			sprintf(pLine, "%s", pThis->pActionParam1); WriteString(1, pLine); // action param1
			sprintf(pLine, "%s", pThis->pActionParam2); WriteString(1, pLine); // action param2
			int iAlsoInstructionNumber = 0;	if (pThis->pAlso) iAlsoInstructionNumber = pThis->pAlso->iInstructionIndex;
			int iElseInstructionNumber = 0;	if (pThis->pElse) iElseInstructionNumber = pThis->pElse->iInstructionIndex;
			if ((pThis->iAction == 0 || pThis->iAction == 1) && pThis->pGoToInstruction)
			{
				// store goto instruction index in ALSO (does same thing in the end as ALSO)
				iAlsoInstructionNumber = pThis->pGoToInstruction->iInstructionIndex;
			}
			sprintf(pLine, "%d", iAlsoInstructionNumber); WriteString(1, pLine); // also
			sprintf(pLine, "%d", iElseInstructionNumber); WriteString(1, pLine); // else
			WriteString(1, "---"); // separator
		}
	}
	if (iVersionNumber >= 102)
	{
		// save the instruction index from the root of the damage state (if any)
		int iDamageStateRootInstructionIndex = -1;
		for (int iStateIndex = 0; iStateIndex < iStateCount; iStateIndex++)
		{
			sStateNode* pState = &instruction_state_list[iStateIndex];
			if (stricmp (pState->pName, "damage") == NULL)
			{
				iDamageStateRootInstructionIndex = pState->instruction_root->iInstructionIndex;
				break;
			}
		}
		sprintf(pLine, "%d", iDamageStateRootInstructionIndex); WriteString(1, pLine);
	}
	CloseFile(1);
}

void gridedit_deletebehaviornodes_rec ( sLeafNode* pThis )
{
	if (pThis == NULL) return;
	gridedit_deletebehaviornodes_rec (pThis->pAlso);
	gridedit_deletebehaviornodes_rec (pThis->pElse);
	pThis->pAlso = NULL;
	pThis->pElse = NULL;
	delete pThis;
}

void gridedit_deletebehavior(void)
{
	for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
	{
		sStateNode* pState = &instruction_state_list[iStateIndex];
		if (pState->instruction_root)
		{
			gridedit_deletebehaviornodes_rec(pState->instruction_root);
			pState->instruction_root = NULL;
		}
	}
	instruction_state_list.clear();
	instruction_singlelist.clear();
}

bool gridedit_loadbehavior (LPSTR pByteFilename)
{
	// delete any previous node tree from all states and clear single list to populate from BYC file
	gridedit_deletebehavior();

	// get real path to script BYC file
	int* pAlsoTable = NULL;
	int* pElseTable = NULL;
	int iStateCount = 0;
	int iInstructionCount = 0;
	char pByteCodeFile[MAX_PATH];
	strcpy (pByteCodeFile, pByteFilename);
	GG_GetRealPath(pByteCodeFile, 0);
	if (FileExist(pByteCodeFile) == 1)
	{
		// read BYC file
		OpenToRead(1, pByteCodeFile);
		LPSTR pMagicNumber = ReadString(1); // magic number
		LPSTR pVersionNumber = ReadString(1); // version number
		int iVersionNumber = atoi(pVersionNumber);
		LPSTR pStateCount = ReadString(1); // state count
		iStateCount = atoi(pStateCount);
		LPSTR pInstructionCount = ReadString(1); // instruction count
		iInstructionCount = atoi(pInstructionCount);

		// table to store alsoe and else instruction numbers
		pAlsoTable = new int[iInstructionCount];
		memset(pAlsoTable, 0, sizeof(int)*iInstructionCount);
		pElseTable = new int[iInstructionCount];
		memset(pElseTable, 0, sizeof(int)*iInstructionCount);

		// Version 101
		if (iVersionNumber >= 101)
		{
			// all states
			for (int iStateIndex = 0; iStateIndex < iStateCount; iStateIndex++)
			{
				sStateNode state;
				state.iStateIndex = 1 + iStateIndex;
				LPSTR pName = ReadString(1); strcpy (state.pName, pName);
				LPSTR pAllowInterupt = ReadString(1); state.bAllowInterupt = atoi(pAllowInterupt);
				state.instruction_root = NULL;
				instruction_state_list.push_back(state);
			}
			LPSTR pStateSeparator = ReadString(1);
			// all instructions
			for (int index = 0; index < iInstructionCount; index++)
			{
				// create new instruction
				sLeafNode* pThis = new sLeafNode();
				memset(pThis, 0, sizeof(sLeafNode));
				instruction_singlelist.push_back(pThis);

				// read instruction data
				LPSTR pUniqueSignatureCode = ReadString(1); pThis->iUniqueSignatureCode = atoi(pUniqueSignatureCode);
				LPSTR pState = ReadString(1); pThis->iState = atoi(pState);
				LPSTR pCondition = ReadString(1); pThis->iCondition = atoi(pCondition);
				LPSTR pConditionParam1 = ReadString(1); strcpy (pThis->pConditionParam1, pConditionParam1);
				LPSTR pConditionParam2 = ReadString(1); strcpy (pThis->pConditionParam2, pConditionParam2);
				LPSTR pAction = ReadString(1); pThis->iAction = atoi(pAction);
				LPSTR pActionParam1 = ReadString(1); strcpy (pThis->pActionParam1, pActionParam1);
				LPSTR pActionParam2 = ReadString(1); strcpy (pThis->pActionParam2, pActionParam2);
				LPSTR pAlsoInstructionNumber = ReadString(1); pAlsoTable[index] = atoi(pAlsoInstructionNumber);
				LPSTR pElseInstructionNumber = ReadString(1); pElseTable[index] = atoi(pElseInstructionNumber);
				LPSTR pSeparator = ReadString(1);
			}
		}
		CloseFile(1);
	}

	// all nodes created, now construct the tree
	if (iInstructionCount > 0)
	{
		// populate state root instruction
		int iCurrentState = -1;

		// create node tree from behavior single list
		for (int index = 0; index < iInstructionCount; index++)
		{
			// for each instruction in list
			sLeafNode* pInstructionFromList = instruction_singlelist[index];

			// find and connect root instruction to state
			int iThisState = pInstructionFromList->iState - 1;
			if (iThisState > iCurrentState)
			{
				sStateNode* pState = &instruction_state_list[iThisState];
				pState->instruction_root = pInstructionFromList;
				iCurrentState = iThisState;
			}

			// link up nodes
			sLeafNode* pInstructionAlsoRef = NULL; if (pAlsoTable[index] > 0) pInstructionAlsoRef = instruction_singlelist[pAlsoTable[index] - 1];
			sLeafNode* pInstructionElseRef = NULL; if (pElseTable[index] > 0) pInstructionElseRef = instruction_singlelist[pElseTable[index] - 1];
			pInstructionFromList->pAlso = pInstructionAlsoRef;
			pInstructionFromList->pElse = pInstructionElseRef;

			// special case for restart state and goto instruction
			if (pInstructionFromList->iAction == 0 || pInstructionFromList->iAction == 1)
			{
				// move to GOTO instruction and remove from ALSO ref
				pInstructionFromList->pGoToInstruction = pInstructionFromList->pAlso;
				pInstructionFromList->pAlso = NULL;
				pInstructionAlsoRef = NULL;
			}

			// and link up parent ref
			if (pInstructionAlsoRef) pInstructionAlsoRef->pParent = pInstructionFromList;
			if (pInstructionElseRef) pInstructionElseRef->pParent = pInstructionFromList;
		}
	}
	else
	{
		// fresh new behavior (one state, one instruction)
		sLeafNode* pInstruction = new sLeafNode();
		pInstruction->iUniqueSignatureCode = rand() % 999999;
		pInstruction->iInstructionIndex = -1;
		pInstruction->iCondition = 11;
		pInstruction->iAction = 11;
		instruction_singlelist.push_back(pInstruction);
		sStateNode state;
		state.iStateIndex = 1;
		strcpy (state.pName, "Initial");
		state.bAllowInterupt = true;
		state.instruction_root = pInstruction;
		instruction_state_list.push_back(state);
	}

	// and finally generate updated instruction indices
	instruction_regenerateinstructionindices = true;

	// free resources
	if (pAlsoTable)
	{
		delete[] pAlsoTable;
		pAlsoTable = NULL;
	}
	if (pElseTable)
	{
		delete[] pElseTable;
		pElseTable = NULL;
	}

	// when load new behavior, reset running data (debugging)
	instruction_running_index = 0;
	instruction_freezewheneditingbehavior = false;

	// success
	return true;
}

void gridedit_setvsync(bool bLevelVSyncEnabled)
{
	// ensure only test game and standalones obey VSYNC, editor should always run FULL SPEED
	extern bool bImGuiInTestGame;
	if (t.game.gameisexe == 0 && bImGuiInTestGame == false )
	{
		if(g.iEditorVSync == 0)
			bLevelVSyncEnabled = false;
	}
	master.bVsyncEnabled = bLevelVSyncEnabled;
	wiEvent::SetVSync(master.bVsyncEnabled);
}

void gridedit_setreflection(bool bReflecctionFlag)
{
	master_renderer->setReflectionsEnabled(bReflecctionFlag);
}

void gridedit_setsky(int iSkyMode)
{
	extern wiECS::Entity g_weatherEntityID;
	wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
	if (iSkyMode == 0)
	{
		weather->SetRealisticSky(true);
		weather->SetVolumetricClouds(true);
	}
	if (iSkyMode == 1)
	{
		weather->SetRealisticSky(false);
		weather->SetVolumetricClouds(false);
	}
}

void tab_tab_visuals(int iPage, int iMode)
{
	//iMode = 0 , editor.
	//iMode = 1 , test game.
	//iPage = 0 , game
	//iPage = 1 , performance data
	//iPage = 2 , visuals panel
	//iPage = 2? , behavior editor. (developer mode)

	//Try to match visuals.ini
	cStr sWindowName = "Environment Effects##VisualsToolsWindow";
	bNeedImGuiInput = false;

	if (iMode == 1 && !bRenderTabTab && !bImGuiFrameState) // lee added !bImGuiFrameState to prevent double newframes
	{
		//We need a new frame.
		ImGui_ImplDX11_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();
		extern bool bSpriteWinVisible;
		bSpriteWinVisible = false;
		bBlockImGuiUntilNewFrame = false;
		bImGuiRenderWithNoCustomTextures = false;
		bRenderTabTab = true;
	}

	if (iMode == 1 && iPage >= 1)
	{
		//Display performance data.
		bool bStatOpen = true;
		if (!wiProfiler::IsEnabled())
			wiProfiler::SetEnabled(true);
		DisplayPerformanceData(&bStatOpen);
	}
	else
	{
		if (!bProfilerEnable)
		{
			if (wiProfiler::IsEnabled())
				wiProfiler::SetEnabled(false);
		}
	}

	if (iMode == 1 && iPage == 1)
	{
		//Make window a floating one for testgame.
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		float window_width = 20 * ImGui::GetFontSize();
		float window_height = 50 * ImGui::GetFontSize();
		if (iPage == 1)
		{
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(viewPortSize.x - window_width - 2.0, 2.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowSize(ImVec2(window_width, viewPortSize.y - 4.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver}
		}
		sWindowName = "Visuals##VisualsTabTabWindow";
		bNeedImGuiInput = true;
	}

	bool bVisualUpdated = false;
	float fTabColumnWidth = 120;
	static bool bSetSimpleSky = false;
	static int g_lutimage_item_count = 0;
	static char** g_lutimage_items = NULL;
	static int current_lutimage_selection = 0;

	// for now, switch visual window for behavior editor!
	bool bBehaviorEditor = false;
	if (bRenderTabTab && iPage == 1)
	{
		// if object selected for in-game debug view/live editing
		if (g_bBehaviorEditorActive ==true) bBehaviorEditor = true;
	}

	// visual window or behavior window
	if (bBehaviorEditor == false && (Visuals_Tools_Window && iMode == 0 || bRenderTabTab) && iPage == 1)
	{
		extern int iGenralWindowsFlags;
		int winflag = iGenralWindowsFlags;
		if (iMode == 1 && iPage == 1)
		{
			winflag |= ImGuiWindowFlags_NoMove;
			winflag |= ImGuiWindowFlags_NoResize;
		}
		ImGui::Begin(sWindowName.Get(), &Visuals_Tools_Window, winflag);

		float w = ImGui::GetWindowContentRegionWidth();

		//PE: Default to closed.
		int wflags = ImGuiTreeNodeFlags_None;

		if (bRenderTabTab)
		{
			imgui_Customize_Sky_V2(1);
			imgui_Customize_Water_V2(1);
			imgui_Customize_Weather_V2(1);
			wflags = ImGuiTreeNodeFlags_None;
		}
		else
		{
			//Condition from test game tab tab. possible.
			if (iLastOpenHeader == 2 || iLastOpenHeader == 3)
			{
				ImGui::SetNextItemOpen(true, ImGuiCond_Always);
				iLastOpenHeader = 1;
			}
			imgui_Customize_Sky_V2(0);
		}

		if (bRenderTabTab)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 7)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Camera Settings", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 7;
				bool bUpdateCam = false;
				if (ImGui::SliderFloat("##WickedCameraNear", &t.visuals.CameraNEAR_f, 1.0f, 30.0f, "%.2f", 1.0f))
				{
					if ( t.visuals.CameraFAR_f < t.visuals.CameraNEAR_f + 0.1f ) t.visuals.CameraFAR_f = t.visuals.CameraNEAR_f + 0.1f;
					t.gamevisuals.CameraNEAR_f = t.visuals.CameraNEAR_f;
					bUpdateCam = true;
				}
				if (ImGui::SliderFloat("##WickedCameraFar", &t.visuals.CameraFAR_f, DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE, "%.2f", 2.0f))
				{
					if ( t.visuals.CameraNEAR_f > t.visuals.CameraFAR_f - 0.1f ) t.visuals.CameraNEAR_f = t.visuals.CameraFAR_f - 0.1f;
					t.gamevisuals.CameraFAR_f = t.visuals.CameraFAR_f;
					//bVisualUpdated = true;
					bUpdateCam = true;
				}

				//PE: Now reverse again as we now follow weapon in tab tab.
				//if (ImGui::MaxSliderInputFloat("##WickedCameraFov", &t.visuals.CameraFOV_f, 20.0f, 110.0f, "Camera Field Of View (FOV)"))
				//LB: Use real degree value so users know the FOV they are choosing
				ImGui::Text("Camera FOV");
				ImGui::SameLine();
				int iCamFOV = t.visuals.CameraFOV_f;
				if ( ImGui::SliderInt("##WickedCameraFov", &iCamFOV, 1, 120) )
				{
					t.visuals.CameraFOV_f = iCamFOV;
					t.gamevisuals.CameraFOV_f = t.visuals.CameraFOV_f;
					bUpdateCam = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Vertical Field Of View (FOV)");

				// ZJ: Update camera settings separately to stop the water going crazy. See https://github.com/TheGameCreators/GameGuruRepo/issues/1851
				if (bUpdateCam)
				{
					float fUsedFOV = t.visuals.CameraFOV_f;
					if (bImGuiInTestGame == false) fUsedFOV = 45;
					float fCameraFov = XM_PI / (fUsedFOV / 15.0f); //Fit GG settings.
					if (bImGuiInTestGame == true)
					{
						//PE: Visual change also need reerse fov in test game and standalone.
						// when in game, weapon FOV correction
						fCameraFov = GGToRadian(fUsedFOV); // Oops - backwards logic, lower FOV needs lower angle passed in
					}
					wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
				}
				ImGui::Indent(-10);
			}

			extern int g_iDevToolsOpen;
			if (g_iDevToolsOpen != 0 )
			{
				if (ImGui::StyleCollapsingHeader("Physics", wflags))
				{
					ImGui::Indent(10);
					bool bDrawPhysicsShapes = t.visuals.iPhysicsDebugDraw;
					bool bRenderStaticShapes = false;
					bool bRenderStaticTerrain = false;
					if (t.visuals.iPhysicsDebugDrawStatics & 1) bRenderStaticShapes = true;
					if (t.visuals.iPhysicsDebugDrawStatics & 2) bRenderStaticTerrain = true;
					bool bRenderConstraints = t.visuals.iPhysicsDebugDrawConstraints;
					if (ImGui::Checkbox("Render Physics Shapes", &bDrawPhysicsShapes))
					{
						t.visuals.iPhysicsDebugDraw = bDrawPhysicsShapes;
						physics_set_debug_draw(bDrawPhysicsShapes);
						bVisualUpdated = true;
					}
					if (bDrawPhysicsShapes)
					{
						if (ImGui::Checkbox("Render Static Shapes", &bRenderStaticShapes))
						{
							t.visuals.iPhysicsDebugDrawStatics = 0;
							if (bRenderStaticShapes) t.visuals.iPhysicsDebugDrawStatics += 1;
							if (bRenderStaticTerrain) t.visuals.iPhysicsDebugDrawStatics += 1<<1;
							physics_set_debug_draw(bDrawPhysicsShapes);
						}
						if (ImGui::Checkbox("Render Static Terrain", &bRenderStaticTerrain))
						{
							t.visuals.iPhysicsDebugDrawStatics = 0;
							if (bRenderStaticShapes) t.visuals.iPhysicsDebugDrawStatics += 1;
							if (bRenderStaticTerrain) t.visuals.iPhysicsDebugDrawStatics += 1 << 1;
							physics_set_debug_draw(bDrawPhysicsShapes);
						}
						if (ImGui::Checkbox("Render Constraints", &bRenderConstraints))
						{
							t.visuals.iPhysicsDebugDrawConstraints = bRenderConstraints;
							physics_set_debug_draw(bDrawPhysicsShapes);
						}
					}
					if (bDrawPhysicsShapes)
					{
						extern bool g_bDebugRagdoll;
						if (ImGui::Checkbox("Render Ragdoll Shapes", &g_bDebugRagdoll))
						{
							// done elsewhere
						}
					}
					ImGui::Indent(-10);
				}
			}
		}

		//PE: Ambient Music Track only in Editor, in test game its already playing. so..
		if (iMode == 0)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 11)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Music Tracks", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 11;

				static bool bTestSound = false;
				float but_gadget_size = ImGui::GetFontSize()*10.0;

				// allow for ambient and combat selections
				for (int iGlobalGameSounds = 0; iGlobalGameSounds < 2; iGlobalGameSounds++)
				{
					// 0-ambient, 1-combat
					LPSTR pTextEnable = "";
					LPSTR pTextTitle = "";
					LPSTR pTextSelect = "";
					LPSTR pTextName = "";
					LPSTR pTextVolume = "";
					LPSTR pTextPlay = "";
					LPSTR pTextStop = "";
					int iFreeSoundID = 0;
					bool bEnableMusicTrack = 0;
					if (iGlobalGameSounds == 0)
					{
						pTextEnable = "Enable Ambient Music Track";
						pTextTitle = "Ambient Music Track";
						pTextSelect = "Select Ambient Music Track";
						pTextName = "##iAmbientMusicTrackVolume";
						pTextVolume = "Select Ambient Music Track Volume";
						pTextPlay = "Play Ambient Music##TabTabEditBehaviors";
						pTextStop = "Stop Ambient Music##TabTabEditBehaviors";
						iFreeSoundID = g.temppreviewsoundoffset + 3;
						bEnableMusicTrack = t.visuals.bEndableAmbientMusicTrack;
					}
					if (iGlobalGameSounds == 1)
					{
						pTextEnable = "Enable Combat Music Track";
						pTextTitle = "Combat Music Track";
						pTextSelect = "Select Combat Music Track";
						pTextName = "##iCombatMusicTrackVolume";
						pTextVolume = "Select Combat Music Track Volume";
						pTextPlay = "Play Combat Music##TabTabEditBehaviors";
						pTextStop = "Stop Combat Music##TabTabEditBehaviors";
						iFreeSoundID = g.temppreviewsoundoffset + 5;
						bEnableMusicTrack = t.visuals.bEnableCombatMusicTrack;
					}

					// gadgets for managing music track
					if (ImGui::Checkbox(pTextEnable, &bEnableMusicTrack))
					{
						if (iGlobalGameSounds == 0) t.gamevisuals.bEndableAmbientMusicTrack = t.visuals.bEndableAmbientMusicTrack = bEnableMusicTrack;
						if (iGlobalGameSounds == 1) t.gamevisuals.bEnableCombatMusicTrack = t.visuals.bEnableCombatMusicTrack = bEnableMusicTrack;
						if (!bEnableMusicTrack)
						{
							if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
							{
								// stop currently playing preview
								StopSound(iFreeSoundID);
							}
							bTestSound = false;
						}
					}
					if (bEnableMusicTrack || iGlobalGameSounds == 1)
					{
						cstr cMusicTrack = "";
						if (iGlobalGameSounds == 0) cMusicTrack = t.visuals.sAmbientMusicTrack;
						if (iGlobalGameSounds == 1) cMusicTrack = t.visuals.sCombatMusicTrack;
						cstr cNewMusicTrack = imgui_setpropertyfile2_v2(0, cMusicTrack.Get(), pTextTitle, pTextSelect, "audiobank\\", false);
						if (cNewMusicTrack != cMusicTrack)
						{
							if (iGlobalGameSounds == 0)
							{
								t.visuals.sAmbientMusicTrack = cNewMusicTrack;
								t.gamevisuals.sAmbientMusicTrack = t.visuals.sAmbientMusicTrack;
								extern bool entity_copytoremoteifnotthere(LPSTR);
								entity_copytoremoteifnotthere(t.visuals.sAmbientMusicTrack.Get());
							}
							if (iGlobalGameSounds == 1)
							{
								t.visuals.sCombatMusicTrack = cNewMusicTrack;
								t.gamevisuals.sCombatMusicTrack = t.visuals.sCombatMusicTrack;
								extern bool entity_copytoremoteifnotthere(LPSTR);
								entity_copytoremoteifnotthere(t.visuals.sCombatMusicTrack.Get());
							}
							if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
							{
								// stop currently playing preview
								StopSound(iFreeSoundID);
							}
							bTestSound = false;
						}
						int iMusicTrackVolume = 0;
						if (iGlobalGameSounds == 0) iMusicTrackVolume = t.visuals.iAmbientMusicTrackVolume;
						if (iGlobalGameSounds == 1) iMusicTrackVolume = t.visuals.iCombatMusicTrackVolume;
						if (ImGui::MaxSliderInputInt(pTextName, &iMusicTrackVolume, 0, 100, pTextVolume))
						{
							if (iGlobalGameSounds == 0) t.visuals.iAmbientMusicTrackVolume = iMusicTrackVolume;
							if (iGlobalGameSounds == 1) t.visuals.iCombatMusicTrackVolume = iMusicTrackVolume;
							if (iGlobalGameSounds == 0) t.gamevisuals.iAmbientMusicTrackVolume = t.visuals.iAmbientMusicTrackVolume;
							if (iGlobalGameSounds == 1) t.gamevisuals.iCombatMusicTrackVolume = t.visuals.iCombatMusicTrackVolume;
							if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
							{
								SetSoundVolume(iFreeSoundID, iMusicTrackVolume);
							}
						}
						if (cMusicTrack.Len() > 0)
						{
							if (!bTestSound)
							{
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
								if (ImGui::StyleButton(pTextPlay, ImVec2(but_gadget_size, 0)))
								{
									// play music
									if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
									if (FileExist(cMusicTrack.Get()) == 1)
									{
										LoadSound(cMusicTrack.Get(), iFreeSoundID, 0, 1);
										if (SoundExist(iFreeSoundID) == 1)
										{
											SetSoundVolume(iFreeSoundID, iMusicTrackVolume);
											LoopSound(iFreeSoundID);
											bTestSound = true;
										}
									}
								}
							}
							else
							{
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
								if (ImGui::StyleButton(pTextStop, ImVec2(but_gadget_size, 0)))
								{
									if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
									{
										// stop currently playing preview
										StopSound(iFreeSoundID);
									}
									bTestSound = false;
								}
							}
						}
					}
				}
				ImGui::Indent(-10);
			}
		}

		//PE: Filter Effect.
		if (pref.bAutoClosePropertySections && iLastOpenHeader != 10)
			ImGui::SetNextItemOpen(false, ImGuiCond_Always);

		if (ImGui::StyleCollapsingHeader("Filter Effect", wflags))
		{
			ImGui::Indent(10);
			ImGui::BeginChild("##filtereffectchild", ImVec2(ImGui::GetContentRegionAvailWidth(), 500), false, ImGuiWindowFlags_AlwaysVerticalScrollbar);
			iLastOpenHeader = 10;
			static int iFilterThumbnailCount = 0;

			//LUT color grading.
			if (lutImages_s.size() <= 0)
			{
				g_lutimage_item_count = 0;
				cstr oldDir_s = GetDir();
				SetDir(g.fpscrootdir_s.Get());
				SetDir("Files\\editors\\lut");
				ChecklistForFiles();
				std::vector<cstr> fileAnnotates_s;

				for (int f = 1; f <= ChecklistQuantity(); f++)
				{
					cstr tfile_s = ChecklistString(f);
					LPSTR pFilename = tfile_s.Get();
					if (tfile_s != "." && tfile_s != "..")
					{
						if (strnicmp(pFilename + strlen(pFilename) - 4, ".png", 4) == NULL)
						{
							// ZJ: Now get titles from text file, this serves as a backup in case something goes wrong with the file.
							// create a readable title from file
							char pTitleName[256];
							strcpy(pTitleName, pFilename);
							pTitleName[strlen(pTitleName) - 4] = 0;
							for (int n = 0; n < strlen(pTitleName); n++)
							{
								if (n == 0)
								{
									if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z')
										pTitleName[n] -= ('a' - 'A');
								}
								else
								{
									if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z')
										pTitleName[n] += ('a' - 'A');
								}
								if (pTitleName[n] == '_') pTitleName[n] = ' ';
							}

							if (!g_lutimage_items)
							{
								g_lutimage_items = new char*[ChecklistQuantity() + 1];
								//PE: Always add a none.
								lutImages_s.push_back(cstr("None"));
								g_lutimage_items[g_lutimage_item_count] = new char[256];
								strcpy(g_lutimage_items[g_lutimage_item_count], "None");
								g_lutimage_item_count++;
							}
							// add script and title to list
							lutImages_s.push_back(cstr("editors\\lut\\") + tfile_s);
							g_lutimage_items[g_lutimage_item_count] = new char[256];
							strcpy(g_lutimage_items[g_lutimage_item_count], pTitleName);
							g_lutimage_item_count++;
						}

						// Extract lut names from text file.
						if (strcmp(pFilename, "filternames.txt") == NULL)
						{
							if (FileExist(pFilename) == 1)
							{
								OpenToRead(1, pFilename);
								while (FileEnd(1) == 0)
								{
									// Get line by line.
									cstr line_s = ReadString(1);
									if (strlen(line_s.Get()) > 0)
										fileAnnotates_s.push_back(line_s);
								}
								CloseFile(1);
							}
						}
					}
				}

				// Assign the names to the filters.
				if (fileAnnotates_s.size() > 0)
				{
					for (int i = 0; i < fileAnnotates_s.size(); i++)
					{
						if(i < g_lutimage_item_count)
							strcpy(g_lutimage_items[i], fileAnnotates_s[i].Get());
					}
				}

				// Load the thumbnails for the filters, so its easier to see the effect it will have on the scene.
				if (_chdir("thumbnails") == 0)
				{
					//SetDir("thumbnails"); //PE: Standalone do not have this.
					ChecklistForFiles();

					image_setlegacyimageloading(true);
					for (int f = 1; f <= ChecklistQuantity(); f++)
					{
						cstr tfile_s = ChecklistString(f);
						LPSTR pFilename = tfile_s.Get();
						if (tfile_s != "." && tfile_s != "..")
						{
							// Only load .jpg files for the thumbnails.
							if (strnicmp(pFilename + strlen(pFilename) - 4, ".jpg", 4) == NULL)
							{
								LoadImage(pFilename, FILTER_THUMBS + iFilterThumbnailCount);
								if (ImageExist(FILTER_THUMBS + iFilterThumbnailCount))
								{
									iFilterThumbnailCount++;
								}
								else
								{
									// Number of loaded thumbnails must match the number of filters, otherwise they will be mismatched.
									for (int i = FILTER_THUMBS; i < FILTER_THUMBS + iFilterThumbnailCount; i++)
									{
										// Load failed, free any loaded images and display text only.
										if (ImageExist(i))
											DeleteImage(i);
									}
									iFilterThumbnailCount = 0;
								}
							}
						}
					}
					image_setlegacyimageloading(false);
				}
				SetDir(oldDir_s.Get());
			}

			if (master_renderer)
			{
				ImGui::PushItemWidth(-10);
				//PE: Set default selection. if not the correct.
				if (t.visuals.ColorGradingLUT != lutImages_s[current_lutimage_selection])
				{
					for (int l = 0; l < g_lutimage_item_count; l++)
					{
						if (t.visuals.ColorGradingLUT == lutImages_s[l])
						{
							current_lutimage_selection = l;
							break;
						}
					}
				}

				// Thumbnail didn't load, display as text instead.
				if (iFilterThumbnailCount == 0)
				{
					if (ImGui::Combo("##WickedLUTImageCombo", &current_lutimage_selection, g_lutimage_items, g_lutimage_item_count, 20))
					{
						if (current_lutimage_selection == 0)
							t.visuals.bColorGrading = false;
						else
							t.visuals.bColorGrading = true;

						t.gamevisuals.bColorGrading = t.visuals.bColorGrading;

						master_renderer->setColorGradingEnabled(t.visuals.bColorGrading);

						t.visuals.ColorGradingLUT = lutImages_s[current_lutimage_selection].Get();
						t.gamevisuals.ColorGradingLUT = t.visuals.ColorGradingLUT;
						bVisualUpdated = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Filter Effect");
				}
				else
				{
					float fButtonSize = ImGui::GetContentRegionAvailWidth() / 4 - 4.0f;
					int id = 54321;

					ImGui::Columns(4, "##filters", false);

					for (int i = 0; i < iFilterThumbnailCount; i++)
					{
						ImGui::PushID(id++);

						// Move the buttons closer together.
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-10.0f, 0.0f));

						if (current_lutimage_selection == i)
						{
							ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
							ImVec2 padding = { 3.0, 3.0 };
							ImGuiWindow* window = ImGui::GetCurrentWindow();
							const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + padding + ImVec2(fButtonSize, fButtonSize));
							window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.f);
						}

						// Display and handle selection of filter.
						if (ImGui::ImgBtn(i == 0 ? CCP_NONE : i + FILTER_THUMBS, ImVec2(fButtonSize, fButtonSize), ImVec4(0.0f, 0.0f, 0.0f, 0.0f), ImVec4(1.0f, 1.0f, 1.0f, 1.0f),
							ImVec4(0.8f, 0.8f, 0.8f, 0.8f), ImVec4(0.8f, 0.8f, 0.8f, 0.8f)))
						{
							current_lutimage_selection = i;

							if (current_lutimage_selection == 0)
								t.visuals.bColorGrading = false;
							else
								t.visuals.bColorGrading = true;

							t.gamevisuals.bColorGrading = t.visuals.bColorGrading;

							master_renderer->setColorGradingEnabled(t.visuals.bColorGrading);

							t.visuals.ColorGradingLUT = lutImages_s[current_lutimage_selection].Get();
							t.gamevisuals.ColorGradingLUT = t.visuals.ColorGradingLUT;
							bVisualUpdated = true;
						}
					
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(10.0f, -10.0f));

						// Enlarged thumbnail.
						if (ImGui::IsItemHovered())
						{
							ImGui::BeginTooltip();
							ImGui::ImgBtn(i + FILTER_THUMBS, ImVec2(fButtonSize * 2, fButtonSize * 2), ImVec4(0.0f, 0.0f, 0.0f, 0.0f), ImVec4(1.0f, 1.0f, 1.0f, 1.0f),
								ImVec4(0.8f, 0.8f, 0.8f, 0.8f), ImVec4(0.8f, 0.8f, 0.8f, 0.8f));
							ImGui::Text(g_lutimage_items[i]);
							ImGui::EndTooltip();
						}

						ImGui::NextColumn();

						ImGui::PopID();
					}
			
					ImGui::Text("");
					ImGui::Columns(1);
				}		
				ImGui::PopItemWidth();
			}
			ImGui::EndChild();
			ImGui::Indent(-10);
		}

		if (pref.iEnableAdvancedPostProcessing)
		{
			static bool bOCDebug = false;
			static bool bBoxDebug = false;
			static int iHiddenObjects = 0;
			static int iObjects = 0;
			static int iFrustumCulled = 0;
			int iSpot = 0 , iPoint = 0;
			int occ = 0;
			if (bOCDebug && g_iDevToolsOpen >= 1)
			{
				int DrawOccludedObjects(bool bDebug, bool bBox = false, int * bHiddenObjects = nullptr, int* spot = nullptr, int* point = nullptr);
				occ = DrawOccludedObjects(bOCDebug, bBoxDebug, &iHiddenObjects,&iSpot,&iPoint);
			}

#ifdef ADVANCEDCOLORS
			ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]);
#endif

			if (pref.bAutoClosePropertySections && iLastOpenHeader != 16)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			//PE: Optimizing
			if (ImGui::StyleCollapsingHeader("Graphics and Performance", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 16;

				// graphics options mode
				ImGui::PushItemWidth(-10);
				char* current_gfx_mode = "";
				int iGFXMode = iGFXMode = t.visuals.shaderlevels.entities - 1;
				const char* gfx_mode_combo[] = { "Highest (best for quality)", "Custom (tailored)" , "Low (best for performance)" };
				if (iGFXMode == 0) current_gfx_mode = (char*)gfx_mode_combo[0];
				if (iGFXMode == 1) current_gfx_mode = (char*)gfx_mode_combo[1];
				if (iGFXMode == 2) current_gfx_mode = (char*)gfx_mode_combo[2];
				if (ImGui::Combo("##ComboGFX_mode_combo", &iGFXMode, gfx_mode_combo, IM_ARRAYSIZE(gfx_mode_combo)))
				{
					if (iGFXMode == 0) visuals_shaderlevels_setlevel(1, true);
					if (iGFXMode == 1) visuals_shaderlevels_setlevel(3, true);
					if (iGFXMode == 2) visuals_shaderlevels_setlevel(4, true);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose the ideal graphics mode for this level, or set custom settings");
				ImGui::PopItemWidth();

				// optimizations
				extern bool bEnable30FpsAnimations;
				extern bool g_bDelayedShadows;
				extern bool g_bDelayedShadowsLaptop;
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Lower Animation & LUA Speed##Animationsculling", &bEnable30FpsAnimations))
				{
					t.gamevisuals.bEnable30FpsAnimations = t.visuals.bEnable30FpsAnimations = bEnable30FpsAnimations;
					g.projectmodified = 1;

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enabling Lower Animation Speed will lower the updating of animation & LUA to 30 FPS for increased speed when using many animations.");
				ImGui::PopItemWidth();

				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Delayed Shadows##Animationsculling", &g_bDelayedShadows))
				{
					t.gamevisuals.g_bDelayedShadows = t.visuals.g_bDelayedShadows = g_bDelayedShadows;
					g.projectmodified = 1;

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enabling Delayed Shadows will make fewer cascade shadow updates and increase your FPS.");
				if (g_bDelayedShadows)
				{
					ImGui::SameLine();
					if (ImGui::Checkbox("Laptop##Animationsculling", &g_bDelayedShadowsLaptop))
					{
						t.gamevisuals.g_bDelayedShadowsLaptop = t.visuals.g_bDelayedShadowsLaptop = g_bDelayedShadowsLaptop;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enabling Delayed Shadows (Laptop) will make even fever cascade shadow updates and increase your FPS.");
				}
				ImGui::PopItemWidth();


				extern bool bEnableObjectCulling;
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Occlusion Culling##bOcclusionCulling", &t.visuals.bOcclusionCulling))
				{
					t.gamevisuals.bOcclusionCulling = t.visuals.bOcclusionCulling;
					g.projectmodified = 1;
					if (t.visuals.bOcclusionCulling)
					{
						bEnableObjectCulling = true;
						t.gamevisuals.bEnableObjectCulling = t.visuals.bEnableObjectCulling = bEnableObjectCulling;
					}
				}
				if (wiRenderer::GetOcclusionCullingEnabled() != t.visuals.bOcclusionCulling)
				{
					wiRenderer::SetOcclusionCullingEnabled(t.visuals.bOcclusionCulling);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enabling Occlusion Culling will cull objects behind other object for less drawcalls");
				ImGui::PopItemWidth();

				if (g_iDevToolsOpen >= 1)
				{
					ImGui::SameLine();
					ImGui::Checkbox("Debug", &bOCDebug);
					ImGui::Checkbox("Debug Bounding Box", &bBoxDebug);
				}
				if (t.visuals.bOcclusionCulling)
				{
					extern uint32_t iCulledPointShadows;
					extern uint32_t iCulledSpotShadows;
					extern uint32_t iCulledAnimations;
					extern bool bEnableTerrainChunkCulling;
					extern bool bEnablePointShadowCulling;
					extern bool bEnableSpotShadowCulling;
					extern bool bEnableAnimationCulling;

					if (ImGui::Checkbox("Terrain Chunk Culling", &bEnableTerrainChunkCulling))
					{
						t.gamevisuals.bEnableTerrainChunkCulling = t.visuals.bEnableTerrainChunkCulling = bEnableTerrainChunkCulling;
						g.projectmodified = 1;
						if (bEnableTerrainChunkCulling && !t.visuals.bOcclusionCulling)
						{
							t.gamevisuals.bOcclusionCulling = t.visuals.bOcclusionCulling = true;
						}
					}
					//if (bEnableTerrainChunkCulling)
					//{
					//	extern int OCCLODSTART;
					//	ImGui::PushItemWidth(-10);
					//	ImGui::SliderInt("Terrain LOD Culling Start", &OCCLODSTART, 0, 8);
					//	if (ImGui::IsItemHovered()) ImGui::SetTooltip("Terrain Chunk Culling Start LOD Level. For less occlusion check make value higher.");
					//	ImGui::PopItemWidth();
					//}
					if (ImGui::Checkbox("Point Shadow Culling", &bEnablePointShadowCulling))
					{
						t.gamevisuals.bEnablePointShadowCulling = t.visuals.bEnablePointShadowCulling = bEnablePointShadowCulling;
						g.projectmodified = 1;
						if (bEnablePointShadowCulling && !t.visuals.bOcclusionCulling)
						{
							t.gamevisuals.bOcclusionCulling = t.visuals.bOcclusionCulling = true;
						}
					}
					if (ImGui::Checkbox("Spot Shadow Culling", &bEnableSpotShadowCulling))
					{
						t.gamevisuals.bEnableSpotShadowCulling = t.visuals.bEnableSpotShadowCulling = bEnableSpotShadowCulling;
						g.projectmodified = 1;
						if (bEnableSpotShadowCulling && !t.visuals.bOcclusionCulling)
						{
							t.gamevisuals.bOcclusionCulling = t.visuals.bOcclusionCulling = true;
						}
					}

					if (ImGui::Checkbox("Object Culling", &bEnableObjectCulling))
					{
						t.gamevisuals.bEnableObjectCulling = t.visuals.bEnableObjectCulling = bEnableObjectCulling;
						g.projectmodified = 1;
						if (bEnableObjectCulling && !t.visuals.bOcclusionCulling)
						{
							t.gamevisuals.bOcclusionCulling = t.visuals.bOcclusionCulling = true;
						}
					}

					if (ImGui::Checkbox("Animation Culling", &bEnableAnimationCulling))
					{
						t.gamevisuals.bEnableAnimationCulling = t.visuals.bEnableAnimationCulling = bEnableAnimationCulling;
						g.projectmodified = 1;
						if (bEnableAnimationCulling && !t.visuals.bOcclusionCulling)
						{
							t.gamevisuals.bOcclusionCulling = t.visuals.bOcclusionCulling = true;
						}
					}

					wiScene::Scene* pScene = &wiScene::GetScene();
					if (pScene)
					{
						iObjects = pScene->objects.GetCount();
						iFrustumCulled = wiProfiler::GetFrustumCulled();
					}
					if (bOCDebug)
						ImGui::Text("Total Objects: %d Hidden: %d", iObjects, iHiddenObjects);
					else
						ImGui::Text("Total Objects: %d", iObjects);
					ImGui::Text("Frustum/Apparent Culled: %d", iFrustumCulled);
					if (bOCDebug)
						ImGui::Text("Occluded Objects: %d", occ);

					extern uint32_t iOccludedTerrainChunks;
					if (bOCDebug)
						ImGui::Text("Occluded Terrain chunks: %d", iOccludedTerrainChunks);

					extern uint32_t iRenderedPointShadows;
					extern uint32_t iRenderedSpotShadows;

					if (bOCDebug)
						ImGui::Text("Occluded Point Shadows: (%d) %d r(%d)", iPoint, iCulledPointShadows, iRenderedPointShadows);
					else
						ImGui::Text("Occluded Point Shadows: %d r(%d)", iCulledPointShadows, iRenderedPointShadows);
					if (bOCDebug)
						ImGui::Text("Occluded Spot Shadows: (%d) %d r(%d)", iSpot, iCulledSpotShadows, iRenderedSpotShadows);
					else
						ImGui::Text("Occluded Spot Shadows: %d r(%d)", iCulledSpotShadows, iRenderedSpotShadows);
					
					if (bOCDebug)
						ImGui::Text("Culled Animations: %d", iCulledAnimations);
				}

				extern float maxApparentSize;
				ImGui::PushItemWidth(-10);
				float fASize = t.visuals.ApparentSize * 10000.0f;
				tab_tab_Column_text("Apparent Size", fTabColumnWidth);
				if (ImGui::SliderFloat("##maxApparentSize", &fASize, 0.02f, 2.0f, "%.2f", 1.0f))
				{
					maxApparentSize = fASize / 10000.0f;
					t.gamevisuals.ApparentSize = t.visuals.ApparentSize = maxApparentSize;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Max Object Apparent Size will cull objects when they get smaller on screen");
				ImGui::PopItemWidth();


				extern float fLODMultiplier;
				//ImGui::Text("LOD Multiplier");
				tab_tab_Column_text("LOD Multiplier", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::SliderFloat("##fLODMultiplier", &fLODMultiplier, 0.0f, 15.0f, "%.2f", 1.0f))
				{
					if (fLODMultiplier < 0)
						fLODMultiplier = 0;
					t.gamevisuals.fLODMultiplier = t.visuals.fLODMultiplier = fLODMultiplier;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Change LOD distance before switching from normal object to LOD");
				ImGui::PopItemWidth();

				extern int g_iUseLODObjects;
				extern bool bDisableLODLoad;
				ImGui::Checkbox("Disable LOD Load", &bDisableLODLoad);

				if (g_iUseLODObjects > 0 && !bDisableLODLoad)
				{
					extern bool bShadowsLowestLOD;
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Shadows Use Fastest LOD##Animationsculling", &bShadowsLowestLOD))
					{
						t.gamevisuals.bShadowsLowestLOD = t.visuals.bShadowsLowestLOD = bShadowsLowestLOD;
						g.projectmodified = 1;

					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("All shadows will use fastest LOD available to render.");
					ImGui::PopItemWidth();

					extern bool bProbesLowestLOD;
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Probes Use Fastest LOD##Animationsculling", &bProbesLowestLOD))
					{
						t.gamevisuals.bProbesLowestLOD = t.visuals.bProbesLowestLOD = bProbesLowestLOD;
						g.projectmodified = 1;

					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("All probes will use fastest LOD available to render.");
					ImGui::PopItemWidth();

					extern bool bRaycastLowestLOD;
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Raycast Use Fastest LOD##Animationsculling", &bRaycastLowestLOD))
					{
						t.gamevisuals.bRaycastLowestLOD = t.visuals.bRaycastLowestLOD = bRaycastLowestLOD;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("All raycast will use fastest LOD available for intersect checks.");
					ImGui::PopItemWidth();


					extern bool bPhysicsLowestLOD;
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Physics Use Fastest LOD##Animationsculling", &bPhysicsLowestLOD))
					{
						t.gamevisuals.bPhysicsLowestLOD = t.visuals.bPhysicsLowestLOD = bPhysicsLowestLOD;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("All physics objects is created using fastest LOD.");
					ImGui::PopItemWidth();

					extern bool bReflectionsLowestLOD;
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Reflections Use Fastest LOD##Animationsculling", &bReflectionsLowestLOD))
					{
						t.gamevisuals.bReflectionsLowestLOD = t.visuals.bReflectionsLowestLOD = bReflectionsLowestLOD;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("All reflection rendering is using fastest LOD.");
					ImGui::PopItemWidth();
				}

				// FSR Mode (FidelityFX Super Resolution)
				const char* fsr_items_align[] = { "None", "Ultra Quality","Quality", "Balanced", "Performance" };
				int fsr_current_type_selection = t.visuals.iFSRMode;
				tab_tab_Column_text("FSR", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setiFSRMode", &fsr_current_type_selection, fsr_items_align, IM_ARRAYSIZE(fsr_items_align)))
				{
					t.visuals.iFSRMode = fsr_current_type_selection;
					t.gamevisuals.iFSRMode = t.visuals.iFSRMode;
					if (t.visuals.iFSRMode == 1)
					{
						master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
						master.masterrenderer.SetFSRScale(1.3f);
						master.masterrenderer.setFSREnabled(true);
						master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
						master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
						t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
						if (master_renderer)
							master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
					}
					else if (t.visuals.iFSRMode == 2)
					{
						master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
						master.masterrenderer.SetFSRScale(1.5f);
						master.masterrenderer.setFSREnabled(true);
						master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
						master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
						t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
						if (master_renderer)
							master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
					}
					else if (t.visuals.iFSRMode == 3)
					{
						master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
						master.masterrenderer.SetFSRScale(1.7f);
						master.masterrenderer.setFSREnabled(true);
						master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
						master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
						t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
						if (master_renderer)
							master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
					}
					else if (t.visuals.iFSRMode == 4)
					{
						master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
						master.masterrenderer.SetFSRScale(2.0f);
						master.masterrenderer.setFSREnabled(true);
						master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
						master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
						t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
						if (master_renderer)
							master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
					}
					else
					{
						//PE: Disable FSR
						master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
						master.masterrenderer.SetFSRScale(1.0f);
						master.masterrenderer.setFSREnabled(false);
						master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
					}

					//PE: change.
					g.projectmodified = 1;
				}

				ImGui::PopItemWidth();
	
				if (master.masterrenderer.getFSREnabled())
				{
					ImGui::Text("FSR Sharpness");
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##fFSRSharpness", &t.visuals.fFSRSharpness, 0.0f, 2.0f, "%.2f", 1.0f))
					{
						if (t.visuals.fFSRSharpness < 0)
							t.visuals.fFSRSharpness = 0;
						t.gamevisuals.fFSRSharpness = t.visuals.fFSRSharpness;
						master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Change FSR Sharpness");
					ImGui::PopItemWidth();
				}

				// end performance
				ImGui::Indent(-10);
			}

			if (pref.bAutoClosePropertySections && iLastOpenHeader != 8)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Post Processing", wflags))
			{
				ImGui::Indent(10);
				iLastOpenHeader = 8;

				// only show option if not disabled VSYNC in SETUP.INI
				if (g.gvsync != 0)
				{
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("VSync##setVSyncEnabled", &t.visuals.bLevelVSyncEnabled))
					{
						t.gamevisuals.bLevelVSyncEnabled = t.visuals.bLevelVSyncEnabled;
						gridedit_setvsync(t.visuals.bLevelVSyncEnabled);
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enabling Vertical Sync will prevent screen tearing and cap FPS in game to your monitors refresh rate");
					ImGui::PopItemWidth();
				}

				//Bloom
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Bloom Enabled##setBloomEnabled", &t.visuals.bBloomEnabled)) 
				{
					t.gamevisuals.bBloomEnabled = t.visuals.bBloomEnabled;
					if (master_renderer)
						master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Setting Bloom enabled will cause bright objects or locations to appear to emit more light");

				ImGui::PopItemWidth();
				if (master_renderer && master_renderer->getBloomEnabled())
				{
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##WickedsetBloomThreshold", &t.visuals.fsetBloomThreshold, 0.1f, 10.0f, "%.2f", 2.0f))
					{
						t.gamevisuals.fsetBloomThreshold = t.visuals.fsetBloomThreshold;
						if (master_renderer) {
							master_renderer->setBloomThreshold(t.visuals.fsetBloomThreshold);
						}
						//bVisualUpdated = true;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Bloom Threshold is a measure of how bright an object or area must be before the bloom effect is applied");

					if (ImGui::SliderFloat("##WickedsetBloomStrength", &t.visuals.fsetBloomStrength, 0.1f, 3.0f, "%.2f", 1.0f))
					{
						t.gamevisuals.fsetBloomStrength = t.visuals.fsetBloomStrength;
						if (master_renderer) {
							master_renderer->setBloomStrength(t.visuals.fsetBloomStrength);
						}
						//bVisualUpdated = true;
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Bloom Strength is a measure of how strongly the bloom is applied to the scene");

					ImGui::PopItemWidth();
				}

				//tab_tab_Column_text("SSR", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("SSR##setSSREnabled", &t.visuals.bSSREnabled)) {
					t.gamevisuals.bSSREnabled = t.visuals.bSSREnabled;
					if (master_renderer)
						master_renderer->setSSREnabled(t.visuals.bSSREnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Screen Space Reflections use data from lights and objects shown on-screen to produce reflections");

				ImGui::PopItemWidth();

				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Reflections##setReflectionsEnabled", &t.visuals.bReflectionsEnabled)) {
					t.gamevisuals.bReflectionsEnabled = t.visuals.bReflectionsEnabled;
					if (master_renderer)
						master_renderer->setReflectionsEnabled(t.visuals.bReflectionsEnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reflections are calculated by taking data from lights in the scene and determining how they react with the sky and terrain");

				ImGui::PopItemWidth();

				//tab_tab_Column_text("FXAA", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("FXAA##setFXAAEnabled", &t.visuals.bFXAAEnabled)) {
					t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled;
					if (master_renderer)
						master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("FXAA can smooth out edges on-screen that look pixelated, at the cost of a slight blur");
				ImGui::PopItemWidth();

				/*
				//tab_tab_Column_text("Tessellation", fTabColumnWidth);
				//PE: Tessellation dont work, it deform some objects , so cant be used for now. it need to be controlled per mesh.
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Tessellation##setTessellationEnabled", &t.visuals.bTessellation)) {
					t.gamevisuals.bTessellation = t.visuals.bTessellation;
					if (master_renderer)
					{
						wiRenderer::SetTessellationEnabled(t.visuals.bTessellation);
					}
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Increases polygon counts for some objects based on how close they are to the camera");
				ImGui::PopItemWidth();
				*/

				if (!bSetSimpleSky)
				{
					//tab_tab_Column_text("Light Shafts", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::Checkbox("Light Shafts##setLightShaftsEnabled", &t.visuals.bLightShafts)) {
						t.gamevisuals.bLightShafts = t.visuals.bLightShafts;
						if (master_renderer)
							master_renderer->setLightShaftsEnabled(t.visuals.bLightShafts);
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enables light rays to cast from the sun");
					ImGui::PopItemWidth();
				}

				// LB: aded lens flare
				//tab_tab_Column_text("Lens Flare", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Lens Flare##setLensFlareEnabled", &t.visuals.bLensFlare)) 
				{
					t.gamevisuals.bLensFlare = t.visuals.bLensFlare;
					if (master_renderer)
						master_renderer->setLensFlareEnabled(t.visuals.bLensFlare);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enables lens flare from light cast from the sun");
				ImGui::PopItemWidth();

				// LB: added auto-exposure toggle
				//tab_tab_Column_text("Auto Exposure", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Auto Exposure##setAutoExposureEnabled", &t.visuals.bAutoExposure))
				{
					t.gamevisuals.bAutoExposure = t.visuals.bAutoExposure;
					if (master_renderer)
						master_renderer->setEyeAdaptionEnabled(t.visuals.bAutoExposure);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Automatically adjusts the appearance of the light intensity when the brightness of an area changes");
				ImGui::PopItemWidth();

				if (t.visuals.bAutoExposure)
				{
					tab_tab_Column_text("Auto Exp Rate", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##fAutoExpRate:", &t.visuals.fAutoExposureRate, 0.01, 4.0)) {
						t.gamevisuals.fAutoExposureRate = t.visuals.fAutoExposureRate;
						master_renderer->setEyeAdaptionRate(t.visuals.fAutoExposureRate);
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sets how fast the brightness is adjusted");

					tab_tab_Column_text("Auto Exp Level", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##fAutoExpKey:", &t.visuals.fAutoExposureKey, 0.01, 0.5)) {
						t.gamevisuals.fAutoExposureKey = t.visuals.fAutoExposureKey;
						master_renderer->setEyeAdaptionKey(t.visuals.fAutoExposureKey);
						g.projectmodified = 1;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Auto Exposure Level - lower values are darker, higher values are lighter");
				}

				//PE: Added DOF.
				ImGui::PushItemWidth(-10);
				if (ImGui::Checkbox("Depth Of Field (DOF)##DOF", &t.visuals.bDOF)) {
					t.gamevisuals.bDOF = t.visuals.bDOF;
					if (master_renderer)
					{
						if (t.visuals.bDOF)
						{
							wiScene::Scene& scene = wiScene::GetScene();
							wiScene::CameraComponent& camera = wiScene::GetCamera();
							camera.aperture_size = t.visuals.fDOFApertureSize;
							camera.focal_length = t.visuals.fDOFFocalLength;
							master_renderer->setDepthOfFieldStrength(t.visuals.fDOFStrength);
						}
						master_renderer->setDepthOfFieldEnabled(t.visuals.bDOF);
					}
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Depth Of Field (DOF): Is the area of acceptable sharpness in front of and behind the subject which the camera lens is focused.");
				ImGui::PopItemWidth();

				if (t.visuals.bDOF)
				{
					tab_tab_Column_text("DOF Strength", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##DOF Strength", &t.visuals.fDOFStrength, 1.0f, 20.0f))
					{
						t.gamevisuals.fDOFStrength = t.visuals.fDOFStrength;
						if (master_renderer)
							master_renderer->setDepthOfFieldStrength(t.visuals.fDOFStrength);
					}
					ImGui::PopItemWidth();

					tab_tab_Column_text("DOF ApertureSize", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##DOF fDOFApertureSize", &t.visuals.fDOFApertureSize, 0.0f, 1.0f))
					{
						t.gamevisuals.fDOFApertureSize = t.visuals.fDOFApertureSize;
						if (master_renderer)
						{
							wiScene::Scene& scene = wiScene::GetScene();
							wiScene::CameraComponent& camera = wiScene::GetCamera();
							camera.aperture_size = t.visuals.fDOFApertureSize;
							camera.UpdateCamera();
							camera.SetDirty();
						}
					}
					ImGui::PopItemWidth();

					tab_tab_Column_text("DOF Focal Length", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if (ImGui::SliderFloat("##DOF focal_length", &t.visuals.fDOFFocalLength, 0.001f, 800.0f))
					{
						t.gamevisuals.fDOFFocalLength = t.visuals.fDOFFocalLength;
						if (master_renderer)
						{
							wiScene::Scene& scene = wiScene::GetScene();
							wiScene::CameraComponent& camera = wiScene::GetCamera();
							camera.focal_length = t.visuals.fDOFFocalLength;
							camera.UpdateCamera();
							camera.SetDirty();
						}
					}
					ImGui::PopItemWidth();
				}

				tab_tab_Column_text("Gamma", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::SliderFloat("##fGamma:", &t.visuals.fGamma, 0.1, 10.0))
				{
					t.gamevisuals.fGamma = t.visuals.fGamma;
					wiRenderer::SetGamma(t.visuals.fGamma);
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Gamma Correction alters how bright colors are perceived");

				ImGui::PopItemWidth();

				const char* msaa_items_align[] = { "1 (disabled)", "2", "4", "8" };
				int msaa_current_type_selection = 0;
				if (t.visuals.iMSAASampleCount == 1) msaa_current_type_selection = 0;
				else if (t.visuals.iMSAASampleCount == 2) msaa_current_type_selection = 1;
				else if (t.visuals.iMSAASampleCount == 4) msaa_current_type_selection = 2;
				else msaa_current_type_selection = 3;
				tab_tab_Column_text("MSAA", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setMSAASampleCount", &msaa_current_type_selection, msaa_items_align, IM_ARRAYSIZE(msaa_items_align)))
				{
					if (msaa_current_type_selection == 0) t.visuals.iMSAASampleCount = 1;
					else if (msaa_current_type_selection == 1) t.visuals.iMSAASampleCount = 2;
					else if (msaa_current_type_selection == 2) t.visuals.iMSAASampleCount = 4;
					else t.visuals.iMSAASampleCount = 8;
					t.gamevisuals.iMSAASampleCount = t.visuals.iMSAASampleCount;

					if (master_renderer)
					{
						master_renderer->setMSAASampleCount(t.visuals.iMSAASampleCount);
						old_iMSAASampleCount = t.visuals.iMSAASampleCount;
					}
					g.projectmodified = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("MSAA can smooth out edges detected on objects. The higher the number of samples the greater the performance cost");

				ImGui::PopItemWidth();

				// SSAO
				//const char* ao_options[] = { "Disabled", "SSAO", "HBAO", "MSAO", "RTAO" };
				const char* ao_options[] = { "Disabled", "Enabled" };
				tab_tab_Column_text("SSAO", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setAmbientOcclusion", &t.visuals.iMSAO, ao_options, IM_ARRAYSIZE(ao_options)))
				{
					t.gamevisuals.iMSAO = master.iAOSetting = t.visuals.iMSAO;
					//master.masterrenderer.setAO( (RenderPath3D::AO) master.iAOSetting );
					if ( master.iAOSetting > 0 ) master.masterrenderer.setAO( RenderPath3D::AO_MSAO );
					else master.masterrenderer.setAO( RenderPath3D::AO_DISABLED );
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Ambient Occlusion makes objects in corners or holes receive less ambient light");
				ImGui::PopItemWidth();

				if (t.visuals.iMSAO > 0 )
				{
					tab_tab_Column_text("AO Power", fTabColumnWidth);
					ImGui::PushItemWidth(-10);
					if ( ImGui::SliderFloat("##setAmbientOcclusionPower", &t.visuals.fMSAOPower, 0.01f, 8.0f, "%.2f", 2.0f) )
					{
						t.gamevisuals.fMSAOPower = master.fAOPower = t.visuals.fMSAOPower;
						master.masterrenderer.setAOPower( master.fAOPower );
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Ambient Occlusion power (default=1.0)");
					ImGui::PopItemWidth();
				}

				// end post processing
				ImGui::Indent(-10);
			}
			#ifdef ADVANCEDCOLORS
			ImGui::PopStyleColor();
			#endif
		}

		if (pref.iEnableAdvancedShadows)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 9)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always);

			if (ImGui::StyleCollapsingHeader("Shadows", wflags))
			{
				ImGui::Indent(10);

				iLastOpenHeader = 9;

				ImGui::TextCenter( "Shadow Resolution" );
				//PE: Change from 1024 to 4096, adds around 2 gb additional gpu mem ?.
				//PE: See comment about point light below.
				const char* shadow_spot_items_align[] = { "Off", "128", "256", "512", "1024", "2048" }; //, "4096" };
				int shadow_cascade_current_type_selection = 0;
				if (t.visuals.iShadowSpotCascadeResolution == 0) shadow_cascade_current_type_selection = 0;
				else if (t.visuals.iShadowSpotCascadeResolution == 128) shadow_cascade_current_type_selection = 1;
				else if (t.visuals.iShadowSpotCascadeResolution == 256) shadow_cascade_current_type_selection = 2;
				else if (t.visuals.iShadowSpotCascadeResolution == 512) shadow_cascade_current_type_selection = 3;
				else if (t.visuals.iShadowSpotCascadeResolution == 1024) shadow_cascade_current_type_selection = 4;
				else if (t.visuals.iShadowSpotCascadeResolution == 2048) shadow_cascade_current_type_selection = 5;
				else shadow_cascade_current_type_selection = 5; //6;
				tab_tab_Column_text("Sun ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_spotresolution", &shadow_cascade_current_type_selection, shadow_spot_items_align, IM_ARRAYSIZE(shadow_spot_items_align)))
				{
					if (shadow_cascade_current_type_selection == 0) t.visuals.iShadowSpotCascadeResolution = 0;
					else if (shadow_cascade_current_type_selection == 1) t.visuals.iShadowSpotCascadeResolution = 128;
					else if (shadow_cascade_current_type_selection == 2) t.visuals.iShadowSpotCascadeResolution = 256;
					else if (shadow_cascade_current_type_selection == 3) t.visuals.iShadowSpotCascadeResolution = 512;
					else if (shadow_cascade_current_type_selection == 4) t.visuals.iShadowSpotCascadeResolution = 1024;
					else if (shadow_cascade_current_type_selection == 5) t.visuals.iShadowSpotCascadeResolution = 2048;
					else t.visuals.iShadowSpotCascadeResolution = 2048;
					t.gamevisuals.iShadowSpotCascadeResolution = t.visuals.iShadowSpotCascadeResolution;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a shadow quality for sun shadows");
				ImGui::PopItemWidth();


				//SPOT
				//const char* shadow_spot_items_align[] = { "Off", "128", "256", "512", "1024", "2048" }; //, "4096" };
				int shadow_spot_current_type_selection = 0;
				if (t.visuals.iShadowSpotResolution == 0) shadow_spot_current_type_selection = 0;
				else if (t.visuals.iShadowSpotResolution == 128) shadow_spot_current_type_selection = 1;
				else if (t.visuals.iShadowSpotResolution == 256) shadow_spot_current_type_selection = 2;
				else if (t.visuals.iShadowSpotResolution == 512) shadow_spot_current_type_selection = 3;
				else if (t.visuals.iShadowSpotResolution == 1024) shadow_spot_current_type_selection = 4;
				else if (t.visuals.iShadowSpotResolution == 2048) shadow_spot_current_type_selection = 5;
				else shadow_spot_current_type_selection = 5; //6;
				tab_tab_Column_text("Spot Lights ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_spotspotresolution", &shadow_spot_current_type_selection, shadow_spot_items_align, IM_ARRAYSIZE(shadow_spot_items_align)))
				{
					if (shadow_spot_current_type_selection == 0) t.visuals.iShadowSpotResolution = 0;
					else if (shadow_spot_current_type_selection == 1) t.visuals.iShadowSpotResolution = 128;
					else if (shadow_spot_current_type_selection == 2) t.visuals.iShadowSpotResolution = 256;
					else if (shadow_spot_current_type_selection == 3) t.visuals.iShadowSpotResolution = 512;
					else if (shadow_spot_current_type_selection == 4) t.visuals.iShadowSpotResolution = 1024;
					else if (shadow_spot_current_type_selection == 5) t.visuals.iShadowSpotResolution = 2048;
					else t.visuals.iShadowSpotResolution = 2048;
					t.gamevisuals.iShadowSpotResolution = t.visuals.iShadowSpotResolution;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a shadow quality spot lights");
				ImGui::PopItemWidth();


				//PE: This drain memory and make everything very slow, limit to max 2048 for now.
				//PE: 1 point light have 6 * 4096x4096 textures. (BIND_DEPTH_STENCIL) DXGI_FORMAT_R16_TYPELESS (2 bytes per pixel).
				//PE: AND 6 * 4096x4096 textures (BIND_RENDER_TARGET) FORMAT_R16G16B16A16_FLOAT (8 bytes per pixel).
				//PE: So 32mb + 128mb. = 160 mb. per texture = 6 * 160mb = 960 mb. PER point light :(
				//PE: Each point light have 12 4096x4096 textures.
				//PE: On my system with 5 point light, it use around 4gb additional mem, when i set 4096 ?
				//PE: This gets allocated as shared GPU mem, and sure tons of swapping is going on.
				//PE: Latest REPO changed from:	desc.Format = FORMAT_R11G11B10_FLOAT; to: desc.Format = FORMAT_R16G16B16A16_FLOAT; (32bit to 64 bit.)
				//PE: https://github.com/turanszkij/WickedEngine/commit/d27ede94cc76a91ac1a1c9e4393db6460262d120#
				//PE: Perhaps limit to 1024 ? - 2048 = 240 mb. per point light , and 1024 = 60mb.

				const char* shadow_point_items_align[] = { "Off" , "128", "256", "512", "1024", "2048" }; //, "4096" };
				int shadow_point_current_type_selection = 0;
				if (t.visuals.iShadowPointResolution == 0) shadow_point_current_type_selection = 0;
				else if (t.visuals.iShadowPointResolution == 128) shadow_point_current_type_selection = 1;
				else if (t.visuals.iShadowPointResolution == 256) shadow_point_current_type_selection = 2;
				else if (t.visuals.iShadowPointResolution == 512) shadow_point_current_type_selection = 3;
				else if (t.visuals.iShadowPointResolution == 1024) shadow_point_current_type_selection = 4;
				else if (t.visuals.iShadowPointResolution == 2048) shadow_point_current_type_selection = 5;
				else shadow_point_current_type_selection = 5; //6;
				tab_tab_Column_text("Point Lights ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_pointresolution", &shadow_point_current_type_selection, shadow_point_items_align, IM_ARRAYSIZE(shadow_point_items_align)))
				{
					if (shadow_point_current_type_selection == 0) t.visuals.iShadowPointResolution = 0;
					else if (shadow_point_current_type_selection == 1) t.visuals.iShadowPointResolution = 128;
					else if (shadow_point_current_type_selection == 2) t.visuals.iShadowPointResolution = 256;
					else if (shadow_point_current_type_selection == 3) t.visuals.iShadowPointResolution = 512;
					else if (shadow_point_current_type_selection == 4) t.visuals.iShadowPointResolution = 1024;
					else if (shadow_point_current_type_selection == 5) t.visuals.iShadowPointResolution = 2048;
					else t.visuals.iShadowPointResolution = 2048;
					if (t.visuals.iShadowPointResolution > 2048) t.visuals.iShadowPointResolution = 2048;
					t.gamevisuals.iShadowPointResolution = t.visuals.iShadowPointResolution;
					bVisualUpdated = true;
				}

				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose a shadow quality for point lights");
				ImGui::PopItemWidth();

				ImGui::TextCenter( "Shadow Quantity" );
				const char* shadow_spot_max_align[] = { "0", "4", "8", "12", "16" };
				int shadow_cascade_max_current_type_selection = 0;
				if (t.visuals.iShadowSpotMax == 0) shadow_cascade_max_current_type_selection = 0;
				else if (t.visuals.iShadowSpotMax == 4) shadow_cascade_max_current_type_selection = 1;
				else if (t.visuals.iShadowSpotMax == 8) shadow_cascade_max_current_type_selection = 2;
				else if (t.visuals.iShadowSpotMax == 12) shadow_cascade_max_current_type_selection = 3;
				else if (t.visuals.iShadowSpotMax == 16) shadow_cascade_max_current_type_selection = 4;
				tab_tab_Column_text("Spot Lights ", fTabColumnWidth);
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_iShadowSpotMax", &shadow_cascade_max_current_type_selection, shadow_spot_max_align, IM_ARRAYSIZE(shadow_spot_max_align)))
				{
					if (shadow_cascade_max_current_type_selection == 0) t.visuals.iShadowSpotMax = 0;
					else if (shadow_cascade_max_current_type_selection == 1) t.visuals.iShadowSpotMax = 4;
					else if (shadow_cascade_max_current_type_selection == 2) t.visuals.iShadowSpotMax = 8;
					else if (shadow_cascade_max_current_type_selection == 3) t.visuals.iShadowSpotMax = 12;
					else if (shadow_cascade_max_current_type_selection == 4) t.visuals.iShadowSpotMax = 16;
					t.gamevisuals.iShadowSpotMax = t.visuals.iShadowSpotMax;
					bForceRefreshLightCount = true;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose max shadow casters for spot lights");
				ImGui::PopItemWidth();

				int shadow_cascade_point_current_type_selection = 0;
				if (t.visuals.iShadowPointMax == 0) shadow_cascade_point_current_type_selection = 0;
				else if (t.visuals.iShadowPointMax == 4) shadow_cascade_point_current_type_selection = 1;
				else if (t.visuals.iShadowPointMax == 8) shadow_cascade_point_current_type_selection = 2;
				else if (t.visuals.iShadowPointMax == 12) shadow_cascade_point_current_type_selection = 3;
				else if (t.visuals.iShadowPointMax == 16) shadow_cascade_point_current_type_selection = 4;
				tab_tab_Column_text("Point Lights ", fTabColumnWidth);

				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##setshadow_iShadowPointMax", &shadow_cascade_point_current_type_selection, shadow_spot_max_align, IM_ARRAYSIZE(shadow_spot_max_align)))
				{
					if (shadow_cascade_point_current_type_selection == 0) t.visuals.iShadowPointMax = 0;
					else if (shadow_cascade_point_current_type_selection == 1) t.visuals.iShadowPointMax = 4;
					else if (shadow_cascade_point_current_type_selection == 2) t.visuals.iShadowPointMax = 8;
					else if (shadow_cascade_point_current_type_selection == 3) t.visuals.iShadowPointMax = 12;
					else if (shadow_cascade_point_current_type_selection == 4) t.visuals.iShadowPointMax = 16;
					t.gamevisuals.iShadowPointMax = t.visuals.iShadowPointMax;
					bForceRefreshLightCount = true;
					bVisualUpdated = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Choose max shadow casters for point lights.");
				ImGui::PopItemWidth();

				if (ImGui::Checkbox("Transparent shadows", &t.visuals.bTransparentShadows))
				{
					t.gamevisuals.bTransparentShadows = t.visuals.bTransparentShadows;
					bForceRefreshLightCount = true;
					bVisualUpdated = true;
				}
				//ImGui::PopItemWidth(); //PE: This looks wrong, try removing it.

				extern bool bShadowsInFrontTakesPriority;
				ImGui::Checkbox("Front Shadows Priority", &bShadowsInFrontTakesPriority);

				ImGui::Indent(-10);
			}
		}

		// Control all in-game debugging options 
		if (pref.iEnableDeveloperProperties)
		{
			if (pref.bAutoClosePropertySections && iLastOpenHeader != 12)
				ImGui::SetNextItemOpen(false, ImGuiCond_Always); 

			if (ImGui::StyleCollapsingHeader("AI Management", wflags))
			{
				iLastOpenHeader = 12;
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				extern bool g_bShowRecastDetourDebugVisuals;
				if (ImGui::Checkbox("Show Navigation Debug Visuals", &g_bShowRecastDetourDebugVisuals))
				{
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle whether the navigation system debug visuals should be shown");
				ImGui::PopItemWidth();
				
				float but_gadget_size = ImGui::GetFontSize()*10.0;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
				if (ImGui::StyleButton("Edit Behaviors##TabTabEditBehaviors", ImVec2(but_gadget_size, 0)))
				{
					extern bool g_bBehaviorEditorActive;
					g_bBehaviorEditorActive = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Open the Behavior Editor to debug and edit logic live");

				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w * 0.5) - (but_gadget_size * 0.5), 0.0f));
				if (ImGui::StyleButton("View Slowest Logic##TabTabEditBehaviors", ImVec2(but_gadget_size, 0)))
				{
					extern int g_iViewPerformanceTimers;
					g_iViewPerformanceTimers = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Run a live snapshot of the ten slowest behaviours currently running");

				ImGui::Indent(-10);
			}
		}

		if (!bRenderTabTab && !pref.bHideTutorials)
		{
			#ifndef REMOVED_EARLYACCESS
			if (ImGui::StyleCollapsingHeader("Tutorial (this feature is incomplete)", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);
				cstr cShowTutorial = "01 - Getting started";
				char* tutorial_combo_items[] = { "01 - Getting started", "02 - Creating terrain", "03 - Add character and set a path" };
				SmallTutorialVideo(cShowTutorial.Get(), tutorial_combo_items, ARRAYSIZE(tutorial_combo_items), SECTION_VISUALS);
				float but_gadget_size = ImGui::GetFontSize()*12.0;
				float w = ImGui::GetWindowContentRegionWidth() - 20.0;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
				#ifdef INCLUDESTEPBYSTEP
				if (ImGui::StyleButton("View Step by Step Tutorial", ImVec2(but_gadget_size, 0)))
				{
					bHelp_Window = true;
					bHelpVideo_Window = true;
					bSetTutorialSectionLeft = false;
					strcpy(cForceTutorialName, cShowTutorial.Get());
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Start Step by Step Tutorial");
				#endif

				ImGui::Indent(-10);
			}
			#endif
		}

		//Reset
		ImGui::Separator();
		float but_gadget_size = ImGui::GetFontSize()*10.0;
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
		if (ImGui::StyleButton("Reset Visuals##WickedResetVisualsUniqueId", ImVec2(but_gadget_size, 0)))
		{
			int iAction = askBoxCancel("This will delete all your visual changes, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
			if (iAction == 1)
			{
				//Reset
				visuals_resetvalues(false);
				t.gamevisuals = t.visuals;
				bVisualUpdated = true;
			}
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset Visuals to Default Values");

		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));

		if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
		{
			//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
			ImGui::Text("");
			ImGui::Text("");
		}
		ImGui::End();
	}

	// behavior editor
	static int iCountdownToRightShift = 0;
	if (bBehaviorEditor)
	{
		//Make window a floating one for testgame.
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		float window_width = 20 * ImGui::GetFontSize();
		float window_height = 50 * ImGui::GetFontSize();
		if (iPage == 1)
		{
			ImGui::SetNextWindowPos(viewPortPos + ImVec2(viewPortSize.x - window_width - 2.0, 2.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowSize(ImVec2(window_width, viewPortSize.y - 4.0), ImGuiCond_Once); //ImGuiCond_FirstUseEver}
		}
		sWindowName = "Behavior Editor##BehaviorEditorTabTabWindow";
		bNeedImGuiInput = true;

		// start behavior editor window
		extern int iGenralWindowsFlags;
		int winflag = iGenralWindowsFlags;
		winflag |= ImGuiWindowFlags_NoMove;
		winflag |= ImGuiWindowFlags_AlwaysVerticalScrollbar;
		winflag |= ImGuiWindowFlags_AlwaysHorizontalScrollbar;

		//PE: This can crash if you resize window outside main viewport so always use main viewport.
		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImGui::SetNextWindowViewport(viewport->ID);

		ImGui::Begin(sWindowName.Get(), &Visuals_Tools_Window, winflag);
		int wflags = ImGuiTreeNodeFlags_DefaultOpen;

		// Window layout and dimensions
		float fMargin = 15.0f;
		float w = ImGui::GetWindowContentRegionWidth();
		instruction_centerline = fMargin;

		// detect if width changes (need to trigger right shift recalc)
		static float lastw = -1.0f;
		if (w != lastw)
		{
			// update all states with latest rightmost shift
			iCountdownToRightShift = 40;
			lastw = w;
		}
		if (iCountdownToRightShift > 0)
		{
			iCountdownToRightShift--;
			if (iCountdownToRightShift == 0)
			{
				for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
					instruction_state_list[iStateIndex].bRecalcRightMost = true;
			}
		}

		// a little code update behavior list if objects active count changes
		static int iLastActiveObjectCount = 0;
		static int iActiveObjectCount = 0;
		iActiveObjectCount = 0;
		for (int e = 1; e <= g.entityelementlist; e++)
		{
			int entid = t.entityelement[e].bankindex;
			if (entid > 0 && t.entityelement[e].active != 0)
				iActiveObjectCount++;
		}
		if (iActiveObjectCount != iLastActiveObjectCount)
		{
			// allows recently inactivated objects to be marked in real time
			iLastActiveObjectCount = iActiveObjectCount;
			instruction_recreatebehaviorlist = true;
		}

		// choose the object parent script you wish to edit
		bool bIsBehaviorToEditValid = false;
		if (ImGui::StyleCollapsingHeader("Behavior Choice##BehaviorEditor", wflags))
		{
			static int iObjectEditingID;
			static int iObjectCount = 0;
			static int* pObjectRefE = NULL;
			static char** pObjectAIScripts = NULL;
			int iTriggerNewObjectEditing = -1;
			if (instruction_recreatebehaviorlist == true)
			{
				if (iObjectCount > 0)
				{
					for (int e = 1; e <= iObjectCount; e++)
					{
						if (pObjectAIScripts[e - 1])
						{
							delete pObjectAIScripts[e - 1];
							pObjectAIScripts[e - 1] = NULL;
						}
					}
					delete[] pObjectAIScripts;
					delete[] pObjectRefE;
				}
				iObjectCount = 0;
				for (int e = 1; e <= g.entityelementlist; e++)
				{
					int entid = t.entityelement[e].bankindex;
					if (entid > 0 && (t.entityprofile[entid].ismarker == 0 || t.entityprofile[entid].ismarker == 3)) // objects and zones
					{
						// also only list those that would actually perform LUA logic in the loop
						if (t.entityelement[e].plrdist < MAXFREEZEDISTANCE || t.entityelement[e].eleprof.phyalways != 0)
						{
							// skip entities that are inside shops or chests, ect
							if (t.entityelement[e].collected >= 3 && t.entityelement[e].active == 0)
								continue;

							LPSTR pObjectAI = t.entityelement[e].eleprof.aimain_s.Get();
							if (stricmp(pObjectAI, "no_behavior_selected.lua") != NULL)
							{
								iObjectCount++;
							}
						}
					}
				}
				pObjectAIScripts = new char*[iObjectCount];
				pObjectRefE = new int[iObjectCount];
				memset(pObjectAIScripts, 0, iObjectCount * sizeof(char*));
				memset(pObjectRefE, 0, iObjectCount * sizeof(int));
				int iObjectIndex = 0;
				for (int e = 1; e <= g.entityelementlist; e++)
				{
					int entid = t.entityelement[e].bankindex;
					if (entid > 0 && (t.entityprofile[entid].ismarker == 0 || t.entityprofile[entid].ismarker == 3)) // objects and zones
					{
						// skip entities that are inside shops or chests, ect
						if (t.entityelement[e].collected >= 3 && t.entityelement[e].active == 0)
							continue;

						// also only list those that would actually perform LUA logic in the loop
						if (t.entityelement[e].plrdist < MAXFREEZEDISTANCE || t.entityelement[e].eleprof.phyalways != 0)
						{
							LPSTR pThisStatus = "";
							if (t.entityelement[e].active == 0) pThisStatus = " (inactive)";
							LPSTR pObjectAI = t.entityelement[e].eleprof.aimain_s.Get();
							if (stricmp(pObjectAI, "no_behavior_selected.lua") != NULL)
							{
								pObjectAIScripts[iObjectIndex] = new char[256];
								sprintf(pObjectAIScripts[iObjectIndex], "%d : %s%s", e, pObjectAI, pThisStatus);
								pObjectRefE[iObjectIndex] = e;
								iObjectIndex++;
							}
						}
					}
				}
				if (iObjectEditingID > iObjectCount-1) iObjectEditingID = iObjectCount-1;
				iTriggerNewObjectEditing = iObjectEditingID;
				instruction_recreatebehaviorlist = false;
			}
			ImGui::Indent(fMargin);
			char pComboObjectsDisplay[1024];
			sprintf(pComboObjectsDisplay, "##BehaviorEditorScriptCombo");
			ImGui::PushItemWidth(w - 20);
			if (ImGui::Combo(pComboObjectsDisplay, &iObjectEditingID, pObjectAIScripts, iObjectCount))
			{
				iTriggerNewObjectEditing = iObjectEditingID;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose the object to edit its behavior");
			if (iTriggerNewObjectEditing != -1)
			{
				// refresh conditions and actions table
				gridedit_instruction_parseandpopulateinstructions();

				// assign new script to edit
				int iEntityIndex = pObjectRefE[iTriggerNewObjectEditing];// 1 + iTriggerNewObjectEditing;
				LPSTR pObjectAI = t.entityelement[iEntityIndex].eleprof.aimain_s.Get();
				sprintf(instruction_objectscriptbeingedited, "scriptbank\\%s", pObjectAI);
				instruction_objectscriptbeingedited[strlen(instruction_objectscriptbeingedited) - 4] = 0;
				strcat(instruction_objectscriptbeingedited, ".byc");

				// fill in animation list
				gridedit_instruction_populateanimationlist(t.entityelement[iEntityIndex].obj);

				// erase last instruction data (so new can be auto loaded)
				gridedit_deletebehavior();

				// and change which entity element we observe for the debug view
				instruction_running_e = 0;
				if (pObjectAI)
				{
					if (strlen(pObjectAI) > 0)
					{
						instruction_running_e = pObjectRefE[iTriggerNewObjectEditing]; //1 + iTriggerNewObjectEditing;
					}
				}
				instruction_running_index = 0;

				// also update layout as script may have changed!
				iCountdownToRightShift = 10;
			}
			ImGui::PopItemWidth();

			float but_gadget_size = ImGui::GetFontSize()*10.0;
			ImVec2 be_button_pos = ImGui::GetCursorPos() + ImVec2((w * 0.5) - (but_gadget_size * 0.5), 0.0f);
			ImGui::SetCursorPos(be_button_pos);
			if (ImGui::StyleButton("Close Behavior Editor##TabTabCloseBehaviorEditor", ImVec2(but_gadget_size, 0)))
			{
				extern bool g_bBehaviorEditorActive;
				g_bBehaviorEditorActive = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Close the Behavior Editor to return to standard in-game controls");

			ImGui::Indent(-fMargin);
		}
		if (instruction_running_e > 0) bIsBehaviorToEditValid = true;
		if (bIsBehaviorToEditValid == true)
		{
			// which state are we in right now?
			int iCurrentlyInsideState = -1;
			if (instruction_freezewheneditingbehavior == false)
			{
				if (instruction_running_e > 0)
				{
					if (instruction_running_index > 0)
					{
						for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
						{
							sStateNode* pState = &instruction_state_list[iStateIndex];
							if (gridedit_instruction_inthisstate_rec(pState->instruction_root) == true)
							{
								iCurrentlyInsideState = iStateIndex;
								break;
							}
						}
					}
				}
			}

			// go through all states
			instruction_hoveringover = NULL;
			for (int iStateIndex = 0; iStateIndex < instruction_state_list.size(); iStateIndex++)
			{
				// Get state details
				sStateNode* pState = &instruction_state_list[iStateIndex];

				// Format display of state name
				char pStateName[1024];
				strcpy (pStateName, pState->pName);
				if (iStateIndex == iCurrentlyInsideState)
				{
					// in this state now
					strupr(pStateName);
				}

				// Component for this state
				char pStateNameDisplay[1024];
				sprintf(pStateNameDisplay, "%s State##BehaviorEditor", pStateName);
				if (ImGui::StyleCollapsingHeader(pStateNameDisplay, wflags))
				{
					// Flow Chart
					instruction_border = 4.0f;
					instruction_vertical_gap = 10.0f;
					instruction_block_width = ImGui::GetFontSize()*6.0f;
					instruction_block_height = ImGui::GetFontSize()*8.6f;

					// start state panel
					ImGui::Indent(fMargin);

					// calculate required widths from hierarchy
					gridedit_instruction_calculatewidth_rec(pState->instruction_root);

					// can scan state layout and work out rightmost X block (so can shift right) 
					ImVec2 vCursorPos = ImGui::GetCursorPos();
					ImVec2 vTopCenterPos = vCursorPos + ImVec2(instruction_centerline, instruction_vertical_gap);
					if (pState->bRecalcRightMost == true)
					{
						// starts the process of working out right most margin to shift within
						pState->fRightMostX = -99999.0f;
					}
					else
					{
						// a little one to get better position in right panel
						vTopCenterPos.x += 20;
					}

					// go through all intructions for this state
					ImGui::SetCursorPos(vTopCenterPos);
					instruction_centerline_absolutex = ImGui::GetCurrentWindow()->DC.CursorPos.x;
					instruction_furthestcursor = vCursorPos;
					gridedit_instruction_block_rec (pState, vTopCenterPos, pStateName, pState->instruction_root, fMargin, 0);
					ImGui::SetCursorPos(instruction_furthestcursor);

					// once calculated, can keep 'fRightMostX' stored to affect new position of block placement
					if (pState->bRecalcRightMost == true)
						pState->bRecalcRightMost = false;

					// Allow Interupt
					char pAllowInteruptDisplay[1024];
					sprintf(pAllowInteruptDisplay, "Allow Interuptions##BehaviorEditor%s", pStateName);
					ImGui::SetCursorPos(ImVec2(vCursorPos.x, ImGui::GetCursorPos().y));
					if (ImGui::Checkbox(pAllowInteruptDisplay, &pState->bAllowInterupt))
					{
						instruction_freezewheneditingbehavior = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("When this is ticked, the state can be interupted when the object takes damage.");

					// Delete button for state
					float fDeleteButtonWidth = ImGui::GetFontSize()*5.0f;
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(w - fMargin - fDeleteButtonWidth, ImGui::GetCursorPos().y));
					char pDeleteButtonDisplay[1024];
					sprintf(pDeleteButtonDisplay, "Delete State##BehaviorEditor%s", pStateName);
					if (ImGui::Button(pDeleteButtonDisplay, ImVec2(fDeleteButtonWidth, 0)))
					{
						// delete this state
						instruction_deletestate = iStateIndex;
						instruction_freezewheneditingbehavior = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select this to permanently delete this state from the behavior");

					// end state panel
					ImGui::Indent(-fMargin);
				}
			}

			// Behavior management buttons
			if (ImGui::StyleCollapsingHeader("Behavior Management##BehaviorEditor", wflags))
			{
				ImGui::Indent(fMargin);

				float but_gadget_size = ImGui::GetFontSize() * 10.0;
				ImVec2 be_button_pos = ImGui::GetCursorPos() + ImVec2((w * 0.5) - (but_gadget_size * 0.5), 0.0f);
				ImGui::SetCursorPos(be_button_pos);
				if (ImGui::Button("Add New State##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					// Add new state
					instruction_createstate = true;
					strcpy (instruction_newstatename, "");
					instruction_freezewheneditingbehavior = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add a new state to this behavior (will require exiting the level to see updated behavior)");
				be_button_pos = ImGui::GetCursorPos() + ImVec2((w * 0.5) - (but_gadget_size * 0.5), 0.0f);
				ImGui::SetCursorPos(be_button_pos);
				if (ImGui::Button("Update Behavior##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					// Save behavior byte code file
					if (strlen(instruction_objectscriptbeingedited) > 0)
					{
						// save BYC file
						gridedit_savebehavior(instruction_objectscriptbeingedited);

						// the magic - we can trigger this script to reload its BYC data file
						// and resume from its current instruction using the 'iUniqueSignatureCode'
						if (instruction_running_e > 0)
						{
							// quick trigger to 
							LuaSetFunction("UpdateEntityDebugger", 2, 0);
							LuaPushInt(instruction_running_e);
							LuaPushInt(1);
							LuaCall();

							// release any freeze caused by a change/edit o the logic
							instruction_freezewheneditingbehavior = false;
						}
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Save any changes that have been made to this behavior");
				be_button_pos = ImGui::GetCursorPos() + ImVec2((w * 0.5) - (but_gadget_size * 0.5), 0.0f);
				ImGui::SetCursorPos(be_button_pos);
				if (ImGui::Button("Restart Behavior##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					if (instruction_running_e > 0)
					{
						LuaSetFunction("UpdateEntityDebugger", 2, 0);
						LuaPushInt(instruction_running_e);
						LuaPushInt(2);
						LuaCall();
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Restarts the behavior to the first state");
				be_button_pos = ImGui::GetCursorPos() + ImVec2((w * 0.5) - (but_gadget_size * 0.5), 0.0f);
				ImGui::SetCursorPos(be_button_pos);
				if (ImGui::Button("Stop Behavior##BehaviorEditor", ImVec2(but_gadget_size, 0)))
				{
					// freeze so can edit
					instruction_freezewheneditingbehavior = false;
					if (instruction_running_e > 0)
					{
						LuaSetFunction("UpdateEntityDebugger", 2, 0);
						LuaPushInt(instruction_running_e);
						LuaPushInt(3);
						LuaCall();
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Restarts the behavior to the first state");

				ImGui::Indent(-fMargin);
			}
		}

		// solves vertical scroll flicker
		if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
		{
			ImGui::Text("");
			ImGui::Text("");
		}

		// end behavior editor window
		ImGui::End();
	}
	else
	{
		// ensures we update layout each time we enter B.E
		iCountdownToRightShift = 2;
	}

	// if added a new instruction, must regenerate instruction indices
	if (instruction_regenerateinstructionindices == true)
	{
		gridedit_generateuniqueinstructionindices();
		instruction_regenerateinstructionindices = false;
	}

	// create a new state with unique name
	if (instruction_createstate == true)
	{
		// Can create new behvaior state
		ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 8 * ImGui::GetFontSize()), ImGuiCond_Once);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
		cstr sUniqueWinName = cstr("Enter A Name for your New Behavior State##BehaviorEditorNewState");
		ImGui::Begin(sUniqueWinName.Get(), &instruction_createstate, 0);
		ImGui::Indent(10);
		cstr sUniqueInputName = cstr("##Behavior State Name") + cstr(1);
		ImGui::PushItemWidth(-10);
		ImGui::Text("");
		ImGui::Text("Type a name for your new Behavior State and press ENTER:");
		if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0)) ImGui::SetKeyboardFocusHere(0);
		if (ImGui::InputText(sUniqueInputName.Get(), instruction_newstatename, 250, ImGuiInputTextFlags_EnterReturnsTrue))
		{
			// create the new behavior state
			sStateNode state;
			memset(&state, 0, sizeof(state));
			strcpy (state.pName, instruction_newstatename);

			// create new instruction root node for this new state
			state.instruction_root = new sLeafNode();
			memset(state.instruction_root, 0, sizeof(sLeafNode));
			state.instruction_root->iUniqueSignatureCode = rand() % 999999;
			state.instruction_root->iInstructionIndex = -1;
			state.instruction_root->iCondition = 11;
			state.instruction_root->iAction = 11;
			state.bAllowInterupt = true;

			// add to state list
			instruction_state_list.push_back(state);

			// finished here
			instruction_createstate = false;
			strcpy(instruction_newstatename, "");

			// new changes means new instruction indices!
			instruction_regenerateinstructionindices = true;
		}
		ImGui::PopItemWidth();
		ImGui::Indent(-10);
		bImGuiGotFocus = true;
		ImGui::End();
	}

	// if delete state, wait until IMGUI stuff done
	if (instruction_deletestate != -1)
	{
		// delete all the instructions in this state
		sLeafNode* pThis = instruction_state_list[instruction_deletestate].instruction_root;
		gridedit_deletebehaviornodes_rec(pThis);

		// delete the state itself
		instruction_state_list.erase(instruction_state_list.begin() + instruction_deletestate);
		instruction_deletestate = -1;

		// new changes means new instruction indices!
		instruction_regenerateinstructionindices = true;
	}

	// if delete an instruction, do it outside of recursion
	if (instruction_deletethis)
	{
		// record relationship ptrs and delete
		sLeafNode* pParentInstruction = instruction_deletethis->pParent;
		sLeafNode* pNextAlso = instruction_deletethis->pAlso;
		sLeafNode* pNextElse = instruction_deletethis->pElse;

		// a little protection, you cannot delete an instruction that has BOTH ALSE and ELSE!! Or the last instruction in a state.
		if ((pNextAlso && pNextElse) || (pParentInstruction==NULL && pNextAlso==NULL && pNextElse ==NULL) )
		{
			// reason is, where does the other instruction chain go - not showing
			// end now, no delete today!
			instruction_deletethis = NULL;
		}
		else
		{
			// next instruction after one we deleted
			sLeafNode* pNextInstruction = pNextAlso;
			if (pNextInstruction == NULL) pNextInstruction = pNextElse;

			// reconstruct parent ref and sibling refs
			if (pParentInstruction)
			{
				if (pParentInstruction->pAlso == instruction_deletethis)
				{
					// parent also ref
					pParentInstruction->pAlso = pNextInstruction;
					if (pNextInstruction) pNextInstruction->pParent = pParentInstruction;
				}
				if (pParentInstruction->pElse == instruction_deletethis)
				{
					// parent else ref
					pParentInstruction->pElse = pNextInstruction;
					if (pNextInstruction) pNextInstruction->pParent = pParentInstruction;
				}
			}
			else
			{
				// new parent
				instruction_deleteinthisstate->instruction_root = pNextInstruction;
				instruction_deleteinthisstate->instruction_root->pParent = NULL;
			}

			// finally delete it
			delete instruction_deletethis;
			instruction_deletethis = NULL;
			instruction_deleteinthisstate = NULL;
		}
	}

	// when in instruction pcik mode, wait for a click
	if (instruction_pickaninstruction != NULL)
	{
		ImGuiIO& io = ImGui::GetIO();
		if (io.MouseDown[0] != 0)
		{
			if (instruction_hoveringover && instruction_pickaninstruction)
			{
				// selected an instruction
				sLeafNode* pChosenInstruction = instruction_hoveringover;
				if (instruction_pickstateorinstruction == 1)
				{
					// the root of this state
					sLeafNode* pFindRoot = pChosenInstruction;
					int iStateIndex = pFindRoot->iState;
					while (pFindRoot && pFindRoot->pParent && pFindRoot->pParent->iState == iStateIndex) pFindRoot = pFindRoot->pParent;
					instruction_pickaninstruction->pGoToInstruction = pFindRoot;

					// and add name to action param so user can see state being switched to in UI
					int iDestinationStateIndex = pChosenInstruction->iState - 1;
					strcpy (instruction_pickaninstruction->pActionParam1, instruction_state_list[iDestinationStateIndex].pName);
				}
				if (instruction_pickstateorinstruction == 2)
				{
					// a specific instruction
					instruction_pickaninstruction->pGoToInstruction = pChosenInstruction;
					strcpy (instruction_pickaninstruction->pActionParam1, "");
				}
			}
			instruction_pickaninstruction = NULL;
			instruction_pickstateorinstruction = 0;
		}
	}

	// states have at leat one instruction
	if (instruction_state_list.size() == 0)
	{
		if (strlen(instruction_objectscriptbeingedited) > 0)
		{
			// test load template behavior, will change as we PICK objects to edit
			gridedit_loadbehavior(instruction_objectscriptbeingedited);
		}
	}

	if (bVisualUpdated)
	{
		// visuals have been updated, inform wicked engine and mark level has modified
		Wicked_Update_Visuals((void *)&t.visuals);
		g.projectmodified = 1;
	}
}

void Wicked_Update_Shadows(void *voidvisual)
{
	extern int spot_lights_count;
	extern int point_lights_count;

	visualstype* visuals = (visualstype *)voidvisual;
	if (visuals == NULL) visuals = &t.visuals;

	static int total_active_2d_shadows = -1;

	bool bTransparentChanged = false;
	static bool bOldTransparent = false;
	wiRenderer::SetTransparentShadowsEnabled(visuals->bTransparentShadows);
	if (bOldTransparent != visuals->bTransparentShadows)
	{
		bOldTransparent = visuals->bTransparentShadows;
		bTransparentChanged = true;
	}

	if (old_iShadowSpotCascadeResolution != visuals->iShadowSpotCascadeResolution || bTransparentChanged )
	{
		char debug[256];
		sprintf(debug, "wiRenderer::SetShadowProps2D: 5");
		timestampactivity(0, debug);
		if (visuals->iShadowSpotCascadeResolution > 2048) visuals->iShadowSpotCascadeResolution = 2048;
		old_iShadowSpotCascadeResolution = visuals->iShadowSpotCascadeResolution;
		if(visuals->iShadowSpotCascadeResolution == 0)
			wiRenderer::SetShadowProps2D(visuals->iShadowSpotCascadeResolution, 0 ); //cascade only now.
		else
			wiRenderer::SetShadowProps2D(visuals->iShadowSpotCascadeResolution, 5); //cascade only now.
	}


	int shadows = spot_lights_count;
	if (shadows <= 2) shadows = 2;
	else if (shadows <= 4) shadows = 4;
	else if (shadows <= 8) shadows = 8;
	else if (shadows <= 12) shadows = 12;
	else if (shadows <= 16) shadows = 16;
	if (shadows > visuals->iShadowSpotMax) shadows = visuals->iShadowSpotMax;
	
	if (old_iShadowSpotResolution != visuals->iShadowSpotResolution || shadows > total_active_2d_shadows || (bForceRefreshLightCount && shadows != total_active_2d_shadows) || bTransparentChanged)
	{
		char debug[256];
		sprintf(debug, "wiRenderer::SetShadowPropsSpot2D: %d", shadows);
		timestampactivity(0, debug);
		total_active_2d_shadows = shadows;
		if (visuals->iShadowSpotResolution > 2048) visuals->iShadowSpotResolution = 2048;
		old_iShadowSpotResolution = visuals->iShadowSpotResolution;
		if(visuals->iShadowSpotResolution == 0 || visuals->iShadowSpotMax == 0 )
			wiRenderer::SetShadowPropsSpot2D(visuals->iShadowSpotResolution, 0);//soft shadow removed from here , -1);
		else
			wiRenderer::SetShadowPropsSpot2D(visuals->iShadowSpotResolution, total_active_2d_shadows);//soft shadow removed from here , -1);
	}

	//PE: MEM - 1546 : END SetShadowProps2D                                     S:529MB V: (4157,0)     
	static int total_active_cube_shadows = -1;
	int shadowscube = point_lights_count;
	if (shadowscube <= 2) shadowscube = 2;
	else if (shadowscube <= 4) shadowscube = 4;
	else if (shadowscube <= 8) shadowscube = 8;
	else if (shadowscube <= 12) shadowscube = 12;
	else if (shadowscube <= 16) shadowscube = 16;

	//LB: Increased cap in Wicked to SIXTEEN as hitting issues on even small interior levels, lets see what the fall out is
	//if (shadowscube > 5) shadowscube = 5;
	if (shadowscube > visuals->iShadowPointMax) shadowscube = visuals->iShadowPointMax;
	
	if (old_iShadowPointResolution != visuals->iShadowPointResolution || shadowscube > total_active_cube_shadows || (bForceRefreshLightCount && shadowscube != total_active_cube_shadows ) || bTransparentChanged )
	{
		bForceRefreshLightCount = false;
		char debug[256];
		sprintf(debug, "wiRenderer::SetShadowPropsCube: %d", shadowscube);
		timestampactivity(0, debug);
		total_active_cube_shadows = shadowscube;
		if (visuals->iShadowPointResolution > 2048) visuals->iShadowPointResolution = 2048;
		old_iShadowPointResolution = visuals->iShadowPointResolution;
		if(visuals->iShadowPointResolution == 0 || visuals->iShadowPointMax == 0)
			wiRenderer::SetShadowPropsCube(visuals->iShadowPointResolution, 0);
		else
			wiRenderer::SetShadowPropsCube(visuals->iShadowPointResolution, total_active_cube_shadows);
	}

	if(bForceRefreshLightCount) bForceRefreshLightCount = false;

	//PE: MEM - 1556 : END SetShadowPropsCube                                   S : 360MB V : (4518, 0)
}

void Wicked_Update_Fog(void* visual)
{
	visualstype* visuals = (visualstype *)visual;
	wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
	if (weather)
	{
		weather->fogStart = visuals->FogNearest_f;
		weather->fogEnd = visuals->FogDistance_f;
		weather->fogColorAndOpacity.x = visuals->FogR_f / 255.0f;
		weather->fogColorAndOpacity.y = visuals->FogG_f / 255.0f;
		weather->fogColorAndOpacity.z = visuals->FogB_f / 255.0f;
		weather->fogColorAndOpacity.w = visuals->FogA_f;
		weather->horizon.x = visuals->FogR_f / 255.0f;
		weather->horizon.y = visuals->FogG_f / 255.0f;
		weather->horizon.z = visuals->FogB_f / 255.0f;
	}
}

void Wicked_Update_LightColors(void* visual)
{
	visualstype* visuals = (visualstype *)visual;
	wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);

	if (weather)
	{
		weather->ambient.x = visuals->AmbienceRed_f / 255.0;
		weather->ambient.y = visuals->AmbienceGreen_f / 255.0;
		weather->ambient.z = visuals->AmbienceBlue_f / 255.0;
		weather->zenith.x = visuals->ZenithRed_f / 255.0f;
		weather->zenith.y = visuals->ZenithGreen_f / 255.0f;
		weather->zenith.z = visuals->ZenithBlue_f / 255.0f;
	}
	WickedCall_SetSunColors(visuals->SunRed_f / 255.0, visuals->SunGreen_f / 255.0, visuals->SunBlue_f / 255.0, visuals->SunIntensity_f, 1.0f, t.visuals.fSunShadowBias);
}

void Wicked_Update_Visuals(void *voidvisual)
{
	visualstype* visuals = (visualstype *) voidvisual;
	wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
	if (weather)
	{
		weather->ambient.x = visuals->AmbienceRed_f / 255.0;
		weather->ambient.y = visuals->AmbienceGreen_f / 255.0;
		weather->ambient.z = visuals->AmbienceBlue_f / 255.0;
		weather->fogStart = visuals->FogNearest_f;
		weather->fogEnd = visuals->FogDistance_f;
		//weather->fogHeight = visuals->FogA_f; // mergecheck: field no longer present
		weather->fogColorAndOpacity.x = visuals->FogR_f / 255.0f;
		weather->fogColorAndOpacity.y = visuals->FogG_f / 255.0f;
		weather->fogColorAndOpacity.z = visuals->FogB_f / 255.0f;
		weather->fogColorAndOpacity.w = visuals->FogA_f;
		weather->horizon.x = visuals->FogR_f / 255.0f;
		weather->horizon.y = visuals->FogG_f / 255.0f;
		weather->horizon.z = visuals->FogB_f / 255.0f;
		weather->zenith.x = visuals->ZenithRed_f / 255.0f;
		weather->zenith.y = visuals->ZenithGreen_f / 255.0f;
		weather->zenith.z = visuals->ZenithBlue_f / 255.0f;
		weather->cloudScale = visuals->SkyCloudHeight;

		if (visuals->bDisableSkybox)
		{
			weather->cloudiness = 0.0f;
			weather->cloudSpeed = 0.0f;
			weather->volumetricCloudParameters.CoverageAmount = 0.0f;
			weather->volumetricCloudParameters.CoverageMinimum = 0.0f;
			weather->volumetricCloudParameters.WindSpeed = 0.0f;
			weather->SetRealisticSky(false);
			weather->SetVolumetricClouds(false);
			//weather->SetSimpleSky(false);
		}
		else if (visuals->skyindex == 0)
		{
			weather->cloudiness = visuals->SkyCloudiness;
			weather->cloudSpeed = visuals->SkyCloudSpeed;
			weather->volumetricCloudParameters.CloudStartHeight = GGTerrain_UnitsToMeters( visuals->SkyCloudHeight );
			weather->volumetricCloudParameters.CoverageAmount = visuals->SkyCloudiness;
			weather->volumetricCloudParameters.CoverageMinimum = visuals->SkyCloudCoverage;
			weather->volumetricCloudParameters.CloudThickness = GGTerrain_UnitsToMeters( visuals->SkyCloudThickness );
			weather->volumetricCloudParameters.WindSpeed = visuals->SkyCloudSpeed;
			weather->volumetricCloudParameters.CoverageWindSpeed = visuals->SkyCloudSpeed;
			weather->SetRealisticSky(true);
			weather->SetVolumetricClouds(true);
		}
		else
		{
			weather->cloudiness = 0.0f; //PE: This has changed in the new repo, same shader is now used and cloudiness turn it off, so must now be zero.
			weather->cloudSpeed = 0.0f; //To stop moving lightshaft.
			//PE: Also disable volumetricCloud.
			weather->volumetricCloudParameters.CoverageAmount = 0.0f;
			weather->volumetricCloudParameters.CoverageMinimum = 0.0f;
			weather->volumetricCloudParameters.WindSpeed = 0.0f;
			weather->SetRealisticSky(false);
			weather->SetVolumetricClouds(false);
		}

		weather->pp_voxel_steps = visuals->voxel_steps;
		weather->windDirection = XMFLOAT3(visuals->wind_direction_x, visuals->wind_direction_y, visuals->wind_direction_z);
		weather->windSpeed = visuals->wind_speed;
		weather->windWaveSize = visuals->pp_size;
		weather->pp_alpha = visuals->pp_alpha;
		weather->windRandomness = visuals->wind_randomness;

		if (t.game.set.ismapeditormode != 1)
			weather->SetPPSnowEnabled(visuals->bPPSnow);
		else if (bEnableWeather)
			weather->SetPPSnowEnabled(visuals->bPPSnow);
		else
			weather->SetPPSnowEnabled(false);

		// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
		bool bWaterEnabled;
		if(t.game.set.ismapeditormode == 1)
			bWaterEnabled = t.showeditorwater;
		else
			bWaterEnabled = visuals->bWaterEnable;

		//if (t.interactive.testgameused == 1 || t.game.gameisexe == 1)
		//	bWaterEnabled = visuals->bWaterEnable;
		//else
		//	bWaterEnabled = t.showeditorwater;

		if (bWaterEnabled)
		{
			weather->SetOceanEnabled(true);
			weather->oceanParameters.waterHeight = g.gdefaultwaterheight;
			//XMFLOAT3 waterColor = XMFLOAT3(visuals->WaterRed_f / 255.0f, visuals->WaterGreen_f / 255.0f, visuals->WaterBlue_f / 255.0f); // LB seems to tame water color with latest Wicked Engine
			XMFLOAT4 waterColor = XMFLOAT4(visuals->WaterRed_f / 255.0f, visuals->WaterGreen_f / 255.0f, visuals->WaterBlue_f / 255.0f, visuals->WaterAlpha_f / 255.0f);
			weather->oceanParameters.waterColor = waterColor;
			weather->oceanParameters.time_scale = visuals->WaterSpeed1;
			weather->oceanParameters.patch_length = visuals->fWaterPatchLength;
			weather->oceanParameters.choppy_scale = visuals->fWaterChoppyScale;
			weather->oceanParameters.wave_amplitude = visuals->fWaterWaveAmplitude;
			//weather->oceanParameters.wind_speed = visuals->WaterFlowSpeed;
			weather->oceanParameters.wind_dependency = visuals->fWaterWindDependency;
			//weather->oceanParameters.wind_dir.x = acos( visuals->WaterFlowDirectionX * PI / 180.0f );
			//weather->oceanParameters.wind_dir.y = asin( visuals->WaterFlowDirectionX * PI / 180.0f );

			weather->oceanParameters.fogMaxDist = visuals->WaterFogMaxDist;
			weather->oceanParameters.fogMinDist = visuals->WaterFogMinDist;
			weather->oceanParameters.fogMinAmount = visuals->WaterFogMinAmount;

			wiScene::GetScene().ocean = {};
		}
		else
		{
			weather->oceanParameters.waterHeight = g.gdefaultwaterheight; //PE: Pauls shader need this set.
			weather->SetOceanEnabled(false);
		}
		
		//weather->skyIntensity = visuals->SkyIntensity_f;
	}

	WickedCall_SetSunColors(visuals->SunRed_f / 255.0, visuals->SunGreen_f / 255.0, visuals->SunBlue_f / 255.0, visuals->SunIntensity_f, 1.0f, t.visuals.fSunShadowBias);
	WickedCall_SetSunDirection(visuals->SunAngleX, visuals->SunAngleY, visuals->SunAngleZ);

	//
	if (master_renderer) 
	{
		#ifdef POSTPROCESSSNOW
		if (bImGuiInTestGame == true)
		{
			master_renderer->setSnowEnabled(visuals->bSnowEnabled);
		}
		else
		{
			if (bEnableWeather)
				master_renderer->setSnowEnabled(visuals->bSnowEnabled);
			else
				master_renderer->setSnowEnabled(false);
		}
		master_renderer->setSnowLayers(visuals->fSnowLayers);
		master_renderer->setSnowDepth(visuals->fSnowDepth);
		master_renderer->setSnowWindiness(visuals->fSnowWind);
		//master_renderer->setSnowSpeed(visuals->fSnowSpeed); //PE: Now controlled by offset.
		master_renderer->setSnowOpacity(visuals->fSnowOpacity);
		#endif

		#ifdef POSTPROCESSRAIN
		if (bImGuiInTestGame == true)
		{
			master_renderer->setRainEnabled(visuals->bRainEnabled);
		}
		else
		{
			if(bEnableWeather)
				master_renderer->setRainEnabled(visuals->bRainEnabled);
			else
				master_renderer->setRainEnabled(false);
		}
		master_renderer->setRainOpacity(visuals->fRainOpacity);
		master_renderer->setRainScaleX(visuals->fRainScaleX);
		master_renderer->setRainScaleY(visuals->fRainScaleY);
		master_renderer->setRainRefreactionScale(visuals->fRainRefreactionScale);
		#endif

		std::shared_ptr<wiResource> image = NULL;
		master_renderer->setColorGradingEnabled(visuals->bColorGrading);
		if (master_renderer->getColorGradingEnabled())
		{
			weather->colorGradingMapName = visuals->ColorGradingLUT.Get();
			weather->colorGradingMap = wiResourceManager::Load(visuals->ColorGradingLUT.Get(), wiResourceManager::IMPORT_COLORGRADINGLUT);
		}

		master.bVsyncEnabled = visuals->bLevelVSyncEnabled;
		if (g.gvsync == 0)
		{
			// VSYNC override to switch OFF the VSYNC (each level can control on/off of the VSYNC in MAX)
			master.bVsyncEnabled = false;
		}
		gridedit_setvsync(master.bVsyncEnabled);

		master_renderer->setBloomEnabled(visuals->bBloomEnabled);
		master_renderer->setBloomThreshold(visuals->fsetBloomThreshold);
		master_renderer->setBloomStrength(visuals->fsetBloomStrength);
		master_renderer->setSSREnabled(visuals->bSSREnabled);
		master_renderer->setReflectionsEnabled(visuals->bReflectionsEnabled);
		master_renderer->setFXAAEnabled(visuals->bFXAAEnabled);
		wiRenderer::SetOcclusionCullingEnabled(visuals->bOcclusionCulling);
		

		master_renderer->setDepthOfFieldEnabled(visuals->bDOF);
		if (visuals->bDOF)
		{
			wiScene::Scene& scene = wiScene::GetScene();
			wiScene::CameraComponent& camera = wiScene::GetCamera();
			camera.aperture_size = visuals->fDOFApertureSize;
			camera.focal_length = visuals->fDOFFocalLength;
			master_renderer->setDepthOfFieldStrength(visuals->fDOFStrength);
		}


		if (visuals->ApparentSize < 0.000001f)
			visuals->ApparentSize = 0.000001f;
		if (visuals->ApparentSize > 0.2f)
			visuals->ApparentSize = 0.2f;

		extern float maxApparentSize;
		maxApparentSize = visuals->ApparentSize;

		extern bool bEnableTerrainChunkCulling;
		bEnableTerrainChunkCulling = visuals->bEnableTerrainChunkCulling;
		extern bool bEnablePointShadowCulling;
		bEnablePointShadowCulling = visuals->bEnablePointShadowCulling;
		extern bool bEnableSpotShadowCulling;
		bEnableSpotShadowCulling = visuals->bEnableSpotShadowCulling;
		extern bool bEnableObjectCulling;
		bEnableObjectCulling = visuals->bEnableObjectCulling;
		extern bool bEnableAnimationCulling;
		bEnableAnimationCulling = visuals->bEnableAnimationCulling;
		extern float fLODMultiplier;
		fLODMultiplier = visuals->fLODMultiplier;

		extern bool bEnable30FpsAnimations;
		bEnable30FpsAnimations = visuals->bEnable30FpsAnimations;
		extern bool g_bDelayedShadows;
		g_bDelayedShadows = visuals->g_bDelayedShadows;
		extern bool g_bDelayedShadowsLaptop;
		g_bDelayedShadowsLaptop = visuals->g_bDelayedShadowsLaptop;

		extern bool bShadowsLowestLOD;
		extern bool bProbesLowestLOD;
		extern bool bRaycastLowestLOD;
		extern bool bPhysicsLowestLOD;
		extern bool bReflectionsLowestLOD;

		bShadowsLowestLOD = visuals->bShadowsLowestLOD;
		bProbesLowestLOD = visuals->bProbesLowestLOD;
		bRaycastLowestLOD = visuals->bRaycastLowestLOD;
		bPhysicsLowestLOD = visuals->bPhysicsLowestLOD;
		bReflectionsLowestLOD = visuals->bReflectionsLowestLOD;

		extern bool bThreadedPhysics;
		bThreadedPhysics = visuals->bThreadedPhysics;
		
		// when in editor, keep enforcing a fixed exposure value (so we dont see fade-ins all the time)
		if (t.game.set.ismapeditormode==0 || pref.iEnableAutoExposureInEditor )
			master_renderer->setEyeAdaptionEnabled(visuals->bAutoExposure);
		else
			master_renderer->setEyeAdaptionEnabled(false);

		master_renderer->setEyeAdaptionRate(visuals->fAutoExposureRate);
		master_renderer->setEyeAdaptionKey(visuals->fAutoExposureKey);
		master_renderer->setExposure(visuals->fExposure);

		//master_renderer->setTessellationEnabled(visuals->bTessellation); moved to renderer
		//wiRenderer::SetTessellationEnabled(visuals->bTessellation);  //PE: Tessellation dont work like this it has to be set per mesh, so have never worked.
		//PE: Still need a way to disable light shafts :)
		master_renderer->setLightShaftsEnabled(visuals->bLightShafts);
		//LB: master_renderer->setLightShaftValues(visuals->lightShaftDensity, visuals->lightShaftWeight, visuals->lightShaftDecay, visuals->lightShaftExposure);

		master_renderer->setLensFlareEnabled(visuals->bLensFlare);
		
		if (old_iMSAASampleCount != visuals->iMSAASampleCount) {
			//PE: Will also resize buffers , so only when needed.
			old_iMSAASampleCount = visuals->iMSAASampleCount;
			master_renderer->setMSAASampleCount(visuals->iMSAASampleCount);
		}
		
		//PE: FSR can't work with VR as it use the openXR resolution, for VR another way is needed.
		extern bool	m_bUsingVR;
		if (!m_bUsingVR)
		{
			if (old_iFSRMode != visuals->iFSRMode) {
				old_iFSRMode = visuals->iFSRMode;
				if (visuals->iFSRMode == 1)
				{
					master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
					master.masterrenderer.SetFSRScale(1.3f);
					master.masterrenderer.setFSREnabled(true);
					master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
					master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
					t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
					if (master_renderer)
						master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
				}
				else if (visuals->iFSRMode == 2)
				{
					master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
					master.masterrenderer.SetFSRScale(1.5f);
					master.masterrenderer.setFSREnabled(true);
					master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
					master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
					t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
					if (master_renderer)
						master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
				}
				else if (visuals->iFSRMode == 3)
				{
					master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
					master.masterrenderer.SetFSRScale(1.7f);
					master.masterrenderer.setFSREnabled(true);
					master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
					master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
					t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
					if (master_renderer)
						master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
				}
				else if (visuals->iFSRMode == 4)
				{
					master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
					master.masterrenderer.SetFSRScale(2.0f);
					master.masterrenderer.setFSREnabled(true);
					master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
					master.masterrenderer.setFSRSharpness(t.visuals.fFSRSharpness);
					t.gamevisuals.bFXAAEnabled = t.visuals.bFXAAEnabled = true; //PE: need FXAA or FSR dont work.
					if (master_renderer)
						master_renderer->setFXAAEnabled(t.visuals.bFXAAEnabled);
				}
				else
				{
					//PE: Disable FSR
					master.masterrenderer.Set3DResolution(master.masterrenderer.GetPhysicalWidth(), master.masterrenderer.GetPhysicalHeight(), false);
					master.masterrenderer.SetFSRScale(1.0f);
					master.masterrenderer.setFSREnabled(false);
					master.masterrenderer.ResizeBuffers(); //PE: Force resizebuffers.
				}

			}
		}

		if (old_iMSAO != visuals->iMSAO || old_fMSAOPower != visuals->fMSAOPower)
		{
			master.fAOPower = old_fMSAOPower = visuals->fMSAOPower;
			master.iAOSetting = old_iMSAO = visuals->iMSAO;
			if (master.iAOSetting > 0) master.masterrenderer.setAO(RenderPath3D::AO_MSAO);
			else master.masterrenderer.setAO(RenderPath3D::AO_DISABLED);
			if (master.iAOSetting > 0) master.masterrenderer.setAOPower(master.fAOPower);
		}

		Wicked_Update_Shadows(visuals);
	}

	extern float fWickedMaxCenterTest;
	if (visuals->CameraFAR_f < 70000.0 && visuals->CameraFAR_f < visuals->fShadowFarPlane)
		fWickedMaxCenterTest = 1500000.0;
	else if (visuals->CameraFAR_f < 250000.0 && visuals->CameraFAR_f < visuals->fShadowFarPlane)
		fWickedMaxCenterTest = 1000000.0;
	else if (visuals->CameraFAR_f < 300000.0 && visuals->CameraFAR_f < visuals->fShadowFarPlane)
		fWickedMaxCenterTest = 500000.0;
	else
		fWickedMaxCenterTest = 0.0; //PE: 0.0=Auto adjust min max z for orthographic shadow matrix, auto dont really work when CameraFAR_f < fShadowFarPlane ?

	WickedCall_SetShadowRange(visuals->fShadowFarPlane);

	// when in editor mode, separate control of gamma
	extern float g_fGlobalGammaFadeIn;
	extern float g_fGlobalGammaFadeInDest;
	if (bImGuiInTestGame == false && t.game.gameisexe == 0)
	{
		//leave editor to call setgamma
	}
	else
	{
		wiRenderer::SetGamma(visuals->fGamma);
		g_fGlobalGammaFadeIn = visuals->fGamma;
	}
	g_fGlobalGammaFadeInDest = visuals->fGamma;

	float fUsedFOV = visuals->CameraFOV_f;
	if (bImGuiInTestGame == false) fUsedFOV = 45;
	float fCameraFov = XM_PI / (fUsedFOV / 15.0f); //Fit GG settings.
	if (bImGuiInTestGame == true)
	{
		//PE: Visual change also need reerse fov in test game and standalone.
		// when in game, weapon FOV correction
		fCameraFov = GGToRadian(fUsedFOV); // Oops - backwards logic, lower FOV needs lower angle passed in
	}
	wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), visuals->CameraNEAR_f, visuals->CameraFAR_f, fCameraFov);

	if (visuals->bWaterEnable) 
	{
		static float last_wave_amplitude = -1;
		static float last_wind_dependency = -1;
		weather->oceanParameters.wave_amplitude = visuals->fWaterWaveAmplitude;
		weather->oceanParameters.wind_dependency = visuals->fWaterWindDependency;
		if (last_wave_amplitude != weather->oceanParameters.wave_amplitude || last_wind_dependency != weather->oceanParameters.wind_dependency) 
		{
			last_wave_amplitude = weather->oceanParameters.wave_amplitude;
			last_wind_dependency = weather->oceanParameters.wind_dependency;

			//wiRenderer::OceanRegenerate(); now needs a weather component
			//wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
			//wiScene::GetScene().OceanRegenerate();

			// delay update because RunWeatherUpdateSystem needs to run before our new values can take effect
			iUpdateOcean = 2;
		}
	}

	// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
	bool bSetting;
	if(t.game.set.ismapeditormode == 1)
		bSetting = t.showeditortrees;
	else
		bSetting = t.visuals.bEndableTreeDrawing;

	if(ggtrees_global_params.hide_until_update == 0)
		ggtrees_global_params.draw_enabled = bSetting;

	// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
	if (t.game.set.ismapeditormode == 1)
		bSetting = t.showeditorveg;
	else
		bSetting = t.visuals.bEndableGrassDrawing;
	gggrass_global_params.draw_enabled = bSetting;

	// can call this to affect some visibles without causing water to flicker
	Wicked_Update_Visibles(voidvisual);
}

void Wicked_Update_Visibles(void* voidvisual)
{
	// vars
	bool bSetting = false;

	// If in Test Level or in standalone, use visual settings, otherwise just use the temporary editor setting.
	if (t.game.set.ismapeditormode == 1)
	{
		bSetting = t.showeditorterrain;
	}
	else
	{
		bSetting = t.visuals.bEndableTerrainDrawing;
		if (bSetting == true)
		{
			if (t.hardwareinfoglobals.noterrain == 1) bSetting = false;
		}
	}
	GGTerrain::ggterrain_draw_enabled = (int)bSetting;
}

#endif

//PE: Using t.gridentityposx_f,t.gridentityposy_f,t.gridentityposz_f,t.gridentity,t.gridentityobj
void Add_Grid_Snap_To_Position(void)
{
	// no snapping at all until move
	if (g_bHoldGridEntityPosWhenManaged == true)
		return;

	//  grid system for entities
	if (t.gridentitygridlock == 1)
	{
		//Snap.
		if (iObjectMoveMode == 1)
		{
			// small grid lock for better alignments on Y
			t.gridentityposy_f = (int(t.gridentityposy_f / 5) * 5);
		}
		else
		{
			// small grid lock for better alignments on XZ
			t.gridentityposx_f = (int(t.gridentityposx_f / 5) * 5);
			t.gridentityposz_f = (int(t.gridentityposz_f / 5) * 5);
		}

		//  special snap-to when edge of entity gets near another
		if (t.gridentity > 0)
		{
			t.tobj = t.gridentityobj;
			if (t.tobj > 0)
			{
				if (ObjectExist(t.tobj) == 1 )
				{
					t.tsrcx_f = t.gridentityposx_f;
					t.tsrcy_f = t.gridentityposy_f;
					t.tsrcz_f = t.gridentityposz_f;
					t.tsrcradius_f = ObjectSize(t.tobj, 1);
					t.tfindclosest = -1; t.tfindclosestbest_f = 999999;
					for (t.e = 1; t.e <= g.entityelementlist; t.e++)
					{
						// this object
						t.ttobj = t.entityelement[t.e].obj;

						//LB: never include syblings of a current group :)
						bool bThisOneIsSybling = false;
						for (int i = 0; i < g.entityrubberbandlist.size(); i++)
						{
							if (g.entityrubberbandlist[i].e == t.e)
							{
								bThisOneIsSybling = true;
								break;
							}
						}
						if (bThisOneIsSybling == true)
							continue;

						if (t.ttobj > 0 && t.tobj != t.ttobj ) //PE: Never check ourself.
						{
							if (t.entityelement[t.e].bankindex == t.gridentity)
							{
								t.tdiffx_f = t.entityelement[t.e].x - t.tsrcx_f;
								t.tdiffy_f = t.entityelement[t.e].y - t.tsrcy_f;
								t.tdiffz_f = t.entityelement[t.e].z - t.tsrcz_f;
								t.tdiff_f = Sqrt(abs(t.tdiffx_f*t.tdiffx_f) + abs(t.tdiffy_f*t.tdiffy_f) + abs(t.tdiffz_f*t.tdiffz_f));
								t.tthisradius_f = ObjectSize(t.ttobj, 1);
								if (t.tdiff_f < t.tsrcradius_f + t.tthisradius_f && t.tdiff_f < t.tfindclosestbest_f)
								{
									t.tfindclosestbest_f = t.tdiff_f;
									t.tfindclosest = t.e;
								}
							}
						}
					}
					if (t.tfindclosest != -1)
					{
						//  go through 6 magnet points of the src entity
						t.tmag1sizex_f = ObjectSizeX(t.tobj, 1) / 2;
						t.tmag1sizey_f = ObjectSizeY(t.tobj, 1) / 2;
						t.tmag1sizez_f = ObjectSizeZ(t.tobj, 1) / 2;
						t.tmag2sizex_f = ObjectSizeX(t.entityelement[t.tfindclosest].obj, 1) / 2;
						t.tmag2sizey_f = ObjectSizeY(t.entityelement[t.tfindclosest].obj, 1) / 2;
						t.tmag2sizez_f = ObjectSizeZ(t.entityelement[t.tfindclosest].obj, 1) / 2;
						if (ObjectExist(g.entityworkobjectoffset) == 0) { MakeObjectCube(g.entityworkobjectoffset, 40); HideObject(g.entityworkobjectoffset); }
						t.tbestmag_f = 99999; t.tbestmag2id = -1;
						for (t.magid = 1; t.magid <= 6; t.magid++)
						{
							t.tmagx_f = t.gridentityposx_f;
							t.tmagy_f = t.gridentityposy_f;
							t.tmagz_f = t.gridentityposz_f;
							PositionObject(g.entityworkobjectoffset, t.tmagx_f, t.tmagy_f, t.tmagz_f);
							RotateObject(g.entityworkobjectoffset, ObjectAngleX(t.tobj), ObjectAngleY(t.tobj), ObjectAngleZ(t.tobj));
							if (t.magid == 1)  MoveObjectLeft(g.entityworkobjectoffset, t.tmag1sizex_f);
							if (t.magid == 2)  MoveObjectRight(g.entityworkobjectoffset, t.tmag1sizex_f);
							if (t.magid == 3)  MoveObjectUp(g.entityworkobjectoffset, t.tmag1sizey_f);
							if (t.magid == 4)  MoveObjectDown(g.entityworkobjectoffset, t.tmag1sizey_f);
							if (t.magid == 5)  MoveObject(g.entityworkobjectoffset, t.tmag1sizez_f);
							if (t.magid == 6)  MoveObject(g.entityworkobjectoffset, t.tmag1sizez_f*-1);
							t.tmagx_f = ObjectPositionX(g.entityworkobjectoffset);
							t.tmagy_f = ObjectPositionY(g.entityworkobjectoffset);
							t.tmagz_f = ObjectPositionZ(g.entityworkobjectoffset);
							t.ttobj = t.entityelement[t.tfindclosest].obj;
							for (t.mag2id = 1; t.mag2id <= 6; t.mag2id++)
							{
								t.tmag2x_f = t.entityelement[t.tfindclosest].x;
								t.tmag2y_f = t.entityelement[t.tfindclosest].y;
								t.tmag2z_f = t.entityelement[t.tfindclosest].z;
								PositionObject(g.entityworkobjectoffset, t.tmag2x_f, t.tmag2y_f, t.tmag2z_f);
								RotateObject(g.entityworkobjectoffset, ObjectAngleX(t.ttobj), ObjectAngleY(t.ttobj), ObjectAngleZ(t.ttobj));
								if (t.mag2id == 1)  MoveObjectLeft(g.entityworkobjectoffset, t.tmag2sizex_f);
								if (t.mag2id == 2)  MoveObjectRight(g.entityworkobjectoffset, t.tmag2sizex_f);
								if (t.mag2id == 3)  MoveObjectUp(g.entityworkobjectoffset, t.tmag2sizey_f);
								if (t.mag2id == 4)  MoveObjectDown(g.entityworkobjectoffset, t.tmag2sizey_f);
								if (t.mag2id == 5)  MoveObject(g.entityworkobjectoffset, t.tmag2sizez_f);
								if (t.mag2id == 6)  MoveObject(g.entityworkobjectoffset, t.tmag2sizez_f*-1);
								t.tmag2x_f = ObjectPositionX(g.entityworkobjectoffset);
								t.tmag2y_f = ObjectPositionY(g.entityworkobjectoffset);
								t.tmag2z_f = ObjectPositionZ(g.entityworkobjectoffset);
								//  are magnets close enough together to snap?
								t.tdiffx_f = t.tmag2x_f - t.tmagx_f;
								t.tdiffy_f = t.tmag2y_f - t.tmagy_f;
								t.tdiffz_f = t.tmag2z_f - t.tmagz_f;
								t.tdiff_f = Sqrt(abs(t.tdiffx_f*t.tdiffx_f) + abs(t.tdiffy_f*t.tdiffy_f) + abs(t.tdiffz_f*t.tdiffz_f));
								if (t.tdiff_f < 25.0)
								{
									//  yes, maybe snap to this edge
									if (t.tdiff_f < t.tbestmag_f)
									{
										t.tbestmag_f = t.tdiff_f;
										t.tbestmag2id = t.mag2id;
										t.tbestmag2x_f = t.tmag2x_f + (t.gridentityposx_f - t.tmagx_f);
										t.tbestmag2y_f = t.tmag2y_f + (t.gridentityposy_f - t.tmagy_f);
										t.tbestmag2z_f = t.tmag2z_f + (t.gridentityposz_f - t.tmagz_f);
									}
								}
							}
						}
						if (t.tbestmag2id != -1)
						{
							#ifdef WICKEDENGINE
							if (iObjectMoveMode == 1)
							{
								// only magnetise Y for vert mode
								t.gridentityposy_f = t.tbestmag2y_f;
							}
							else
							{
								if (iObjectMoveMode == 0)
								{
									// only magnetise XZ for horiz modes
									t.gridentityposx_f = t.tbestmag2x_f;
									t.gridentityposz_f = t.tbestmag2z_f;
								}
								else
								{
									// magnetize all three to fix the Y coming from unstable terrain/floor (-0.0 misalignment)
									t.gridentityposx_f = t.tbestmag2x_f;
									t.gridentityposy_f = t.tbestmag2y_f;
									t.gridentityposz_f = t.tbestmag2z_f;
								}
							}
							#else
							t.gridentityposx_f = t.tbestmag2x_f;
							t.gridentityposy_f = t.tbestmag2y_f;
							t.gridentityposz_f = t.tbestmag2z_f;
							#endif
						}
					}
				}
			}
		}
	}
	if (t.gridentitygridlock == 2)
	{
		if (t.entityprofile[t.gridentity].isebe != 0)
		{
			// align EBE structure to match the 100x100 grid
			t.gridentityposx_f = 0 + (int(t.gridentityposx_f / pref.fEditorGridSizeX) * pref.fEditorGridSizeX);
			t.gridentityposz_f = 0 + (int(t.gridentityposz_f / pref.fEditorGridSizeZ) * pref.fEditorGridSizeZ);
		}
		else
		{
			//LB: apply grid alignment with custom offset for full end user control
			fHitOffsetX = 0; fHitOffsetZ = 0; // allows more intuitive placement of chosen object
			float fGripX = t.gridentityposx_f + fHitOffsetX + (pref.fEditorGridSizeX / 2);
			float fGripZ = t.gridentityposz_f + fHitOffsetZ + (pref.fEditorGridSizeZ / 2);
			fGripX -= pref.fEditorGridOffsetX;
			if (fGripX < 0)
				fGripX = ((int(fGripX / pref.fEditorGridSizeX) - 1) * pref.fEditorGridSizeX);
			else
				fGripX = (int(fGripX / pref.fEditorGridSizeX) * pref.fEditorGridSizeX);
			fGripX += pref.fEditorGridOffsetX;
			fGripZ -= pref.fEditorGridOffsetZ;
			if (fGripZ < 0)
				fGripZ = ((int(fGripZ / pref.fEditorGridSizeZ) - 1) * pref.fEditorGridSizeZ);
			else
				fGripZ = (int(fGripZ / pref.fEditorGridSizeZ) * pref.fEditorGridSizeZ);
			fGripZ += pref.fEditorGridOffsetZ;
			t.gridentityposx_f = fGripX;
			t.gridentityposz_f = fGripZ;
		}

		// 130517 - new EBE entity offset to align with 0,0,0 cornered entities from Aslum level and Store (Martin)
		if (t.entityprofile[t.gridentity].isebe != 0)
		{
			if (g.gdefaultebegridoffsetx != 50)
			{
				t.gridentityposx_f -= (g.gdefaultebegridoffsetx - 50);
				t.gridentityposz_f -= (g.gdefaultebegridoffsetz - 50);
			}
		}
	}
}

#ifndef PRODUCTCLASSIC
void DisplaySmallImGuiMessage(char *text)
{
	ImGui::SetNextWindowPos(OldrenderTargetPos + ImVec2(50, 50), ImGuiCond_Always); //ImGuiCond_Always
	ImGui::SetNextWindowSize(ImVec2(OldrenderTargetSize.x - 100, 0), ImGuiCond_Always); //ImGuiCond_Always
	bool winopen = true;

	ImVec4* style_colors = ImGui::GetStyle().Colors;
	ImVec4 oldBgColor = style_colors[ImGuiCol_WindowBg];
	ImVec4 oldTextColor = style_colors[ImGuiCol_Text];

	float fader = 0.75;
	style_colors[ImGuiCol_WindowBg].x = 0.0;
	style_colors[ImGuiCol_WindowBg].y = 0.0;
	style_colors[ImGuiCol_WindowBg].z = 0.0;
	style_colors[ImGuiCol_WindowBg].w *= (fader*0.25);

	style_colors[ImGuiCol_Text].x = 1.0;
	style_colors[ImGuiCol_Text].y = 1.0;
	style_colors[ImGuiCol_Text].z = 1.0;
	style_colors[ImGuiCol_Text].w *= fader;

	ImGui::Begin("##TriggerSmallMessageinfo", &winopen, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoInputs);
	ImGui::SetWindowFontScale(1.5);
//	ImGui::Text(" ");
	//Center Text.
	float fTextSize = ImGui::CalcTextSize(text).x;
	ImGui::SetCursorPos(ImVec2((ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5), ImGui::GetCursorPos().y));

	ImGui::Text(text);
//	ImGui::Text(" ");
	ImGui::SetWindowFontScale(1.0);
	ImGui::End();
	style_colors[ImGuiCol_WindowBg] = oldBgColor;
	style_colors[ImGuiCol_Text] = oldTextColor;
}

//PE: We can have more then one open at the same time. but only one can play.
#define MAXTUTORIALS 100
bool bSmallVideoReady[MAXTUTORIALS];
bool bSmallVideoResumePossible[MAXTUTORIALS];
bool bSmallVideoInit[MAXTUTORIALS];
bool bSmallVideoFirstClick[MAXTUTORIALS];
int iSmallVideoSlot[MAXTUTORIALS];
int iSmallVideoThumbnail[MAXTUTORIALS];
bool bSmallVideoPerccentStart[MAXTUTORIALS];
int iSmallVideoDelayExecute[MAXTUTORIALS];
int iSmallVideoFindFirstFrame[MAXTUTORIALS];
bool bSmallStartInit[MAXTUTORIALS];
bool bSmallVideoMaximized[MAXTUTORIALS];
cstr cSmallComboSelection[MAXTUTORIALS];
cstr cSmallVideoPath ="";
cstr cSmallVideoDescription = "";
int iCurrentVideoSectionPlaying = 0;
int iStopAndFreeThisVideo = -1;

void SmallTutorialThumbLoad(int index)
{
	if (iSmallVideoThumbnail[index] == 0)
	{
		iSmallVideoThumbnail[index] = -1;
		t.tvideofile_s = cSmallVideoPath;
		t.text_s = Lower(Right(t.tvideofile_s.Get(), 4));
		if (t.text_s == ".ogv" || t.text_s == ".mp4")
		{
			cStr Thumb_s = Lower(Left(t.tvideofile_s.Get(), strlen(t.tvideofile_s.Get()) - 4)); Thumb_s += ".jpg";
			if (!FileExist(Thumb_s.Get()))
			{
				Thumb_s = "tutorialbank\\welcome-video.jpg";
			}
			if (FileExist(Thumb_s.Get()))
			{
				int iVideoThumbImage = g.videothumbnailsimageoffset + index;
				if (ImageExist(iVideoThumbImage) == 1) DeleteImage(iVideoThumbImage);
				image_setlegacyimageloading(true);
				LoadImage(Thumb_s.Get(), iVideoThumbImage);
				image_setlegacyimageloading(false);
				if (ImageExist(iVideoThumbImage) == 1) iSmallVideoThumbnail[index] = iVideoThumbImage;
			}
		}
	}
}

void SmallTutorialVideoInit(int index)
{
	if (!bSmallVideoInit[index])
	{
		t.tvideofile_s = cSmallVideoPath;
		iSmallVideoSlot[index] = 0;
		iSmallVideoThumbnail[index] = 0;
		t.text_s = Lower(Right(t.tvideofile_s.Get(), 4));
		if (t.text_s == ".ogv" || t.text_s == ".mp4")
		{
			for (int itl = 1; itl <= 32; itl++)
			{
				if (AnimationExist(itl) == 0) { iSmallVideoSlot[index] = itl; break; }
			}
			if (LoadAnimation(t.tvideofile_s.Get(), iSmallVideoSlot[index], g.videoprecacheframes, g.videodelayedload, 1) == false)
			{
				iSmallVideoSlot[index] = -999;
			}
			// also load in the thumnb image for this video
			cStr Thumb_s = Lower(Left(t.tvideofile_s.Get(), strlen(t.tvideofile_s.Get())-4)); Thumb_s += ".jpg";
			if (ImageExist(g.videothumbnailsimageoffset + index) != 1)
			{
				if (!FileExist(Thumb_s.Get()))
				{
					Thumb_s = "tutorialbank\\welcome-video.jpg";
				}
				if (FileExist(Thumb_s.Get()))
				{
					int iVideoThumbImage = g.videothumbnailsimageoffset + index;
					if (ImageExist(iVideoThumbImage) == 1) DeleteImage(iVideoThumbImage);
					image_setlegacyimageloading(true);
					LoadImage(Thumb_s.Get(), iVideoThumbImage);
					image_setlegacyimageloading(false);
					if (ImageExist(iVideoThumbImage) == 1) iSmallVideoThumbnail[index] = iVideoThumbImage;
				}
			}
		}
		if (iSmallVideoSlot[index] > 0) 
		{
			PlaceAnimation(iSmallVideoSlot[index], -1, -1, -1, -1);
			bSmallVideoResumePossible[index] = false;
			bSmallVideoPerccentStart[index] = false;
		}
		bSmallVideoInit[index] = true;
	}
}

void SmallTutorialVideoCheckStop(char *tutorial)
{
	if (!tutorial) return;
	int iVideoEntry = -1;

	if (tutorial_videos.size() > 0)
	{
		int i = 0;
		for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it)
		{
			if (it->first.length() > 0)
			{
				if (strcmp(it->first.c_str(), tutorial) == 0)
				{
					iVideoEntry = i;
					break;
				}
			}
			i++;
		}
	}

	if (iStopAndFreeThisVideo >= 0)
	{
		if (iSmallVideoSlot[iStopAndFreeThisVideo] > 0) {
			if (AnimationExist(iSmallVideoSlot[iStopAndFreeThisVideo])) {
				if (AnimationPlaying(iSmallVideoSlot[iStopAndFreeThisVideo]))
					StopAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				DeleteAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				iSmallVideoSlot[iStopAndFreeThisVideo] = 0;
				bSmallVideoPerccentStart[iStopAndFreeThisVideo] = false;
				bSmallVideoFrameStart = false;
				bSmallVideoResumePossible[iStopAndFreeThisVideo] = false;
			}
		}
		iStopAndFreeThisVideo = -1;
		bSmallVideoInit[iVideoEntry] = false;
	}

}
void SmallTutorialVideo(char *tutorial, char* combo_items[], int combo_entries,int iVideoSection, bool bAutoStart)
{
	//LB: added lines to exit early
	if ((bStoryboardWindow && !bProceduralLevel) && iVideoSection != SECTION_STORYBOARD) return;
	if (bProceduralLevel && iVideoSection != SECTION_TERRAIN_GENERATOR) return;
	if (bWelcomeScreen_Window &&  iVideoSection != SECTION_MAX_HUB) return;

	bool bSectionHub = false;
	if (iVideoSection == SECTION_MAX_HUB) bSectionHub = true;

	int iVideoEntry = -1;

	cSmallVideoPath = "";
	cSmallVideoDescription = "";
	int iCurrentVideoEntry = -1;

	static int iOneTimeSetup = true;
	if (iOneTimeSetup)
	{
		iOneTimeSetup = false;
		for (int i = 0; i < MAXTUTORIALS; i++)
		{
			bSmallVideoFirstClick[i] = true;
			iSmallVideoDelayExecute[i] = 0;
		}
	}
	
	if (tutorial_videos.size() > 0)
	{
		int i = 0;
		for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it)
		{
			if (it->first.length() > 0)
			{
				if (strcmp(it->first.c_str(), tutorial) == 0)
				{
					iVideoEntry = i;
					iCurrentVideoEntry = i;
					cSmallVideoPath = it->second.c_str();
					if (cSmallComboSelection[iVideoEntry].Len() > 0) 
					{
						//PE: Overwrite settings.
						int il = 0;
						for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it) 
						{
							if (it->first.length() > 0 && strcmp(it->first.c_str(), cSmallComboSelection[iVideoEntry].Get()) == 0 ) 
							{
								cSmallVideoPath = it->second.c_str();
								iCurrentVideoEntry = il;
								break;
							}
							il++;
						}
					}
					break;
				}
			}
			i++;
		}
	}
	
	if (bSectionHub && iStopAndFreeThisVideo >= 0)
	{
		if (iSmallVideoSlot[iStopAndFreeThisVideo] > 0) 
		{
			if (AnimationExist(iSmallVideoSlot[iStopAndFreeThisVideo])) 
			{
				if (AnimationPlaying(iSmallVideoSlot[iStopAndFreeThisVideo])) StopAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				DeleteAnimation(iSmallVideoSlot[iStopAndFreeThisVideo]);
				iSmallVideoSlot[iStopAndFreeThisVideo] = 0;
				bSmallVideoPerccentStart[iStopAndFreeThisVideo] = false;
				bSmallVideoFrameStart = false;
				bSmallVideoResumePossible[iStopAndFreeThisVideo] = false;
			}
		}
		iStopAndFreeThisVideo = -1;
		bSmallVideoInit[iVideoEntry] = false;
	}

	if (iVideoEntry >= 0 && cSmallVideoPath.Len() > 0 ) 
	{
		//PE: Auto launch maximized , if first time in a section.
		if (iCurrentVideoSectionPlaying > 0 && iVideoSection > 0 && iCurrentVideoSectionPlaying != iVideoSection)
		{
			//PE: Pause any playing video , when changing section.
			for (int i = 0; i < MAXTUTORIALS; i++) 
			{
				if (iSmallVideoSlot[i] > 0) 
				{
					if (AnimationExist(iSmallVideoSlot[i])) 
					{
						if (AnimationPlaying(iSmallVideoSlot[i]))
						{
							PauseAnim(iSmallVideoSlot[i]);
							bSmallVideoResumePossible[i] = false;
							iCurrentVideoSectionPlaying = 0;
						}
					}
				}
			}
		}

		if (iVideoSection > 0 && iVideoSection < 20)
		{
			if (0)
			{
				if (pref.iPlayedVideoSection[iVideoSection] == 0)
				{
					pref.iPlayedVideoSection[iVideoSection] = 1;
					bSmallVideoMaximized[iVideoEntry] = true;
					//PE: Perhaps auto start here ?
				}
			}
		}


		//PE: Only delete one video on first run, if same tutorials use same iVideoEntry.
		if (bSmallVideoFrameStart && !bSmallVideoInit[iVideoEntry])
		{
			if (iSmallVideoSlot[iVideoEntry] > 0) {
				if (AnimationExist(iSmallVideoSlot[iVideoEntry])) {
					if (AnimationPlaying(iSmallVideoSlot[iVideoEntry]))
						StopAnimation(iSmallVideoSlot[iVideoEntry]);
					DeleteAnimation(iSmallVideoSlot[iVideoEntry]);
					iSmallVideoSlot[iVideoEntry] = 0;
					bSmallVideoPerccentStart[iVideoEntry] = false;
					bSmallVideoFrameStart = false;
					bSmallVideoResumePossible[iVideoEntry] = false;
				}
			}
		}

		if (1)
		{
			if (iSmallVideoFindFirstFrame[iVideoEntry] > 0) {
				if (iSmallVideoFindFirstFrame[iVideoEntry] == 1) {
					PauseAnim(iSmallVideoSlot[iVideoEntry]);
					iCurrentVideoSectionPlaying = 0;
					bSmallVideoResumePossible[iVideoEntry] = false;
					SetVideoVolume(100.0);
				}
				iSmallVideoFindFirstFrame[iVideoEntry]--;
			}

			switch (iSmallVideoDelayExecute[iVideoEntry]) {

				case 1: //Play restart
				{
					//PE: We can only start one video per frame.
					if (bSmallVideoFrameStart) {
						bSmallVideoFrameStart = false;
						iSmallVideoDelayExecute[iVideoEntry] = 0;
						SmallTutorialVideoInit(iVideoEntry);
						if (iSmallVideoSlot[iVideoEntry] > 0) {
							StopAnimation(iSmallVideoSlot[iVideoEntry]);
							PlayAnimation(iSmallVideoSlot[iVideoEntry]);
							SetRenderAnimToImage(iSmallVideoSlot[iVideoEntry], true);
							UpdateAllAnimation();
							Sleep(50); //Sleep so we get a video texture in the next call.
							UpdateAllAnimation();
							SetVideoVolume(100.0);
							bSmallVideoResumePossible[iVideoEntry] = false;
							bSmallVideoPerccentStart[iVideoEntry] = true;
							iCurrentVideoSectionPlaying = iVideoSection;
						}
					}
					break;
				}
				case 2: //Resume
				{
					SmallTutorialVideoInit(iVideoEntry);
					if (iSmallVideoSlot[iVideoEntry] > 0) {
						iSmallVideoDelayExecute[iVideoEntry] = 0;
						ResumeAnim(iSmallVideoSlot[iVideoEntry]);
						iCurrentVideoSectionPlaying = iVideoSection;
					}
					break;
				}
				case 3: //Pause
				{
					SmallTutorialVideoInit(iVideoEntry);
					if (iSmallVideoSlot[iVideoEntry] > 0) {
						iSmallVideoDelayExecute[iVideoEntry] = 0;
						PauseAnim(iSmallVideoSlot[iVideoEntry]);
						bSmallVideoResumePossible[iVideoEntry] = true;
						iCurrentVideoSectionPlaying = 0;
					}
					break;
				}
				default:
					break;
			}

			int combo_current_type_selection = 0;

			if (combo_items && combo_entries > 0 ) {
				if (cSmallComboSelection[iVideoEntry].Len() > 0)
				{
					for (int i = 0; i < combo_entries;i++)
					{
						if (combo_items[i])
						{
							if (strcmp(cSmallComboSelection[iVideoEntry].Get(), combo_items[i]) == 0)
							{
								combo_current_type_selection = i;
								break;
							}
						}
					}
				}
			}
			if (combo_items && combo_entries > 0)
			{
				std::map<std::string, std::string>::iterator it = tutorial_description.find(combo_items[combo_current_type_selection]);
				if (it != tutorial_description.end()) {
					cSmallVideoDescription = it->second.c_str();
				}
			}
			else
			{
				std::map<std::string, std::string>::iterator it = tutorial_description.find(tutorial);
				if (it != tutorial_description.end()) {
					cSmallVideoDescription = it->second.c_str();
				}
			}
			//bSmallVideoMaximized[iVideoEntry] = true; //For now.
			bool bMustEndWindow = false;
			if (bSmallVideoMaximized[iVideoEntry]) {
				
				//	Display the maximised tutorial video window.
				ImGui::SetNextWindowSize(ImVec2(62 * ImGui::GetFontSize(), 45 * ImGui::GetFontSize()), ImGuiCond_Once);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Once);

				//LB: ImGui::Begin("Tutorial Video##VideosMaxSize", &bSmallVideoMaximized[iVideoEntry], 0);
				ImGui::Begin("Tutorial Video##VideosMaxSize", &bSmallVideoMaximized[iVideoEntry], ImGuiWindowFlags_ForceRender);
				bMustEndWindow = true;
				bSmallVideoPlayerMaximized = true;
				ImGui::Indent(10);
			}


			if (combo_items && combo_entries > 0 ) 
			{
				//Display combo.
				ImGui::PushItemWidth(-10);
				cstr sUniqueLabel = cstr("##TutorialSimpleInput") + cstr(iVideoEntry);
				if (combo_current_type_selection < combo_entries)
				{
					char *findcur = strstr(combo_items[combo_current_type_selection], "-");
					if (findcur) findcur++;
					else findcur = combo_items[combo_current_type_selection];

					if (ImGui::BeginCombo(sUniqueLabel.Get(), findcur, ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge))
					{
						for (int n = 0; n < combo_entries; n++)
						{
							if (combo_items[n])
							{
								bool is_selected = (combo_current_type_selection == n);
								char *find = strstr(combo_items[n], "-");
								if (find) find++;
								else find = combo_items[n];

								if (ImGui::Selectable(find, is_selected) )
								{
									combo_current_type_selection = n;
									cSmallComboSelection[iVideoEntry] = combo_items[combo_current_type_selection];
									bSmallVideoInit[iVideoEntry] = false;
									bSmallVideoFrameStart = false; //PE: Wait until next frame.
								}
								if (is_selected)
									ImGui::SetItemDefaultFocus();
							}
						}
						ImGui::EndCombo();

					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Tutorial Video");
				ImGui::PopItemWidth();
			}

			float fRatio = 1.0f / ((float)GetDesktopWidth() / (float)GetDesktopHeight());

			ID3D11ShaderResourceView* lpVideoTexture = NULL;
			if (bSmallVideoInit[iVideoEntry] )
				lpVideoTexture = GetAnimPointerView(iSmallVideoSlot[iVideoEntry]);
			float fVideoW = GetAnimWidth(iSmallVideoSlot[iVideoEntry]);
			float fVideoH = GetAnimHeight(iSmallVideoSlot[iVideoEntry]);
			if (bSmallVideoInit[iVideoEntry] && iSmallVideoSlot[iVideoEntry] > 0 && lpVideoTexture) {
				fRatio = 1.0f / (fVideoW / fVideoH);
			}

			int iActiveID = iVideoEntry;
			if (iCurrentVideoEntry >= 0 && iCurrentVideoEntry < MAXTUTORIALS && iCurrentVideoEntry != iVideoEntry) iActiveID = iCurrentVideoEntry;

			bool bShowBoder = true;
			float fLeftBorder = 10.0;
			if (bSectionHub) bShowBoder = false;
			if (bSectionHub && !bSmallVideoMaximized[iVideoEntry]) fLeftBorder = 2.0;

			float videoboxheight = (ImGui::GetContentRegionAvail().x - fLeftBorder) * fRatio;

			ImVec4 oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
			ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);

			//LB: ImGui::BeginChild("Video##TutorialVideo", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, videoboxheight), true, iGenralWindowsFlags);
			ImGui::BeginChild("Video##TutorialVideo", ImVec2(ImGui::GetContentRegionAvail().x - fLeftBorder, videoboxheight), bShowBoder, ImGuiWindowFlags_NoScrollbar| ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_ForceRender | iGenralWindowsFlags);

			bool bToogleMinMax = false;
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + ImGui::GetContentRegionAvail());
			image_bb.Floor();

			bool bIsPlaying = false;
			//PE: We always play into iVideoEntry not iActiveID.
			if (iSmallVideoSlot[iVideoEntry] > 0)
			{
				if (AnimationExist(iSmallVideoSlot[iVideoEntry]) && AnimationPlaying(iSmallVideoSlot[iVideoEntry]))
					bIsPlaying = true;
			}

			bool bVideoAreaPressed = false;

			if (lpVideoTexture) 
			{
				SetRenderAnimToImage(iSmallVideoSlot[iVideoEntry], true);
				float animU = GetAnimU(iSmallVideoSlot[iVideoEntry]);
				float animV = GetAnimV(iSmallVideoSlot[iVideoEntry]);
				ImVec2 uv0 = ImVec2(0, 0);
				ImVec2 uv1 = ImVec2(animU, animV);
				//window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));

				ImGui::PushID(lpVideoTexture);
				const ImGuiID id = window->GetID("#image");
				ImGui::PopID();
				ImGui::ItemSize(image_bb);
				if (ImGui::ItemAdd(image_bb, id))
				{
					window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));

					bool hovered, held;
					bVideoAreaPressed = ImGui::ButtonBehavior(image_bb, id, &hovered, &held);
				}

			}
			else 
			{
				// Display thumbnail of the video (from .jpg)

				SmallTutorialThumbLoad(iActiveID);
				ID3D11ShaderResourceView* lpTexture = NULL;
				if (iSmallVideoThumbnail[iActiveID] > 0) lpTexture = GetImagePointerView(iSmallVideoThumbnail[iActiveID]);

				//if (lpTexture) window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min, image_bb.Max, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));

				ImGui::PushID(lpTexture);
				const ImGuiID id = window->GetID("#image");
				ImGui::PopID();
				ImGui::ItemSize(image_bb);
				if (ImGui::ItemAdd(image_bb, id))
				{
					if (lpTexture) window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min, image_bb.Max, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
					bool hovered, held;
					bVideoAreaPressed = ImGui::ButtonBehavior(image_bb, id, &hovered, &held);
				}

				//Display a play button.
				ImVec2 vOldPos = ImGui::GetCursorPos();
				float fPlayButSize = ImGui::GetContentRegionAvail().x * 0.15;
				float fCenterX = (ImGui::GetContentRegionAvail().x*0.5) - (fPlayButSize*0.5);
				float fCenterY = (videoboxheight*0.5) - (fPlayButSize*0.5);
				ImGui::SetCursorPos(ImVec2(fCenterX, fCenterY));
				ImVec4 vColorFade = { 1.0,1.0,1.0,0.5 };
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fPlayButSize, fPlayButSize), ImColor(255, 255, 255, 0), drawCol_normal*vColorFade, drawCol_hover*vColorFade, drawCol_Down*vColorFade, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
				{
					bSmallVideoPerccentStart[iVideoEntry] = true;
					bSmallVideoResumePossible[iVideoEntry] = false;
					iSmallVideoDelayExecute[iVideoEntry] = 1; //force play - restart.
					bSmallVideoFrameStart = false; //PE: Wait until next frame.
					//bVideoAreaPressed = true;
					if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
					{
						bSmallVideoFirstClick[iVideoEntry] = false;
						bSmallVideoMaximized[iVideoEntry] = true;
					}
				}
				if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

				ImGui::SetCursorPos(vOldPos);
			}

			#ifdef WICKEDENGINE
			//PE: Double click trigger an inver, so also invert here.
			if (!bStoryboardWindow && !bProceduralLevel)
			{
				if (bVideoAreaPressed || (ImGui::IsMouseDoubleClicked(0) && ImGui::IsMouseHoveringRect(image_bb.Min, image_bb.Max)))
				{
					//Video pause/play
					if (bIsPlaying)
					{
						//Pause
						bSmallVideoPerccentStart[iVideoEntry] = true;
						iSmallVideoDelayExecute[iVideoEntry] = 3; // pause
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
					}
					else
					{
						//Play
						bSmallVideoPerccentStart[iVideoEntry] = true;
						if (bSmallVideoResumePossible[iVideoEntry]) {
							iSmallVideoDelayExecute[iVideoEntry] = 2; //resume
						}
						else {
							iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
						}
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
						if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
						{
							bSmallVideoFirstClick[iVideoEntry] = false;
							bSmallVideoMaximized[iVideoEntry] = true;
						}

					}
				}
			}
			if (ImGui::IsMouseHoveringRect(image_bb.Min, image_bb.Max))
			{
				if (!bStoryboardWindow && !bProceduralLevel )
				{
					if (ImGui::IsMouseDoubleClicked(0) && !bVideoAreaPressed)
					{
						bSmallVideoMaximized[iVideoEntry] = 1 - bSmallVideoMaximized[iVideoEntry];
					}
				}
			}

			ImGui::EndChild();
			ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = oldImGuiCol_ChildWindowBg;

			{
				float fdone = GetAnimPercentDone(iSmallVideoSlot[iVideoEntry]) / 100.0f;
				if (!bSmallVideoPerccentStart[iVideoEntry]) fdone = 0.0f;

				ImVec2 rstart = ImGui::GetWindowPos() + ImGui::GetCursorPos();
				ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - fLeftBorder, 8), "");
				ImVec2 rend = ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvail().x - fLeftBorder, 0.0);

				if (ImGui::IsMouseClicked(0) && ImGui::IsMouseHoveringRect(rstart, rend))
				{
					float GetVideoDuration();
					void SetVideoPositionPause(float seconds);
					void SetVideoPositionPlay(float seconds);

					ImVec2 mpos = ImGui::GetMousePos() - rstart;
					ImVec2 rwidth = rend - rstart;
					float percent = 100.0 / (rwidth.x / mpos.x);
					float videolength = GetVideoDuration();
					float vpercent = videolength / 100.0f;
					SetVideoPositionPlay((vpercent * percent) );
					ResumeAnim(iSmallVideoSlot[iVideoEntry]);
					bSmallVideoResumePossible[iVideoEntry] = false;
					if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
					{
						bSmallVideoFirstClick[iVideoEntry] = false;
						bSmallVideoMaximized[iVideoEntry] = true;
					}
				}

				#define MEDIAICONSIZE 20

				if (bIsPlaying)
				{
					if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bSmallVideoPerccentStart[iVideoEntry] = true;
						iSmallVideoDelayExecute[iVideoEntry] = 3; // pause
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Pause");
				}
				else
				{
					if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bSmallVideoPerccentStart[iVideoEntry] = true;
						if (bSmallVideoResumePossible[iVideoEntry]) {
							iSmallVideoDelayExecute[iVideoEntry] = 2; //resume
						}
						else {
							if (!bSectionHub && bSmallVideoFirstClick[iVideoEntry])
							{
								bSmallVideoFirstClick[iVideoEntry] = false;
								bSmallVideoMaximized[iVideoEntry] = true;
							}
							iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
						}
						bSmallVideoFrameStart = false; //PE: Wait until next frame.
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");
				}
				ImGui::SameLine();
				if (ImGui::ImgBtn(MEDIA_REFRESH, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false,false,false,false,false, bBoostIconColors))
				{
					bSmallVideoPerccentStart[iVideoEntry] = true;
					iSmallVideoDelayExecute[iVideoEntry] = 1; //play - restart.
					bSmallVideoFrameStart = false; //PE: Wait until next frame.
				}
				if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Restart");

				if (!bSmallVideoMaximized[iVideoEntry])
				{
					ImGui::SameLine();
					if (ImGui::ImgBtn(MEDIA_MAXIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true,false,false,false,false, bBoostIconColors))
					{
						bSmallVideoMaximized[iVideoEntry] = true;
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Maximize");
				}
				else
				{
					ImGui::SameLine();
					if (ImGui::ImgBtn(MEDIA_MINIMIZE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true,false,false,false,false, bBoostIconColors))
					{
						bSmallVideoMaximized[iVideoEntry] = false;
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Minimize");
				}
			}
			#endif

			if (bMustEndWindow) 
			{

				if (cSmallVideoDescription.Len() > 0) {
					ImGui::Separator();
					ImGui::Text("Description");
					ImGui::TextWrapped(cSmallVideoDescription.Get());
				}

				bImGuiGotFocus = true;
				ImGui::Indent(-10);

				if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) 
				{
					//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
					ImGui::Text("");
					ImGui::Text("");
				}

				ImGui::End();
			}

		}
	}
	return;
}

// Useful function
UINT OpenURLForGETPOST(LPSTR pServerName, LPSTR* pDataReturned, DWORD* pReturnDataSize, LPSTR pAuthHeader, LPSTR pszPostData, LPSTR pVerb, LPSTR urlWhere)
{
	// create large area to drop reply into
	int i100MB = 102400000;
	*pDataReturned = new char[i100MB];
	memset(*pDataReturned, 0, i100MB);

	UINT iError = 0;
	unsigned int dwDataLength = 0;
	HINTERNET m_hInet = InternetOpenA("InternetConnection", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (m_hInet == NULL)
	{
		iError = GetLastError();
	}
	else
	{
		unsigned short wHTTPType = INTERNET_DEFAULT_HTTPS_PORT;
		HINTERNET m_hInetConnect = InternetConnectA(m_hInet, pServerName, wHTTPType, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
		if (m_hInetConnect == NULL)
		{
			iError = GetLastError();
		}
		else
		{
			int m_iTimeout = 2000;
			InternetSetOption(m_hInetConnect, INTERNET_OPTION_CONNECT_TIMEOUT, (void*)&m_iTimeout, sizeof(m_iTimeout));
			HINTERNET hHttpRequest = HttpOpenRequestA(m_hInetConnect, pVerb, urlWhere, "HTTP/1.1", NULL, NULL, INTERNET_FLAG_IGNORE_CERT_CN_INVALID | INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_SECURE, 0);
			if (hHttpRequest == NULL)
			{
				iError = GetLastError();
			}
			else
			{
				HttpAddRequestHeadersA(hHttpRequest, "Content-Type: application/x-www-form-urlencoded", -1, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
				if (pAuthHeader) HttpAddRequestHeadersA(hHttpRequest, pAuthHeader, -1, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
				int bSendResult = 0;
				if (pszPostData)
					bSendResult = HttpSendRequest(hHttpRequest, NULL, -1, (void*)(pszPostData), strlen(pszPostData));
				else
					bSendResult = HttpSendRequest(hHttpRequest, NULL, -1, NULL, 0);
				if (bSendResult == 0)
				{
					iError = GetLastError();
				}
				else
				{
					int m_iStatusCode = 0;
					char m_szContentType[150];
					unsigned int dwBufferSize = sizeof(int);
					unsigned int dwHeaderIndex = 0;
					HttpQueryInfo(hHttpRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, (void*)&m_iStatusCode, (LPDWORD)&dwBufferSize, (LPDWORD)&dwHeaderIndex);
					dwHeaderIndex = 0;
					unsigned int dwContentLength = 0;
					HttpQueryInfo(hHttpRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, (void*)&dwContentLength, (LPDWORD)&dwBufferSize, (LPDWORD)&dwHeaderIndex);
					dwHeaderIndex = 0;
					unsigned int ContentTypeLength = 150;
					HttpQueryInfo(hHttpRequest, HTTP_QUERY_CONTENT_TYPE, (void*)m_szContentType, (LPDWORD)&ContentTypeLength, (LPDWORD)&dwHeaderIndex);
					char pBuffer[20000];
					for (;;)
					{
						unsigned int written = 0;
						if (!InternetReadFile(hHttpRequest, (void*)pBuffer, 2000, (LPDWORD)&written))
						{
							// error
						}
						if (written == 0) break;
						if (dwDataLength + written > 102400000) written = 102400000 - dwDataLength;
						memcpy(*pDataReturned + dwDataLength, pBuffer, written);
						dwDataLength = dwDataLength + written;
						if (dwDataLength >= 102400000) break;
					}
					InternetCloseHandle(hHttpRequest);
				}
			}
			InternetCloseHandle(m_hInetConnect);
		}
		InternetCloseHandle(m_hInet);
	}
	if (iError > 0)
	{
		char *szError = 0;
		if (iError > 12000 && iError < 12174)
			FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, GetModuleHandleA("wininet.dll"), iError, 0, (char*)&szError, 0, 0);
		else
			FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0, iError, 0, (char*)&szError, 0, 0);
		if (szError)
		{
			LocalFree(szError);
		}
	}

	// complete
	*pReturnDataSize = dwDataLength;
	return iError;
}

//#####################################
//#### Process Preferences window. ####
//#####################################

#ifdef WICKEDENGINE
void ProcessPreferences(void) 
{
	if (!bPreferences_Window)
		return;

	float fs = ImGui::CalcTextSize("#").x;

	if (refresh_gui_docking == 1)
	{
		ImGui::SetNextWindowSize(ImVec2(54 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Always);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
	}
	else
	{
		ImGui::SetNextWindowSize(ImVec2(54 * ImGui::GetFontSize(), 38 * ImGui::GetFontSize()), ImGuiCond_Once);
		ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
	}

	static float fLastContentWidth = 0;
	static ImVec2 vLastWindowSize = ImVec2(0, 0);
	if (refresh_gui_docking >= 3 )
	{
		if (fLastContentWidth > 0 && fLastContentWidth < 700.0f && vLastWindowSize.y > 0)
		{
			ImGui::SetNextWindowSize(ImVec2(700.0f, vLastWindowSize.y), ImGuiCond_Always);
		}
	}

	ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings;
	if (bDigAHoleToHWND) window_flags |= ImGuiWindowFlags_ForceRender;

	ImGui::Begin("Settings", &bPreferences_Window, window_flags);

	ImGuiWindow* bwindow = ImGui::GetCurrentWindow(); // ImGui::FindWindowByName("Save New Level##Storyboard");
	if (bDigAHoleToHWND && bwindow)
		bwindow->DrawList->AddCallback((ImDrawCallback)10, NULL); //force render.

	int inputcolx = fs * 18;
	bool change_colors = false;

	static int iCurrentTab = 0;

	//Tabs
	if (ImGui::BeginTabBar("preferencestabbar"))
	{
		int flags = 0;
		if(iSetSettingsFocusTab == 1)
			flags = ImGuiTabItemFlags_SetSelected;
		if (ImGui::BeginTabItem(" General ",NULL, flags))
		{
			iCurrentTab = 0;

			if (iSetSettingsFocusTab == 1) iSetSettingsFocusTab = 0;
			ImGui::Columns(2, "preferencescolumns2", false);  //false no border
			ImGui::SetColumnWidth(0, ImGui::GetWindowSize().x*0.45);
			ImGui::PushItemWidth(-10);
			ImGui::Text("Editor Options");
			//ImGui::Text("");
			ImGui::Indent(10);


			bool bIntroStartup = pref.iDisplayIntroScreen;
			if (ImGui::Checkbox("Show Intro Video on Start Up", &bIntroStartup)) {
				pref.iDisplayIntroScreen = bIntroStartup;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show or hide the Intro Video when GameGuru MAX first loads");

			//pref.iDisplayWelcomeScreen
			bool bWelcomeStartup = pref.iDisplayWelcomeScreen;
			if (ImGui::Checkbox("Show GameGuru MAX Hub on Startup", &bWelcomeStartup)) 
			{
				pref.iDisplayWelcomeScreen = bWelcomeStartup;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show or hide the Welcome Screen when GameGuru MAX first loads");

			ImGui::Checkbox("Auto Close Property Sections", &pref.bAutoClosePropertySections);
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "After opening a new property section on the right, auto close any open ones");

			ImGui::Checkbox("Hide Tutorials Components From All Panels", &pref.bHideTutorials);
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Hides all tutorial sections from all panels");

			bool bHideShortcuts = pref.iHideKeyboardShortcuts;
			if(ImGui::Checkbox("Hide Keyboard Shortcuts From All Panels", &bHideShortcuts))
			{
				pref.iHideKeyboardShortcuts = bHideShortcuts;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Hides all keyboard shortcuts from all panels");

			bool bTmp = pref.iTurnOffUITransparent;
			if (ImGui::Checkbox("Turn Off UI Transparency", &bTmp)) {
				pref.iTurnOffUITransparent = bTmp;
				change_colors = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Stops the backgrounds in the UI from using transparency and uses an opaque color");

			bTmp = pref.iTurnOffEditboxTooltip;
			if (ImGui::Checkbox("Turn Off Help Pop-up Tips on Edit fields", &bTmp)) {
				pref.iTurnOffEditboxTooltip = bTmp;
				change_colors = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Hides the pop-up help tips when you hover over edit fields");

			//PE: TODO - This system dont really work , it need to be per object.
			bTmp = pref.iEnableAutoFlattenSystem; //g_bEnableAutoFlattenSystem;
			if (ImGui::Checkbox("Auto flatten terrain under large objects", &bTmp)) 
			{
				g_bEnableAutoFlattenSystem = bTmp;
				pref.iEnableAutoFlattenSystem = bTmp;
				bool bChangeState = false;
				if (bTmp)
				{
					bChangeState = true;
				}
				//PE: Loop into all.
				for (int i = 1; i <= g.entityelementlist; i++) {

					int entid = t.entityelement[i].bankindex;
					if (entid > 0)
					{
						int iAutoFlattenMode = t.entityprofile[entid].autoflatten;
						if (iAutoFlattenMode != 0)
							t.entityelement[i].eleprof.bAutoFlatten = bChangeState;
						else
							t.entityelement[i].eleprof.bAutoFlatten = false;
						if (!bTmp && t.entityelement[i].eleprof.iFlattenID != -1)
						{
							//PE: Disabled remove any flatten.
							GGTerrain_RemoveFlatArea(t.entityelement[i].eleprof.iFlattenID);
							t.entityelement[i].eleprof.iFlattenID = -1;
						}
						if (iAutoFlattenMode != 0 && bTmp)
						{
							if (t.entityelement[i].eleprof.iFlattenID == -1)
								entity_autoFlattenWhenAdded(i);
							else
								entity_updateautoflatten(i);
							g.projectmodified = 1;
						}
					}
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Flattens the terrain and clears any trees and grass when placing large objects");

			bool iCheckFileModifications = pref.iCheckFilesModifiedOnFocus;
			if (ImGui::Checkbox("Auto replace objects when files are modified", &iCheckFileModifications))
			{
				pref.iCheckFilesModifiedOnFocus = iCheckFileModifications;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("When the software regains focus, any objects that use outdated files will be reloaded");

			ImGui::Indent(-10);
			ImGui::Text("Graphic Settings");
			ImGui::Indent(10);

			const char* quaity_items[] = { "Test Level - Low Settings", "Test Level - Medium Settings", "Test Level - High Settings" };
			if (ImGui::Combo("##GraphicsQualityTest", &pref.iTestGameGraphicsQuality, quaity_items, IM_ARRAYSIZE(quaity_items))) {
				//PE: This will overwrite "level designer" settings , in editor and test game, this is only for test game, so set later.
				//SetGlobalGraphicsSettings( pref.iTestGameGraphicsQuality );
			}

			//PE: Not possible at the moment.
			//ImGui::Checkbox("Disable Multiple Viewport Support", &pref.bDisableMultipleViewport);
			//if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Restart Max for this to take effect");

			ImGui::PopItemWidth();
			ImGui::Indent(-10);

			ImGui::NextColumn();

			ImGui::PushItemWidth(-10);
			ImGui::Text("Interface style");
			//ImGui::Text("");
			ImGui::Indent(10);

			//const char* style_combo[] = {	"Dark Style",//0->12
			//								"Darker Style",//1->13 
			//								"Evening blue",//2->9
			//								"Green tea",//3->2
			//								"Light Style",//4->14 
			//								"Moody red",//5->8
			//								"Purple haze",//6->4
			//								"Racing green",//7->10
			//								"Red Lines",//8->7
			//								"Retro green",//9->11
			//								"Sea blue",//10->0
			//								"Smart purple",//11->5
			//								"Striking yellow",//12->6
			//								"Sunset red",//13->3
			//								"Tango",//14->3
			//								"Blue" };//15->1

			//// current_style: 0-3 are the old styles, 10+ are the new colorful ones
			//int style_current_type_selection;
			//if (pref.current_style == 0) style_current_type_selection = 0;
			//if (pref.current_style == 1) style_current_type_selection = 1;
			//if (pref.current_style == 3) style_current_type_selection = 4;
			//if (pref.current_style >= 10) style_current_type_selection = pref.current_style - 10;

			//if (ImGui::Combo("##BehavioursSimpleInput", &style_current_type_selection, style_combo, IM_ARRAYSIZE(style_combo))) 
			//{
			//	if (style_current_type_selection == 0) {
			//		// dark
			//		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.current_style = 0;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 1) {
			//		// darker
			//		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.current_style = 1;
			//		myDarkStyle(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 2) {
			//		//Evening blue
			//		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(0, 0, 0, 1.0);
			//		pref.title_style = ImVec4(1 / 255.0, 36 / 255.0, 73 / 255.0, 0.0);
			//		pref.current_style = 12;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 3) {
			//		//Green tea
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(4 / 255.0, 124 / 255.0, 10 / 255.0, 0.0);
			//		pref.title_style = ImVec4(89 / 255.0, 160 / 255.0, 93 / 255.0, 0.0);
			//		pref.current_style = 13;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 4) {
			//		// Light style
			//		pref.tint_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.shade_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.title_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.current_style = 3;
			//		myLightStyle(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 5) {
			//		//Moody red
			//		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(14 / 255.0, 12 / 255.0, 29 / 255.0, 0.0);
			//		pref.title_style = ImVec4(131 / 255.0, 16 / 255.0, 6 / 255.0, 0.0);
			//		pref.current_style = 15;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 6) {
			//		//Purple haze
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(163 / 255.0, 43 / 255.0, 179 / 255.0, 0.0);
			//		pref.title_style = ImVec4(251 / 255.0, 251 / 255.0, 251 / 255.0, 0.0);
			//		pref.current_style = 16;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 7) {
			//		//Racing green
			//		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(0, 0, 0, 1.0);
			//		pref.title_style = ImVec4(18 / 255.0, 62 / 255.0, 0 / 255.0, 0.0);
			//		pref.current_style = 17;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 8) {
			//		//Red Lines
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.title_style = ImVec4(230 / 255.0, 56 / 255.0, 56 / 255.0, 0.0);
			//		pref.current_style = 18;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 9) {
			//		//Retro green
			//		pref.tint_style = ImVec4(11 / 255.0, 248 / 255.0, 25 / 255.0, 0.0);
			//		pref.shade_style = ImVec4(0, 0, 0, 1.0);
			//		pref.title_style = ImVec4(0, 0, 0, 1.0);
			//		pref.current_style = 19;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 10) {
			//		//Sea blue
			//		pref.tint_style = ImVec4(7 / 255.0, 7 / 255.0, 7 / 255.0, 1.0);
			//		pref.shade_style = ImVec4(12 / 255.0, 100 / 255.0, 168 / 255.0, 0.0);
			//		pref.title_style = ImVec4(28 / 255.0, 77 / 255.0, 244 / 255.0, 0.0);
			//		pref.current_style = 20;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 11) {
			//		//Smart purple
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.title_style = ImVec4(172 / 255.0, 96 / 255.0, 182 / 255.0, 0.0);
			//		pref.current_style = 21;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 12) {
			//		//Striking yellow
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
			//		pref.title_style = ImVec4(200 / 255.0, 191 / 255.0, 34 / 255.0, 0.0);
			//		pref.current_style = 22;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 13) {
			//		//Sunset red
			//		pref.tint_style = ImVec4(0,0,0, 1.0);
			//		pref.shade_style = ImVec4(164 / 255.0, 70 / 255.0, 70 / 255.0, 0.0);
			//		pref.title_style = ImVec4(204 / 255.0, 63 / 255.0, 50 / 255.0, 0.0);
			//		pref.current_style = 23;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 14) {
			//		//Tango
			//		pref.tint_style = ImVec4(0, 0, 0, 1.0);
			//		pref.shade_style = ImVec4(244 / 255.0, 251 / 255.0, 0, 0.0);
			//		pref.title_style = ImVec4(237 / 255.0, 86 / 255.0, 7 / 255.0, 0.0);
			//		pref.current_style = 24;
			//		myStyle2(NULL);
			//		SetIconSet();
			//	}
			//	if (style_current_type_selection == 15) {
			//		//Blue
			//		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			//		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			//		pref.current_style = 25;
			//		myStyleBlue(NULL);
			//		SetIconSet();
			//	}
			//}
			//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select interface style");
const char* style_combo[] = { 
											"Blue Style", //0->1
											"Dark Style",//1->12
											"Darker Style",//2->13 
											"Evening Blue",//3->9
											"Green Tea",//4->2
											"Light Style",//5->14 
											"Moody Red",//6->8
											"Purple Haze",//7->4
											"Racing Green",//8->10
											"Red Lines",//9->7
											"Retro Green",//10->11
											"Sea Blue",//11->0
											"Smart Purple",//12->5
											"Striking Yellow",//13->6
											"Sunset Red",//14->3
											"Tango",//15->3
											};

int style_current_type_selection;
if (pref.current_style == 0) style_current_type_selection = 1;
if (pref.current_style == 1) style_current_type_selection = 2;
if (pref.current_style == 3) style_current_type_selection = 5;
if (pref.current_style >= 10) style_current_type_selection = pref.current_style - 9;
if (pref.current_style == 25) style_current_type_selection = 0; // ZJ: Moved blue to top of list, so pref.current_style - 10 no longer works.

if (ImGui::Combo("##BehavioursSimpleInput", &style_current_type_selection, style_combo, IM_ARRAYSIZE(style_combo)))
{
	if (style_current_type_selection == 0) {
		//Blue
		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.current_style = 25;
		myStyleBlue(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 1) {
		// dark
		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.current_style = 0;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 2) {
		// darker
		pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.current_style = 1;
		myDarkStyle(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 3) {
		//Evening blue
		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.shade_style = ImVec4(0, 0, 0, 1.0);
		pref.title_style = ImVec4(1 / 255.0, 36 / 255.0, 73 / 255.0, 0.0);
		pref.current_style = 12;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 4) {
		//Green tea
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(4 / 255.0, 124 / 255.0, 10 / 255.0, 0.0);
		pref.title_style = ImVec4(89 / 255.0, 160 / 255.0, 93 / 255.0, 0.0);
		pref.current_style = 13;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 5) {
		// Light style
		pref.tint_style = ImVec4(0.0, 0.0, 0.0, 0.0);
		pref.shade_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.title_style = ImVec4(1.0, 1.0, 1.0, 1.0);
		pref.current_style = 3;
		myLightStyle(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 6) {
		//Moody red
		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.shade_style = ImVec4(14 / 255.0, 12 / 255.0, 29 / 255.0, 0.0);
		pref.title_style = ImVec4(131 / 255.0, 16 / 255.0, 6 / 255.0, 0.0);
		pref.current_style = 15;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 7) {
		//Purple haze
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(163 / 255.0, 43 / 255.0, 179 / 255.0, 0.0);
		pref.title_style = ImVec4(251 / 255.0, 251 / 255.0, 251 / 255.0, 0.0);
		pref.current_style = 16;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 8) {
		//Racing green
		pref.tint_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.shade_style = ImVec4(0, 0, 0, 1.0);
		pref.title_style = ImVec4(18 / 255.0, 62 / 255.0, 0 / 255.0, 0.0);
		pref.current_style = 17;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 9) {
		//Red Lines
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.title_style = ImVec4(230 / 255.0, 56 / 255.0, 56 / 255.0, 0.0);
		pref.current_style = 18;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 10) {
		//Retro green
		pref.tint_style = ImVec4(11 / 255.0, 248 / 255.0, 25 / 255.0, 0.0);
		pref.shade_style = ImVec4(0, 0, 0, 1.0);
		pref.title_style = ImVec4(0, 0, 0, 1.0);
		pref.current_style = 19;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 11) {
		//Sea blue
		pref.tint_style = ImVec4(7 / 255.0, 7 / 255.0, 7 / 255.0, 1.0);
		pref.shade_style = ImVec4(12 / 255.0, 100 / 255.0, 168 / 255.0, 0.0);
		pref.title_style = ImVec4(28 / 255.0, 77 / 255.0, 244 / 255.0, 0.0);
		pref.current_style = 20;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 12) {
		//Smart purple
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.title_style = ImVec4(172 / 255.0, 96 / 255.0, 182 / 255.0, 0.0);
		pref.current_style = 21;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 13) {
		//Striking yellow
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0, 0.0);
		pref.title_style = ImVec4(200 / 255.0, 191 / 255.0, 34 / 255.0, 0.0);
		pref.current_style = 22;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 14) {
		//Sunset red
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(164 / 255.0, 70 / 255.0, 70 / 255.0, 0.0);
		pref.title_style = ImVec4(204 / 255.0, 63 / 255.0, 50 / 255.0, 0.0);
		pref.current_style = 23;
		myStyle2(NULL);
		SetIconSet();
	}
	if (style_current_type_selection == 15) {
		//Tango
		pref.tint_style = ImVec4(0, 0, 0, 1.0);
		pref.shade_style = ImVec4(244 / 255.0, 251 / 255.0, 0, 0.0);
		pref.title_style = ImVec4(237 / 255.0, 86 / 255.0, 7 / 255.0, 0.0);
		pref.current_style = 24;
		myStyle2(NULL);
		SetIconSet();
	}
	
}
if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select your preferred user interface style");
			
			ImGui::PopItemWidth();		

			bTmp = pref.iEnableCustomColors;
			if (ImGui::Checkbox("Enable Custom Colors", &bTmp)) 
			{
				pref.iEnableCustomColors = bTmp;
				change_colors = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Use this to design your own custom interface style");

			if (pref.iEnableCustomColors)
			{
				//Tint
				float ChangeColor[4];
				ChangeColor[0] = pref.tint_style.x;
				ChangeColor[1] = pref.tint_style.y;
				ChangeColor[2] = pref.tint_style.z;
				ChangeColor[3] = 1.0f;

				//float hw = (ImGui::GetContentRegionAvailWidth() - 20.0f) * 0.5;
				float hw = (ImGui::GetContentRegionAvailWidth() - 20.0f) * 0.33;
				ImGui::Text("");
				ImVec2 cpos = ImGui::GetCursorPos();
				ImGui::Text("Text ");
				ImGui::SetCursorPos(cpos + ImVec2(hw + 8.0, 0));
				ImGui::Text("Background ");
				ImGui::SetCursorPos(cpos + ImVec2((hw*2) + 16.0, 0));
				ImGui::Text("Highlight "); 

				ImGui::PushItemWidth(hw);
				//ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()+30.0, ImGui::GetCursorPosY()));
				if (ImGui::ColorPicker4("##ChangeTintColor", &ChangeColor[0], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_DisplayRGB))
				{
					pref.tint_style.x = ChangeColor[0];
					pref.tint_style.y = ChangeColor[1];
					pref.tint_style.z = ChangeColor[2];
					change_colors = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change the color of the text to make your own custom style");

				ChangeColor[0] = pref.shade_style.x;
				ChangeColor[1] = pref.shade_style.y;
				ChangeColor[2] = pref.shade_style.z;
				ChangeColor[3] = 1.0f;
				ImGui::SameLine();
				if (ImGui::ColorPicker4("##ChangeshadeColor", &ChangeColor[0], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_DisplayRGB))
				{
					pref.shade_style.x = ChangeColor[0];
					pref.shade_style.y = ChangeColor[1];
					pref.shade_style.z = ChangeColor[2];
					change_colors = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change the color of the background to make your own custom style");
				//ImGui::PopItemWidth();


				ChangeColor[0] = pref.title_style.x;
				ChangeColor[1] = pref.title_style.y;
				ChangeColor[2] = pref.title_style.z;
				ChangeColor[3] = 1.0f;
				ImGui::SameLine();
				if (ImGui::ColorPicker4("##ChangehighlightColor", &ChangeColor[0], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_DisplayRGB))
				{
					pref.title_style.x = ChangeColor[0];
					pref.title_style.y = ChangeColor[1];
					pref.title_style.z = ChangeColor[2];
					change_colors = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change the color of the highlight to make your own custom style");
				ImGui::PopItemWidth();


			}

			if (change_colors) {
				if (pref.current_style == 0 || pref.current_style >= 10 && pref.current_style != 25) {
					//myStyle2_colors_only();
					myStyle2(NULL);
				}
				if (pref.current_style == 1) {
					myDarkStyle(NULL);
				}
				if (pref.current_style == 3) {
					myLightStyle(NULL);
				}
				if (pref.current_style == 25) {
					myStyleBlue(NULL);
				}
				SetIconSet();
			}

			ImGui::PushItemWidth(-10);
			ImGui::Indent(-10);
			ImGui::Text("");
			ImGui::Text("Windows Layout");
			ImGui::Text("");
			ImGui::Indent(10);
			float w = ImGui::GetContentRegionAvailWidth() - 10.0f;
			if (ImGui::StyleButton("Reset Interface",ImVec2(w,0)) ) {
				refresh_gui_docking = 0;
				MaximiseWindow(); 
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "This will reset the interface to fit the current desktop size");

			/*
			if (ImGui::StyleButton("Reset view to current window size", ImVec2(w, 0)) ) {
				refresh_gui_docking = 0;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reset view to current window size");
			*/

			ImGui::Indent(-10);

			ImGui::PopItemWidth();

			ImGui::Columns(1);
			ImGui::EndTabItem();
		}

		flags = 0;
		if (iSetSettingsFocusTab == 2)
			flags = ImGuiTabItemFlags_SetSelected;

		if (ImGui::BeginTabItem(" Advanced ", NULL , flags) )
		{
			static bool bCheckedInitialState = false;
			iCurrentTab = 1;
			if (iSetSettingsFocusTab == 2) iSetSettingsFocusTab = 0;
			static int iAdvCountDown = 10;
			if (iAdvCountDown > 0) 
			{
				iAdvCountDown--;
				if (iAdvCountDown == 0)
				{
					if (pref.iObjectEnableAdvanced == 2)
					{
						// skip message warnings when advanced user is in compact mode
					}
					else
					{
						/* removed, annoying everyone - added warning to user manual instead
						int iAction = askBoxCancel("Are you sure you want to change settings in here? This will add a lot of additional features to the software.", "Warning"); //1==Yes 2=Cancel 0=No
						if (iAction != 1)
						{
							iAdvCountDown = 10;
							iSetSettingsFocusTab = 1;
						}
						*/
					}
				}
			}

			ImGui::Columns(2, "preferencesAdvancedcolumns2", false);  //false no border

			ImGui::PushItemWidth(-10);
			ImGui::Text("Panel and Drop-Down Menu Advanced Settings");
			ImGui::Indent(10);

			bool bTmp = pref.bAutoOpenMenuItems;
			if (ImGui::Checkbox("Auto Open Drop-down Menus", &bTmp)) {
				pref.bAutoOpenMenuItems = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Automatically open drop down menus (without clicking)");

			bTmp = pref.iEnableSingleRightPanelAdvanced;
			if (ImGui::Checkbox("Show Multiple Panels in Tabs", &bTmp)) {
				pref.iEnableSingleRightPanelAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allow tabbed sections in the right panel");

			bTmp = pref.iEnableAdvancedEntityList;
			if (ImGui::Checkbox("Allow Selection of the Collection List", &bTmp)) {
				current_sort_order = 0;
				pref.iEnableAdvancedEntityList = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enable the collection list filter in the level objects window");

			void ToggleDPIAwareness(bool);
			// DPI Awareness Flag
			bool bDPIAware = true;
			// read DPI Aware from registry
			char pDPINotAware[256];
			strcpy(pDPINotAware, "0");
			HKEY hKeyNames = 0;
			DWORD Status = RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\GameGuruMAX", 0L, KEY_READ, &hKeyNames);
			if (Status == ERROR_SUCCESS)
			{
				DWORD Type = REG_SZ;
				DWORD Size = 256;
				Status = RegQueryValueExA(hKeyNames, "DPINotAware", NULL, &Type, NULL, &Size);
				if (Size < 255)
				{
					RegQueryValueExA(hKeyNames, "DPINotAware", NULL, &Type, (LPBYTE)pDPINotAware, &Size);
				}
				RegCloseKey(hKeyNames);
			}
			if (pDPINotAware[0] == '1') bDPIAware = false;
			if (ImGui::Checkbox("Enable DPI Awareness", &bDPIAware))
			{
				ToggleDPIAwareness(bDPIAware);
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "If the UI is too large, enable DPI awareness to improve the scale. Requires a restart to see changes");
			ImGui::Indent(-10);
			ImGui::PopItemWidth();

			ImGui::PushItemWidth(-10);
			//ImGui::Text("");
			ImGui::Spacing();
			ImGui::Text("Game Editing Advanced Settings");
			ImGui::Indent(10);

			bTmp = pref.iEnableAxisRotationShortcuts;
			if (ImGui::Checkbox("Allow Axis Rotation Shortcuts", &bTmp)) {
				pref.iEnableAxisRotationShortcuts = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allows you to rotate a selected object with keys 1 through 6");

			bTmp = pref.iEnableLevelEditorOpenAndNew;
			if (ImGui::Checkbox("Level Editor - Allow New And Open Options", &bTmp)) {
				pref.iEnableLevelEditorOpenAndNew = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allows you to use menu options new and open from level editor");

			//New and Open options.


			bTmp = pref.iEnableIdentityProperties;
			if (ImGui::Checkbox("Display Identity in Object Tools", &bTmp)) {
				pref.iEnableIdentityProperties = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Display the identity of the selected object in the tools panel");

#ifdef STORYBOARD
			bTmp = pref.iStoryboardAdvanced;
			if (ImGui::Checkbox("Game Storyboard", &bTmp)) {
				pref.iStoryboardAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Game Storyboard settings");
#endif
#ifdef PROCEDURALTERRAINWINDOW
			bTmp = pref.iTerrainAdvanced;
			if (ImGui::Checkbox("Terrain Generator", &bTmp)) {
				pref.iTerrainAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Terrain Generator settings");

			bTmp = pref.iEnableTerrainHeightmaps;
			if (ImGui::Checkbox("Terrain Heightmaps", &bTmp)) {
				pref.iEnableTerrainHeightmaps = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show settings for importing heightmaps during terrain generation");
#endif

			bTmp = pref.iObjectEnableAdvanced;
			if (ImGui::Checkbox("Object Tools", &bTmp)) 
			{
				pref.iObjectEnableAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Object Tools settings");
			if (pref.iObjectEnableAdvanced)
			{
				ImGui::SameLine();
				bTmp = false;
				if (pref.iObjectEnableAdvanced == 2) bTmp = true;
				if (ImGui::Checkbox("Compact Pos/Rot/Scl", &bTmp))
				{
					if (bTmp==false)
						pref.iObjectEnableAdvanced = 1;
					else
						pref.iObjectEnableAdvanced = 2;
					bCheckedInitialState = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Compact the Position, Rotation and Scale and keep component open");
			}

			bTmp = pref.iEnableAdvancedWater;
			if (ImGui::Checkbox("Water", &bTmp)) {
				pref.iEnableAdvancedWater = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Water customization settings");

			bTmp = pref.iEnableAdvancedCharacterCreator;
			if (ImGui::Checkbox("Character Creator", &bTmp)) {
				pref.iEnableAdvancedCharacterCreator = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Character Creator settings");

			bTmp = pref.iFullscreenPreviewAdvanced;
			if (ImGui::Checkbox("Object Library Preview Details", &bTmp)) {
				pref.iFullscreenPreviewAdvanced = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show more details about an object when viewing in full screen mode in the object library");
			ImGui::Indent(-10);
			ImGui::PopItemWidth();

			ImGui::NextColumn();

			ImGui::PushItemWidth(-10);
			//ImGui::Text("");
			ImGui::Text("Advanced Environmental Effects");
			ImGui::Indent(10);

			 bTmp = pref.iEnableAdvancedSky;
			if (ImGui::Checkbox("Sky", &bTmp)) {
				pref.iEnableAdvancedSky = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the Advanced Sky customization settings");

			bTmp = pref.iEnableAdvancedPostProcessing;
			if (ImGui::Checkbox("Post Processing", &bTmp)) {
				pref.iEnableAdvancedPostProcessing = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reveal the Post Processing properties section");

			bTmp = pref.iEnableAdvancedShadows;
			if (ImGui::Checkbox("Shadows", &bTmp)) {
				pref.iEnableAdvancedShadows = bTmp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reveal the Shadows properties section");
			ImGui::Indent(-10);
			ImGui::PopItemWidth();

			ImGui::Text("");
			ImGui::Indent(10);

			// Determine if all the settings are on/off to check required state change.
			static std::array<int*, 16> advancedsettings = {
			&pref.bAutoOpenMenuItems,
			&pref.iEnableSingleRightPanelAdvanced,
			&pref.iEnableAdvancedEntityList,
			&pref.iEnableAxisRotationShortcuts,
			&pref.iEnableIdentityProperties,
			&pref.iStoryboardAdvanced,
			&pref.iTerrainAdvanced,
			&pref.iObjectEnableAdvanced,
			&pref.iEnableAdvancedWater,
			&pref.iEnableAdvancedCharacterCreator,
			&pref.iFullscreenPreviewAdvanced,
			&pref.iEnableAdvancedSky,
			&pref.iEnableAdvancedPostProcessing,
			&pref.iEnableAdvancedShadows,
			&pref.iImporterDome,
			&pref.iEnableAdvancedGrass
			};

			static bool bAllEnabled = false;
			
			// Check the initial state once, so that the correct button label can be assigned.
			if (!bCheckedInitialState)
			{
				bCheckedInitialState = true;
				int iEnabledSettings = 0;
				for (int i = 0; i < advancedsettings.size(); i++)
				{
					if (*advancedsettings[i] == 1)
						iEnabledSettings++;
				}
				if (iEnabledSettings == advancedsettings.size())
					bAllEnabled = true;		
			}
			
			char title[250];
			if (bAllEnabled)
				strcpy(title, "Turn Off All Advanced Settings");
			else
				strcpy(title, "Turn On All Advanced Settings");

			if (ImGui::StyleButton(title, ImVec2(ImGui::GetContentRegionAvailWidth() - 10, 0.0f))) 
			{
				int iEnabledSettings = 0;
				for (int i = 0; i < advancedsettings.size(); i++)
				{
					if (*advancedsettings[i] == 1)
						iEnabledSettings++;
				}

				int iDesiredValue = 1;
				if (iEnabledSettings == advancedsettings.size())
				{
					iDesiredValue = 0;
					if(bDPIAware)
						ToggleDPIAwareness(!bDPIAware);
				}
				
				for (int i = 0; i < advancedsettings.size(); i++)
					*advancedsettings[i] = iDesiredValue;

				if (iDesiredValue)
				{
					// Handle DPI Awareness differently.
					if (!bDPIAware)
						ToggleDPIAwareness(!bDPIAware);

					bAllEnabled = true;
				}
				else
					bAllEnabled = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle all advanced settings on or off");
			ImGui::Indent(-10);

			// Custom Writables Folder
			ImGui::Text("");
			ImGui::Text("Writables Folder Location");
			ImGui::Indent(10);
			float path_gadget_size = ImGui::GetFontSize()*2.0;
			ImGui::PushItemWidth(-10 - path_gadget_size);
			extern char szWriteDir[MAX_PATH];
			static bool bWriteFolderActive = false;
			if (strlen(pref.cCustomWriteFolder) > 0) bWriteFolderActive = true;
			if (ImGui::Checkbox("Allow the Writables Folder to be changed", &bWriteFolderActive)) 
			{
				if (!bWriteFolderActive)
				{
					strcpy(pref.cCustomWriteFolder, "");
					SetUpdaterWritePathFile(pref.cCustomWriteFolder);		
					strcpy(cPreferencesMessage, "Please restart MAX for this change to take effect!");
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose a new writables location where your projects are to be saved by default");
			if (bWriteFolderActive)
			{
				if (strlen(pref.cCustomWriteFolder) == 0)
					ImGui::InputText("##InputCustomWriteFolder", &szWriteDir[0], 250, ImGuiInputTextFlags_ReadOnly);
				else
					ImGui::InputText("##InputCustomWriteFolder", &pref.cCustomWriteFolder[0], 250, ImGuiInputTextFlags_ReadOnly);

				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Current Writables Folder");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				ImGui::SameLine();
				ImGui::PushItemWidth(path_gadget_size);
				if (ImGui::StyleButton("...##pathCustomWriteFolder")) 
				{
					//PE: filedialogs change dir so.
					cStr tOldDir = GetDir();
					char * cFileSelected;
					cstr fulldir = pref.cCustomWriteFolder;
					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0) 
					{
						strcpy(pref.cCustomWriteFolder, cFileSelected);
						SetUpdaterWritePathFile(pref.cCustomWriteFolder);
						if (pref.cCustomWriteFolder[strlen(pref.cCustomWriteFolder) - 1] != '\\') strcat(pref.cCustomWriteFolder, "\\");
						strcpy(cPreferencesMessage, "Please restart MAX for this change to take effect!");
					}
					//Validate Write ?
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose a new writables location where your projects are to be saved by default");
				ImGui::PopItemWidth();
			}
			ImGui::PopItemWidth();

			ImGui::Text("");
			ImGui::Indent(-10);
			ImGui::Text("Default Import Folder Location");

			ImGui::Indent(10);
			path_gadget_size = ImGui::GetFontSize()*2.0;
			ImGui::PushItemWidth(-10 - path_gadget_size);
			ImGui::InputText("##InputDefaultImportFolder", &pref.cDefaultImportPath[0], 250, ImGuiInputTextFlags_ReadOnly);
			ImGui::PopItemWidth();
			if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select a new folder path from where to import models");
			if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

			ImGui::SameLine();
			ImGui::PushItemWidth(path_gadget_size);
			if (ImGui::StyleButton("...##pathDefaultImportFolder")) {
				//PE: filedialogs change dir so.
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cstr fulldir = pref.cDefaultImportPath;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
				SetDir(tOldDir.Get());
				if (cFileSelected && strlen(cFileSelected) > 0) {
					strcpy(pref.cDefaultImportPath, cFileSelected);
					if (pref.cDefaultImportPath[strlen(pref.cDefaultImportPath) - 1] != '\\')
						strcat(pref.cDefaultImportPath, "\\");
					sDefaultImportPath = pref.cDefaultImportPath;
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select a new folder path from where to import models");
			ImGui::PopItemWidth();

			bool bTemp = pref.iImporterDome;
			if (ImGui::Checkbox("Show the Importer 'Dome' environment", &bTemp))
			{
				pref.iImporterDome = bTemp;
				bCheckedInitialState = false;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("During the import process, a dome shape surrounds the imported model, use this to turn it off");

			ImGui::Indent(-10);
			ImGui::Columns(1);
			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem(" Developer "))
		{
			iCurrentTab = 2;

			static int iDevCountDown = 10;
			if (iDevCountDown > 0) 
			{
				iDevCountDown--;
				if (iDevCountDown == 0)
				{
					if (pref.iObjectEnableAdvanced == 2)
					{
						// skip message warnings when advanced user is in compact mode
					}
					else
					{
						/* removed, annoying everyone - added warning to user manual instead
						int iAction = askBoxCancel("Be aware these settings are for developers only, Are you very sure you want to change any of these settings ?", "Warning"); //1==Yes 2=Cancel 0=No
						if (iAction != 1)
						{
							iDevCountDown = 10;
							iSetSettingsFocusTab = 1;
						}
						*/
					}
				}
			}

			ImGui::Columns(2, "preferencestoolscolumns2", false);  //false no border

			ImGui::Text("Developer Modules");
			ImGui::Indent(10);
			extern int g_iDevToolsOpen;
			bool bT = (bool)g_iDevToolsOpen;
			if (ImGui::Checkbox("Show Additional Developer Options", &bT))
			{
				g_iDevToolsOpen = bT;
				pref.iDevToolsOpen = g_iDevToolsOpen;
				wiProfiler::SetEnabled(bProfilerEnable);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Enable additional settings (auto-refresh library folders, physics debugging, developer mode tools, save anim templates)");
			
			if (ImGui::Checkbox("Enable the 3D Editor Profiler", &bProfilerEnable))
			{
				wiProfiler::SetEnabled(bProfilerEnable);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Display the rendering profile data in the level editor");
			//ImGui::NextColumn();
			//ImGui::Text("");
			//ImGui::Text("");
			//ImGui::NextColumn();
			ImGui::Indent(-10);

			ImGui::Text("");
			ImGui::Text("Multi-Monitor Support");
			ImGui::Indent(10);
			bool bTmp = pref.iAllowUndocking;
			if (ImGui::Checkbox("Enable Window Undocking", &bTmp)) {
				pref.iAllowUndocking = bTmp;
				if (pref.iAllowUndocking)
				{
					//PE: When enabling we need to reset layout, or docked windows display with no tabbar, and docking node can hide.
					//PE: This is caused by window where we set ImGuiDockNodeFlags_NoTabBar. so need reset nodes.
					refresh_gui_docking = 0;
					MaximiseWindow();
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Allows you to move and dock/undock the various level editor windows");

			bTmp = pref.iDisableObjectLibraryViewport;
			if (ImGui::Checkbox("Disable Multi-Viewport", &bTmp)) {
				pref.iDisableObjectLibraryViewport = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Don't allow windows to be moved to another monitor or viewport");
			ImGui::Indent(-10);

			//

			ImGui::Text("");
			ImGui::Text("VR Support");
			ImGui::Indent(10);
			ImGui::Text("Ensure you have correctly configured your OpenXR runtime");
			ImGui::Text("as OpenXR needs to know which VR device you are using:");
			bool bVRFlag = false;
			if (g.gvrmode > 0) bVRFlag = true;
			if (ImGui::Checkbox("Enable Virtual Reality Support", &bVRFlag))
			{
				// toggle vr support
				if (bVRFlag == true) 
					g.gvrmode = 2;
				else
					g.gvrmode = 0;

				// save setting
				FPSC_SaveSETUPVRINI();

				// if been activated, init system (no need to relaunch with OpenXR)
				extern void vr_init(void);
				vr_init();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Activates experimental support for VR via OpenXR");
			ImGui::Indent(-10);

			//

			if (g_iDevToolsOpen != 0)
			{
				//ImGui::PushItemWidth(-10);
				ImGui::Text("");
				ImGui::Text("Developer Mode Tools");

				float save_gadget_size = ImGui::GetFontSize()*10.0;
				float w = ImGui::GetWindowContentRegionWidth();

				ImGui::Indent(10);
				w = ImGui::GetContentRegionAvailWidth();
				if (ImGui::StyleButton("Reset Auto Start Videos", ImVec2(save_gadget_size*1.3, 0))) 
				{
					CloseAllOpenTools();
					pref.iResetAutoRunVideosOnNextStartup = 1;
					bPreferences_Window = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset introduction videos for so they play automatically once as though a new user");
				ImGui::Indent(-10);
			}

			ImGui::NextColumn();
			ImGui::Indent(10);

			//ImGui::Text("");
			ImGui::Text("Object Management Options");
			ImGui::Indent(10);
			bTmp = pref.iDragCameraMovement;
			if (ImGui::Checkbox("Use Drag Camera Movement", &bTmp)) 
			{
				pref.iDragCameraMovement = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Left click and drag the terrain to move the camera position around in the Level Editor");

			bTmp = pref.iEnableDragDropEntityMode;
			if (ImGui::Checkbox("Drag/Drop Entity Mode", &bTmp)) {
				pref.iEnableDragDropEntityMode = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "When ticked you can drag and drop objects, unticked you have to click to select an object then again to place it");

			if (pref.iEnableDragDropEntityMode)
			{
				ImGui::Indent(20);
				bTmp = pref.iEnableDragDropWidgetSelect;
				if (ImGui::Checkbox("Enable Widget When Needed", &bTmp)) {
					pref.iEnableDragDropWidgetSelect = bTmp;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Show the 3D widget for movement, rotation and scaling");
				ImGui::Indent(-20);

				ImGui::Indent(20);
				bTmp = pref.iEnableDragDropStopSelectFromInside;
				if (ImGui::Checkbox("Stop object from being moved when camera is inside", &bTmp)) {
					pref.iEnableDragDropStopSelectFromInside = bTmp;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Tick this if you want to avoid selecting objects (eg buildings) when viewed inside of them");
				ImGui::Indent(-20);
			}

			bTmp = pref.iEnableEditorOutlineSelection;
			if (ImGui::Checkbox("Use Outline For Selected Editor Objects", &bTmp)) {
				pref.iEnableEditorOutlineSelection = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Add a yellow outline around the currently selected object");

			if (pref.iEnableEditorOutlineSelection)
			{
				//ImGui::SameLine();
				ImGui::Indent(20);
				ImGui::SliderFloat("##OutlineThicknessSmall", &pref.fHighLightThickness, 0.0, 6.0, "%.2f");
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set the outline's thickness with this slider");
				ImGui::Indent(-20);
			}

			ImGui::Text("");
			ImGui::Text("Other Developer Options");

			bTmp = pref.iEnableFpsMemMonitor;
			if (ImGui::Checkbox("Show Live FPS And Memory Stats", &bTmp)) {
				pref.iEnableFpsMemMonitor = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Show Live FPS And Memory Stats");

			bTmp = pref.iEnableAutoExposureInEditor;
			if (ImGui::Checkbox("Use Auto Exposure in Editor", &bTmp)) {
				if (!pref.iEnableAutoExposureInEditor)
				{
					//Set autoexposure on if first time. if set in visuals.
					master_renderer->setEyeAdaptionEnabled(t.visuals.bAutoExposure);
				}
				pref.iEnableAutoExposureInEditor = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("The auto exposure effect can be turned on and off during editing of a level");

			//pref.iEnableAutoExposureInEditor
			//pref.iEnableDeveloperProperties = false;
			
			bTmp = pref.iEnableDeveloperObjectTools;
			if (ImGui::Checkbox("Display Object Tools Developer Mode", &bTmp)) 
			{
				pref.iEnableDeveloperObjectTools = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Shows the developer section in the objects panel");
			
			bTmp = pref.iEnableDeveloperProperties;
			if (ImGui::Checkbox("Display AI Management in Test Level", &bTmp)) 
			{
				pref.iEnableDeveloperProperties = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Shows the AI management options and gives access to Behavior Editing");

			bTmp = pref.iDisableProjectAutoSave;
			if (ImGui::Checkbox("Disable Storyboard Auto Save", &bTmp)) {
				pref.iDisableProjectAutoSave = bTmp;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Turn on and off the auto save system");

			#ifdef PROCEDURALTERRAINWINDOW
			if (g_iDevToolsOpen)
			{
				bTmp = pref.iTerrainDebugMode;
				if (ImGui::Checkbox("Display Terrain Debug Mode", &bTmp)) {
					pref.iTerrainDebugMode = bTmp;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Reveals the terrain debugging mode in the terrain panel in the level editor");
			}
			else
			{
				pref.iTerrainDebugMode = 0;
			}
			#endif

			
			ImGui::Indent(-10);
			ImGui::Columns(1);
			ImGui::EndTabItem();
		}


		ImGui::EndTabBar();
	}

	//ImGui::Separator();
	ImGui::Text("");
	if (strlen(cPreferencesMessage) > 0)
	{
		ImGui::SetWindowFontScale(1.25);
		ImGui::TextCenter(cPreferencesMessage);
		ImGui::SetWindowFontScale(1.0);
	}
	ImVec2 ws = ImGui::GetWindowSize();
	ImGui::Indent();
	if (ImGui::GetCursorPosY() < ws.y - (fs * 4))
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ws.y - (fs * 4) + ImGui::GetScrollY()));

	float save_gadget_size = ImGui::GetFontSize()*10.0;

	if (ImGui::StyleButton("Reset to Defaults", ImVec2(save_gadget_size,0.0f)) )
	{
		int iAction = askBoxCancel("This will change all your settings back to the defaults, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
		if (iAction == 1)
		{
			pref.current_style = 25; // 0

			pref.tint_style = ImVec4(1.0, 1.0, 1.0, 1.0);
			pref.shade_style = ImVec4(0.0, 0.0, 0.0, 0.0);
			pref.title_style = ImVec4(0.0, 0.0, 0.0, 0.0);

			pref.iMaximized = 1;
			pref.bHideTutorials = false;
			pref.bMultiplyOpenHeaders = false;
			pref.bAutoClosePropertySections = true;
			pref.bAutoOpenMenuItems = true;
			pref.bDisableMultipleViewport = false;
			pref.iTurnOffUITransparent = false;
			pref.iEnableCustomColors = 0;
			pref.iEnableAdvancedSky = 0;
			pref.iEnableAdvancedWater = 0;
			pref.iEnableAdvancedPostProcessing = 0;
			pref.iEnableAdvancedShadows = 0;
			pref.iObjectEnableAdvanced = 0;
			pref.iEnableArcRelationshipLines = 1;
			pref.iAllowUndocking = 0;
			pref.iEnableAxisRotationShortcuts = 0;

			pref.iEnableDragDropWidgetSelect = 0;

			pref.iEnableEditorOutlineSelection = 1;
			pref.iEnableSingleRightPanelAdvanced = 0;

			pref.iEnableDragDropEntityMode = 1;

			strcpy(pref.cCustomWriteFolder, "");
			SetUpdaterWritePathFile(pref.cCustomWriteFolder);
			strcpy(pref.cDefaultImportPath, "");
			strcpy(pref.cDefaultStandalonePath, "");
			strcpy(pref.cRememberLastSearchObjects, "");

			for (int i = 0; i < 10; i++)
				pref.iCheckboxFilters[i] = 1;

			pref.iEnableDeveloperProperties = 0;
			pref.iEnableIdentityProperties = 1;
			pref.iDragCameraMovement = 1;

			pref.iGameCreaterStore = 0;
			pref.iFullscreenPreviewAdvanced = 0;
			pref.iDisplayWelcomeScreen = 1;
			pref.iDisplayIntroScreen = 1;
			pref.iImporterDome = 1;
			pref.iTerrainAdvanced = 0;
			pref.iTerrainDebugMode = 0;
			pref.iEnableAdvancedCharacterCreator = 0;
			pref.iStoryboardAdvanced = 0;
			pref.iDisableProjectAutoSave = 0;
			pref.iDisableLevelAutoSave = 0;

			pref.iSplashStartMessage = 0;
			pref.iTitleStartMessage = 0;
			pref.iLoadingStartMessage = 0;
			pref.iGameWonStartMessage = 0;
			pref.iGameOverStartMessage = 0;

			pref.iHideKeyboardShortcuts = 0;
			pref.iEnableDeveloperObjectTools = 0;
			pref.iEnableTerrainHeightmaps = 0;

			for (int il = 0;il < 16; il++)
			{
				pref.vSaved_Light_Palette_R[il] = 1.0f;
				pref.vSaved_Light_Palette_G[il] = 1.0f;
				pref.vSaved_Light_Palette_B[il] = 1.0f;
				pref.iSaved_Light_Type[il] = -1;
				pref.iSaved_Light_Range[il] = 0;
				pref.fSaved_Light_ProbeScale[il] = 1.0f;
				pref.iSaved_Light_Radius[il] = 45;
				pref.fSaved_Light_AngX[il] = 90;
				pref.fSaved_Light_AngY[il] = 0;
				pref.fSaved_Light_AngZ[il] = 0;
			}

			for (int il = 0;il < 16; il++)
			{
				strcpy(pref.Saved_Particle_Name[il], "");
				pref.Saved_bParticle_Preview[il] = true;
				pref.Saved_bParticle_Show_At_Start[il] = true;
				pref.Saved_bParticle_Looping_Animation[il] = true;
				pref.Saved_bParticle_Full_Screen[il] = false;
				pref.Saved_fParticle_Fullscreen_Duration[il] = 10.0f;
				pref.Saved_fParticle_Fullscreen_Fadein[il] = 1.0f;
				pref.Saved_fParticle_Fullscreen_Fadeout[il] = 1.0f;
				strcpy(pref.Saved_Particle_Fullscreen_Transition[il], "");
				pref.Saved_fParticle_Speed[il] = 1.0f;
				pref.Saved_fParticle_Opacity[il] = 1.0f;
			}

			pref.iEnableAdvancedEntityList = 0;
			pref.fHighLightThickness = 1.0;
			pref.iTurnOffEditboxTooltip = false;
			pref.iEnableAutoExposureInEditor = 0;
			pref.iSetColumnsEntityLib = 3;

			pref.iDisableObjectLibraryViewport = 1;
			strcpy(pref.cLastUsedStoryboardProject, "");

			pref.iEnableLevelEditorOpenAndNew = 0;
			pref.iDisplayTerrainGeneratorWelcome = 1;
			pref.iTestGameGraphicsQuality = 2;
			pref.iEnableAutoFlattenSystem = 1;

			pref.iEnableAdvancedGrass = 0;
			pref.iEnableFpsMemMonitor = 0;
			pref.iEnableAutoFlattenSystem = 1;
			pref.iProjectSortMode = 0;

			pref.iEnableDragDropStopSelectFromInside = 0;

			if (pref.current_style == 0 || pref.current_style >= 10 && pref.current_style != 25) {
				//myStyle2_colors_only();
				myStyle2(NULL);
			}
			if (pref.current_style == 1) {
				myDarkStyle(NULL);
			}
			if (pref.current_style == 3) {
				myLightStyle(NULL);
			}
			if (pref.current_style == 25) {
				myStyleBlue(NULL);
			}

			SetIconSet();

			refresh_gui_docking = 0;
			if (bProfilerEnable) {
				bProfilerEnable = false;
				wiProfiler::SetEnabled(bProfilerEnable);
			}
			MaximiseWindow();
		}
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset everything to default values");

	vLastWindowSize = ImGui::GetWindowSize();
	fLastContentWidth = ImGui::GetContentRegionAvailWidth();

//	if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
//		//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
//		ImGui::Text("");
//		ImGui::Text("");
//	}

	bImGuiGotFocus = true;


	ImGui::End();
	if (bDigAHoleToHWND && bwindow)
		bwindow->DrawList->AddCallback((ImDrawCallback)11, NULL); //disable force render.

}
#endif

void CloseAllOpenTools(bool bTerrainTools)
{
	if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
	if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
	if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
	if (bEntity_Properties_Window) bEntity_Properties_Window = false;
	if (t.ebe.on == 1) ebe_hide();
	if (bTerrainTools)
	{
		if (bTerrain_Tools_Window) bTerrain_Tools_Window = false;
		//if (Visuals_Tools_Window) Visuals_Tools_Window = false; //PE: Now toggle.
	}
	#ifdef WICKEDENGINE
	if (Shooter_Tools_Window)
		Shooter_Tools_Window = false;
	#endif
}

void CloseAllOpenToolsThatNeedSave(void)
{
	if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
	if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
	if (t.ebe.on == 1) ebe_hide();
}

#ifdef WICKEDENGINE
void imgui_shooter_tools(void)
{
	if (ImGui::windowTabVisible())
	{
		Shooter_Tools_Window_Active = true;

		// globals
		#ifndef REMOVED_EARLYACCESS
		if (ImGui::StyleCollapsingHeader("Shooter Settings", ImGuiTreeNodeFlags_DefaultOpen))
		{
			ImGui::Indent(10);
			ImGui::TextCenter("Level Difficulty");
			if (ImGui::MaxSliderInputFloat("##ShooterfLevelDifficulty", &t.visuals.fLevelDifficulty, 0.0f, 100.0f, "Set Level Difficulty"))
			{
				t.gamevisuals.fLevelDifficulty = t.visuals.fLevelDifficulty;
			}
			ImGui::Indent(-10);
		}
		#endif

		// if have selection selected
		bool bRubberBand = false;
		bool bToolsOpen = false;
		int iEntID = 0;
		int iEntIndex = t.widget.pickedEntityIndex;
		if (!pref.iEnableRelationPopupWindow && bDotMiddleWindow && g_selected_middle_dot_pobject)
		{
			int iDotMiddleIndex = g_selected_middle_dot_pobject->dwObjectNumber - DOTMIDDLEOBJECTID;
			if (iDotMiddleIndex >= 0 && iDotMiddleIndex < MAXDOTMIDDLE)
			{
				if (ImGui::StyleCollapsingHeader("Shooter Connections", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);
					DisplayRelationshipMenu(iDotMiddleIndex, 0);
					ImGui::Indent(-10);
				}
			}
		}
		else if (t.widget.pickedObject != 0)
		{
			if (iEntIndex > 0)
			{
				iEntID = t.entityelement[iEntIndex].bankindex;
				if (iEntID > 0)
					if (t.entityprofile[iEntID].ischaracter > 0)
						bToolsOpen = true;
			}
			// rubber band
			if (g.entityrubberbandlist.size() > 0)
			{
				bRubberBand = true;
				//Any chars selected.
				for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
				{
					int e = g.entityrubberbandlist[i].e;
					if (e > 0)
					{
						int tobj = t.entityelement[e].obj;
						if (t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
						{
							bToolsOpen = true;
						}
					}
				}
			}
			if (!bRubberBand && iEntIndex <= 0)
				bToolsOpen = false;

			if (bToolsOpen)
			{
				// ZJ: Moved to character settings.
				/*
				//PE: A char is selected.
				//Character
				if (ImGui::StyleCollapsingHeader("Character Logic", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);
					ImGui::TextCenter("Allegiance");
					ImGui::PushItemWidth(-10);
					if (!bRubberBand)
					{
						// ZJ: Moved to character settings.
						////PE: Single Char
						//const char* items_combo[] = { "Enemy", "Ally", "Neutral" };
						//if (ImGui::Combo("##ShooteriCharAlliance", &t.entityelement[iEntIndex].eleprof.iCharAlliance, items_combo, IM_ARRAYSIZE(items_combo)))
						//{
						//	//No function yet.
						//}
						//if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Alliance");

					}
					else
					{
						//PE: As we can have diffent results , start by displaying change all.
						const char* items_combo[] = { "... change all to ...", "Enemies", "Allies", "Neutrale" };
						
						int new_selection = t.entityelement[g.entityrubberbandlist[0].e].eleprof.iCharAlliance;
						bool bGotSameSelection = true;
						//Check if all selection are the same.
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
							{
								if (t.entityelement[e].eleprof.iCharAlliance != new_selection)
								{
									bGotSameSelection = false;
									break;
								}
							}
						}
						if (bGotSameSelection)
							new_selection++;
						else
							new_selection = 0;
						
						if (ImGui::Combo("##ShooteriCharAlliancem", &new_selection, items_combo, IM_ARRAYSIZE(items_combo)))
						{
							if (new_selection > 0)
							{
								new_selection--;
								for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
								{
									int e = g.entityrubberbandlist[i].e;
									if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
									{
										t.entityelement[e].eleprof.iCharAlliance = new_selection;
									}
								}
							}
						}
						if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Alliance");
					}
					ImGui::PopItemWidth();
					ImGui::Indent(-10);
				}
				*/

				#ifndef REMOVED_EARLYACCESS
				if (t.visuals.sFactionName[0] == "")
				{
					t.visuals.sFactionName[0] = "Faction 1";
					t.visuals.sFactionName[1] = "Faction 2";
					t.visuals.sFactionName[2] = "Faction 3";
					for (int iL = 0; iL < 16; iL++)
						bFactionWindow[iL] = false;
				}
				for (int iL = 0; iL < 16; iL++)
				{
					if (bFactionWindow[iL])
					{
						//Ask for a proper name of faction.
						ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 8 * ImGui::GetFontSize()), ImGuiCond_Once);
						ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
						cstr sUniqueWinName = cstr("Faction Name##ttn") + cstr(iL);
						ImGui::Begin(sUniqueWinName.Get(), &bFactionWindow[iL], 0);
						ImGui::Indent(10);
						static char NewTextureName[256];
						cstr sUniqueInputName = cstr("##InputFactionName") + cstr(iL);
						ImGui::PushItemWidth(-10);
						ImGui::Text("Enter a name for faction:");

						if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0))
							ImGui::SetKeyboardFocusHere(0);

						if (t.visuals.sFactionName[iL] == " ")
							t.visuals.sFactionName[iL] = "";

						if (ImGui::InputText(sUniqueInputName.Get(), t.visuals.sFactionName[iL].Get(), 250, ImGuiInputTextFlags_EnterReturnsTrue)) {
							t.gamevisuals.sFactionName[iL] = t.visuals.sFactionName[iL];
							bFactionWindow[iL] = false;
						}
						if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

						if (t.visuals.sFactionName[iL] == "")
							t.visuals.sFactionName[iL] = " ";
						ImGui::PopItemWidth();
						ImGui::Indent(-10);
						if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
						{
							//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
							ImGui::Text("");
							ImGui::Text("");
						}
						bImGuiGotFocus = true;
						ImGui::End();
					}
				}

				if (t.entityelement[iEntIndex].eleprof.iCharAlliance == 1)
				{
					// only for an enemy do they have a faction
					ImGui::Indent(10);
					ImGui::TextCenter("Enemy Faction");
					//PE: New code support both rubberband and single changes.
					if (1)
					{
						int UseEntIndex = iEntIndex;

						if (bRubberBand)
							UseEntIndex = g.entityrubberbandlist[0].e;

						bool bGotSameSelection = true;

						int new_selection = t.entityelement[UseEntIndex].eleprof.iCharFaction;
						if (bRubberBand)
						{
							//Check if all selection are the same.
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
								{
									if (t.entityelement[e].eleprof.iCharFaction != new_selection)
									{
										bGotSameSelection = false;
										break;
									}
								}
							}
						}
						cstr cFactionName = "";
						if (t.entityelement[UseEntIndex].eleprof.iCharFaction >= 0 && t.entityelement[UseEntIndex].eleprof.iCharFaction < 16)
							cFactionName = t.visuals.sFactionName[t.entityelement[UseEntIndex].eleprof.iCharFaction];

						if (bRubberBand && !bGotSameSelection)
						{
							cFactionName = "... change all to ...";
						}

						if (ImGui::BeginCombo("##SelectFactionName", cFactionName.Get()))
						{
							int iCountIndex = 0;
							for (int iL = 0; iL < 16; iL++)
							{
								if (t.visuals.sFactionName[iL] != "")
								{
									bool is_selected = false;
									if (t.entityelement[UseEntIndex].eleprof.iCharFaction == iCountIndex)
										is_selected = true;
									if (ImGui::Selectable(t.visuals.sFactionName[iL].Get(), is_selected))
									{
										t.entityelement[UseEntIndex].eleprof.iCharFaction = iCountIndex;
										if (bRubberBand)
										{
											for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
											{
												int e = g.entityrubberbandlist[i].e;
												if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
												{
													t.entityelement[e].eleprof.iCharFaction = iCountIndex;
												}
											}
										}
									}
									if (is_selected)
										ImGui::SetItemDefaultFocus();

									ImVec2 cpos = ImGui::GetCursorPos();

									ImGui::SetItemAllowOverlap();
									ImGui::SetCursorPos(ImVec2(cpos.x + ImGui::GetContentRegionAvail().x - 30.0f, cpos.y - (ImGui::GetFontSize()*1.5) - 3.0));
									ImGui::PushID(99 + iL);
									if (ImGui::ImgBtn(TOOL_PENCIL, ImVec2(16, 16), ImColor(255, 255, 255, 0)))
									{
										bFactionWindow[iL] = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Change Faction Name");
									ImGui::PopID();

									ImGui::SetCursorPos(cpos);

									iCountIndex++;
								}
							}

							//Find first free.
							for (int iL = 0; iL < 16; iL++)
							{
								if (t.visuals.sFactionName[iL] == "")
								{
									//Add new.
									bool is_selected = false;
									if (ImGui::Selectable("Add a New Faction", is_selected))
									{
										t.visuals.sFactionName[iL] = cstr("Faction") + cstr(iL);
										bFactionWindow[iL] = true;
									}
									break;
								}
							}

							ImGui::EndCombo();
						}
						if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Enemy Characters Faction (this feature is not yet complete)");
					}
					ImGui::Indent(-10);
				}
				#endif
			}
		}

		if (!pref.bHideTutorials)
		{
			#ifdef REMOVED_EARLYACCESS
			#else
			if (ImGui::StyleCollapsingHeader("Tutorial (this feature is incomplete)", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);
				cstr cShowTutorial = "01 - Getting started";
				char* tutorial_combo_items[] = { "01 - Getting started", "02 - Creating terrain", "03 - Add character and set a path" };
				SmallTutorialVideo(cShowTutorial.Get(), tutorial_combo_items, ARRAYSIZE(tutorial_combo_items), SECTION_SHOOTERGENRE);
				float but_gadget_size = ImGui::GetFontSize()*12.0;
				float w = ImGui::GetWindowContentRegionWidth() - 20.0;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
				#ifdef INCLUDESTEPBYSTEP
				if (ImGui::StyleButton("View Step by Step Tutorial", ImVec2(but_gadget_size, 0)))
				{
					bHelp_Window = true;
					bHelpVideo_Window = true;
					extern bool bSetTutorialSectionLeft;
					bSetTutorialSectionLeft = false;
					strcpy(cForceTutorialName, cShowTutorial.Get());
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Start Step by Step Tutorial");
				#endif
				ImGui::Indent(-10);
			}
			#endif
		}
	}
	else
	{
		Shooter_Tools_Window_Active = false;
	}
}
#endif
#endif

//PE: This also fixed TW TASK "BETA 3 - When placing an Audio marker, an outline of another appeared off - screen.Not sure what I did and I can't seem to replicate it. I can't select the outline.".

void DeleteWaypointsAddedToCurrentCursor(void)
{
	//PE: Delete any waypoints added to current cursor.
	if (t.grideditselect == 5 && t.gridentity > 0 && t.grideleprof.trigger.waypointzoneindex > 0)
	{
		t.waypointindex = t.grideleprof.trigger.waypointzoneindex;
		if (t.waypointindex > 0)
		{
			t.w = t.waypoint[t.waypointindex].start;
			waypoint_delete();
		}
		t.grideleprof.trigger.waypointzoneindex = 0;
	}
}

// New Logic System - Visual Relational Lines
#ifdef WICKEDENGINE

std::multimap<std::int32_t, std::int32_t> arcs_relations;
struct NodeConnection
{
	std::int32_t from;
	std::int32_t to;
	std::int32_t nodeconnectionid;
	std::int32_t middle;
};
std::vector<NodeConnection> nodeconnections;
void AddDotObjectRelation(int sobj, int dobj);
void FindDotObjectRelation(int sobj, int dobj,int middle_index);
void GetMiddleEntityIdAndRelationshipId(int sobj, int dobj, int &Entid, int &ReleationshipId, int& NodeConnectionId, int* NodeConnectionIndex = nullptr);
//void DrawDotArcs(int from, int to,bool bDrawMiddleBut);
void DrawObjectRelation(int from, int to, bool bDrawMiddleBut, int forceVertUpdate = 0);
void CreateDotMiddleObject(int obj);
void deleterelationobjects();

float fHighlightCount = 0.0f;
int iTotalArcs = 0;
int iTotalRelationObjects = 0; // The first node connection object is reserved for editing with cursor movement.
int iTotalMiddle = 0;
int iLargestArcs = 0;
int iLargestMiddle = 0;
int iCurrentDotCount = 0;
float fRelationUVs[24] = { 0 };
float fRelationUVsStorage[24] = { 0 };
bool bUVsAlreadySet = false;
float fUVCounter = 0.0f;

int GenerateRelationshipUniqueLinkID (void)
{
	// search all current entities and relationship links to find unique ID not used
	int iUniqueID = 42000;
	for (int e = 1; e <= g.entityelementlist; e++)
	{
		int iBankIndex = t.entityelement[e].bankindex;
		if (iBankIndex > 0)
		{
			int iObj = t.entityelement[e].obj;
			if (iObj > 0)
			{
				int iLinkID = t.entityelement[e].eleprof.iObjectLinkID;
				if (iLinkID > iUniqueID) iUniqueID = iLinkID;
				for (int i = 0; i < 10; i++)
				{
					iLinkID = t.entityelement[e].eleprof.iObjectRelationships[i];
					if (iLinkID > iUniqueID) iUniqueID = iLinkID;
				}
			}
		}
	}
	iUniqueID += 1;
	return iUniqueID;
}

void GetRelationshipObject (int iFindLinkID, int* piEntityID, int* piObj)
{
	// extra feature that if 'piObj' passes a value, discover correct 'piEntityID' (as in the past some corruption caused duplicate 'iFindLinkID' values)
	int iMatchPassedInObjID = 0;
	if (*piObj > 0) iMatchPassedInObjID = *piObj;

	*piEntityID = 0;
	*piObj = 0;
	if (iFindLinkID > 0)
	{
		for (int e = 1; e <= g.entityelementlist; e++)
		{
			int iObj = t.entityelement[e].obj;
			if (iObj > 0)
			{
				int iLinkID = t.entityelement[e].eleprof.iObjectLinkID;
				if (iLinkID == iFindLinkID && (iMatchPassedInObjID==0 || (iMatchPassedInObjID>0 && iMatchPassedInObjID == iObj)))
				{
					*piEntityID = e;
					*piObj = iObj;
					return;
				}
			}
		}
	}
}

void DrawLogicNodes(bool bVisible)
{
	//PE: Use 110000 for dot objects.
	//PE: Use 130000 for arcs.
	if (iCursorDotObject <= 0)
	{
		//PE: No collision on this one.
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
		CreateDotObject(DOTCURSOROBJECTID);
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
		HideObject(DOTCURSOROBJECTID);
		iCursorDotObject = DOTCURSOROBJECTID;
	}

	MoveSelectedDotObject();

	iTotalMiddle = 0;

	if (arcs_relations.size() > 0)
	{
		//Hide dot objects.
		for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
		{
			if (it->first > 0 && it->second > 0)
			{
				HideObject(it->first);
				HideObject(it->second);
			}
		}
	}

	arcs_relations.clear();

	for (int i = 0; i < iLargestMiddle; i++)
	{
		HideObject(DOTMIDDLEOBJECTID + i);
		HideObject(RELATIONOBJECTID + i);
	}

	if (iLargestDotCount != iCurrentDotCount)
	{
		//Something has changed, cleanup.
		iLargestDotCount = iCurrentDotCount;
		int iKeepInMem = 1000; //PE: Always keep upto 1000, delete the rest.
		int iStartObj = 70001;
		for (int i = iStartObj; i < iStartObj + MAXDOTARCSOBJECTS; i++)
		{
			if (ObjectExist(i + DOTOBJECTIDADD))
			{
				if (iKeepInMem-- > 0)
					HideObject(i + DOTOBJECTIDADD);
				else
					DeleteObject(i + DOTOBJECTIDADD);
			}
		}
	}

	int iCurrentLargestDotObjectID = 70001;
	iCurrentDotCount = 0;

	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iObjectLinkID = t.entityelement[iEntityID].eleprof.iObjectLinkID;
		int iEntityObject = t.entityelement[iEntityID].obj;
		if (iEntityObject > 0)
		{
			if (iEntityObject > iCurrentLargestDotObjectID)
				iCurrentLargestDotObjectID = iEntityObject;
			if (iEntityObject > iLargestDotObjectID)
				iLargestDotObjectID = iEntityObject;
			if (ObjectExist(iEntityObject) == 1)
			{
				iCurrentDotCount++;

				bool bObjectNeedDot = false;
				int iColorType = -1;
				if (t.entityelement[iEntityID].staticflag == 0)
				{
					// only dynamic objects can interact and have dot!
					if (t.entityprofile[iBankIndex].ischaracter == 1)
					{
						iColorType = 1;
						bObjectNeedDot = true;
					}
					else if (t.entityprofile[iBankIndex].ismarker == 11) //Flags
					{
						iColorType = 2;
						bObjectNeedDot = true;
					}
					else if (t.entityprofile[iBankIndex].ismarker == 3) //Trigger zone
					{
						iColorType = 3;
						bObjectNeedDot = true;
					}
					else
					{
						//PE: Everything else is a object type.
						//PE: Adding dots to these would be a problem , like stacked boxes ...
						iColorType = 4;
						bObjectNeedDot = true;
					}
				}

				if (bObjectNeedDot)
				{
					CreateDotObject(iEntityObject + DOTOBJECTIDADD);
					PositionDotObject(iEntityObject + DOTOBJECTIDADD);
					if (bVisible)
					{
						int iConnectionsCount = 0;
						for (int i = 0; i < 10; i++)
						{
							if (t.entityelement[iEntityID].eleprof.iObjectRelationships[i] > 0)
							{
								int iRelationShipObject = 0, iRelationShipEntityID = 0;
								GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
								int iRelationshipLinkID = t.entityelement[iEntityID].eleprof.iObjectRelationships[i];
								if (iObjectLinkID != iRelationshipLinkID)
								{
									//PE: If we got a reverse already dont add to arcs list.
									bool bAlreadyThere = false;
									for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
									{
										if (it->first == iRelationShipObject + DOTOBJECTIDADD && it->second == iEntityObject + DOTOBJECTIDADD)
										{
											bAlreadyThere = true;
											break;
										}
									}
									if (!bAlreadyThere)
									{
										//Validate reverse relation.
										int iEntIDd = 0;
										int iRelationIDd = 0;
										int iNodeConnectionIDd = 0;
										GetMiddleEntityIdAndRelationshipId(iRelationShipObject, iEntityObject, iEntIDd, iRelationIDd, iNodeConnectionIDd);
										if (iEntIDd > 0)
										{
											//PE: ok
											arcs_relations.insert(std::make_pair(iEntityObject + DOTOBJECTIDADD, iRelationShipObject + DOTOBJECTIDADD));
										}
									}
								}
								iConnectionsCount++;
							}
						}
						ShowObject(iEntityObject + DOTOBJECTIDADD);
					}
					else
					{
						HideObject(iEntityObject + DOTOBJECTIDADD);
					}
				}
			}
		}
	}
	
	if (iLargestDotObjectID > iCurrentLargestDotObjectID)
	{
		//PE: We got a deleted object, make sure to release all not used dots.
		for (int i = iCurrentLargestDotObjectID; i < iLargestDotObjectID; i++)
		{
			if (i >= 70001 && i <= 90000) //Secure range.
			{
				if (ObjectExist(i + DOTOBJECTIDADD))
				{
					DeleteObject(i + DOTOBJECTIDADD);
				}
			}
		}
		iLargestDotObjectID = iCurrentLargestDotObjectID;
	}

	// Update the reference UVs for the node connection objects.
	if (fUVCounter >= 1.0f)
	{
		for (int i = 0; i < 24; i++)
		{
			fRelationUVs[i] = fRelationUVsStorage[i];
		}

		fUVCounter = 0.0f;
	}

	for (int i = 0; i < 24; i++)
	{
		if (i < 12)
			fRelationUVs[i] += (0.2f * ImGui::GetIO().DeltaTime);
		else
			fRelationUVs[i] -= (0.2f * ImGui::GetIO().DeltaTime);
	}

	fUVCounter += (0.2f * ImGui::GetIO().DeltaTime);

	if (arcs_relations.size() > 0)
	{
		// When an object gets deleted and another takes its place, it can have the same object number...
		// ...which can prevent the relation object vertices from being updated
		static int vertUpdateCounter = 0;
		vertUpdateCounter++;
		if (vertUpdateCounter > 30)
			vertUpdateCounter = 0;

		//Draw connections.
		for (std::multimap<std::int32_t, std::int32_t>::iterator it = arcs_relations.begin(); it != arcs_relations.end(); ++it)
		{
			if (it->first > 0 && it->second > 0)
			{	
				if (vertUpdateCounter < 30)
				{
					DrawObjectRelation(it->first, it->second, true);
				}
				else
				{
					// vertUpdateCounter forces all the verts to be updated.
					DrawObjectRelation(it->first, it->second, true, 1);
				}
			}
		}
	}

	// Hide any relation objects that are no longer used.
	if (arcs_relations.empty())
	{
		for (int i = 0; i < nodeconnections.size(); i++)
		{
			HideObject(RELATIONOBJECTID + iTotalMiddle + 1 + i);
		}
	}
	else if (arcs_relations.size() < nodeconnections.size())
	{
		for (int i = arcs_relations.size() - 1; i < nodeconnections.size(); i++)
		{
			// Hide any relation objects no longer used (but don't delete so they can be reused).
			HideObject(RELATIONOBJECTID + iTotalMiddle + 1 + i);
		}
	}

	if (g_source_dot_pobject && bDotObjectDragging && !bDraggingActive)
		DrawObjectRelation(g_source_dot_pobject->dwObjectNumber, DOTCURSOROBJECTID, false);
	else if (!bDotObjectDragging)
		HideObject(RELATIONOBJECTID);
}

void PositionDotObject(int obj)
{
	if (ObjectExist(obj))
	{
		int iRealObjID = obj - DOTOBJECTIDADD;
		if (ObjectExist(iRealObjID))
		{
			bool bRestoreDotTOObjectCenter = true;
			if (g_hovered_pobject)
			{
				if (iRealObjID == g_hovered_pobject->dwObjectNumber)
				{
					PositionObject(obj, fLastHitPosition[0], fLastHitPosition[1], fLastHitPosition[2]);
					bRestoreDotTOObjectCenter = false;
				}
			}
			else if (g_hovered_dot_pobject)
			{
				if (obj == g_hovered_dot_pobject->dwObjectNumber)
				{
					// instruction what to do 
					pastebitmapfontcenter("Connect To Create Logic", GetScreenX(obj), GetScreenY(obj) + 10, 2, 255);
					bRestoreDotTOObjectCenter = false;
				}
			}
			if (bRestoreDotTOObjectCenter == true )
			{
				PositionObject(obj, ObjectPositionX(iRealObjID) + GetObjectCollisionCenterX(iRealObjID), ObjectPositionY(iRealObjID) + GetObjectCollisionCenterY(iRealObjID), ObjectPositionZ(iRealObjID) + GetObjectCollisionCenterZ(iRealObjID));
			}
		}
	}
}

void CreateDotMiddleObject(int obj)
{
	if (ObjectExist(obj) == 0)
	{
		if (ObjectExist(g.gameplayparentobjects + 2) == 0)
		{
			//LoadObject("editors\\uiv3\\dotmiddleobject.dbo", g.gameplayparentobjects + 2);
			//LoadObject("editors\\uiv3\\brain_marker.dbo", g.gameplayparentobjects + 2);
			//ScaleObject(g.gameplayparentobjects + 2, 30, 30, 30);
			//MakeObjectSphere(g.gameplayparentobjects + 2, 10, 2, 4 );
			LoadObject("editors\\uiv3\\brain_logic_marker.dbo", g.gameplayparentobjects + 2);
			ScaleObject(g.gameplayparentobjects + 2, 25, 25, 25);
			HideObject(g.gameplayparentobjects + 2);
		}
		CloneObject(obj, g.gameplayparentobjects + 2);
		DisableObjectZRead(obj);
		HideObject(obj);
		SetObjectMask(obj, 1);
		SetObjectTransparency(obj, 6);
		SetObjectEffect (obj, g.decaleffectoffset);
		//DisableObjectZWrite(obj);
		DisableObjectZDepth (obj);
		SetObjectCull(obj, 0);
		TextureObject(obj, UI3D_DOTMIDDLEOBJECTS);
		sObject* pDotObject = GetObjectData(obj);
		if (pDotObject)
		{
			WickedCall_SetObjectCastShadows(pDotObject, false);
			WickedCall_SetObjectLightToUnlit(pDotObject, (int)wiScene::MaterialComponent::SHADERTYPE_UNLIT);
		}
	}
}

void CreateDotObject(int obj)
{
	if (ObjectExist(obj) == 0)
	{
		//float fSphereSize = 15.0f;
		//MakeObjectSphere(obj, fSphereSize);
		if (ObjectExist(g.gameplayparentobjects + 0) == 0)
		{
			//LoadObject("editors\\uiv3\\dotobject.dbo", g.gameplayparentobjects + 0);
			//ScaleObject(g.gameplayparentobjects + 0, 50, 50, 50);
			MakeObjectSphere(g.gameplayparentobjects + 0, 5, 5, 5);
			HideObject(g.gameplayparentobjects + 0); //PE: Hide object its visible on maps.
		}
		CloneObject(obj, g.gameplayparentobjects + 0);
		//SetAlphaMappingOn(obj, 25);
		//DisableObjectZRead(obj);
		HideObject(obj);
		SetObjectMask(obj, 1);
		SetObjectEffect(obj, g.guishadereffectindex);
		SetObjectMask(obj, 1);
		
		//SetObjectTransparency(obj, 6);

		//TextureObject(obj, UI3D_DOTOBJECTS);
		//DisableObjectZWrite(obj);
		DisableObjectZDepth (obj);
		SetObjectCull(obj, 0);
		TextureObject(obj, UI3D_DOTOBJECTS);// UI3D_DOTMIDDLEOBJECTS);

		sObject* pDotObject = GetObjectData(obj);
		if (pDotObject)
		{
			WickedCall_SetObjectCastShadows(pDotObject, false);
			WickedCall_SetObjectLightToUnlit(pDotObject, (int)wiScene::MaterialComponent::SHADERTYPE::SHADERTYPE_UNLIT);
		}
	}
}

void CreateDotArcObject(int obj)
{
	if (ObjectExist(obj) == 0)
	{
		float fSphereSize = 15.0f;
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
		//MakeObjectBox(obj, 2.5f, 2.5f, 7.0f);
		if (ObjectExist(g.gameplayparentobjects + 1) == 0)
		{		
			//LoadObject("editors\\uiv3\\dotpipe.dbo", g.gameplayparentobjects + 1);
			LoadObject("editors\\uiv3\\dotobject.dbo", g.gameplayparentobjects + 1);
			ScaleObject(g.gameplayparentobjects + 1, 25, 25, 25);
			//RotateObject(g.gameplayparentobjects + 1, 0, 90, 0);
			//FixObjectPivot(g.gameplayparentobjects + 1);
		}
		CloneObject(obj, g.gameplayparentobjects + 1);
		WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);
		//DisableObjectZRead(obj);
		DisableObjectZDepth (obj);
		HideObject(obj);
		SetObjectMask(obj, 1);
		SetObjectEffect(obj, g.guishadereffectindex);
		//SetObjectDiffuseEx(obj, Rgb(255, 255, 0), 0);
		TextureObject(obj, UI3D_DOTOBJECTS);
		SetObjectMask(obj, 1);
		sObject* pDotObject = GetObjectData(obj);
		if (pDotObject)
		{
			WickedCall_SetObjectCastShadows(pDotObject, false);
		}
	}
}

int iLastEmmisiveObject = 0;
bool bReadyToClickDot = false;

void MoveSelectedDotObject(void)
{
	//	extern uint64_t g_hovered_dot_entity;
	//	extern sObject* g_hovered_dot_pobject;

	bool bMiddleDotActive = false;
	if (!bDotObjectDragging && g_hovered_dot_pobject && g_hovered_dot_pobject->dwObjectNumber >= DOTMIDDLEOBJECTID)
	{
		bMiddleDotActive = true;
	}
	if(bDotMiddleWindow && !pref.iEnableRelationPopupWindow)
	{
		if (t.inputsys.mclick == 0)
			bReadyToClickDot = true;
		if (bReadyToClickDot && t.inputsys.mclick == 1)
			bDotMiddleWindow = false;
	}

	if (t.onedragmode == 1 && t.onedrag > 0)
		return;
	if (t.widget.pickedObject > 0)
		return;
	if (g.entityrubberbandlist.size() > 0)
		return;
	if (t.inputsys.rubberbandmode != 0)
		return;

	if (bMiddleDotActive) 
	{
		if (t.inputsys.mclick == 1 && !bDotMiddleWindow)
		{
			if (g_selected_middle_dot_pobject != g_hovered_dot_pobject)
			{
				ImVec2 wpos = ImGui::GetWindowPos();
				ImVec2 mpos = ImGui::GetMousePos();
				vDotMiddleWindowPos = mpos + ImVec2(10, 10);
			}
			g_selected_middle_dot_pobject = g_hovered_dot_pobject;
			int iId = (g_selected_middle_dot_pobject->dwObjectNumber - DOTMIDDLEOBJECTID);
			if (iId >= 0 && iId < MAXDOTMIDDLE)
			{
				bDotMiddleWindow = true;
				bReadyToClickDot = false;
				if (pref.iEnableRelationPopupWindow)
				{
					ImGui::OpenPopup("Relation##DotMiddleWindowRelation");
				}
			}
		}
	}
	if (pref.iEnableRelationPopupWindow)
	{
		if (bDotMiddleWindow)
		{
			if (g_selected_middle_dot_pobject)
			{
				int iSelectedDotObj = g_selected_middle_dot_pobject->dwObjectNumber;
				ImVec2 v2DPos = Convert3DTo2D(ObjectPositionX(iSelectedDotObj), ObjectPositionY(iSelectedDotObj), ObjectPositionZ(iSelectedDotObj));
				//PE: Window is relative to viewport position.
				v2DPos += ImGui::GetMainViewport()->Pos;
				ImGui::SetNextWindowPos(ImVec2(v2DPos.x, v2DPos.y));
			}
			else
			{
				ImGui::SetNextWindowPos(vDotMiddleWindowPos);
			}
			ImGui::SetNextWindowSize(ImVec2(ImGui::GetFontSize()*16.0, 0));
		}
		if (ImGui::BeginPopup("Relation##DotMiddleWindowRelation", ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings)) //ImGuiWindowFlags_AlwaysAutoResize
		{
			bDotMiddleWindow = true;
			int iDotMiddleIndex = g_selected_middle_dot_pobject->dwObjectNumber - DOTMIDDLEOBJECTID;
			if (iDotMiddleIndex >= 0 && iDotMiddleIndex < MAXDOTMIDDLE)
			{
				DisplayRelationshipMenu(iDotMiddleIndex, 1);
				bImGuiGotFocus = true;
				ImGui::EndPopup();
			}
		}
		else 
		{
			bDotMiddleWindow = false;
		}
	}

	if (!bMiddleDotActive && (g_hovered_dot_pobject || bDotObjectDragging))
	{
		if (t.inputsys.mclick == 1 && !bDotObjectDragging) 
		{
			g_source_dot_pobject = g_hovered_dot_pobject;
			ShowObject(DOTCURSOROBJECTID);
		}
		if (t.inputsys.mclick == 1) 
		{
			bDotObjectDragging = true;
			if (g_hovered_dot_pobject)
			{
				int dobj = g_hovered_dot_pobject->dwObjectNumber;
				int sobj = g_source_dot_pobject->dwObjectNumber;
				if (dobj > 70000)
				{
					if (iLastEmmisiveObject != dobj) 
					{
						if (iLastEmmisiveObject > 0) 
						{
							SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
							//sObject* pLastObj = GetObjectData(iLastEmmisiveObject);
							//WickedCall_SetObjectHighlightBlue(pLastObj, false);
							if (sobj > 0)
							{
								SetObjectEmissive(sobj, Rgb(0, 0, 0));
								//sObject* pSrcObj = GetObjectData(sobj);
								//WickedCall_SetObjectHighlightBlue(pSrcObj, false);
							}
						}

						// Turn the dots green when hovered over each other (unless dragging the object that the dot is attached to).
						if (!bDraggingActive)
						{
							SetObjectEmissive(dobj, Rgb(56, 110, 146));// 255, 0));
							//sObject* pDestObj = GetObjectData(dobj);
							//WickedCall_SetObjectHighlightBlue(pDestObj, true);
							if (sobj > 0)
							{
								SetObjectEmissive(sobj, Rgb(56, 110, 146));//255, 0));
								//sObject* pSrcObj = GetObjectData(sobj);
								//WickedCall_SetObjectHighlightBlue(pSrcObj, true);
							}
						}
					}
					iLastEmmisiveObject = dobj;
				}
			}
			else
			{
				if (iLastEmmisiveObject > 0)
				{
					SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
					iLastEmmisiveObject = 0;
				}
			}
		}
		else 
		{
			//PE: Release
			if (bDotObjectDragging && g_hovered_dot_pobject)
			{
				if (g_source_dot_pobject != g_hovered_dot_pobject)
				{
					//PE: Connect to this.
					g_destination_dot_pobject = g_hovered_dot_pobject;
					AddDotObjectRelation(g_source_dot_pobject->dwObjectNumber, g_destination_dot_pobject->dwObjectNumber);
				}
			}
			if (iLastEmmisiveObject > 0)
			{
				SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
				//sObject* pLastObj = GetObjectData(iLastEmmisiveObject);
				//WickedCall_SetObjectHighlightBlue(pLastObj, false);
				int sobj = g_source_dot_pobject->dwObjectNumber;
				if (sobj > 0)
				{
					SetObjectEmissive(sobj, Rgb(0, 0, 0));
					//sObject* pSrcObj = GetObjectData(sobj);
					//WickedCall_SetObjectHighlightBlue(pSrcObj, false);
				}
			}
			iLastEmmisiveObject = 0;

			if (bDotObjectDragging)
				HideObject(DOTCURSOROBJECTID);
			bDotObjectDragging = false;

			//Make sure action did not select anything.
			t.widget.pickedObject = 0;
			t.tentitytoselect = 0;
			gridedit_clearentityrubberbandlist();
		}
		PositionObject(DOTCURSOROBJECTID, fLastHitPosition[0], fLastHitPosition[1], fLastHitPosition[2]);
		PointObject(DOTCURSOROBJECTID, CameraPositionX(), CameraPositionY(), CameraPositionZ());
	}
	else
	{
		if(bDotObjectDragging)
			HideObject(DOTCURSOROBJECTID);
		if (iLastEmmisiveObject > 0)
		{
			SetObjectEmissive(iLastEmmisiveObject, Rgb(0, 0, 0));
			//sObject* pLastObj = GetObjectData(iLastEmmisiveObject);
			//WickedCall_SetObjectHighlightBlue(pLastObj, false);
		}
		iLastEmmisiveObject = 0;
		g_destination_dot_pobject = NULL;
		bDotObjectDragging = false;
	}
}

void DisplayRelationshipMenu(int iDotMiddleIndex, int mode)
{
	//PE: We can use both source and dest entity to find type.
	//iObjectRelationshipsType
	//1 = Character + Character
	//2 = Character + Flag
	//3 = Character + Zone
	//4 = Character + Object
	//5 = Flag + Flag
	//6 = Flag + Zone
	//7 = Flag + Object
	//8 = Zone + Zone
	//9 = Zone + Object
	//10= Object + Object: Show When Object Activated dropdown: Activate other object, Destroy other object

	// Display a brain icon next to the dropdown.
	ImVec2 cursorPos = ImGui::GetCursorPos();
	float fFontSize = ImGui::GetFontSize();
	ImGui::SetCursorPos(cursorPos + ImVec2(-fFontSize + 10, fFontSize));
	ImGui::ImgBtn(BRAIN_ICON, ImVec2(fFontSize * 2, fFontSize * 2), ImVec4(255, 255, 255, 0), ImVec4(255,255,255,255), ImVec4(255,255,255,255), ImVec4(255,255,255,255));
	ImGui::SetCursorPos(cursorPos + ImVec2(fFontSize + 10, 0));

	int sobj = iDotMiddleInfoSource[iDotMiddleIndex] - DOTOBJECTIDADD;
	int dobj = iDotMiddleInfoDestination[iDotMiddleIndex] - DOTOBJECTIDADD;
	int iEntID = 0;
	int iRelationID = 0;
	int iNodeConnectionID = 0;
	GetMiddleEntityIdAndRelationshipId(sobj, dobj, iEntID, iRelationID, iNodeConnectionID);
	if (iEntID > 0)
	{
		int iRelationType = t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID];
		ImGui::Indent(10);
		//ImGui::PushItemWidth(-10);
		ImGui::PushItemWidth(-1.25f * fFontSize);
		
		// character v character
		if (iRelationType == 1)
		{
			ImGui::TextCenter("Character and Character");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize *2 , 0));
			const char* items_combo[] = { "Alert other character", "Stand-down other character", "Toggle alert of other character" };
			if (ImGui::Combo("##iCharRelationshipsDataAllies", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				//Reverse data.
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "One character can activate activity in another character when alerted");
		}

		// character v flag
		if (iRelationType == 2)
		{
			ImGui::TextCenter("Character and Flag");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Reverse at End", "Loop Around At End", "Follow One Way", "Choose Random Flag" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				//PE: Also change chars Patrol settings.
				t.entityelement[iEntID].eleprof.iCharPatrolMode = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
					t.entityelement[iEntDID].eleprof.iCharPatrolMode = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1 && t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] != 3)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set the characters patrol style when connected to a flag element");
		}

		// character v zone
		if (iRelationType == 3)
		{
			ImGui::TextCenter("Character and Zone");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			//const char* items_combo[] = { "Alert character", "Stand-down character", "Toggle alert the character", "Activate zone", "Deactivate zone", "Toggle zone" };
			const char* items_combo[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can alert character when zone activated, and activate zone when character alerted");
		}

		// character v object
		if (iRelationType == 4)
		{
			ImGui::TextCenter("Character and Object");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate object when character alerted, and alert character when object activated");
		}

		// flag v flag
		if (iRelationType == 5)
		{
			ImGui::TextCenter("Flag and Flag");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Do Nothing" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can set a suggested movement style for between these flags");
		}

		// flag v zone
		if (iRelationType == 6 || iRelationType == 7)
		{
			ImGui::TextCenter("Flag and Zone");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Do Nothing" };// Activate flag", "Deactivate flag", "Toggle flag" ;
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can set zone to enable or disable any flag element");
		}

		// zone v zone
		if (iRelationType == 8)
		{
			ImGui::TextCenter("Zone and Zone");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			//const char* items_combo[] = { "Do Nothing" }; // Activate other zone", "Deactivate other zone", "Toggle other zone" ;
			const char* items_combo[] = { "Activate other zone", "Deactivate other zone", "Toggle other zone" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate or deactivate a zone from another zone");
		}

		// zone v object
		if (iRelationType == 9)
		{
			ImGui::TextCenter("Zone and Object");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Activate object", "Deactivate object", "Toggle object" }; // "Activate zone", "Deactivate zone", "Toggle zone", "Activate object", "Deactivate object", "Toggle object" ;
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate object from zone, or activate zone from object activation");
		}

		// object v object
		if (iRelationType == 10)
		{
			ImGui::TextCenter("Object and Object");
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(fFontSize * 2, 0));
			const char* items_combo[] = { "Activate other object", "Deactivate other object", "Toggle other object" };
			if (ImGui::Combo("##iCharRelationshipsDataPatrol", &t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID], items_combo, IM_ARRAYSIZE(items_combo)))
			{
				int iEntDID = 0, iDRelationID = 0, iNodeID = 0;
				GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntDID, iDRelationID, iNodeID);
				if (iEntDID > 0)
				{
					t.entityelement[iEntDID].eleprof.iObjectRelationshipsData[iDRelationID] = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				}
				if (mode == 1)
					ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Can activate the other object when the first object is activated");
		}

		// delete relationship button
		float but_gadget_size = ImGui::GetFontSize()*12.0;
		float w = ImGui::GetWindowContentRegionWidth() - 10.0;
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
		if (ImGui::StyleButton("Delete Relationship", ImVec2(but_gadget_size, 0)))
		{
			t.entityelement[iEntID].eleprof.iObjectRelationships[iRelationID] = 0;
			t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID] = 0;
			t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] = 0;
			int iEntIDd = 0;
			int iRelationIDd = 0;
			int iNodeConnectionID = 0;
			int iNodeConnectionIndex = -1;
			GetMiddleEntityIdAndRelationshipId(dobj, sobj, iEntIDd, iRelationIDd, iNodeConnectionID, &iNodeConnectionIndex);
			if (iEntIDd > 0)
			{
				t.entityelement[iEntIDd].eleprof.iObjectRelationships[iRelationIDd] = 0;
				t.entityelement[iEntIDd].eleprof.iObjectRelationshipsType[iRelationIDd] = 0;
				t.entityelement[iEntIDd].eleprof.iObjectRelationshipsData[iRelationIDd] = 0;

				// Delete the node connection object and remove from storage.
				if (ObjectExist(iNodeConnectionID))
				{
					DeleteObject(iNodeConnectionID);
					iTotalRelationObjects--;
				}

				if (iNodeConnectionIndex > -1)
					nodeconnections.erase(nodeconnections.begin() + iNodeConnectionIndex);
			}

			if (mode == 1)
				ImGui::CloseCurrentPopup();
		}
		if (mode == 1)
		{
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
			if (ImGui::StyleButton("Close", ImVec2(but_gadget_size, 0)))
			{
				ImGui::CloseCurrentPopup();
			}
		}
		ImGui::PopItemWidth();
		ImGui::Indent(-10);
	}
}

void AddDotObjectRelation(int sobj,int dobj)
{
	sobj -= DOTOBJECTIDADD;
	dobj -= DOTOBJECTIDADD;
	if (sobj < 70000 || dobj < 70000 || sobj > 90000 || dobj > 90000)
		return;

	//PE: Find real entity.
	bool bSourceSet = false;
	bool bDestSet = false;
	int iEntityIDSource = 0;
	int iEntityIDDest = 0;
	int iTypeSource = 0;
	int iTypeDest = 0;
	int iEntTypeSource = 0;
	int iEntTypeDest = 0;
	int iRelationIndexSource = -1;
	int iRelationIndexDest = -1;
	int iRelationshipLinkIDSource = 0;
	int iRelationshipLinkIDDest = 0;

	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iEntityObject = t.entityelement[iEntityID].obj;

		//PE: We make 2 ways relations , so no need to scan everything to find a relation.
		//PE: source get destobject.

		int iEntType = -1;
		if (t.entityprofile[iBankIndex].ischaracter == 1)
		{
			iEntType = 1;
		}
		else if (t.entityprofile[iBankIndex].ismarker == 11) //Flags
		{
			iEntType = 2;
		}
		else if (t.entityprofile[iBankIndex].ismarker == 1 || t.entityprofile[iBankIndex].ismarker == 3 || t.entityprofile[iBankIndex].ismarker == 6) //Player start, checkpoint or Trigger zone
		{
			iEntType = 3;
		}
		else 
		{
			//PE: Everything else is a object type.
			//PE: Adding dots to these could be a problem , like stacked boxes ...
			iEntType = 4;
		}

		if (sobj == iEntityObject)
		{
			int iFirstFree = -1;
			bool bAlreadyThere = false;
			iEntityIDSource = iEntityID;
			iEntTypeSource = iEntType;
			int iRelationShipEntityID = 0;
			for (int i = 0; i < 10; i++)
			{
				if (iFirstFree < 0 && t.entityelement[iEntityID].eleprof.iObjectRelationships[i] == 0)
				{
					iFirstFree = i;
				}
				int iRelationShipObject = dobj; // special extra search condition to bypass corruption
				GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
				if (iRelationShipObject == dobj)
				{
					iRelationIndexSource = i;
					iRelationshipLinkIDSource = t.entityelement[iEntityID].eleprof.iObjectLinkID;
					bAlreadyThere = true;
					break;
				}
			}
			if (!bAlreadyThere && iFirstFree >= 0)
			{
				iRelationIndexSource = iFirstFree;
			}
			bSourceSet = true;
		}

		if (dobj == iEntityObject)
		{
			int iFirstFree = -1;
			bool bAlreadyThere = false;
			iEntityIDDest = iEntityID;
			iEntTypeDest = iEntType;
			int iRelationShipEntityID = 0;
			for (int i = 0; i < 10; i++)
			{
				if (iFirstFree < 0 && t.entityelement[iEntityID].eleprof.iObjectRelationships[i] == 0)
				{
					iFirstFree = i;
				}
				int iRelationShipObject = sobj; // special extra search condition to bypass corruption
				GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
				if (iRelationShipObject == sobj)
				{
					iRelationIndexDest = i;
					iRelationshipLinkIDDest = t.entityelement[iEntityID].eleprof.iObjectLinkID;
					bAlreadyThere = true;
					break;
				}
			}
			if (!bAlreadyThere && iFirstFree >= 0)
			{
				iRelationIndexDest = iFirstFree;
			}
			bDestSet = true;
		}
	}

	// create unique links (if needed), then connect them
	if (iRelationshipLinkIDSource == 0)
	{
		if (t.entityelement[iEntityIDSource].eleprof.iObjectLinkID == 0)
		{
			iRelationshipLinkIDSource = GenerateRelationshipUniqueLinkID();
			t.entityelement[iEntityIDSource].eleprof.iObjectLinkID = iRelationshipLinkIDSource;
		}
		else
			iRelationshipLinkIDSource = t.entityelement[iEntityIDSource].eleprof.iObjectLinkID;
	}
	if (iRelationshipLinkIDDest == 0)
	{
		if (t.entityelement[iEntityIDDest].eleprof.iObjectLinkID == 0)
		{
			iRelationshipLinkIDDest = GenerateRelationshipUniqueLinkID();
			t.entityelement[iEntityIDDest].eleprof.iObjectLinkID = iRelationshipLinkIDDest;
		}
		else
			iRelationshipLinkIDDest = t.entityelement[iEntityIDDest].eleprof.iObjectLinkID;
	}
	if (bDestSet && bSourceSet && iRelationIndexDest >= 0 && iRelationIndexSource >= 0)
	{
		t.entityelement[iEntityIDSource].eleprof.iObjectRelationships[iRelationIndexSource] = iRelationshipLinkIDDest;
		t.entityelement[iEntityIDDest].eleprof.iObjectRelationships[iRelationIndexDest] = iRelationshipLinkIDSource;
	}

	if (bDestSet && bSourceSet && iRelationIndexDest >= 0 && iRelationIndexSource >= 0)
	{
		//Type: 1=Char, 2=Flag, 3=Zone , 4=Object.
		if (iEntTypeSource == 1 && iEntTypeDest == 1) 
		{ //Char,Char
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 1;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 1;
		}
		else if ((iEntTypeSource == 1 && iEntTypeDest == 2) || (iEntTypeSource == 2 && iEntTypeDest == 1)) 
		{ //Char,Flag
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 2;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 2;
		}
		else if ((iEntTypeSource == 1 && iEntTypeDest == 3) || (iEntTypeSource == 3 && iEntTypeDest == 1)) 
		{ //Char,zone
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 3;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 3;
		}
		else if ((iEntTypeSource == 1 && iEntTypeDest == 4) || (iEntTypeSource == 4 && iEntTypeDest == 1))
		{ //Char,Object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 4;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 4;
		}
		else if (iEntTypeSource == 2 && iEntTypeDest == 2) { //Flag,Flag
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 5;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 5;
		}
		else if ((iEntTypeSource == 2 && iEntTypeDest == 3) || (iEntTypeSource == 3 && iEntTypeDest == 2)) 
		{ //flag,zone
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 6;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 6;
		}
		else if ((iEntTypeSource == 2 && iEntTypeDest == 4) || (iEntTypeSource == 4 && iEntTypeDest == 2)) 
		{ //flag,object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 7;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 7;
		}
		else if (iEntTypeSource == 3 && iEntTypeDest == 3) 
		{ //zone,zone
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 8;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 8;
		}
		else if ((iEntTypeSource == 3 && iEntTypeDest == 4) || (iEntTypeSource == 4 && iEntTypeDest == 3)) 
		{ //zone,object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 9;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 9;
		}
		else if (iEntTypeSource == 4 && iEntTypeDest == 4) 
		{ 
			//object,object
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsType[iRelationIndexSource] = 10;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsType[iRelationIndexDest] = 10;

			// objects toggle by default
			t.entityelement[iEntityIDSource].eleprof.iObjectRelationshipsData[iRelationIndexSource] = 2;
			t.entityelement[iEntityIDDest].eleprof.iObjectRelationshipsData[iRelationIndexDest] = 2;
		}
	}
}

void GetMiddleEntityIdAndRelationshipId(int sobj, int dobj, int &Entid, int &ReleationshipId, int& NodeConnectionId, int* NodeConnectionIndex)
{
	if (sobj < 70000 || sobj > 90000 || dobj < 70000 || dobj > 90000)
		return;

	Entid = 0;
	ReleationshipId = 0;
	NodeConnectionId = 0;

	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iEntityObject = t.entityelement[iEntityID].obj;

		//PE: We make 2 ways relations , so no need to scan everything to find a relation.
		//PE: source get destobject.
		if (sobj == iEntityObject)
		{
			for (int i = 0; i < 10; i++)
			{
				int iRelationShipEntityID = 0;
				int iRelationShipObject = dobj; // special extra search condition to bypass corruption
				GetRelationshipObject(t.entityelement[iEntityID].eleprof.iObjectRelationships[i], &iRelationShipEntityID, &iRelationShipObject);
				if (iRelationShipObject == dobj)
				{
					Entid = iEntityID;
					ReleationshipId = i;

					for (int j = 0; j < nodeconnections.size(); j++)
					{
						if ((nodeconnections[j].from == sobj && nodeconnections[j].to == dobj) || (nodeconnections[j].from == dobj && nodeconnections[j].to == sobj))
						{
							NodeConnectionId = nodeconnections[j].nodeconnectionid;
							if (NodeConnectionIndex)
								*NodeConnectionIndex = j;
							break;
						}
					}
					return;
				}
			}
		}
	}
}

void FindDotObjectRelation(int sobj, int dobj,int middle_index)
{
	sobj -= DOTOBJECTIDADD;
	dobj -= DOTOBJECTIDADD;

	if (sobj < 70000 || dobj < 70000 || sobj > 90000 || dobj > 90000)
		return;

	//PE: Find real entity.
	for (int iEntityID = 1; iEntityID <= g.entityelementlist; iEntityID++)
	{
		int iBankIndex = t.entityelement[iEntityID].bankindex;
		int iMasterObject = g.entitybankoffset + t.entityelement[iEntityID].bankindex;
		int iEntityObject = t.entityelement[iEntityID].obj;

		if (sobj == iEntityObject)
		{
			//iDotMiddleInfoSourceType[middle_index] = from;
		}

		if (dobj == iEntityObject)
		{
			//iDotMiddleInfoDestinationType[middle_index] = from;
		}
	}
}

void DrawDotArcsCircle(int from, int radius)
{
	if (radius < 1)
		return;

	float ffromx = ObjectPositionX(from);
	float ffromy = ObjectPositionY(from);
	float ffromz = ObjectPositionZ(from);
	int AddDots = radius / 4;//8 8.0;
	if (AddDots < 8)
		AddDots = 8;
	float fStep = (3.14159265*2.0) / ((float)AddDots);
	DWORD dwNewColor = Rgb(255, 128, 0);
	int iColor = 199;
	int iPointObject = iTotalArcs;
	float sincount = 0;
	for (int i = 0;i < AddDots;i++)
	{
		CreateDotArcObject(DOTARCSOBJECTID + iTotalArcs);
		ShowObject(DOTARCSOBJECTID + iTotalArcs);

		float fnfromx = ffromx + (sin(sincount)*(float)radius);
		float fnfromy = ffromy;
		float fnfromz = ffromz + (cos(sincount)*(float)radius);;
		PositionObject(DOTARCSOBJECTID + iTotalArcs, fnfromx, fnfromy, fnfromz);

		sincount += fStep;

		if (i > 0) 
		{
			int iOldObj = DOTARCSOBJECTID + (iTotalArcs - 1);
			PointObject(DOTARCSOBJECTID + iTotalArcs, ObjectPositionX(iOldObj), ObjectPositionY(iOldObj), ObjectPositionZ(iOldObj));
		}

		if (iDotArceColor[iTotalArcs] != iColor)
		{
			iDotArceColor[iTotalArcs] = iColor;
			SetObjectDiffuseEx(DOTARCSOBJECTID + iTotalArcs, dwNewColor, 0);
		}

		if (iTotalArcs < MAXDOTARCSOBJECTS)
		{
			iTotalArcs++;
			if (iTotalArcs > iLargestArcs)
				iLargestArcs = iTotalArcs;
		}
	}
	int iOldObj = DOTARCSOBJECTID + iPointObject;
	PointObject(iOldObj, ObjectPositionX(iOldObj + 1), ObjectPositionY(iOldObj + 1), ObjectPositionZ(iOldObj + 1));
}

void AddVertToObjectRelation(float x, float y, float z, float texU, float texV, int v, int memblock)
{
	//  Position of vertex in memblock
	int pos = 12 + (v * 32);

	//  Set vertex position
	WriteMemblockFloat(memblock, pos + 0, x);
	WriteMemblockFloat(memblock, pos + 4, y);
	WriteMemblockFloat(memblock, pos + 8, z);
	WriteMemblockFloat(memblock, pos + 12, 0);
	WriteMemblockFloat(memblock, pos + 16, 0);
	WriteMemblockFloat(memblock, pos + 20, 0);
	WriteMemblockFloat(memblock, pos + 24, texU);
	WriteMemblockFloat(memblock, pos + 28, texV);
}

void CreateObjectRelationMesh(float fromx, float fromy, float fromz, float tox, float toy, float toz, DWORD color)
{
	// this gets the diffuse into the emissive for a glowier line for logic lines!
	WickedCall_PresetObjectPutInEmissive(1);

	// Find a free memblock.
	int iFound = 0;
	for (int i = 1; i <= 257; i++)
	{
		if (MemblockExist(i) == 0)
		{
			iFound = i;
			break;
		}
	}
	if (iFound == 0) return;

	// Find a free object slot.
	int obj = t.activerelationobjectid;
	if (ObjectExist(obj) == 1)
		return;

	iTotalRelationObjects++;

	int vertsize = 32;
	int iSizeBytes = 0;
	int vertexCount = 36;
	iSizeBytes = vertsize * vertexCount;
	iSizeBytes += 12; // Add header bytes.
	MakeMemblock(iFound, iSizeBytes);

	// Write the memblock header.
	// FVF format.
	WriteMemblockDWord(iFound, 0, GGFVF_XYZ | GGFVF_NORMAL | GGFVF_TEX1);
	// Size of single vertex - 3 x float: position, 3 x float: normal, 2 x float: tex coords = 32 bytes.
	WriteMemblockDWord(iFound, 4, 32);
	// Number of vertices in the mesh.
	WriteMemblockDWord(iFound, 8, vertexCount);

	// Corners of the prism.
	float x0, x1, x2, x3, x4, x5;
	float y0, y1, y2, y3, y4, y5;
	float z0, z1, z2, z3, z4, z5;
	// Midpoints to split the prism in two.
	float mx03, mx14, mx25;
	float my03, my14, my25;
	float mz03, mz14, mz25;

	int v = 0;
	float p0[3];
	float p1[3];
	float points[18];
	
	p0[0] = fromx; p0[1] = fromy; p0[2] = fromz;
	p1[0] = tox; p1[1] = toy; p1[2] = toz;

	physics_debug_make_prism_between_points(p0, p1, points, 0.5f);// 3);

	// Corners of the prism.
	x0 = points[0]; y0 = points[1]; z0 = points[2];
	x1 = points[3]; y1 = points[4]; z1 = points[5];
	x2 = points[6]; y2 = points[7]; z2 = points[8];
	x3 = points[9]; y3 = points[10]; z3 = points[11];
	x4 = points[12]; y4 = points[13]; z4 = points[14];
	x5 = points[15]; y5 = points[16]; z5 = points[17];

	// Midpoints.
	mx03 = (x0 + x3) / 2.0f; my03 = (y0 + y3) / 2.0f; mz03 = (z0 + z3) / 2.0f;
	mx14 = (x1 + x4) / 2.0f; my14 = (y1 + y4) / 2.0f; mz14 = (z1 + z4) / 2.0f;
	mx25 = (x2 + x5) / 2.0f; my25 = (y2 + y5) / 2.0f; mz25 = (z2 + z5) / 2.0f;
	
	// Tex Coords.
	if (!bUVsAlreadySet)
	{
		fRelationUVs[0] = 0; fRelationUVs[1] = 0;
		fRelationUVs[2] = 0; fRelationUVs[3] = 1;
		fRelationUVs[4] = 1; fRelationUVs[5] = 0;
		fRelationUVs[6] = 1; fRelationUVs[7] = 0;
		fRelationUVs[8] = 0; fRelationUVs[9] = 1;
		fRelationUVs[10] = 1; fRelationUVs[11] = 1;
		const float off = 0.16666667f;
		fRelationUVs[12] = 0 + off; fRelationUVs[13] = 0 + off;
		fRelationUVs[14] = 0 + off; fRelationUVs[15] = 1 + off;
		fRelationUVs[16] = 1 + off; fRelationUVs[17] = 0 + off;
		fRelationUVs[18] = 1 + off; fRelationUVs[19] = 0 + off;
		fRelationUVs[20] = 0 + off; fRelationUVs[21] = 1 + off;
		fRelationUVs[22] = 1 + off; fRelationUVs[23] = 1 + off;

		for (int i = 0; i < 24; i++)
		{
			fRelationUVsStorage[i] = fRelationUVs[i];
		}

		bUVsAlreadySet = true;
	}
	
	// TODO: Just make one face and point at camera.

	// Bottom face.
	AddVertToObjectRelation(x0, y0, z0, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(x2, y2, z2, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(x2, y2, z2, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[10], fRelationUVs[11], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(x3, y3, z3, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(x3, y3, z3, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(x5, y5, z5, fRelationUVs[10], fRelationUVs[11], v++, iFound);

	// Right face.
	AddVertToObjectRelation(x1, y1, z1, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(x0, y0, z0, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(x0, y0, z0, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[10], fRelationUVs[11], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(x4, y4, z4, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(x4, y4, z4, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(mx03, my03, mz03, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(x3, y3, z3, fRelationUVs[10], fRelationUVs[11], v++, iFound);

	// Left face.
	AddVertToObjectRelation(x2, y2, z2, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(x1, y1, z1, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(x1, y1, z1, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[10], fRelationUVs[11], v++, iFound);
	AddVertToObjectRelation(mx25, my25, mz25, fRelationUVs[0], fRelationUVs[1], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[2], fRelationUVs[3], v++, iFound);
	AddVertToObjectRelation(x5, y5, z5, fRelationUVs[4], fRelationUVs[5], v++, iFound);
	AddVertToObjectRelation(x5, y5, z5, fRelationUVs[6], fRelationUVs[7], v++, iFound);
	AddVertToObjectRelation(mx14, my14, mz14, fRelationUVs[8], fRelationUVs[9], v++, iFound);
	AddVertToObjectRelation(x4, y4, z4, fRelationUVs[10], fRelationUVs[11], v++, iFound);

	CreateMeshFromMemblock(obj, iFound);
	MakeObject(obj, obj, 0);

	sObject* pObject = GetObjectData(obj);

	WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_CURSOROBJECT);
	WickedCall_RemoveObject(pObject);
	WickedCall_AddObject(pObject);
	
	if (ImageExist(g.visuallogicimageoffset) == 0)
		LoadImage("editors\\uiv3\\nodeconnection.png", g.visuallogicimageoffset);
	image_setlegacyimageloading(false);

	TextureObject(obj, g.visuallogicimageoffset);
	//TextureObject(obj, ABOUT_LOGO);
	
	WickedCall_SetObjectCastShadows(pObject, false);
	WickedCall_SetObjectLightToUnlit(pObject, (int)wiScene::MaterialComponent::SHADERTYPE::SHADERTYPE_UNLIT);

	WickedCall_PresetObjectRenderLayer(GGRENDERLAYERS_NORMAL);

	//SetObjectDiffuse(obj, color);
	SetObjectCull(obj, 0);

	//DisableObjectZRead(obj);
	//DisableObjectZDepth(obj);

	// Set alpha and transparency of this object
	//SetObjectTransparency(obj, 1);
	//SetAlphaMappingOn(obj, 35);

	DeleteMemblock(iFound);
	ShowObject(obj);

	WickedCall_PresetObjectPutInEmissive(0);
}

// Update the vertex positions of half the node connection mesh, used for one way movement.
void UpdateObjectRelationMeshHalf(float fromx, float fromy, float fromz, float tox, float toy, float toz)
{
	float x0, x1, x2, x3, x4, x5;
	float y0, y1, y2, y3, y4, y5;
	float z0, z1, z2, z3, z4, z5;
	int v = 0;
	float p0[3];
	float p1[3];
	float points[18];
	int id = RELATIONOBJECTID;
	sObject* pObject = GetObjectData(id);
	if (!pObject)
	{
		return;
	}

	sMesh* pMesh = pObject->ppMeshList[0];
	if (!pMesh)
	{
		return;
	}

	LockVertexDataForLimbCore(id, 0, 1);
	
	// Every 6 elements of data contain two points on the physics object.
	p0[0] = fromx; p0[1] = fromy; p0[2] = fromz;
	p1[0] = tox; p1[1] = toy; p1[2] = toz;

	physics_debug_make_prism_between_points(p0, p1, points, 0.5f);// 3);

	// Corners of the prism.
	x0 = points[0]; y0 = points[1]; z0 = points[2];
	x1 = points[3]; y1 = points[4]; z1 = points[5];
	x2 = points[6]; y2 = points[7]; z2 = points[8];
	x3 = points[9]; y3 = points[10]; z3 = points[11];
	x4 = points[12]; y4 = points[13]; z4 = points[14];
	x5 = points[15]; y5 = points[16]; z5 = points[17];

	// Make each face of the prism (two triangles per face).
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x5, y5, z5);

	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x3, y3, z3);

	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x4, y4, z4);

	for (int i = 0; i < 18; i++)
		SetVertexDataPosition(v++, 0, 0, 0);

	UnlockVertexData();

	WickedCall_UpdateMeshVertexData(pMesh);
}

// Used when the user drags an object with an active relation, so need to update the node connection mesh.
void UpdateObjectRelationMesh(float fromx, float fromy, float fromz, float tox, float toy, float toz)
{
	float x0, x1, x2, x3, x4, x5;
	float y0, y1, y2, y3, y4, y5;
	float z0, z1, z2, z3, z4, z5;
	// Midpoints to split the prism in two.
	float mx03, mx14, mx25;
	float my03, my14, my25;
	float mz03, mz14, mz25;

	int v = 0;
	float p0[3];
	float p1[3];
	float points[18];
	int id = t.activerelationobjectid;
	sObject* pObject = GetObjectData(id);
	if (!pObject)
	{
		return;
	}

	sMesh* pMesh = pObject->ppMeshList[0];
	if (!pMesh)
	{
		return;
	}

	LockVertexDataForLimbCore(id, 0, 1);

	// Every 6 elements of data contain two points on the physics object.
	p0[0] = fromx; p0[1] = fromy; p0[2] = fromz;
	p1[0] = tox; p1[1] = toy; p1[2] = toz;

	physics_debug_make_prism_between_points(p0, p1, points, 0.5f);// 3);

	// Corners of the prism.
	x0 = points[0]; y0 = points[1]; z0 = points[2];
	x1 = points[3]; y1 = points[4]; z1 = points[5];
	x2 = points[6]; y2 = points[7]; z2 = points[8];
	x3 = points[9]; y3 = points[10]; z3 = points[11];
	x4 = points[12]; y4 = points[13]; z4 = points[14];
	x5 = points[15]; y5 = points[16]; z5 = points[17];
	// Midpoints.
	mx03 = (x0 + x3) / 2.0f; my03 = (y0 + y3) / 2.0f; mz03 = (z0 + z3) / 2.0f;
	mx14 = (x1 + x4) / 2.0f; my14 = (y1 + y4) / 2.0f; mz14 = (z1 + z4) / 2.0f;
	mx25 = (x2 + x5) / 2.0f; my25 = (y2 + y5) / 2.0f; mz25 = (z2 + z5) / 2.0f;

	// Make each face of the prism (two triangles per face).
	SetVertexDataUV(v, fRelationUVs[0], fRelationUVs[1]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[2], fRelationUVs[3]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[4], fRelationUVs[5]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[6], fRelationUVs[7]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[8], fRelationUVs[9]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[10], fRelationUVs[11]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x3, y3, z3);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x5, y5, z5);

	SetVertexDataUV(v, fRelationUVs[0], fRelationUVs[1]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[2], fRelationUVs[3]);
	SetVertexDataPosition(v++, x0, y0, z0);
	SetVertexDataUV(v, fRelationUVs[4], fRelationUVs[5]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[6], fRelationUVs[7]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[8], fRelationUVs[9]);
	SetVertexDataPosition(v++,x0 ,y0 ,z0 );
	SetVertexDataUV(v, fRelationUVs[10], fRelationUVs[11]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x4, y4, z4);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, mx03, my03, mz03);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x3, y3, z3);

	SetVertexDataUV(v, fRelationUVs[0], fRelationUVs[1]);
	SetVertexDataPosition(v++, x2, y2, z2);
	SetVertexDataUV(v, fRelationUVs[2], fRelationUVs[3]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[4], fRelationUVs[5]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[6], fRelationUVs[7]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[8], fRelationUVs[9]);
	SetVertexDataPosition(v++, x1, y1, z1);
	SetVertexDataUV(v, fRelationUVs[10], fRelationUVs[11]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[12], fRelationUVs[13]);
	SetVertexDataPosition(v++, mx25, my25, mz25);
	SetVertexDataUV(v, fRelationUVs[14], fRelationUVs[15]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[16], fRelationUVs[17]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[18], fRelationUVs[19]);
	SetVertexDataPosition(v++, x5, y5, z5);
	SetVertexDataUV(v, fRelationUVs[20], fRelationUVs[21]);
	SetVertexDataPosition(v++, mx14, my14, mz14);
	SetVertexDataUV(v, fRelationUVs[22], fRelationUVs[23]);
	SetVertexDataPosition(v++, x4, y4, z4);

	UnlockVertexData();

	WickedCall_UpdateMeshVertexData(pMesh);
}

void UpdateObjectRelationUVs(int id)
{
	sObject* pObject = GetObjectData(id);
	if (!pObject)
	{
		return;
	}

	sMesh* pMesh = pObject->ppMeshList[0];
	if (!pMesh)
	{
		return;
	}

	int v = 0;

	LockVertexDataForLimbCore(id, 0, 1);

	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 24; j+=2)
			SetVertexDataUV(v++, fRelationUVs[j], fRelationUVs[j+1]);

	UnlockVertexData();

	WickedCall_UpdateMeshVertexData(pMesh);
}

void DrawObjectRelation(int from, int to, bool bDrawMiddleBut, int forceVertUpdate)
{
	//Find relation colors.
	bool bHighlight = false;
	int iColor = -1;
	int sobj = from - DOTOBJECTIDADD;
	int dobj = to - DOTOBJECTIDADD;
	int iEntID = 0;
	int iRelationID = 0;
	int iNodeConnectionID = 0;
	//DWORD dwNewColor = Rgb(255, 255, 0);
	DWORD dwNewColor = Rgb(225, 225, 225);

	if (bDotMiddleWindow && g_selected_middle_dot_pobject && g_selected_middle_dot_pobject->dwObjectNumber == DOTMIDDLEOBJECTID + iTotalMiddle)
	{
		bHighlight = true;
	}

	if (bHighlight)
	{
		//dwNewColor = Rgb(255, 255, 32);
		dwNewColor = Rgb(255, 255, 255);
	}

	int iNodeConnectionIndex = -1;
	GetMiddleEntityIdAndRelationshipId(sobj, dobj, iEntID, iRelationID, iNodeConnectionID, &iNodeConnectionIndex);
	if (iEntID > 0)
	{
		int iRelationType = t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID];
		if (iRelationType == 1) //Char,Char
		{
			//"Standard Alliances behavior", "Assist other when attacked", "Run away from other when attacked","Stay away from other","Meet other when in visual range"
			if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 0)
			{
				iColor = 1; //Green Standard Alliances behavior
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 1)
			{
				iColor = 2; //Red Assist other when attacked
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 2)
			{
				iColor = 3; //Blue Run away from other when attacked
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 3)
			{
				iColor = 3; //Blue Stay away from other
			}
			else if (t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID] == 4)
			{
				iColor = 1; //Green Meet other when in visual range
			}
		}

		int iColorAdd = 0;
		if (bHighlight)
			iColorAdd = 45;

		//dwNewColor = Rgb(6 + iColorAdd, 65 + iColorAdd, 100 + iColorAdd);

		/* cleaner light blue for EA
		if (iColor == 1)
			dwNewColor = Rgb(0 + iColorAdd, 255, 0 + iColorAdd);
		else if (iColor == 2)
			dwNewColor = Rgb(255, 0 + iColorAdd, 0 + iColorAdd);
		else if (iColor == 3)
			dwNewColor = Rgb(20 + iColorAdd, 100 + iColorAdd, 255);
		*/
	}

	if (bHighlight)
	{
		iColor += 99;
	}

	// when established connection, use centers of object
	float ffromx = ObjectPositionX(sobj) + GetObjectCollisionCenterX(sobj);
	float ffromy = ObjectPositionY(sobj) + GetObjectCollisionCenterY(sobj);
	float ffromz = ObjectPositionZ(sobj) + GetObjectCollisionCenterZ(sobj);
	float ftox = ObjectPositionX(dobj) + GetObjectCollisionCenterX(dobj);
	float ftoy = ObjectPositionY(dobj) + GetObjectCollisionCenterY(dobj);
	float ftoz = ObjectPositionZ(dobj) + GetObjectCollisionCenterZ(dobj);

	// cursor connect at click drag release sites
	if (to == DOTCURSOROBJECTID)
	{
		ftox = ObjectPositionX(to);
		ftoy = ObjectPositionY(to);
		ftoz = ObjectPositionZ(to);
	}

	float fdx = ffromx - ftox;
	float fdy = ffromy - ftoy;
	float fdz = ffromz - ftoz;

	float fDistance = sqrt((fdx * fdx) + (fdy * fdy) + (fdz * fdz));

	if (to == DOTCURSOROBJECTID)
	{
		// Drawing a new relation.
		t.activerelationobjectid = RELATIONOBJECTID;
		if (!ObjectExist(RELATIONOBJECTID))
			CreateObjectRelationMesh(ffromx, ffromy, ffromz, ftox, ftoy, ftoz, dwNewColor);
		else
			UpdateObjectRelationMeshHalf(ffromx, ffromy, ffromz, ftox, ftoy, ftoz);

		ShowObject(RELATIONOBJECTID);
	}

	if (bDrawMiddleBut)
	{
		// Make the button go green when selected.
		if (bHighlight && iNodeConnectionIndex >= 0 && !bDraggingActive)
		{
			//SetObjectDiffuse(nodeconnections[iNodeConnectionIndex].middle, Rgb(40, 140, 65));
			//SetObjectEmissive(nodeconnections[iNodeConnectionIndex].middle, Rgb(0, 255, 0));
			//ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 130, 130, 130);
			ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 35, 35, 35);
		}
		else if (iNodeConnectionIndex >= 0)
		{
			//SetObjectDiffuse(nodeconnections[iNodeConnectionIndex].middle, Rgb(255, 255, 255));
			//SetObjectEmissive(nodeconnections[iNodeConnectionIndex].middle, Rgb(0, 0, 0));
			//ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 100, 100, 100);
			ScaleObject(nodeconnections[iNodeConnectionIndex].middle, 25, 25, 25);
		}

		if (iTotalMiddle < MAXDOTMIDDLE)
		{
			//PE: Middle add a dropdown gadget.
			CreateDotMiddleObject(DOTMIDDLEOBJECTID + iTotalMiddle);

			// Create/Update the lines that travel between the objects.
			t.activerelationobjectid = RELATIONOBJECTID + iTotalMiddle + 1;
			if (ObjectExist(RELATIONOBJECTID + iTotalMiddle + 1) == 0)
			{
				CreateObjectRelationMesh(ffromx, ffromy, ffromz, ftox, ftoy, ftoz, dwNewColor);
				NodeConnection connection;
				connection.from = sobj; connection.to = dobj; connection.nodeconnectionid = RELATIONOBJECTID + iTotalMiddle + 1;
				connection.middle = DOTMIDDLEOBJECTID + iTotalMiddle;
				nodeconnections.push_back(connection);
			}
			else
			{
				SetObjectDiffuse(t.activerelationobjectid, dwNewColor);

				if (nodeconnections[iTotalMiddle].from == sobj && nodeconnections[iTotalMiddle].to == dobj && forceVertUpdate == 0)
				{
					// No vertex update necessary.
					UpdateObjectRelationUVs(t.activerelationobjectid);
				}
				else
				{
					// Update verts and UVs.
					nodeconnections[iTotalMiddle].from = sobj;
					nodeconnections[iTotalMiddle].to = dobj;
					UpdateObjectRelationMesh(ffromx, ffromy, ffromz, ftox, ftoy, ftoz);
				}
				ShowObject(RELATIONOBJECTID + iTotalMiddle + 1);
			}
			//CreateDotMiddleObject(iTotalMiddle);
			ShowObject(DOTMIDDLEOBJECTID + iTotalMiddle);
			PositionObject(DOTMIDDLEOBJECTID + iTotalMiddle, ffromx, ffromy, ffromz);
			PointObject(DOTMIDDLEOBJECTID + iTotalMiddle, ftox, ftoy, ftoz);
			MoveObject(DOTMIDDLEOBJECTID + iTotalMiddle, fDistance*0.5);

			if (bDotMiddleWindow == false)
			{
				/* do not show labels
				// show label of relationship connection
				int thisobj = DOTMIDDLEOBJECTID + iTotalMiddle;
				LPSTR pRelationshipActivity = "";
				int iRelationType = t.entityelement[iEntID].eleprof.iObjectRelationshipsType[iRelationID];
				int iRelationshipsData = t.entityelement[iEntID].eleprof.iObjectRelationshipsData[iRelationID];
				const char* items_combo1[] = { "Alert other character", "Stand-down other character", "Toggle alert of other character" };
				const char* items_combo2[] = { "Reverse at End", "Loop Around At End", "Follow One Way", "Choose Random Flag" };
				const char* items_combo3[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
				const char* items_combo4[] = { "Alert character", "Stand-down character", "Toggle alert the character" };
				const char* items_combo9[] = { "Activate object", "Deactivate object", "Toggle object" }; // "Activate zone", "Deactivate zone", "Toggle zone", "Activate object", "Deactivate object", "Toggle object" ;
				const char* items_combo10[] = { "Activate other object", "Deactivate other object", "Toggle other object" };
				if (iRelationType == 1)	pRelationshipActivity = (LPSTR)items_combo1[iRelationshipsData];
				if (iRelationType == 2)	pRelationshipActivity = (LPSTR)items_combo2[iRelationshipsData];
				if (iRelationType == 3)	pRelationshipActivity = (LPSTR)items_combo3[iRelationshipsData];
				if (iRelationType == 4)	pRelationshipActivity = (LPSTR)items_combo4[iRelationshipsData];
				if (iRelationType == 9)	pRelationshipActivity = (LPSTR)items_combo9[iRelationshipsData];
				if (iRelationType == 10) pRelationshipActivity = (LPSTR)items_combo10[iRelationshipsData];
				if (GetInScreen(thisobj) == 1 && iRelationType !=5 && iRelationType != 6 && iRelationType != 7 && iRelationType != 8)
				{
					pastebitmapfontcenter(pRelationshipActivity, GetScreenX(thisobj), GetScreenY(thisobj), 1, 192);
				}
				*/
			}

			iDotMiddleInfoSource[iTotalMiddle] = from;
			iDotMiddleInfoDestination[iTotalMiddle] = to;
	
			iTotalMiddle++;
			if (iTotalMiddle > iLargestMiddle)
				iLargestMiddle = iTotalMiddle;
		}
	}
}

void deleterelationobjects()
{
	for (int i = RELATIONOBJECTID; i < RELATIONOBJECTID + RELATIONOBJECTMAX; i++)
	{
		if (ObjectExist(i))
			DeleteObject(i);
	}
}
#endif

///

float ImGuiGetMouseX( void )
{
#ifdef WICKEDENGINE
	RECT rect = { NULL };
	GetWindowRect(g_pGlob->hWnd, &rect);
	return(t.inputsys.xmouse - rect.left);
#else
	return(t.inputsys.xmouse);
#endif
}

float ImGuiGetMouseY(void)
{
#ifdef WICKEDENGINE
	RECT rect = { NULL };
	GetWindowRect(g_pGlob->hWnd, &rect);
	return(t.inputsys.ymouse - rect.top);
#else
	return(t.inputsys.ymouse);
#endif
}

#ifdef WICKEDENGINE

//PE:Turning 180 make artifacts in colors, and are hard to control. it get reflections/light from env.
//#define TURNBACKDROP180
//#define MOVEPROBETO_BLACK //Move probe to black area, for better control of colors. This make titanium objects black, without ambient control this will not work.

bool bBackdropSettingsSet = false;
bool old_g_bNoSwapchainPresent = false;
float composx;
float composy;
float composz;
float comangx;
float comangy;
float comangz;
int iFogChangedFramesBeforeRestore = 0;

void CreateBackdropObject(bool bForceRecreate,cstr newImageFile,cstr fpefile)
{
	if(cUseBackbufferCubemap.Len() > 0)
		RevertBackbufferCubemap();
	cUseBackbufferCubemap = "";
	
	if (newImageFile.Len() > 0)
	{
		if (cCurrentBackDropImageFile != newImageFile)
		{
			// this is the new current backdrop
			cCurrentBackDropImageFile = newImageFile;

			// delete if old one exists
			image_setlegacyimageloading(true);
			if (ImageExist(BACKDROPMAGE))
				DeleteImage(BACKDROPMAGE);
			image_setlegacyimageloading(false);

			// LB: Prefer DDS if available
			LPSTR pLoadThisBackdrop = cCurrentBackDropImageFile.Get();
			char pDDSVariantOfBackdropFile[MAX_PATH];
			strcpy ( pDDSVariantOfBackdropFile, cCurrentBackDropImageFile.Get());
			pDDSVariantOfBackdropFile[strlen(pDDSVariantOfBackdropFile) - 4] = 0;
			strcat (pDDSVariantOfBackdropFile, ".dds");
			if (FileExist(pDDSVariantOfBackdropFile) == 1)
				pLoadThisBackdrop = pDDSVariantOfBackdropFile;

			// load for IMGUI to display
			image_setlegacyimageloading(true);
			LoadImage(pLoadThisBackdrop, BACKDROPMAGE);
			image_setlegacyimageloading(false);
			bForceRecreate = true;
		}
	}

	//Simple Sky.
	if((!ImageExist(BACKDROPMAGE) || newImageFile == "None") && fpefile.Len() > 0)
	{
		if (pestrcasestr(fpefile.Get(), ".fpe"))
		{
			std::string sString = fpefile.Get();
			replaceAll(sString, ".fpe", "_fpe_cube.dds");
			cUseBackbufferCubemap = cstr("entitybank\\") + cstr( (char *) sString.c_str());
			// showcase\titanium_fpe_cube.dds
			if (FileExist(cUseBackbufferCubemap.Get()))
			{
				wiScene::WeatherComponent* weather = wiScene::GetScene().weathers.GetComponent(g_weatherEntityID);
				if (weather->skyMap != nullptr && weather->skyMapName.length() > 0)
				{
					//PE: Make sure to free any old resources.
					WickedCall_DeleteImage(weather->skyMapName);
				}
				weather->skyMapName = cUseBackbufferCubemap.Get();
				weather->skyMap = WickedCall_LoadImage(weather->skyMapName);
				weather->cloudiness = 0.0f;
				weather->cloudSpeed = 0.0f;

				// update cubes
				WickedCall_DisplayCubes(false);

				if (ObjectExist(t.terrain.terrainobjectindex) == 1)
				{
					HideObject(t.terrain.terrainobjectindex);
				}
				t.hardwareinfoglobals.noterrain = 1;

				float centerx = -1000, centery = 39000, centerz = -1000;
				WickedCall_MoveReflectionProbe(centerx, centery, centerz, "editorProbe", 500);
				WickedCall_UpdateProbes();
				bBackbufferCubemapActive = true;
			}
			else
			{
				cUseBackbufferCubemap = "";
			}
		}
	}

	int backdropobj = BACKDROPMAGE;
	if (bForceRecreate || (bUseBackDropImage && !ObjectExist(backdropobj)))
	{
		if (ObjectExist(backdropobj))
			DeleteObject(backdropobj);
		//float fDist = 6.5f;
		float fDist = 13.0f;
		MakeObjectPlane(backdropobj, 1920 * fDist, 1080 * fDist);
		//PE: No light.
		LockVertexDataForLimbCore(backdropobj, 0, 1);
		SetVertexDataNormals(0, 0, 1, 0);
		SetVertexDataNormals(1, 0, 1, 0);
		SetVertexDataNormals(2, 0, 1, 0);
		SetVertexDataNormals(3, 0, 1, 0);
		SetVertexDataNormals(4, 0, 1, 0);
		SetVertexDataNormals(5, 0, 1, 0);
		UnlockVertexData();
		#ifndef TURNBACKDROP180
		//Flip image.
		float U_f = 1.0f , V_f = 0.0f, D_f = -1.0f;
		LockVertexDataForLimb(backdropobj, 0);
		SetVertexDataUV(0, U_f, V_f);
		SetVertexDataUV(1, U_f + D_f, V_f);
		SetVertexDataUV(2, U_f + D_f, V_f + 1.0f);
		SetVertexDataUV(3, U_f + D_f, V_f + 1.0f);
		SetVertexDataUV(4, U_f, V_f + 1.0f);
		SetVertexDataUV(5, U_f, V_f);
		UnlockVertexData();
		#endif
		//SetObjectUVManually(backdropobj, 0, 1, 1);

		FixObjectPivot(backdropobj);
		SetObjectTransparency(backdropobj, 1);
		SetObjectCollisionOff(backdropobj);
		SetObjectTextureMode(backdropobj, 0, 0);
		SetObjectLight(backdropobj, 0);
		SetObjectMask(backdropobj, 1);
		if(cCurrentBackDropImageFile.Len() > 0 && ImageExist(BACKDROPMAGE))
			TextureObject(backdropobj, BACKDROPMAGE);
		SetObjectCull(backdropobj, 0);
		//DisableObjectZDepth(backdropobj);
		//DisableObjectZRead(backdropobj);
		sObject* pBackObject = GetObjectData(backdropobj);
		if (pBackObject)
		{
			//Make sure we flip UV , image is inverted in the x dir.
			if (pBackObject->ppMeshList)
			{
				sMesh* pMesh = pBackObject->ppMeshList[0];
				if (pMesh) WickedCall_UpdateMeshVertexData(pMesh);
			}

			WickedCall_SetObjectCastShadows(pBackObject, false);

			float fColorR,fColorG,fColorB;
			if (cCurrentBackDropImageFile.Len() > 0 && ImageExist(BACKDROPMAGE))
			{
				fColorR = 1.0f;
				fColorG = 1.0f;
				fColorB = 1.0f;
			}
			else
			{
				//Default thumb color , changed for unlit shader.
				fColorR = 0.32f;
				fColorG = 0.32f;
				fColorB = 0.32f;

			}

			for (int iMesh = 0; iMesh < pBackObject->iMeshCount; iMesh++)
			{
				sMesh* pMesh = pBackObject->ppMeshList[iMesh];
				if (pMesh)
				{
					//Boost colors. we are way out there in 3D space.
					#ifdef TURNBACKDROP180
					pMesh->mMaterial.Diffuse.r = fColorR * 2.0f;
					pMesh->mMaterial.Diffuse.g = fColorG * 2.0f;
					pMesh->mMaterial.Diffuse.b = fColorB * 2.0f;
					#else

					if (cCurrentBackDropImageFile.Len() > 0 && ImageExist(BACKDROPMAGE))
					{
						//Place above water level.
						pMesh->mMaterial.Diffuse.r = fColorR; // *1.0f;
						pMesh->mMaterial.Diffuse.g = fColorG; // *1.0f;
						pMesh->mMaterial.Diffuse.b = fColorB; // *1.0f;
					}
					else
					{
						//ENV-Probe placed at play area.
						pMesh->mMaterial.Diffuse.r = fColorR * 2.5f;
						pMesh->mMaterial.Diffuse.g = fColorG * 2.5f;
						pMesh->mMaterial.Diffuse.b = fColorB * 2.5f;
					}

					#endif
					pMesh->mMaterial.Diffuse.a = 1.0f;
					wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
					if (mesh)
					{
						uint64_t materialEntity = mesh->subsets[0].materialID;
						wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
						if (pObjectMaterial)
						{
							pObjectMaterial->SetReflectance(0.0f);
							pObjectMaterial->shaderType = wiScene::MaterialComponent::SHADERTYPE_UNLIT; //PE: Yes 1:1 mapping and no light,env... :)
							//PE: Also ignoes all other material settings , so its perfect.
							pObjectMaterial->SetDirty(true);
						}
					}
					WickedCall_SetMeshMaterial(pMesh,true);
				}
			}
			WickedCall_SetObjectMetalness(pBackObject, 0.0f);
			WickedCall_SetObjectRoughness(pBackObject, 0.0f);
		}
	}
	if (ObjectExist(backdropobj))
		HideObject(backdropobj);
	WickedCall_DisplayCubes(false);

	if (!bRotateBackBuffer) {
		//Dont disable bloom when hover over , so the scene behind dont flash with bloom on / off.
		//WickedCall_SetSunDirection(45.0f, 270.0f, 0.0f);
		master_renderer->setBloomEnabled(false);
	}
	//PE: Always move probe, as terrain is now not grass.
	float centerx = -1000, centery = 190000000, centerz = -1000;
	//PE: This pos is black.
	#ifdef MOVEPROBETO_BLACK
	WickedCall_MoveReflectionProbe(centerx, centery, centerz, "editorProbe", 500);
	#endif

	//PE: Disable fog.
	float oldFogNear = t.visuals.FogNearest_f;
	float oldFogFar = t.visuals.FogDistance_f;
	//PE: Fog is now removed in wicked repo.
//	if (t.visuals.FogDistance_f < 30000.0f)
//	{
//		t.visuals.FogDistance_f = 1000000.0f; //Disable fog.
//		t.visuals.FogNearest_f = 960400;// 1000000.0f;
//		Wicked_Update_Visuals((void *)&t.visuals);
//		iFogChangedFramesBeforeRestore = 5;
//		t.visuals.FogDistance_f = oldFogFar;
//		t.visuals.FogNearest_f = oldFogNear;
//	}
	//Now always use thumb light.
	WickedCall_EnableThumbLight(true);

	extern bool g_bNoSwapchainPresent;
	old_g_bNoSwapchainPresent = g_bNoSwapchainPresent;

	composx = CameraPositionX(0);
	composy = CameraPositionY(0);
	composz = CameraPositionZ(0);
	comangx = CameraAngleX(0);
	comangy = CameraAngleY(0);
	comangz = CameraAngleZ(0);

	bBackdropSettingsSet = true;
}

extern Master master;

void StartForceRender(void)
{
	extern bool g_bNoGGUntilGameGuruMainCalled;
	//PE: Cant use forcerender until init is done.
	if (!g_bNoGGUntilGameGuruMainCalled) return;
	//bool renderstate = master.ForceRender(0);
	extern bool bSkipAllGameLogic;
	bSkipAllGameLogic = true;
	//PE: Empty messages , so windows dont think we are dead. ( perhaps remember QUIT ? )
	MSG msg = { 0 };
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	master.RunCustom();
	//Give some time for wicked to finish its jobs.
	Sleep(1);
	bSkipAllGameLogic = false;
	return;
}

int current_backbuffer_width = 0;
int current_backbuffer_height = 0;
int current_backbuffer_grabimg = 0;

void GrabBackBufferForAnImage(void)
{
	//if (g.vrglobals.GGVREnabled > 0 && g.vrglobals.GGVRUsingVRSystem == 1 && t.game.activeStoryboardScreen > -1)
	extern int g_iActivelyUsingVRNow;
	if (g.vrglobals.GGVREnabled > 0 && g_iActivelyUsingVRNow == 1 && t.game.activeStoryboardScreen > -1)
	{
		// instruct to grab screen 
		BackBufferSaveCacheName = "";
		current_backbuffer_grabimg = g.importermenuimageoffset + 50;
		BackBufferImageID = current_backbuffer_grabimg;
		BackBufferZoom = 1.0f;
		BackBufferCamLeft = 0.0f;
		BackBufferCamUp = 0.0f;
		bRotateBackBuffer = false;
		bLoopBackBuffer = true;
		BackBufferObjectID = 0;
		BackBufferGrabGameScreen = true;
		BackBufferSizeX = 1920;
		BackBufferSizeY = 1080;
		bFullScreenBackbuffer = true;

		// quad to view HUD screen
		bool bShowMe = true;
		if (bShowMe == true)
		{
			if (ObjectExist(g.hudscreen3dobjectoffset) == 0)
			{
				float fCorrectWidth = 192.0f / 5.0f;
				float fCorrectHeight = 108.0f / 5.0f;
				int backdropobj = g.hudscreen3dobjectoffset;
				MakeObjectPlane(backdropobj, fCorrectWidth, fCorrectHeight);
				LockVertexDataForLimbCore(backdropobj, 0, 1);
				SetVertexDataNormals(0, 0, 1, 0);
				SetVertexDataNormals(1, 0, 1, 0);
				SetVertexDataNormals(2, 0, 1, 0);
				SetVertexDataNormals(3, 0, 1, 0);
				SetVertexDataNormals(4, 0, 1, 0);
				SetVertexDataNormals(5, 0, 1, 0);
				UnlockVertexData();
				float U_f = 0.0f, V_f = 0.0f, D_f = 1.0f;
				LockVertexDataForLimb(backdropobj, 0);
				SetVertexDataUV(0, U_f, V_f);
				SetVertexDataUV(1, U_f + D_f, V_f);
				SetVertexDataUV(2, U_f + D_f, V_f + 1.0f);
				SetVertexDataUV(3, U_f + D_f, V_f + 1.0f);
				SetVertexDataUV(4, U_f, V_f + 1.0f);
				SetVertexDataUV(5, U_f, V_f);
				UnlockVertexData();
				FixObjectPivot(backdropobj);
				SetObjectTransparency(backdropobj, 0);// 1); transparency mode (preferred) is WAT TOO DIM!
				SetObjectCollisionOff(backdropobj);
				SetObjectTextureMode(backdropobj, 0, 0);
				SetObjectLight(backdropobj, 0);
				SetObjectCull(backdropobj, 0);
				sObject* pBackObject = GetObjectData(backdropobj);
				if (pBackObject)
				{
					if (pBackObject->ppMeshList)
					{
						sMesh* pMesh = pBackObject->ppMeshList[0];
						if (pMesh) WickedCall_UpdateMeshVertexData(pMesh);
					}
					WickedCall_SetObjectCastShadows(pBackObject, false);
					float fColorR, fColorG, fColorB;
					fColorR = 1.0f;
					fColorG = 1.0f;
					fColorB = 1.0f;
					for (int iMesh = 0; iMesh < pBackObject->iMeshCount; iMesh++)
					{
						sMesh* pMesh = pBackObject->ppMeshList[iMesh];
						if (pMesh)
						{
							pMesh->mMaterial.Diffuse.r = fColorR; // *1.0f;
							pMesh->mMaterial.Diffuse.g = fColorG; // *1.0f;
							pMesh->mMaterial.Diffuse.b = fColorB; // *1.0f;
							pMesh->mMaterial.Diffuse.a = 1.0f;
							wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
							if (mesh)
							{
								uint64_t materialEntity = mesh->subsets[0].materialID;
								wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
								if (pObjectMaterial)
								{
									pObjectMaterial->SetReflectance(0.0f);
									pObjectMaterial->shaderType = wiScene::MaterialComponent::SHADERTYPE_UNLIT;
									pObjectMaterial->SetDirty(true);
								}
							}
						}
						WickedCall_SetMeshMaterial(pMesh,true);
					}
					WickedCall_SetObjectMetalness(pBackObject, 0.0f);
					WickedCall_SetObjectRoughness(pBackObject, 0.0f);
				}
				SetObjectMask (g.hudscreen3dobjectoffset, (1 << 6) + (1 << 7) + 1);
			}
			if (ObjectExist(g.hudscreen3dobjectoffset) == 1)
			{
				float fX = CameraPositionX(0);
				float fY = CameraPositionY(0);
				float fZ = CameraPositionZ(0);
				PositionObject (g.hudscreen3dobjectoffset, fX, fY, fZ);
				
				//not reliable in VR mode
				//SetObjectToCameraOrientation(g.hudscreen3dobjectoffset);
				RotateObject(g.hudscreen3dobjectoffset, 0, t.playercontrol.cy_f, 0);
				MoveObject(g.hudscreen3dobjectoffset, 20.0f);

				sObject* pHUDScreenObject = GetObjectData(g.hudscreen3dobjectoffset);
				if (pHUDScreenObject)
				{
					TextureObject (g.hudscreen3dobjectoffset, current_backbuffer_grabimg);
					WickedCall_TextureObjectWithImagePtr(pHUDScreenObject, 0);
				}
				ShowObject(g.hudscreen3dobjectoffset);
				if (t.currentgunobj > 0 && ObjectExist(t.currentgunobj) == 1) HideObject(t.currentgunobj);
			}
		}
	}
	else
	{
		if (ObjectExist(g.hudscreen3dobjectoffset) == 1)
		{
			HideObject(g.hudscreen3dobjectoffset);
			if (t.currentgunobj > 0 && ObjectExist(t.currentgunobj) == 1) ShowObject(t.currentgunobj);
		}
	}
}

void GrabBackBufferCopy(void)
{
#ifdef OPTICK_ENABLE
	OPTICK_EVENT();
#endif
	// reject backbuffer copy under certain conditions
	if (iFogChangedFramesBeforeRestore > 0)
	{
		if(iFogChangedFramesBeforeRestore == 1) Wicked_Update_Visuals((void *)&t.visuals);
		iFogChangedFramesBeforeRestore--;
	}
	if (!bImGuiInitDone)
		return;

	if (BackBufferObjectID == 0 && BackBufferGrabGameScreen)
	{
		// allow no object if grabbing whole game scene
	}
	else
	{
		if ((BackBufferObjectID <= 0 && !BackBufferSnapShotMode && !BackBufferParticlesMode) || BackBufferImageID <= 0)
			return;
	}

	if (BackBufferParticlesMode && iBackBufferParticlesTrigger > 0)
	{
		// wait some frames before capture.
		iBackBufferParticlesTrigger--;
		return;
	}

	if (iFogChangedFramesBeforeRestore > 0) iFogChangedFramesBeforeRestore = 5;

	if (!BackBufferParticlesMode && BackBufferParticleEmitter != -1)
	{
		gpup_deleteEffect(BackBufferParticleEmitter);
		BackBufferParticleEmitter = -1;
	}

	// can detect backbuffer size changes
	extern int iLastResolutionWidth;
	extern int iLastResolutionHeight;

	// make sure new rendertarget is the same as the backbuffer size.
	if (!BitmapExist(99) || (iLastResolutionWidth != current_backbuffer_width || iLastResolutionHeight != current_backbuffer_height))
	{
		current_backbuffer_height = iLastResolutionHeight;
		current_backbuffer_width = iLastResolutionWidth;
		if (wiRenderer::GetDevice())
		{
			ID3D11Texture2D *pBackBuffer = (ID3D11Texture2D *)wiRenderer::GetDevice()->GetBackBufferForGG( &master.swapChain );
			if (pBackBuffer)
			{
				GGSURFACE_DESC ddsd;
				pBackBuffer->GetDesc(&ddsd);
				//PE: This is the resolution all current thumbs has used.
				if (bProceduralLevel || bFullScreenBackbuffer || BackBufferGrabGameScreen)
				{
					//Use current backbuffer size on this.
					MakeBitmap(99, ddsd.Width, ddsd.Height);
				}
				else
				{
					MakeBitmap(99, 1920, 1017);
				}
			}
		}
	}
	if (BitmapExist(99))
	{
		SetCurrentBitmap(99);
		SETUPClearEx(64, 64, 64, 64);
	}

	// using a render target in g_DefaultGGFORMAT is way faster.
	LPGGRENDERTARGETVIEW rendertarget;
	rendertarget = (LPGGRENDERTARGETVIEW)GetBitmapRenderTarget(99);

	// store current camera pos and angle
	if (!bBackdropSettingsSet || bSnapShotModeUseCamera || BackBufferParticlesMode)
	{
		composx = CameraPositionX(0);
		composy = CameraPositionY(0);
		composz = CameraPositionZ(0);
		comangx = CameraAngleX(0);
		comangy = CameraAngleY(0);
		comangz = CameraAngleZ(0);
	}

	// get water state
	bool bOldWater = t.visuals.bWaterEnable;

	// get backbuffer size as grab size
	float grabx = BackBufferSizeX;
	float graby = BackBufferSizeY;
	if (grabx <= 0 || graby <= 0)
	{
		grabx = 512;
		graby = 288;
	}

	// vars for below
	int displayobj, entid;
	float fOldObjPosX, fOldObjAngX, fOldObjPosY, fOldObjAngY, fOldObjPosZ, fOldObjAngZ;
	bool bDisplayObjVisible = false;
	bool bWaterVisible = false;

	// move camera for the grab, but not too far given camera resolution
	float centerx = -1000, centery = 39000, centerz = -1000;

	// if backbuffer ready to grab
	int backdropobj = BACKDROPMAGE;
	if (!BackBufferSnapShotMode && !BackBufferParticlesMode)
	{
		if (bUseBackDropImage && !ObjectExist(backdropobj))
		{
			CreateBackdropObject(false,"","");
		}
		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			if (BackBufferSizeX >= 1024)
				ScaleObject(backdropobj, 100, 100, 100);
			else if (BackBufferSizeX <= 512)
				ScaleObject(backdropobj, 50, 50, 50);
			ShowObject(backdropobj);
			if (cUseBackbufferCubemap.Len() > 0)
			{
				HideObject(backdropobj);
			}
		}

		// if object used
		sObject* pObject = NULL;
		bool bNeedZRotation = false;
		float fLargestY = 111;
		float fLargestX = 111;
		float fLargestZ = 111;
		float fLargest = 111;
		if (BackBufferObjectID > 0)
		{
			// place Object to be the subject of the grab
			displayobj = BackBufferObjectID;
			entid = displayobj - g.entitybankoffset;
			fOldObjPosX = ObjectPositionX(displayobj); fOldObjPosY = ObjectPositionY(displayobj); fOldObjPosZ = ObjectPositionZ(displayobj);
			fOldObjAngX = ObjectAngleX(displayobj); fOldObjAngY = ObjectAngleY(displayobj); fOldObjAngZ = ObjectAngleZ(displayobj);
			if (g_ObjectList[displayobj] && g_ObjectList[displayobj]->bVisible)	bDisplayObjVisible = true;
			float fOffsetX = 0.0f, fOffsetY = 0.0f, fOffsetZ = 0.0f;
			pObject = g_ObjectList[displayobj];
			if (pObject)
			{
				float fAdjustScaleX = 1.0, fAdjustScaleY = 1.0, fAdjustScaleZ = 1.0;
				if (pObject->pInstanceOfObject)
				{
					fAdjustScaleX = pObject->position.vecScale[0];
					fAdjustScaleY = pObject->position.vecScale[1];
					fAdjustScaleZ = pObject->position.vecScale[2];
					pObject = pObject->pInstanceOfObject;
				}
				float fValue;
				if (t.entityprofile[entid].ischaracter != 1)
				{
					fValue = (pObject->collision.vecMax[0] + pObject->collision.vecMin[0]);
					fValue = ApplyPivot(pObject, 0, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
					fValue = fValue * pObject->position.vecScale[0] * fAdjustScaleX;
					fOffsetX = fValue * 0.5f;
					fValue = (pObject->collision.vecMax[2] + pObject->collision.vecMin[2]);
					fValue = ApplyPivot(pObject, 2, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
					fValue = fValue * pObject->position.vecScale[2] * fAdjustScaleZ;
					fOffsetZ = fValue * 0.5f;
				}
				fValue = (pObject->collision.vecMax[1] + pObject->collision.vecMin[1]);
				fValue = ApplyPivot(pObject, 1, GGVECTOR3(pObject->collision.vecMax - pObject->collision.vecMin), fValue);
				fValue = fValue * pObject->position.vecScale[1] * fAdjustScaleY;
				fOffsetY = fValue * 0.5f;
				if (pObject->pFrame)
				{
					fOffsetX += -(pObject->pFrame->vecOffset.x * fAdjustScaleX);
					fOffsetY += -(pObject->pFrame->vecOffset.y * fAdjustScaleY);
					fOffsetZ += -(pObject->pFrame->vecOffset.z * fAdjustScaleZ);
				}
			}

			// find largest dimension
			fLargestY = ObjectSizeY(displayobj, 1);
			fLargestX = ObjectSizeX(displayobj, 1);
			fLargestZ = ObjectSizeZ(displayobj, 1);
			fLargest = fLargestX;
			if (fLargestZ > fLargest) fLargest = fLargestZ;
			if (fLargestY > fLargest) fLargest = fLargestY;

			// handle small objects.
			if (fLargest < 15.0) fLargest = 15.0;
			if (fLargest >= 2500.0) fLargest = 2500.0;

			// set object up
			PositionObject(displayobj, centerx, centery, centerz);
			if (t.entityprofile[entid].bIsDecal)
			{
				PositionObject(displayobj, centerx + (fLargestX * 0.5), centery + (fLargestY * 0.5), centerz);
			}
			if (t.entityprofile[entid].ismarker != 0 || t.entityprofile[entid].zdepth == 0)
			{
				SetObjectMask(displayobj, 1);
			}
			else
			{
				SetObjectMask(displayobj, 1 + (1 << 31));
			}
			ShowObject(displayobj);
			RotateObject(displayobj, fOldObjAngX, fOldObjAngY + 15, fOldObjAngZ);

			// set camera up
			RotateCamera(0, 0, 0);
			PositionCamera(centerx, centery, centerz);
			PointCamera(centerx, centery, centerz);

			// adjustments needed
			float fAdjustRange = 5.0;
			fAdjustRange -= (grabx + graby) / 512.0;
			if (fAdjustRange < 0.5)
				fAdjustRange = 0.5;
			if ((grabx + graby) <= 256)
				fAdjustRange += 2.0;
			if ((grabx + graby) >= 2048)
				fAdjustRange += 0.5;

			// 512x288=3.5 - This really depend on the image size we capture to.
			float fCamMove = fLargest * (fAdjustRange + 0.1);
			MoveCamera(-(fCamMove));
			BackBufferCamMove = fCamMove * 2.0;

			// adjust camera based on object largest calc and adjustment
			if (fLargest != 15.0 && fLargestY < 4.0) fLargestY += 200.0;
			if (fLargest != 15.0 && fLargestY < 7.0) fLargestY += 100.0;
			if (fLargest != 15.0 && fLargestY < 40.0) fLargestY = 40.0;
			if (fLargestY < 10.0) fLargestY = 10.0;
			float fAdjustY = fAdjustRange * 0.5;
			if (fLargestY >= 2500.0) fLargestY = 2500.0;
			if (t.entityprofile[entid].isebe == 1)
			{
				fLargestY += 140.0;
			}
			PositionCamera(CameraPositionX(0), CameraPositionY(0) + (fLargestY * fAdjustY), CameraPositionZ(0));
			PointCamera(centerx + fOffsetX, centery + fOffsetY, centerz + fOffsetZ);

			// work out if need rotation on the Z
			float cangx = CameraAngleX();
			float cangy = CameraAngleY();
			float cangz = CameraAngleZ();
			if (cangx > 39 && cangx < 300)
			{
				bNeedZRotation = true;
			}

			// restore backbuffer camera
			if (bBackBufferRestoreCamera)
			{
				//Restore camera settings from FPE. Only trigger this one time.
				BackBufferRotateY = RestoreBackBufferRotateY;
				if (t.entityprofile[entid].ischaracter == 0)
				{
					BackBufferRotateX = RestoreBackBufferRotateX;
				}
				else
				{
					BackBufferRotateX = 0.0;
				}
				BackBufferCamUp = RestoreBackBufferCamUp;
				BackBufferCamLeft = RestoreBackBufferCamLeft;
				BackBufferZoom = RestoreBackBufferZoom;
				if (BackBufferSizeX < 1024)
				{
					BackBufferZoom *= 1.7f;
					BackBufferCamUp *= 0.95f;
				}
			}

			// apply camera zoom and shift
			MoveCamera(BackBufferZoom);
			MoveCameraLeft(0, BackBufferCamLeft);
			MoveCameraUp(0, BackBufferCamUp);
		}

		// if backbuffer in loop or restore mode
		if (bLoopBackBuffer || bBackBufferRestoreCamera)
		{
			if (BackBufferObjectID > 0)
			{
				// object animation speed
				if (bBackBufferAnimated)
				{
					t.tanimspeed_f = t.entityprofile[BackBufferEntityID].animspeed;
					if (ObjectExist(BackBufferObjectID) == 1)
					{
						SetObjectSpeed(BackBufferObjectID, t.tanimspeed_f);
					}
				}

				// rotation mode
				if (bRotateBackBuffer && !bBackBufferAnimated)
				{
					if (bNeedZRotation)
					{
						BackBufferRotateZ += 3.0 * g.timeelapsed_f;
						if (BackBufferRotateZ > 360.0)
							BackBufferRotateZ -= 360.0;
					}
					else
					{
						BackBufferRotateY += 3.0 * g.timeelapsed_f;
						if (BackBufferRotateY > 360.0)
							BackBufferRotateY -= 360.0;
					}
				}

				// object and camera stats
				float ox = ObjectPositionX(displayobj);
				float oy = ObjectPositionY(displayobj);
				float oz = ObjectPositionZ(displayobj);
				float cx = CameraPositionX();
				float cy = CameraPositionY();
				float cz = CameraPositionZ();
				float dist = GetDistance(cx, cy, cz, ox, oy, oz);

				// apply object handling
				RotateObject(displayobj, 0, 0, 0);
				if (pObject && pObject->position.bApplyPivot)
				{
					PitchObjectUpWorld(displayobj, BackBufferRotateX);
					TurnObjectRightWorld(displayobj, BackBufferRotateY);
					if (bNeedZRotation) RollObjectLeftWorld(displayobj, BackBufferRotateZ);
				}
				else
				{
					PitchObjectDownWorld(displayobj, BackBufferRotateX);
					TurnObjectRightWorld(displayobj, BackBufferRotateY);
					if (bNeedZRotation)	RollObjectLeftWorld(displayobj, BackBufferRotateZ);
				}
			}
		}
		bBackBufferRestoreCamera = false;

		// using backdrop object
		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			MoveCamera(2.0f);
			PositionObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
			MoveCamera(-2.0f);
			PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
			MoveObject(backdropobj, -21200.0f);
			PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
		}

		// wwitch away from editor light , so we dont interfere with the current light on the scene.
		if (BackBufferObjectID > 0)
		{
			extern wiECS::Entity g_entityThumbLight, g_entityThumbLight2;
			if (g_entityThumbLight)
			{
				wiScene::TransformComponent* transformLightCamera = wiScene::GetScene().transforms.GetComponent(g_entityThumbLight);
				transformLightCamera->ClearTransform();
				float fCamX = CameraPositionX(0);
				float fCamY = CameraPositionY(0);
				float fCamZ = CameraPositionZ(0);
				transformLightCamera->Translate(XMFLOAT3(fCamX, fCamY + 20.0f, fCamZ));
				transformLightCamera->SetDirty();
			}
			if (g_entityThumbLight2)
			{
				wiScene::TransformComponent* transformLightCamera = wiScene::GetScene().transforms.GetComponent(g_entityThumbLight2);
				transformLightCamera->ClearTransform();
				float fCamX = ObjectPositionX(displayobj) - (fLargestX * 2.0);
				float fCamY = ObjectPositionY(displayobj);
				float fCamZ = ObjectPositionZ(displayobj) + (fLargestZ * 2.0); // move behind object
				transformLightCamera->Translate(XMFLOAT3(fCamX, fCamY + 20.0f, fCamZ));
				transformLightCamera->SetDirty();
			}
		}
	}
	else
	{
		// snap shop mode.
		if (BackBufferParticlesMode)
		{
			RotateCamera(0, 0, 0);
			PositionCamera(centerx, centery, centerz);
			PointCamera(centerx, centery, centerz);
			MoveCamera(-BackBufferZoom);
			MoveCameraUp(0, BackBufferCamUp);
			PointCamera(centerx, centery, centerz);
			if (bUseBackDropImage && ObjectExist(backdropobj))
			{
				if (BackBufferSizeX >= 1024) ScaleObject(backdropobj, 100, 100, 100);
				else if (BackBufferSizeX <= 512) ScaleObject(backdropobj, 50, 50, 50);
				ShowObject(backdropobj);
				MoveCamera(2.0f);
				PositionObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
				MoveCamera(-2.0f);
				PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
				MoveObject(backdropobj, -21200.0f); //Large objects get clipped, move further away.
				PointObject(backdropobj, CameraPositionX(), CameraPositionY(), CameraPositionZ());
			}
		}
		if (bSnapShotModeUseCamera )
		{
			PositionCamera(fSnapShotModeCameraX, fSnapShotModeCameraY, fSnapShotModeCameraZ);
			RotateCamera(fSnapShotModeCameraAngX, fSnapShotModeCameraAngY, fSnapShotModeCameraAngZ);
		}
	}

	// render settings
	extern bool g_bNoSwapchainPresent;
	bool ioldstate = g_bNoSwapchainPresent;
	g_bNoSwapchainPresent = true;

	extern bool g_bNo2DRender;
	g_bNo2DRender = true;
	if(bSnapShotModeUse2D || BackBufferGrabGameScreen)
		g_bNo2DRender = false;

	extern bool g_bNoTerrainRender;
	bool bOldg_bNoTerrainRender = g_bNoTerrainRender;
	if (bProceduralLevel)
		g_bNoTerrainRender = false;
	else
		g_bNoTerrainRender = true;

	// handlw wide screen scenario
	bool bIsWideScreen = false;
	float gpw = master.masterrenderer.GetWidth3D();
	float gph = master.masterrenderer.GetHeight3D();
	if (( (float)gpw / (float) gph) > 2.1 && gpw > 1920)
		bIsWideScreen = true;

	// fit fixed backbuffer and thumb resolution
	if (bIsWideScreen && !bFullScreenBackbuffer)
	{
		float fCameraFov = XM_PI / ((45.0) / 15.0f); 
		wiScene::GetCamera().CreatePerspective( 1920.0f, 1017.0f, t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
		wiScene::GetCamera().SetDirty(true);
	}

	// force a render of the backbuffer to do the grab
	bool renderstate = master.ForceRender(rendertarget);

	// restore render settings after the forced render
	if (bIsWideScreen && !bFullScreenBackbuffer)
	{
		float fCameraFov = XM_PI / ((t.visuals.CameraFOV_f) / 15.0f); //Fit GG settings.
		wiScene::GetCamera().CreatePerspective((float)master.masterrenderer.GetLogicalWidth(), (float)master.masterrenderer.GetLogicalHeight(), t.visuals.CameraNEAR_f, t.visuals.CameraFAR_f, fCameraFov);
		wiScene::GetCamera().SetDirty(true);
	}
	if (bProceduralLevel)
	{
		extern bool g_bNoTerrainRender;
		g_bNoTerrainRender = true;
	}
	else
	{
		g_bNoTerrainRender = bOldg_bNoTerrainRender;
	}
	g_bNo2DRender = false;
	g_bNoSwapchainPresent = ioldstate;
	bBackdropSettingsSet = false;

	// restore after grab process
	if (!BackBufferSnapShotMode && !BackBufferParticlesMode)
	{
		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			HideObject(backdropobj);
			if (!bLoopBackBuffer)
			{
				RevertBackbufferCubemap();
				WickedCall_UpdateProbes();
			}
		}
		if (!bLoopBackBuffer)
		{
			WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
			master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
			WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y + 5000, GGORIGIN_Z, "editorProbe", 500);
			WickedCall_EnableThumbLight(false);
		}
		PositionCamera(composx, composy, composz);
		RotateCamera(comangx, comangy, comangz);
		if (BackBufferObjectID > 0)
		{
			PositionObject(displayobj, fOldObjPosX, fOldObjPosY, fOldObjPosZ);
			RotateObject(displayobj, fOldObjAngX, fOldObjAngY, fOldObjAngZ);
			if (bDisplayObjVisible)
				ShowObject(displayobj);
			else
				HideObject(displayobj);
		}
	}
	else
	{
		if (bUseBackDropImage && ObjectExist(backdropobj))
		{
			HideObject(backdropobj);
		}
		if (bSnapShotModeUseCamera || BackBufferParticlesMode)
		{
			PositionCamera(composx, composy, composz);
			RotateCamera(comangx, comangy, comangz);
		}
		if (t.widget.pickedEntityIndex > 0 && t.widget.activeObject > 0)
		{
			widget_show_widget();
		}
	}
	if (!renderstate)
	{
		BackBufferSnapShotMode = false;
		BackBufferParticlesMode = false;
		return;
	}

	// if not snaposhot mode - save a second file to act as our ICON image (RPG inventory usage mainly)
	if (!BackBufferSnapShotMode && !BackBufferGrabGameScreen)
	{
		if (BackBufferSaveCacheName != "")
		{
			// ensure the grab results in a square icon
			int iIconImageID = BackBufferImageID;
			extern GlobStruct* g_pGlob;
			LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
			ID3D11Texture2D* pBackBuffer = NULL;
			if (rendertarget)
			{
				pBackBuffer = (ID3D11Texture2D*)GetBitmapTexture2D(99);
				if (!pBackBuffer) pBackBuffer = (ID3D11Texture2D*)wiRenderer::GetDevice()->GetBackBufferForGG(&master.swapChain);
			}
			else
			{
				pBackBuffer = (ID3D11Texture2D*)wiRenderer::GetDevice()->GetBackBufferForGG(&master.swapChain);
			}
			g_pGlob->pCurrentBitmapSurface = pBackBuffer;
			SetGrabImageMode(1);

			// get surface size to ensure grab not larger
			int grabiconx = 288;
			int grabicony = 288;
			GGSURFACE_DESC ddsd;
			pBackBuffer->GetDesc(&ddsd);
			if (grabiconx > ddsd.Width) grabiconx = ddsd.Width;
			if (grabicony > ddsd.Height) grabicony = ddsd.Height;
			float imgcx = (ddsd.Width * 0.5) - (grabiconx * 0.5);
			float imgcy = (ddsd.Height * 0.5) - (grabicony * 0.5);
			if (imgcy < 0) imgcy = 0;
			if (imgcx < 0) imgcx = 0;
			if (imgcx + grabiconx > ddsd.Width)	grabiconx = (ddsd.Width - imgcx) - 1.0f;
			if (imgcy + grabicony > ddsd.Height) grabicony = (ddsd.Height - imgcy) - 1.0f;
			if (grabiconx > 0 && grabicony > 0)
			{
				GrabImage(iIconImageID, imgcx, imgcy, imgcx + grabiconx, imgcy + grabicony, 3);
			}

			// restore bitmap pointer
			SetGrabImageMode(0);
			g_pGlob->pCurrentBitmapSurface = pTmpSurface;
				
			// ensure we save to writables area only
			if (ImageExist(iIconImageID))
			{
				char pRealICONFile[MAX_PATH];
				strcpy(pRealICONFile, BackBufferSaveCacheName.Get());
				pRealICONFile[strlen(pRealICONFile) - 4] = 0;
				strcat(pRealICONFile, ".png");
				GG_SetWritablesToRoot(true);
				GG_GetRealPath(pRealICONFile, 1);
				if (FileExist(pRealICONFile) == 1) DeleteAFile(pRealICONFile);
				SaveImage(pRealICONFile, iIconImageID);
				GG_SetWritablesToRoot(false);
			}
		}
	}

	// handle loop grab mode
	static int loop = 0;
	if(loop++ % 2 == 0 || !bLoopBackBuffer || bLoopFullFPS || BackBufferGrabGameScreen || BackBufferSnapShotMode || BackBufferParticlesMode)
	{
		// get backbuffer pointer
		int iPerEntityImageID = BackBufferImageID;
		extern GlobStruct* g_pGlob;
		LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
		ID3D11Texture2D *pBackBuffer = NULL;
		if (rendertarget)
		{
			pBackBuffer = (ID3D11Texture2D *) GetBitmapTexture2D(99);
			if (!pBackBuffer) pBackBuffer = (ID3D11Texture2D *)wiRenderer::GetDevice()->GetBackBufferForGG( &master.swapChain );
		}
		else
		{
			pBackBuffer = (ID3D11Texture2D*)wiRenderer::GetDevice()->GetBackBufferForGG(&master.swapChain);
		}
		g_pGlob->pCurrentBitmapSurface = pBackBuffer;

		// get surface size to ensure grab not larger
		GGSURFACE_DESC ddsd;
		pBackBuffer->GetDesc(&ddsd);
		SetGrabImageMode(1);
		if (graby > ddsd.Height)
			graby = ddsd.Height;
		if (grabx > ddsd.Width)
			grabx = ddsd.Width;

		// handle image size
		float imgcx = (ddsd.Width*0.5) - (grabx*0.5);
		float imgcy = (ddsd.Height*0.5) - (graby*0.5);
		if (imgcy < 0) imgcy = 0;
		if (imgcx < 0) imgcx = 0;

		// all screen for BackBufferGrabGameScreen
		if (BackBufferObjectID == 0 && BackBufferGrabGameScreen)
		{
			imgcy = 0;
			imgcx = 0;
			grabx = ddsd.Width;
			graby = ddsd.Height;
		}

		// if snapshot mode
		if (BackBufferSnapShotMode)
		{
			if (fLastRubberBandX2 > fLastRubberBandX1 && fLastRubberBandY2 > fLastRubberBandY1)
			{
				imgcx = fLastRubberBandX1;
				imgcy = fLastRubberBandY1;
				imgcy -= 10.0f;
				if (imgcx < 1.0f) imgcx = 1.0f;
				if (imgcy < 1.0f) imgcy = 1.0f;
				float fRatio = graby / grabx;
				if ((fLastRubberBandX2 - fLastRubberBandX1) > ((fLastRubberBandY2 - fLastRubberBandY1)*1.3))
				{
					grabx = fLastRubberBandX2 - fLastRubberBandX1;
					graby = grabx * fRatio;
					float fObjectsHeight = fLastRubberBandY2 - fLastRubberBandY1;
					if (graby > fObjectsHeight)
						imgcy -= ((graby - fObjectsHeight)*0.5);
					if (imgcy < 0) imgcy = 0;
				}
				else
				{
					fRatio = grabx / graby;
					graby = fLastRubberBandY2 - fLastRubberBandY1;
					float fObjectsWidth = fLastRubberBandX2 - fLastRubberBandX1;
					grabx = graby * fRatio;
					if(grabx > fObjectsWidth)
						imgcx -= ((grabx-fObjectsWidth)*0.5);
					if (imgcx < 0) imgcx = 0;
				}
			}
		}
		// make sure we are not going outside image.
		if (imgcy + graby > ddsd.Height)
			graby = (ddsd.Height - imgcy) - 1.0f;
		if (imgcx + grabx > ddsd.Width)
			grabx = (ddsd.Width - imgcx) - 1.0f;

		if (graby > 0 && grabx > 0)
		{
			GrabImage(iPerEntityImageID, imgcx, imgcy, imgcx + grabx, imgcy + graby, 3);
		}
		SetGrabImageMode(0);

		// restore bitmap pointer
		g_pGlob->pCurrentBitmapSurface = pTmpSurface;
	}

	// if not snaposhot mode and we want to save the grab
	if (!BackBufferSnapShotMode)
	{
		if (BackBufferSaveCacheName != "")
		{
			if (ImageExist(BackBufferImageID))
			{
				// ensure we save to writables area only
				char pRealThumbFile[MAX_PATH];
				strcpy(pRealThumbFile, BackBufferSaveCacheName.Get());
				GG_SetWritablesToRoot(true);
				GG_GetRealPath(pRealThumbFile, 1);
				if (FileExist(pRealThumbFile) == 1) DeleteAFile(pRealThumbFile);
				SaveImage(pRealThumbFile, BackBufferImageID);
				GG_SetWritablesToRoot(false);
			}
			BackBufferSaveCacheName = "";
		}
	}

	// restore other settings after grab
	if (!bLoopBackBuffer)
	{
		BackBufferImageID = 0;
		if (BackBufferParticlesMode && BackBufferParticleEmitter != -1)
		{
			gpup_deleteEffect(BackBufferParticleEmitter);
			BackBufferParticleEmitter = -1;
		}
		if (BackBufferParticlesMode)
		{
			BackBufferZoom = 0.0f;
			BackBufferCamUp = 0.0f;
		}
	}
	BackBufferSnapShotMode = false;
	BackBufferParticlesMode = false;
	BackBufferGrabGameScreen = false;
}

void RevertBackbufferCubemap(void)
{
	if (bBackbufferCubemapActive && cUseBackbufferCubemap.Len() > 0)
	{
		sky_skyspec_init();
		WickedCall_DeleteImage(cUseBackbufferCubemap.Get());
		if (t.grideditselect == 0)
		{
			WickedCall_DisplayCubes(true);
		}
		if (ObjectExist(t.terrain.terrainobjectindex) == 1)
		{
			ShowObject(t.terrain.terrainobjectindex);
		}
		t.hardwareinfoglobals.noterrain = 0;
		WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
		master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
		WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y+5000, GGORIGIN_Z, "editorProbe", 500);
		WickedCall_EnableThumbLight(false);
		WickedCall_UpdateProbes();
		bBackbufferCubemapActive = false;
	}
}

bool CreateProjectCacheName(char *project_name,char *file)
{
	if (!project_name || !file) return false;
	if (strlen(project_name) <= 0) return false;

	char tmp[MAX_PATH];
	char project[MAX_PATH];
	strcpy(tmp, file);
	char *find = (char *)pestrcasestr(tmp, "thumbbank\\");
	if (find) find += 10;
	else find = &tmp[0];
	strcpy(project, "projectbank\\");
	strcat(project, project_name);
	strcat(project, "\\");
	strcat(project, find);
	ProjectCacheName = project; //PE: Should be relative.
	return(true);
}
bool CopyToProjectFolder(char *file)
{
	if (strlen(Storyboard.gamename) <= 0) return false;
	// D:\MAX-DocWrite\Files\thumbbank\mapbank_cool level 1 - copy.fpm512x288.jpg
	char tmp[MAX_PATH];
	char project[MAX_PATH];

	strcpy(tmp, file);
	char *find = (char *) pestrcasestr(tmp, "thumbbank\\");
	if (find) find += 10;
	else find = &tmp[0];

	strcpy(project, "projectbank\\");
	strcat(project, Storyboard.gamename);
	strcat(project, "\\");
	strcat(project, find);
	strcpy(tmp, project);
	GG_GetRealPath(project, 1); //Resolve name. need full path.
	bool bRet = CopyFileA( (LPSTR) file, project, FALSE);
	ProjectCacheName = tmp; //PE: Should be relative.
	return bRet;
}
bool CreateBackBufferCacheNameEx(char *file,int width,int height, bool bUsedForSaving)
{
	// returns true if have own thumb or a group that does not generate one
	bool bHasOwnLocalThumb = false;

	std::string cache_name = file;
	replaceAll(cache_name, ".fpe", "");
	replaceAll(cache_name, "entitybank\\", "");
	replaceAll(cache_name, "\\", "_");
	replaceAll(cache_name, "/", "_");
	replaceAll(cache_name, "\"", ""); //Got this when deleting a file in user, if fpe not found and already in list.
	std::string cache_final_name = cache_name;
	if (bUsedForSaving == false)
	{
		std::string src_thumbbank_path = g.fpscrootdir_s.Get();
		src_thumbbank_path = src_thumbbank_path + "\\Files\\thumbbank\\";
		cache_final_name = src_thumbbank_path + cache_name + std::to_string(width) + "x" + std::to_string(height) + ".jpg";
	}
	else
	{
		cache_final_name = g.mysystem.thumbbank_s.Get() + cache_name + std::to_string(width) + "x" + std::to_string(height) + ".jpg";
	}
	BackBufferCacheName = cache_final_name.c_str();

	// LB: We have pre-generated all stock assets thumbs, so copy over if we have them to save time
	if (g_bThumbBankCopyMode == true)
	{
		if (FileExist(BackBufferCacheName.Get()) == 0)
		{
			// source from thumbnank in parent files
			std::string src_file = g.fpscrootdir_s.Get();
			src_file = src_file + "\\Files\\thumbbank\\";
			src_file = src_file + cache_name;
			src_file = src_file + std::to_string(width) + "x" + std::to_string(height) + ".jpg";
			LPSTR pSrcFile = (LPSTR)src_file.c_str();
			char pAssociatedThumb[MAX_PATH];
			GG_SetWritablesToRoot(true);
			if (FileExist(pSrcFile) == 0)
			{
				// any object that has a JPG of the same FPE name can force a custom thumb
				char pRelativePath[MAX_PATH];
				strcpy(pAssociatedThumb, file);
				strcpy(pRelativePath, pAssociatedThumb);
				GG_SetWritablesToRoot(true);
				GG_GetRealPath(pAssociatedThumb, 0);
				GG_SetWritablesToRoot(false);
				if (FileExist(pAssociatedThumb) == 0)
				{
					// sometimes the file path is passed in without the entitybank
					strcpy(pAssociatedThumb, "entitybank\\");
					strcat(pAssociatedThumb, file);
					strcpy(pRelativePath, pAssociatedThumb);
					GG_SetWritablesToRoot(true);
					GG_GetRealPath(pAssociatedThumb, 0);
					GG_SetWritablesToRoot(false);
				}
				GG_SetWritablesToRoot(true);
				if (FileExist(pAssociatedThumb) == 1)
				{
					GG_SetWritablesToRoot(false);
					// so as not to disrupt purchased and other thumbs generated, just tackle building editor for now
					if (strnicmp(pRelativePath, "entitybank\\user\\buildingeditor", 30) == NULL)
					{
						if (strnicmp(pAssociatedThumb + strlen(pAssociatedThumb) - 4, ".fpe", 4) == NULL)
						{
							pAssociatedThumb[strlen(pAssociatedThumb) - 4] = 0;
							strcat(pAssociatedThumb, ".jpg");
							GG_GetRealPath(pAssociatedThumb, 0);
							if (FileExist(pAssociatedThumb) == 0)
							{
								strcpy(pAssociatedThumb, g.fpscrootdir_s.Get());
								strcat(pAssociatedThumb, "\\Files\\editors\\uiv3\\filetype-object.jpg");
							}
							pSrcFile = pAssociatedThumb;
							bHasOwnLocalThumb = true;
						}
					}
				}
			}
			GG_SetWritablesToRoot(false);

			// file destination not exist, copy src to it to save time
			CopyFileA (pSrcFile, BackBufferCacheName.Get(), TRUE);
		}
	}

	// determined to have own thumb
	return bHasOwnLocalThumb;
}
bool CreateBackBufferCacheName(char* file, int width, int height)
{
	return CreateBackBufferCacheNameEx(file, width, height, false);
}
#endif

#ifdef VRTECH

void process_entity_library(void)
{
	if (bExternal_Entities_Window)
	{
		ImGuiWindowFlags ex_window_flags = 0;
		ImGuiIO& io = ImGui::GetIO();

		static int uniqueId = 4000; //PE: Also used for imageID for previews.
		static int loaded_images = 0;
		static bool multi_selections = false;
		int multi_selections_count = 0;
		static int lf_multi_selections_count = 0;
		int olduniqueId = uniqueId;
		bool bReleaseIconsDynamic = false;
		uniqueId = 4000;
#ifdef DYNAMICLOADUNLOAD
		static int max_load_persync = 200; //First time only , changed later to 15
		bReleaseIconsDynamic = true;
#else
		int max_load_persync = 2000;
#endif

		int preview_count = 0;
		int media_icon_size = 64;
		int iColumnsWidth = 110;

		time_t tCurrentTimeSec;
		time(&tCurrentTimeSec);

		ImGui::Begin("Entity Library##ExternalWindow", &bExternal_Entities_Window, ex_window_flags);

		bool bAddSelectionToGame = false;
		bool bIsWeDocked = ImGui::IsWindowDocked();
		static int current_tab = -1;


		CheckTutorialAction("TABMARKERS", 54.0f); //Tutorial: check if we are waiting for this action
		if (current_tab == 1 && bTutorialCheckAction)
			TutorialNextAction(); //Clicked - selected the tab markers.
		CheckTutorialAction("TABENTITIES", -10.0f); //Tutorial: check if we are waiting for this action
		if (current_tab == 0 && bTutorialCheckAction)
			TutorialNextAction(); //Clicked - selected the tab Entities.

		ImGui::SetItemAllowOverlap();
		if (ImGui::BeginTabBar("entlibtabbar"))
		{
			static int iCurrentFilter = 0;
			static char cSearchAllEntities[3][MAX_PATH] = { "\0","\0","\0" };

			for (int i = 0; i < 2; i++) {

				cStr sTabHeader;
				if (i == 0) sTabHeader = " Entities ";
				if (i == 1) sTabHeader = " Markers! ";


				if (ImGui::BeginTabItem(sTabHeader.Get()))
				{
					if (current_tab != i) {
						//Tab changed.
						//timestampactivity(0, "Entity Library Tab change");
						current_tab = i;
						iCurrentFilter = 0;
					}

					static char cAllFilters[10][MAX_PATH];
					char cFilter[MAX_PATH], cHeader[MAX_PATH];
					int splitsections = 1;

					if (i == 1) {
						splitsections = 5;
					}

					int control_wrap_width = 70;
					strcpy(cFilter, "");
					strcpy(cHeader, "");
					//PE: Debug dynamic icon load unload.
					//ImGui::Text("Entities: %ld , in memory: %ld", olduniqueId-4000, loaded_images);
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3.0));
					ImGui::Text("Filter: ");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3.0));
					if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
						ImGui::Text(""); //NewLine
					bool rb_change = false;
					ImGui::RadioButton("All ", &iCurrentFilter, 0);
					ImGui::SameLine();
					if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
						ImGui::Text(""); //NewLine

					if (i == 0) {

						CheckTutorialAction("BUTCHARACTER", -28.0f); //Tutorial: check if we are waiting for this action
						if (ImGui::RadioButton("Characters ", &iCurrentFilter, 1)) {
							//On click remove search.
							strcpy(cSearchAllEntities[i], "");
							if (bTutorialCheckAction)
								TutorialNextAction(); //Clicked - on "Characters"
						}
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine

						CheckTutorialAction("BUTBUILDINGS", -28.0f); //Tutorial: check if we are waiting for this action
						if (ImGui::RadioButton("Buildings", &iCurrentFilter, 2)) {
							//On click remove search.
							strcpy(cSearchAllEntities[i], "");
							if (bTutorialCheckAction)
								TutorialNextAction(); //Clicked - on "Buildings"
						}
						ImGui::SameLine();

						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine


						CheckTutorialAction("BUTOBJECTS", -28.0f); //Tutorial: check if we are waiting for this action
						if (ImGui::RadioButton("Objects", &iCurrentFilter, 6)) {
							//On click remove search.
							strcpy(cSearchAllEntities[i], "");
							if (bTutorialCheckAction)
								TutorialNextAction(); //Clicked - on "objects"
						}

						if (iCurrentFilter == 1) strcpy(cFilter, "Character");
						if (iCurrentFilter == 2) strcpy(cFilter, "Building");
						//								if (iCurrentFilter == 3) strcpy(cFilter, "Foliage");
						//								if (iCurrentFilter == 4) strcpy(cFilter, "Cartoon");
						//								if (iCurrentFilter == 5) strcpy(cFilter, "Fixtures");
						if (iCurrentFilter == 6) strcpy(cFilter, "*");

						strcpy(cAllFilters[0], "Character");
						strcpy(cAllFilters[1], "Building");
						//								strcpy(cAllFilters[2], "Foliage");
						//								strcpy(cAllFilters[3], "Cartoon");
						//								strcpy(cAllFilters[4], "Fixtures");

					}
					if (i == 1) {
						ImGui::RadioButton("Players ", &iCurrentFilter, 1);
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine
						ImGui::RadioButton("Zones", &iCurrentFilter, 2);
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine
						ImGui::RadioButton("Lights", &iCurrentFilter, 3);
						ImGui::SameLine();
						if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
							ImGui::Text(""); //NewLine
						ImGui::RadioButton("Spot Lights", &iCurrentFilter, 4);


						if (iCurrentFilter == 1) { strcpy(cFilter, "player"); strcpy(cHeader, "Player Positions"); }
						if (iCurrentFilter == 2) { strcpy(cFilter, "zone.fpe"); strcpy(cHeader, "Zones"); }
						if (iCurrentFilter == 3) { strcpy(cFilter, " light.fpe"); strcpy(cHeader, "Lights"); }
						if (iCurrentFilter == 4) { strcpy(cFilter, "spot.fpe"); strcpy(cHeader, "Spot Lights"); }
						if (iCurrentFilter > 0) splitsections = 1;
					}

					ImGui::SameLine();

					if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
						ImGui::Text(""); //NewLine

					float fXWidth = ImGui::GetFontSize()*1.5;
					if (i == 0)
						ImGui::PushItemWidth(-38 - fXWidth);
					else
						ImGui::PushItemWidth(-1 - fXWidth - 4.0);

					ImGui::Text(" Search: ");
					ImGui::SameLine();

					bEntityGotFocus = false;
					if (ImGui::InputText("##cSearchAllEntities", &cSearchAllEntities[i][0], MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						if (strlen(cSearchAllEntities[i]) > 1) {
							bool already_there = false;
							for (int l = 0; l < MAXSEARCHHISTORY; l++) {
								if (strcmp(cSearchAllEntities[i], pref.search_history[l]) == 0) {
									already_there = true;
									break;
								}
							}
							if (!already_there) {
								bool foundspot = false;
								for (int l = 0; l < MAXSEARCHHISTORY; l++) {
									if (strlen(pref.search_history[l]) <= 0) {
										strcpy(pref.search_history[l], cSearchAllEntities[i]);
										foundspot = true;
										break;
									}
								}
								if (!foundspot) {
									//Move entry list.
									for (int l = 0; l < MAXSEARCHHISTORY; l++) {
										strcpy(pref.search_history[l], pref.search_history[l + 1]);
									}
									strcpy(pref.search_history[MAXSEARCHHISTORY - 1], cSearchAllEntities[i]);
								}
							}
						}
					}
					ImGui::SameLine();
					if (ImGui::StyleButton("X##deletesearch"))
					{
						strcpy(cSearchAllEntities[i], "");
					}
					//}
					ImGui::PopItemWidth();


					//Combo dropdown. Use folder names as seach.
					if (i == 0) {
						ImGui::SameLine();
						static char * current_combo_entry = "\0";
						int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
						ImGui::PushItemWidth(-24);
						if (ImGui::BeginCombo("##combolastsearch", current_combo_entry, comboflags))
						{

							//Do we have a search history.
							bool display_history = false;
							for (int l = 0; l < MAXSEARCHHISTORY; l++) {
								if (strlen(pref.search_history[l]) > 0) {
									display_history = true;
									break;
								}
							}
							if (display_history) {
								ImGui::Text("Search History:");
								ImGui::Indent(10);
								for (int l = 0; l < MAXSEARCHHISTORY; l++) {
									if (strlen(pref.search_history[l]) > 0) {
										bool is_selected = (current_combo_entry == pref.search_history[l]);
										if (ImGui::Selectable(pref.search_history[l], is_selected)) {
											current_combo_entry = (char *)pref.search_history[l];
											strcpy(cSearchAllEntities[i], pref.search_history[l]);
										}
										if (is_selected)
											ImGui::SetItemDefaultFocus();
									}
								}
								ImGui::Indent(-10);
							}
							cFolderItem *pNewFolder = &MainEntityList;
							pNewFolder = pNewFolder->m_pNext;
							if (pNewFolder) {

								ImGui::Text("Folders:");
								ImGui::Indent(10);

								cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
								int ipath_remove_len = path_remove.Len();

								ImVec4* style_colors = ImGui::GetStyle().Colors;
								ImVec2 wsize = ImGui::GetWindowSize();

								int line_count = 0;
								while (pNewFolder)
								{
									cStr path = pNewFolder->m_sFolderFullPath.Get();
									bool bDoubleEntityBank = false;
									char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
									if (finde)
									{
										finde += 11;
										finde = (char *)pestrcasestr(finde, "\\entitybank");
										if (finde) bDoubleEntityBank = true;
									}
									if (!bDoubleEntityBank && path.Right(11) == "\\entitybank")
									{
										ipath_remove_len = path.Len();
									}
									else
									{
										char *final_name = path.Get();
										final_name += ipath_remove_len;
										if (*final_name == '\\')
											final_name++;

										std::string dir_name = final_name;
										replaceAll(dir_name, "\\", " - ");

										if (dir_name.length() > 0 && pNewFolder->m_pFirstFile && !pestrcasestr(dir_name.c_str(), "_markers"))
										{
											bool is_selected = (current_combo_entry == pNewFolder->m_sFolderFullPath.Get());
											if (ImGui::Selectable(dir_name.c_str(), is_selected))
											{
												current_combo_entry = (char *)pNewFolder->m_sFolderFullPath.Get();
												//Make a search entry.
												strcpy(cSearchAllEntities[i], dir_name.c_str());

											}
											if (is_selected)
												ImGui::SetItemDefaultFocus();
											line_count++;
										}
									}
									pNewFolder = pNewFolder->m_pNext;
								}
								ImGui::Indent(-10);
							}
							ImGui::EndCombo();
						}

						ImGui::PopItemWidth();
					}
					ImGui::Separator();

					if (strlen(cSearchAllEntities[i]) > 0 && i == 1) {
						iCurrentFilter = 0;
						splitsections = 1;
					}

					ImGui::BeginChild("##cSearchAllEntitiesBegin", ImVec2(0, 0),false, iGenralWindowsFlags);

					ImVec2 oldCursor = ImGui::GetCursorPos();
					std::string insert_text;
					ImVec2 insert_text_width;

					if (lf_multi_selections_count > 0) {
						//Display insert button.
						insert_text = " Add ";
						insert_text += std::to_string(lf_multi_selections_count);
						insert_text += " Objects to Level ";
						insert_text_width = ImGui::CalcTextSize(insert_text.c_str());
						ImGui::SetCursorPos(ImVec2(0, (ImGui::GetWindowSize().y + ImGui::GetScrollY()) - insert_text_width.y - 10.0f));

						ImGui::Spacing();
						ImGui::SameLine(ImGui::GetWindowContentRegionWidth() - (insert_text_width.x + 18.0f));

						ImGui::SetItemAllowOverlap();
						if (ImGui::StyleButton(insert_text.c_str())) {
							//Inset all selected items.
							bAddSelectionToGame = true;
						}
					}

					ImGui::SetCursorPos(oldCursor);
					if (i == 0)
						ImGui::TextCenter("Click to add an object to your level. Control+Click to select multiple items.");

					int iIconVisiblePosY = ImGui::GetWindowSize().y + ImGui::GetScrollY() + media_icon_size;

					bool bFirstShiftHasBeenSeen = false;
					bool bAnySelectedItemsAvailable = false;
					static cFolderItem::sFolderFiles * firstShiftFile = NULL;
					static cFolderItem::sFolderFiles * lastShiftFile = NULL;

					for (int splitloop = 0; splitloop < splitsections; splitloop++) {

						if (iCurrentFilter == 0) {
							if (i == 1) strcpy(cFilter, "");
							if (i == 1) strcpy(cHeader, "");
							if (i == 1 && splitloop == 0) { strcpy(cFilter, "player"); strcpy(cHeader, "Player Positions"); }
							if (i == 1 && splitloop == 1) { strcpy(cFilter, "zone.fpe"); strcpy(cHeader, "Zones"); }
							if (i == 1 && splitloop == 2) { strcpy(cFilter, " light.fpe"); strcpy(cHeader, "Lights"); }
							if (i == 1 && splitloop == 3) { strcpy(cFilter, "spot.fpe"); strcpy(cHeader, "Spot Lights"); }
							if (i == 1 && splitloop == 4) { strcpy(cFilter, "*"); strcpy(cHeader, "Others"); }
							if (i == 1) strcpy(cAllFilters[splitloop], cFilter);
							if (strlen(cSearchAllEntities[i]) > 0 && i == 1) {
								strcpy(cHeader, "");
							}
						}
						cFolderItem *pNewFolder = &MainEntityList;
						pNewFolder = pNewFolder->m_pNext;
						if (pNewFolder)
						{
							//We start at the "entitybank" entry that we use to parce the others.
							cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
							int ipath_remove_len = path_remove.Len();
							pNewFolder = pNewFolder->m_pNext;
							while (pNewFolder)
							{
								//PE: Full path can now change in the middle of the list , so:
								cStr path = pNewFolder->m_sFolderFullPath.Get();
								LPSTR pPathSearch = path.Get();
								LPSTR pFind = "\\entitybank";
								for (int n = 0; n < strlen(pPathSearch); n++)
								{
									if (strnicmp(pPathSearch + n, pFind, strlen(pFind)) == NULL)
									{
										ipath_remove_len = n + strlen(pFind);
										break;
									}
								}

								if (1)
								{
									bool isMarkers = false;
									bool bDisplayEverythingHere = false;
									bool bHideEverythingHere = false;
									if (i == 0 && cFilter[0] == '*')
									{
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cAllFilters[0]))
											bHideEverythingHere = true;
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cAllFilters[1]))
											bHideEverythingHere = true;
									}
									else if (strlen(cFilter) > 0)
									{
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cFilter))
											bDisplayEverythingHere = true;
									}
									if (strlen(cSearchAllEntities[i]) > 0)
									{
										//When search disable fixed tags search.
										bDisplayEverythingHere = false;
										bHideEverythingHere = false;
									}
									char *final_name = path.Get();
									final_name += ipath_remove_len;
									if (*final_name == '\\')
										final_name++;

									std::string path_for_filename = final_name;
									std::string dir_name = final_name;
									replaceAll(dir_name, "\\", " - ");

									if (pestrcasestr(dir_name.c_str(), "_markers"))
										isMarkers = true;

									if (!isMarkers && i == 0 && !bDisplayEverythingHere && !bHideEverythingHere && strlen(cSearchAllEntities[i]) > 0) {
										if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cSearchAllEntities[i]))
											bDisplayEverythingHere = true;
										else if (pestrcasestr(dir_name.c_str(), cSearchAllEntities[i]))
											bDisplayEverythingHere = true;

									}

									//PE: Check here if we need to reload the folder, for new files.
									if (pNewFolder->m_fLastTimeUpdate < Timer())
									{
										pNewFolder->m_fLastTimeUpdate = Timer() + 4000; //Check every 4-6 sec.
										pNewFolder->m_fLastTimeUpdate += rand() % 2000; //Make sure we dont check folders in same cycle.
										struct stat sb;
										if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
										{
											if (sb.st_mtime != pNewFolder->m_tFolderModify) 
											{
												pNewFolder->m_tFolderModify = sb.st_mtime;
												RefreshEntityFolder(pNewFolder->m_sFolderFullPath.Get(), pNewFolder);
											}
										}
									}
									if (pNewFolder->m_pFirstFile)
									{

										bool bHeaderDisplayed = false;
										bool bDisplayText = true;
										float fWinWidth = ImGui::GetWindowSize().x - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
										if (iColumnsWidth >= fWinWidth && fWinWidth > media_icon_size)
										{
											iColumnsWidth = fWinWidth;
										}
										int iColumns = (int)(ImGui::GetWindowSize().x / (iColumnsWidth));
										if (iColumns <= 1)
											iColumns = 1;

										cFolderItem::sFolderFiles * myfiles = pNewFolder->m_pFirstFile->m_pNext;
										while (myfiles)
										{
											std::string sFinal = Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);

											if (splitloop == 0 && myfiles->iFlags == 1)
												multi_selections_count++;

											bool bIsVisible = true;
											if (i == 0 && isMarkers) bIsVisible = false;
											if (i == 1 && !isMarkers) bIsVisible = false;

											if (bIsVisible && strlen(cSearchAllEntities[i]) > 0) {
												if (!pestrcasestr(myfiles->m_sName.Get(), cSearchAllEntities[i]))
													bIsVisible = false;
											}
											else if (i == 1 && cFilter[0] == '*') {
												//Others not already displayed.
												for (int fl = 0; fl < splitloop; fl++) {
													if (pestrcasestr(myfiles->m_sName.Get(), cAllFilters[fl]))
														bIsVisible = false;
												}
											}
											else if (strlen(cFilter) > 0 && cFilter[0] != '*') {
												if (!pestrcasestr(myfiles->m_sName.Get(), cFilter))
													bIsVisible = false;
											}


											if (bDisplayEverythingHere)
												bIsVisible = true;
											if (bHideEverythingHere)
												bIsVisible = false;

											ImGui::PushID(uniqueId + preview_count);
											if (splitloop == 0)
												uniqueId++;

											int textureId = 0;
											if (myfiles->iPreview <= 0)
											{
												//Only Visible.
												int gcpy = ImGui::GetCursorPosY();
												if (!bReleaseIconsDynamic || (splitloop == 0 && (bIsVisible || isMarkers) && (gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size || isMarkers)))
												{
													myfiles->last_used = (long)tCurrentTimeSec;
													if (max_load_persync-- >= 0)
													{
														//Load preview.
														std::string sImgName = myfiles->m_sPath.Get();
														sImgName = sImgName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
														sImgName += ".bmp";
														myfiles->iPreview = uniqueId; //TOOL_ENTITY; //Just for testing.
														SetMipmapNum(1); //PE: mipmaps not needed.
														image_setlegacyimageloading(true);
														LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
														image_setlegacyimageloading(false);
														SetMipmapNum(-1);
														if (!GetImageExistEx(myfiles->iPreview))
														{
															myfiles->iPreview = TOOL_ENTITY;
															textureId = TOOL_ENTITY;
														}
														else {
															loaded_images++;
															textureId = myfiles->iPreview;
														}
													}
													else
														textureId = TOOL_ENTITY;
												}
												else {
													textureId = TOOL_ENTITY;
												}
											}
											else
											{
												//PE: Only delete in first run. so we dont delete a image that has already been sent to rendering.
												if (splitloop == 0 && bReleaseIconsDynamic) {
													//Only NOT Visible with a preview image..
													int gcpy = ImGui::GetCursorPosY();
													if (!isMarkers && (!(gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size) || !bIsVisible)) {

														if ((long)tCurrentTimeSec - myfiles->last_used > 20) {
															//Delete Image not visible for 20 sec.
															if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
																image_setlegacyimageloading(true);
																DeleteImage(myfiles->iPreview);
																image_setlegacyimageloading(false);
																myfiles->iPreview = 0;
																loaded_images--;
															}
															textureId = TOOL_ENTITY;
														}
														else
															textureId = myfiles->iPreview;
													}
													else {
														//Still visible update time.
														if (bIsVisible || isMarkers)
															myfiles->last_used = (long)tCurrentTimeSec;
														textureId = myfiles->iPreview;
													}
												}
												else
													textureId = myfiles->iPreview;
											}

											//Is object visible
											if (bIsVisible) 
											{
												if (myfiles->iPreview > 0 && !GetImageExistEx(myfiles->iPreview)) 
												{
													myfiles->iPreview = 0;
													textureId = TOOL_ENTITY;
												}

												if (!bHeaderDisplayed) {

													if (!isMarkers && i == 0)
													{
														ImGui::SetWindowFontScale(1.25);
														LPSTR pFinalHeaderTitle = (LPSTR)dir_name.c_str();
														if (stricmp(pFinalHeaderTitle, "user") == NULL) pFinalHeaderTitle = "Custom Assets";
														if (stricmp(pFinalHeaderTitle, "user - charactercreatorplus") == NULL) pFinalHeaderTitle = "Custom Characters";
														if (stricmp(pFinalHeaderTitle, "user - ebestructures") == NULL) pFinalHeaderTitle = "Custom Structures";
														ImGui::Text("%s", pFinalHeaderTitle);
														ImGui::Spacing();
													}
													else if (strlen(cHeader) > 0)
													{
														ImGui::SetWindowFontScale(1.25);
														ImGui::Text("%s", cHeader);
														ImGui::Spacing();
													}

													ImGui::Columns(iColumns, "filescolumns4entities", false);  //false no border
													bHeaderDisplayed = true;
												}
												ImGui::SetWindowFontScale(SMALLFONTSIZE);

												float fFramePadding = (iColumnsWidth - media_icon_size)*0.5;
												float fCenterX = iColumnsWidth * 0.5;

												ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(fFramePadding, 2.0f));

												if (myfiles->iFlags == 1) 
												{
													ImVec4 bg_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]; // { 0.0, 0.0, 0.0, 1.0 };
													ImVec2 padding = { 6.0, 6.0 };
													ImGuiWindow* window = ImGui::GetCurrentWindow();
													const ImRect image_bb((window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f), window->DC.CursorPos + padding + ImVec2(fFramePadding, 2.0f) + ImVec2(media_icon_size, media_icon_size));
													window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(bg_col), 0.0f, 15, 3.0f);
													bAnySelectedItemsAvailable = true;
												}

												CheckTutorialAction(sFinal.c_str(), 13.0f); //Tutorial: check if we are waiting for this action

												//PE: Support Shift fo selecting may items.
												if (!io.KeyShift) 
												{
													//firstShiftFile = NULL;
													lastShiftFile = NULL;
												}

												extern bool g_bFreeTrialVersion;
												if (firstShiftFile && lastShiftFile)
												{
													if (myfiles == firstShiftFile)
														bFirstShiftHasBeenSeen = true;
													if (!bFirstShiftHasBeenSeen && myfiles == lastShiftFile)
													{
														//Swap around, last is first.
														cFolderItem::sFolderFiles * tmpShiftFile = lastShiftFile;
														lastShiftFile = firstShiftFile;
														firstShiftFile = tmpShiftFile;
														bFirstShiftHasBeenSeen = true;
													}

													static bool bStartShiftActive = false;
													myfiles->iFlags = 0;
													if (myfiles == firstShiftFile) 
													{
														bStartShiftActive = true;
														if(g_bFreeTrialVersion == false || (g_bFreeTrialVersion==true && myfiles->bAvailableInFreeTrial==true) )
															myfiles->iFlags = 1;
													}
													if (myfiles == lastShiftFile) 
													{
														bStartShiftActive = false;
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
													}
													if (bStartShiftActive)
													{
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
													}
												}

												if (ImGui::ImgBtn(textureId, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, true))
												{

													if (bTutorialCheckAction) TutorialNextAction(); //Clicked get next tutorial action.

													//If ctrl , just mark them.

													if (io.KeyShift) 
													{
														if (firstShiftFile)
														{
															lastShiftFile = myfiles;
														}
														else
														{
															firstShiftFile = myfiles;
															multi_selections = true;
															if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
																myfiles->iFlags = 1;
														}
													}
													else if (io.KeyCtrl) 
													{
														//Mark object.
														multi_selections = true;
														if (myfiles->iFlags == 0) 
														{
															if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
																myfiles->iFlags = 1;
															firstShiftFile = myfiles;
														}
														else
														{
															myfiles->iFlags = 0;
														}
													}
													else
													{
														if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
														if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
														if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

														//Make sure we are in entity mode.
														bForceKey = true;
														csForceKey = "e";

														DeleteWaypointsAddedToCurrentCursor();
														CheckTooltipObjectDelete();
														CloseDownEditorProperties();
														#ifdef WICKEDENGINE
														iLastEntityOnCursor = 0;
														#endif

														std::string sFpeName = path_for_filename.c_str();
														sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
														t.addentityfile_s = sFpeName.c_str();
														if (t.addentityfile_s != "")
														{
															entity_adduniqueentity(false);
															t.tasset = t.entid;
															if (t.talreadyloaded == 0)
															{
																editor_filllibrary();
															}
														}
														#ifdef WICKEDENGINE
														iExtractMode = 0; //PE: Always start in find floor mode.
														#endif
														t.inputsys.constructselection = t.tasset;

														t.gridentity = t.entid;
														t.inputsys.constructselection = t.entid;
														t.inputsys.domodeentity = 1;
														t.grideditselect = 5;
														#ifdef WICKEDENGINE
														//Make sure we use a fresh t.grideleprof
														entity_fillgrideleproffromprofile();
														#endif

														editor_refresheditmarkers();
														//PE: Close window for now.
														bCheckForClosing = true;
													}
												}

												if (!bEntity_Properties_Window && !g_bCharacterCreatorPlusActivated && !bImporter_Window && i == 0 && ImGui::IsItemHovered()) {

													iTooltipHoveredTimer = Timer();
													static void* additionalcheck = NULL;

													if (iLastTooltipSelection != textureId || (additionalcheck != myfiles)) {

														//Check if we need to delete a old tooltip object.
														if (iTooltipLastObjectId > 0 && iTooltipLastObjectId != textureId) {
															CheckTooltipObjectDelete();
														}
														additionalcheck = myfiles;
														iTooltipTimer = iTooltipHoveredTimer;
														iLastTooltipSelection = textureId;
														iTooltipObjectReady = false;

													}
													else 
													{
														if (iTooltipHoveredTimer - iTooltipTimer > 2000) { // 2 sec before starting.
															if (iTooltipObjectReady) 
															{
																if (iTooltipLastObjectId > 0) 
																{
																	if (GetImageExistEx(g.importermenuimageoffset + 50)) 
																	{
																		float TooltipImageSize = 320.0f;
																		float ImgX = ImageWidth(g.importermenuimageoffset + 50);
																		float ImgY = ImageHeight(g.importermenuimageoffset + 50);
																		float Ratio = TooltipImageSize / ImgX;
																		ImgY *= Ratio;
																		ImVec2 cursor_pos = ImGui::GetIO().MousePos;
																		ImVec2 tooltip_offset(10.0f, ImGui::GetFontSize()*1.5);
																		ImVec2 tooltip_position = cursor_pos;
																		if (tooltip_position.x + TooltipImageSize > GetDesktopWidth())
																			tooltip_position.x -= TooltipImageSize;
																		if (tooltip_position.y + TooltipImageSize > GetDesktopHeight())
																			tooltip_position.y -= (TooltipImageSize + ImGui::GetFontSize()*3.0);
																		tooltip_position.x += tooltip_offset.x;
																		tooltip_position.y += tooltip_offset.y;
																		ImGui::SetNextWindowPos(tooltip_position);
																		ImGui::SetNextWindowContentWidth(TooltipImageSize);
																		ImGui::BeginTooltip();
																		float icon_ratio;
																		ImGui::ImgBtn(g.importermenuimageoffset + 50, ImVec2(TooltipImageSize, ImgY), ImVec4(0.0, 0.0, 0.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false);
																		//char hchar[MAX_PATH];
																		//ImGui::Text("%s", hchar);
																		ImGui::EndTooltip();
																	}
																	else
																		ImGui::SetTooltip("%s", sFinal.c_str());
																}
															}
															else 
															{
																//Generate Thumbnail of object.
																std::string sFpeName = path_for_filename.c_str();
																sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
																t.addentityfile_s = sFpeName.c_str();

																CreateBackBufferCacheName(t.addentityfile_s.Get(), 512, 512);
																BackBufferSaveCacheName = BackBufferCacheName;
																GG_SetWritablesToRoot(true);
																if (FileExist(BackBufferCacheName.Get()))
																{
																	SetMipmapNum(1); //PE: mipmaps not needed.
																	image_setlegacyimageloading(true);
																	if (ImageExist(g.importermenuimageoffset + 50))
																		DeleteImage(g.importermenuimageoffset + 50);
																	LoadImage((char *)BackBufferCacheName.Get(), g.importermenuimageoffset + 50);
																	image_setlegacyimageloading(false);
																	SetMipmapNum(-1);
																	GG_SetWritablesToRoot(false);
																	iTooltipObjectReady = true;
																	iTooltipLastObjectId = t.entid;
																}
																else
																{
																	GG_SetWritablesToRoot(false);
																	t.entdir_s = "entitybank\\";
																	if (cstr(Lower(Left(t.addentityfile_s.Get(), 11))) == "entitybank\\")
																	{
																		t.addentityfile_s = Right(t.addentityfile_s.Get(), Len(t.addentityfile_s.Get()) - 11);
																	}
																	if (cstr(Lower(Left(t.addentityfile_s.Get(), 8))) == "ebebank\\")
																	{
																		t.entdir_s = "";
																	}
																	#ifndef NEWPROJSYSWORKINPROGRESS
																	if (cstr(Lower(Left(t.addentityfile_s.Get(), 12))) == "projectbank\\")
																	{
																		t.entdir_s = "";
																	}
																	#endif

																	t.talreadyloaded = 0;
																	for (t.t = 1; t.t <= g.entidmaster; t.t++)
																	{
																		if (t.entitybank_s[t.t] == t.addentityfile_s) { t.talreadyloaded = 1; t.entid = t.t; }
																	}
																	if (t.talreadyloaded == 0)
																	{
																		//  Allocate one more entity item in array
																		if (g.entidmaster > g.entitybankmax - 4)
																		{
																			Dim(t.tempentitybank_s, g.entitybankmax);
																			for (t.t = 0; t.t <= g.entitybankmax; t.t++) t.tempentitybank_s[t.t] = t.entitybank_s[t.t];
																			++g.entitybankmax;
																			UnDim(t.entitybank_s);
																			Dim(t.entitybank_s, g.entitybankmax);
																			for (t.t = 0; t.t <= g.entitybankmax - 1; t.t++) t.entitybank_s[t.t] = t.tempentitybank_s[t.t];
																		}

																		//  Add entity to bank
																		++g.entidmaster; entity_validatearraysize();
																		t.entitybank_s[g.entidmaster] = t.addentityfile_s;

																		if (ObjectExist(g.entitybankoffset + g.entidmaster)) 
																		{
																			DeleteObject(g.entitybankoffset + g.entidmaster);
																		}

																		//  Load extra entity
																		t.entid = g.entidmaster;
																		t.ent_s = t.entitybank_s[t.entid];
																		t.entpath_s = getpath(t.ent_s.Get());

																		extern bool g_bGracefulWarningAboutOldXFiles;
																		g_bGracefulWarningAboutOldXFiles = true;
																		entity_load();
																		g_bGracefulWarningAboutOldXFiles = false;
																		HideObject(g.entitybankoffset + g.entidmaster);
																		if (t.entityprofile[g.entidmaster].ischaracter == 1) {
																			RotateObject(g.entitybankoffset + g.entidmaster, 0, 180, 0);
																		}
																		g.entidmaster--; //Dont actual add it.

																		//entity_load can change folder by creating a dbo , so update timestamp without refresh.
																		struct stat sb;
																		if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
																		{
																			if (sb.st_mtime != pNewFolder->m_tFolderModify) 
																			{
																				pNewFolder->m_tFolderModify = sb.st_mtime;
																			}
																		}
																		//Create a new thumbnail.
																	}

																	iTooltipLastObjectId = t.entid;
																	iTooltipAlreadyLoaded = t.talreadyloaded;
																	iTooltipObjectReady = true;
																	BackBufferObjectID = g.entitybankoffset + t.entid;
																	BackBufferImageID = g.importermenuimageoffset + 50;
																	BackBufferSizeX = 512;
																	BackBufferSizeY = 512;
																	BackBufferSaveCacheName = ""; //Dont save for now.
																}
															}
														}
													}
												}

												if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
												{

													CheckTooltipObjectDelete();
													CloseDownEditorProperties();
													t.inputsys.constructselection = 0;

													myfiles->m_dropptr = myfiles;

													std::string sFpeName = path_for_filename.c_str();
													sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();

													myfiles->m_sFolder = sFpeName.c_str();
													ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", myfiles, sizeof(void *));
													ImGui::ImgBtn(textureId, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, true);
													//ImGui::Text("%s", myfiles->m_sName.Get());
													ImGui::SetCursorPos(oldCursor);
													pDragDropFile = myfiles;
													ImGui::EndDragDropSource();
												}

												ImGui::PopStyleVar();

												if (bDisplayText) {
													int iTextWidth = ImGui::CalcTextSize(sFinal.c_str()).x;
													if (iTextWidth < iColumnsWidth)
														ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + (fCenterX - (iTextWidth*0.5)), ImGui::GetCursorPosY()));
													ImGui::TextWrapped("%s", sFinal.c_str());
												}

												ImGui::NextColumn();
											}
											ImGui::PopID();
											preview_count++;

											myfiles = myfiles->m_pNext;
										}

										ImGui::Columns(1);

										ImGui::SetWindowFontScale(1.0);
									}
								}
								pNewFolder = pNewFolder->m_pNext;
							}

						}
					}

					if (!bAnySelectedItemsAvailable) {
						//PE: We got no selections , we can reset first shift seen.
						if (!io.KeyShift) {
							firstShiftFile = NULL;
						}
					}
					ImGui::SetWindowFontScale(1.0);

					ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
					if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
					{
						bImGuiGotFocus = true;
						bEntityGotFocus = true;
					}
					if (ImGui::IsAnyItemFocused()) {
						bImGuiGotFocus = true;
						bEntityGotFocus = true;
					}


					if (lf_multi_selections_count > 0) {
						ImGui::SetCursorPos(ImVec2(0, (ImGui::GetWindowSize().y + ImGui::GetScrollY()) - insert_text_width.y - 10.0f));
						ImGui::Spacing();
						ImGui::SameLine(ImGui::GetWindowContentRegionWidth() - (insert_text_width.x + 18.0f));
						ImGui::SetItemAllowOverlap();
						if (ImGui::StyleButton(insert_text.c_str())) {
							bAddSelectionToGame = true;
						}

					}

					ImGui::EndChild();

					ImGui::EndTabItem();
				}

				ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
				if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
				{
					bImGuiGotFocus = true;
					bEntityGotFocus = true;
				}
				if (ImGui::IsAnyItemFocused()) {
					bImGuiGotFocus = true;
					bEntityGotFocus = true;
				}

			}
		}

#ifdef DYNAMICLOADUNLOAD
		max_load_persync = 10; // 15 to slow try 10
#endif
		lf_multi_selections_count = multi_selections_count; //Use last frames count.

		ImGui::EndTabBar();


		if (bAddSelectionToGame) {

			DeleteWaypointsAddedToCurrentCursor();
			CheckTooltipObjectDelete();
			CloseDownEditorProperties();

			//Remove any selections.
			t.inputsys.constructselection = 0;
			if (t.gridentityobj > 0)
			{
				DeleteObject(t.gridentityobj);
				t.gridentityobj = 0;
			}
			t.refreshgrideditcursor = 1;
			t.gridentity = 0;
			t.gridentityposoffground = 0;
			t.gridentityusingsoftauto = 0;
			editor_refresheditmarkers();

			cFolderItem *pSearchFolder = &MainEntityList;
			pSearchFolder = pSearchFolder->m_pNext;
			cStr path_remove;
			int ipath_remove_len;
			if (pSearchFolder) {
				path_remove = pSearchFolder->m_sFolderFullPath.Get();
				ipath_remove_len = path_remove.Len();
			}
			while (pSearchFolder) {

				cStr path = pSearchFolder->m_sFolderFullPath.Get();
				bool bDoubleEntityBank = false;
				char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
				if (finde)
				{
					finde += 11;
					finde = (char *)pestrcasestr(finde, "\\entitybank");
					if (finde) bDoubleEntityBank = true;
				}

				if (!bDoubleEntityBank && path.Right(11) == "\\entitybank") {
					ipath_remove_len = path.Len();
				}
				else
				{
					if (pSearchFolder->m_pFirstFile) {

						cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
						while (searchfiles) 
						{
							if (searchfiles->iFlags == 1) 
							{
								if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
								if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
								if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

								//Insert.
								cStr path = pSearchFolder->m_sFolderFullPath.Get();
								char *final_name = path.Get();
								final_name += ipath_remove_len;
								if (*final_name == '\\')
									final_name++;
								std::string path_for_filename = final_name;

								std::string sFpeName = path_for_filename.c_str();
								sFpeName = sFpeName + "\\" + searchfiles->m_sName.Get();
								#ifdef WICKEDENGINE
								iLastEntityOnCursor = 0;
								#endif

								t.addentityfile_s = sFpeName.c_str();
								if (t.addentityfile_s != "")
								{
									entity_adduniqueentity(false);
									t.tasset = t.entid;
									if (t.talreadyloaded == 0)
									{
										editor_filllibrary();
									}
								}

								searchfiles->iFlags = 0;
							}
							searchfiles = searchfiles->m_pNext;
						}
					}
				}
				pSearchFolder = pSearchFolder->m_pNext;
			}
			bCheckForClosing = true;
		}

		bool bAreWeOverLapping = false;
		if (!bIsWeDocked) {
			//If we are over the rendertarget hide window.
			float itmpmousex = ImGui::GetWindowPos().x;
			float itmpmousey = ImGui::GetWindowPos().y;
			int iSecureZone = 4;
			if (bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			itmpmousey = ImGui::GetWindowPos().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x;
			itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
		}
		if (!bIsWeDocked && bCheckForClosing) {
			if (bAreWeOverLapping)
				bExternal_Entities_Window = false;
		}

		//Remove window on right click if we are overlapping.
		if (bAreWeOverLapping && t.inputsys.mclick == 2)
			bExternal_Entities_Window = false;


		bCheckForClosing = false;

		CheckMinimumDockSpaceSize(250.0f);

		ImGui::End();

	}

}

#ifdef WICKEDENGINE

void FormatLUAFilenameToTitle(LPSTR cDisplayName)
{
	char cRemoveUnderscores[MAX_PATH];
	strcpy (cRemoveUnderscores, "");
	LPSTR pRemoveUnderscores = cRemoveUnderscores;
	bool bFirstLetterOfWord = true;
	for (int n = 0; n < strlen(cDisplayName); n++)
	{
		if (cDisplayName[n] != '_')
		{
			if (bFirstLetterOfWord == true)
			{
				if (cDisplayName[n] >= 'a' && cDisplayName[n] <= 'z')
				{
					char pUpper[2];
					pUpper[0] = cDisplayName[n];
					pUpper[1] = 0;
					strupr(pUpper);
					*(pRemoveUnderscores++) = pUpper[0];
				}
				else
					*(pRemoveUnderscores++) = cDisplayName[n];

				bFirstLetterOfWord = false;
			}
			else
			{
				*(pRemoveUnderscores++) = cDisplayName[n];
			}
		}
		else
		{
			bFirstLetterOfWord = true;
		}
	}
	*(pRemoveUnderscores++) = 0;

	// Now prepare spaces
	char cNewDisplayName[MAX_PATH];
	strcpy (cNewDisplayName, "");
	LPSTR pNewDisPtr = cNewDisplayName;
	for (int n = 0; n < strlen(cRemoveUnderscores); n++)
	{
		// no .LUA extension in title
		if (cRemoveUnderscores[n] == '.')
		{
			break;
		}

		// construct new title, adding spaces between capitalised words
		if (n > 0 && cRemoveUnderscores[n] >= 'A' && cRemoveUnderscores[n] <= 'Z')
		{
			*(pNewDisPtr++) = ' ';
		}
		*(pNewDisPtr++) = cRemoveUnderscores[n];
	}
	*(pNewDisPtr++) = 0;
	strcpy (cDisplayName, cNewDisplayName);
}


struct folder_info
{
	int level;
	int type;
	int id;
	int parentid;
	int folders;
	bool bPinned;
	bool bUsed;
	char real_name[260];
	char show_name[260];
	cFolderItem *pFolder;
};

std::map<std::string, folder_info *> root_folders;
int seleted_tree_item = -1;
bool bViewAllFolders = true;
bool bViewShowcase = false;
bool bViewPurchased = false;
char cSearchAllEntities[3][MAX_PATH] = { "\0","\0","\0" };
bool bUpdateSearchSorting = false;
bool bUpdateSearchScrollbar = false;
bool bUpdateSearchSortingNextFrame = false;
bool bTreeViewInitInNextFrame = false;

bool DoTreeNode(int parentid, char *ignore, char *ignore2, char *selectfolder = NULL, char* pstartfolder = NULL, bool bSwapInSteamName = false)
{
	bool bViewingCommunityFolder = false;
	auto it = root_folders.begin();
	if (pstartfolder)
	{
		// option to do tree in only one root folder (Community)
		for (; it != root_folders.end(); ++it)
		{
			if ( it->second->level==0 && it->second->type == iDisplayLibraryType && stricmp(pstartfolder, it->second->show_name) == NULL)
			{
				bViewingCommunityFolder = true;
				break;
			}
		}
	}
	for (; it != root_folders.end(); ++it)
	{
		bool bValid = true;
		int iCompareType = iDisplayLibraryType;
		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) iCompareType = 6; // Select only animation files when subtype=1
		if (it->second->type == iCompareType && (it->second->parentid == parentid || (it->second->bPinned && parentid == 0)))
		{
			//Pinned level 0 display as is.
			ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow;
			if (it->second->folders <= 0)
				node_flags = ImGuiTreeNodeFlags_Leaf;
			if (seleted_tree_item == it->second->id)
				node_flags |= ImGuiTreeNodeFlags_Selected;
			else
				node_flags &= ~ImGuiTreeNodeFlags_Selected;

			ImGui::PushItemWidth(-20.0);

			std::string treename = it->second->show_name;

			if (parentid != 0) bValid = true;
			if (parentid == 0 && ignore && stricmp(treename.c_str(), ignore) == NULL) bValid = false;
			if (parentid == 0 && ignore2 && stricmp(treename.c_str(), ignore2) == NULL) bValid = false;
			if (parentid == 0)
			{
				// special extended filters for specific types
				if (ignore && stricmp(ignore,"AllNoneBehaviorFolders")==NULL)
				{
					if (stricmp(cSearchAllEntities[0], "purchased") == NULL)
					{
						// only show purchased behaviors
						//bValid = true;
						if (treename == "Animals") bValid = false;
						if (treename == "Effects") bValid = false;
						if (treename == "Horror") bValid = false;
						if (treename == "Markers") bValid = false;
						if (treename == "Objects") bValid = false;
						if (treename == "People") bValid = false;
						if (treename == "Puzzle") bValid = false;
						if (treename == "Rpg") bValid = false;
						if (treename == "User") bValid = false;
						if (treename == "Ai") bValid = false;
						if (treename == "Gfx") bValid = false;
						if (treename == "Images") bValid = false;
						if (treename == "Weather") bValid = false;
					}
					else
					{
						// regular behavior view
						//bValid = true;
						if (treename == "Ai") bValid = false;
						if (treename == "Gfx") bValid = false;
						if (treename == "Images") bValid = false;
						if (treename == "Weather") bValid = false;
					}
				}
			}
			if (bValid)
			{
				if (it->second->bPinned)
				{
					treename = it->second->real_name;
					treename[0] = toupper(treename[0]);
				}

				// shows name in UI
				char pChangeUIName[256];
				strcpy(pChangeUIName, treename.c_str());
				if (bSwapInSteamName == true)
				{
					// all items subscribed to includes meta data for the steam user who created it, we will use the first instance of that
					#ifndef GGMAXEDU
					for (int i = 0; i < g_workshopSteamUserNames.size(); i++)
					{
						if (stricmp(g_workshopSteamUserNames[i].sSteamUserAccountID.Get(), pChangeUIName) == NULL)
						{
							strcpy(pChangeUIName, g_workshopSteamUserNames[i].sSteamUsersPersonaName.Get());
							break;
						}
					}
					#endif
				}
				bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)it->second->id, node_flags, pChangeUIName);

				ImGui::PopItemWidth();
				//PE: Default category select.
				if (selectfolder != NULL && seleted_tree_item == -1 && _stricmp(selectfolder, it->second->real_name) == 0)
				{
					//Select category.
					seleted_tree_item = it->second->id;
				}
				//PE: Select on mouse release.
				if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
				{
					seleted_tree_item = it->second->id;
					strcpy(cSearchAllEntities[0], it->second->real_name);
					bUpdateSearchSorting = true;
					bUpdateSearchScrollbar = true;
				}
				ImGui::SameLine();
				ImGui::SetItemAllowOverlap();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvailWidth() - 18.0, -4.0));
				ImGui::PushID(it->second->id + 80000);
				ImVec4 back = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);

				if (it->second->bPinned)
				{
					if (ImGui::ImgBtn(MEDIA_UNPIN, ImVec2(15, 15), back, ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
					{
						//PE: Delete pinned category.
						extern std::vector<std::string> files_pinned_categories;
						char tmp[2];
						tmp[0] = it->second->type + '0';
						tmp[1] = 0;
						cstr namelower = cstr(Lower(it->second->real_name)) + cstr(tmp);
						for (int i = 0; i < files_pinned_categories.size(); i++)
						{
							cstr check = cstr((char *)files_pinned_categories[i].c_str()).Lower();
							if (namelower == check)
							{
								files_pinned_categories.erase(files_pinned_categories.begin() + i);
							}
						}
						saveVectorFileContent("pinnedlist.ini", files_pinned_categories);
						it->second->bPinned = false;
						bTreeViewInitInNextFrame = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Unpin Category");
				}
				else
				{
					if (ImGui::ImgBtn(MEDIA_PIN, ImVec2(15, 15), back, ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
					{
						//PE Save pinned category.
						extern std::vector<std::string> files_pinned_categories;
						char tmp[2];
						tmp[0] = it->second->type + '0';
						tmp[1] = 0;
						cstr name = cstr(it->second->real_name) + cstr(tmp);
						files_pinned_categories.push_back(name.Get());
						saveVectorFileContent("pinnedlist.ini", files_pinned_categories);
						it->second->bPinned = true;
						bTreeViewInitInNextFrame = true;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pin Category");
				}
				ImGui::PopID();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0, -8.0));

				if (TreeNodeOpen) 
				{
					ImGui::Indent(-5);
					bool bSwapName = false;
					if (bViewingCommunityFolder == true && it->second->level == 0) bSwapName = true;
					if (parentid != it->second->id)	DoTreeNode(it->second->id, ignore, ignore2, NULL, NULL, bSwapName);
					ImGui::Indent(5);
					ImGui::TreePop();
				}
			}
		}
		if (pstartfolder)
		{
			// leave after processing this one folder when pstartfolder mode used
			return(0);
		}
	}
	return(0);
}

bool DoTreeNodeSearch(int parentid, char *lookup)
{
	for (auto it = root_folders.begin(); it != root_folders.end(); ++it)
	{
		bool bValid = false;
		it->second->bUsed = false;

		int iCompareType = iDisplayLibraryType;
		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) iCompareType = 6; // Select only animation files when subtype=1
		if (it->second->type == iCompareType && (it->second->parentid == parentid || (it->second->bPinned && parentid == 0)))
		{
			//Pinned level 0 display as is.

			ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow;
			if (it->second->folders <= 0)
				node_flags = ImGuiTreeNodeFlags_Leaf;
			if (seleted_tree_item == it->second->id)
				node_flags |= ImGuiTreeNodeFlags_Selected;
			else
				node_flags &= ~ImGuiTreeNodeFlags_Selected;

			//ImRect frame_bb = ImRect(ImGui::GetWindowPos()+ImGui::GetCursorPos(), ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetFontSize()) );
			ImGui::PushItemWidth(-20.0);

			std::string treename = it->second->show_name;

			if (parentid != 0) bValid = true;
			if (parentid == 0 && lookup && treename == lookup) bValid = true;

			if (bValid)
			{
				it->second->bUsed = true;

				if (it->second->bPinned)
				{
					treename = it->second->real_name;
					treename[0] = toupper(treename[0]);
				}
				bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)it->second->id, node_flags, treename.c_str());
				ImGui::PopItemWidth();
				//PE: Select on mouse release.
				if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
				{
					seleted_tree_item = it->second->id;
					strcpy(cSearchAllEntities[0], it->second->real_name);
					bUpdateSearchSorting = true;
					bUpdateSearchScrollbar = true;
				}

				if (TreeNodeOpen) 
				{
					ImGui::Indent(-5);
					if (parentid != it->second->id)
						DoTreeNodeSearch(it->second->id, lookup);
					ImGui::Indent(5);
					ImGui::TreePop();
				}
			}
		}
	}
	return(0);
}

bool bDisplayProjectMedia = false;
bool bDisplayFavorite = false;

void process_gotopurchaedandrefreshtopurchases ( void )
{
	seleted_tree_item = -1;
	strcpy(cSearchAllEntities[0], "Purchased");
	bDisplayProjectMedia = false;
	bDisplayFavorite = false;
	bViewAllFolders = false;
	bViewShowcase = false;
	bViewPurchased = true;
	bUpdateSearchSorting = true;
	bUpdateSearchScrollbar = true;
}

bool bPopModalOpenEntity = false;
void process_entity_library_v2(void)
{
	static int iStopVideoInNextFrame = 0;
	static int iStartVideoInNextFrame = 0;
	static int iVideoGetFirstFrame = 0;
	static int iVideoThumbID = 0;
	static cstr sVideoLoadName = "";

	if (iStopVideoInNextFrame > 0 && iVideoGetFirstFrame == 0)
	{
		if (AnimationExist(iStopVideoInNextFrame))
		{
			StopAnimation(iStopVideoInNextFrame);
			DeleteAnimation(iStopVideoInNextFrame);
		}
		SetVideoVolume(100.0);
		iStopVideoInNextFrame = 0;
	}

	if (iStartVideoInNextFrame && iVideoGetFirstFrame == 0)
	{
		iVideoThumbID = 0;
		for (int itl = 1; itl <= 32; itl++)
		{
			if (AnimationExist(itl) == 0) { iVideoThumbID = itl; break; }
		}
		if (LoadAnimation((char *)sVideoLoadName.Get(), iVideoThumbID, g.videoprecacheframes, 0, 1) == false)
		{
			iVideoThumbID = -999;
		}
		if (iVideoThumbID > 0)
		{
			PlaceAnimation(iVideoThumbID, -1, -1, -1, -1);
			//Try to get first frame.
			StopAnimation(iVideoThumbID);
			SetVideoVolume(100.0);
			PlayAnimation(iVideoThumbID);
			SetRenderAnimToImage(iVideoThumbID, true);

			UpdateAllAnimation();
			Sleep(50); //Sleep so we get a video texture in the next call.
			UpdateAllAnimation();
			iStartVideoInNextFrame = 0;
			PlayAnimation(iVideoThumbID);
			SetVideoVolume(100.0);
		}
	}

	static bool bLargePreview = false;
	bool bCheckGotoPreview = false;

	if (sGotoPreviewWithFile != "")
	{
		if (!bLargePreview)
		{
			bExternal_Entities_Window = true;
			iDisplayLibraryType = 0;
			iDisplayLibrarySubType = 0;
			bCheckGotoPreview = true;
		}
	}


	if (bExternal_Entities_Window)
	{
		//PE:As we can switch type on the fly, make sure to free object images when we switch.
		static int iOldDisplayLibraryType = -1;
		static int iOldDisplayLibrarySubType = -1;
		if (iDisplayLibraryType != iOldDisplayLibraryType || iDisplayLibrarySubType != iOldDisplayLibrarySubType)
		{
			iOldDisplayLibraryType = iDisplayLibraryType;
			iOldDisplayLibrarySubType = iDisplayLibrarySubType;
			FreeTempImageList();
			iRestoreEntidMaster = g.entidmaster; //Start over.
			bUpdateSearchSorting = true;
		}
		if (g_TempimageList.size() == 0)
		{
			g_TempimageList = g_imageList;
			iRestoreEntidMaster = g.entidmaster; //PE: Mark where we are.
		}
		//PE: Make sure we dont use all memory.
		//PE: 03-18-2021: Decreased from 50 to 20 as some users reported it used all there memory.
		if (!bLoopBackBuffer && g_imageList.size() > g_TempimageList.size() + 20)
		{
			//PE: After we cached 50 textures free all so we dont run out of mem. We might auto generate 1000 thumbs :)
			//PE: This is like allowing around 15 fpe with objects textures to be cached.
			FreeTempImageList();
			iRestoreEntidMaster = g.entidmaster; //Start over.
		}


		ImGuiWindowFlags ex_window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
		ImGuiIO& io = ImGui::GetIO();

		static bool bDoneOneThumbPerSync;
		static int iDeleteInNextUpdate = 0;
		static int uniqueId = 4000; //PE: Also used for imageID for previews.
		static int loaded_images = 0;
		static bool multi_selections = false;
		int multi_selections_count = 0;
		static int lf_multi_selections_count = 0;
		int olduniqueId = uniqueId;
		bool bReleaseIconsDynamic = false;

		//uniqueId (imageid) range goes from 4000-43000 MAX.
		uniqueId = 4000;
		if (iDisplayLibraryType == 2)
		{
			uniqueId += 6000;
		}
		if (iDisplayLibraryType == 1)
		{
			uniqueId += 12000;
		}
		if (iDisplayLibraryType == 3)
		{
			uniqueId += 18000;
		}
		if (iDisplayLibraryType == 4)
		{
			uniqueId += 24000;
		}
		if (iDisplayLibraryType == 5)
		{
			uniqueId += 30000;
		}

#ifdef DYNAMICLOADUNLOAD
		static int max_load_persync = 200; //First time only , changed later to 15
		bReleaseIconsDynamic = true;
#else
		int max_load_persync = 2000;
#endif

		if (iDisplayLibraryType == 3)
		{
			//Generating of video preview, could take some time so one per frame.
			max_load_persync = 1;
		}
		else if (iDisplayLibraryType == 2)
		{
			//Loading images takes to long, max one per sync. perhaps use preloader here ?
			max_load_persync = 1;
		}
		else if (iDisplayLibraryType == 4)
		{
			//Only Loading thumbs.
			max_load_persync = 10;
		}
		else if (iDisplayLibraryType == 5)
		{
			//Only Loading thumbs.
			max_load_persync = 10;
		}
		else
		{
			if (max_load_persync != 200)
				max_load_persync = 10;
		}

		int preview_count = 0;
		int media_icon_size = 64;
		int media_icon_size_y = 32;
		int thumb_x = 512;
		int thumb_y = 288;
		int iColumnsWidth = 110;

		bDoneOneThumbPerSync = false;

		if (iDeleteInNextUpdate > 0)
		{
			image_setlegacyimageloading(true);
			DeleteImage(iDeleteInNextUpdate);
			image_setlegacyimageloading(false);
			iDeleteInNextUpdate = 0;
		}

		time_t tCurrentTimeSec;
		time(&tCurrentTimeSec);

		static int iLargePreviewImageID = false;
		static cFolderItem::sFolderFiles * pPreviewFile = NULL;
		static bool bStartAnimation = false;
		static int iAnimationSet = 0;
		static bool bAnimationAll = true;
		static bool bLoopAnim = true;
		static int iGetTriangles = 0;
		static int iGetVertex = 0;
		static int iGetLodLevels = 0;
		static cstr cGetTextureSize;
		static int iLowestAnimFrame = 0, iHigestAnimFrame = 0;
		static cstr cCurrentBackDrop = "None";
		bool bImagesStillInImGuiQueue = false;

		//bUpdateSearchSorting = false; // cleared later so other funcs can set this to trigger
		static int current_sortby = 1;

		static cFolderItem::sFolderFiles * firstvisiblefile = NULL;
		static cFolderItem::sFolderFiles * scrolltofile = NULL;
		static cFolderItem::sFolderFiles * secondscrolltofile = NULL;
		static bool bScrollInNextFrame = false;
		firstvisiblefile = NULL;

		bool bAdvancedFPEFeatures = true;
		static bool bUpdateSearchAfterFPEScan = false;
		if (fpe_thread_in_progress())
		{
			bAdvancedFPEFeatures = false;
			bUpdateSearchAfterFPEScan = true;
		}
		else
		{
			if (bUpdateSearchAfterFPEScan)
			{
				bUpdateSearchAfterFPEScan = false;
				bUpdateSearchSorting = true;
			}
		}

		static char cCheckboxFilters[5][MAX_PATH];
		static bool bCheckboxFilters[5] = { true,true,true,true,true };

		//When changing media type , always refresh search results.

		if (iLastDisplayLibraryType != iDisplayLibraryType)
		{
			//Reset search
			iLastDisplayLibraryType = iDisplayLibraryType;
			bUpdateSearchSorting = true;
			bUpdateSearchScrollbar = true;
			strcpy(cSearchAllEntities[0], "");
			strcpy(cSearchAllEntities[1], "");
			strcpy(cSearchAllEntities[2], "");

			static bool bRestoreSearchOnLaunch = true;

			//PE: sStartLibrarySearchString can overwrite cRememberLastSearchObjects.
			if (iDisplayLibraryType == 0)
			{
				if (bRestoreSearchOnLaunch)
				{
					if(strlen(pref.cRememberLastSearchObjects) >  0)
						strcpy(cSearchAllEntities[0], pref.cRememberLastSearchObjects);
					for (int i = 0; i < 5; i++)
						bCheckboxFilters[i] = pref.iCheckboxFilters[i];

					bRestoreSearchOnLaunch = false;
				}
			}

			if (sStartLibrarySearchString != "")
			{
				strcpy(cSearchAllEntities[0], sStartLibrarySearchString.Get());
				sTriggerCategorySelect = sStartLibrarySearchString;
				seleted_tree_item = -1;
				sStartLibrarySearchString = "";
				bDisplayFavorite = false; //Disable favorite. so we see real search list.
			}
		}
		else
		{
			if (iDisplayLibraryType == 2)
			{
				//if image always use sStartLibrarySearchString.
				if (sStartLibrarySearchString != "")
				{
					strcpy(cSearchAllEntities[0], sStartLibrarySearchString.Get());
					sTriggerCategorySelect = sStartLibrarySearchString;
					seleted_tree_item = -1;
					sStartLibrarySearchString = "";
					bDisplayFavorite = false; //Disable favorite. so we see real search list.
				}
			}
		}

		//#########################################
		//#### Large preview window of objects ####
		//#########################################

		if (bLargePreview)
		{
			bImGuiGotFocus = true;
			bool bIsCCPObject = false;

			if (!bPopModalOpenEntity)
			{
				ImGui::OpenPopup("##Preview##DisModalMode");
				ImGui::SetNextWindowSize(ImVec2(1320.0f, 0), ImGuiCond_Always);
				bStartAnimation = false;
				bAnimationAll = true;
				iAnimationSet = 0;
				iGetTriangles = 0;
				iGetVertex = 0;
				iGetLodLevels = 0;
				sObject* pObject = g_ObjectList[BackBufferObjectID];
				if (ObjectExist(BackBufferObjectID))
				{
					iGetTriangles = GetObjectPolygonCount(BackBufferObjectID);
					iGetVertex = GetObjectTotalVertexCount(BackBufferObjectID);
					iGetLodLevels = GetLodLevels(BackBufferObjectID);

					//Get texture plate size from wicked.
					cGetTextureSize = "Texture Plate Size: ";

					if (pObject)
					{
						// Ensure that the characters created are rendered with double siced hair:
						if (sGotoPreviewWithFile != "")
						{
							if (strstr(sGotoPreviewWithFile.Get(), "entitybank\\user"))
							{
								if (FileOpen(1) == 1) CloseFile(1);

								OpenToRead(1, sGotoPreviewWithFile.Get());
								while (FileEnd(1) == 0)
								{
									t.tline_s = ReadString(1);
									t.tcciStat_s = Lower(FirstToken(t.tline_s.Get(), " "));
									if (t.tcciStat_s == "ccpassembly")
									{
										bIsCCPObject = true;

										t.entityprofile[BackBufferEntityID].thumbnailbackdrop = "Blue spotlight.dds";
									
										// this is a character creator creation!!
										for (int i = 0; i < pObject->iFrameCount; i++)
										{
											if (strstr(pObject->ppFrameList[i]->szName, "hair"))
											{
												wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pObject->ppFrameList[i]->pMesh->wickedmeshindex);
												if (mesh)
												{
													// Set the meshes double sided so that the hair renders correctly.
													mesh->SetDoubleSided(true);
												}
											}
										}
										break;
									}
								}
								CloseFile(1);
							}
						}
						
						sMesh* pMesh = NULL;
						for (int i = 0; i < pObject->iFrameCount; i++)
						{
							if (pObject->ppFrameList[i]->pMesh && pObject->ppFrameList[i]->pMesh->wickedmeshindex > 0)
							{
								pMesh = pObject->ppFrameList[i]->pMesh;
								break;
							}
						}
						if (pMesh)
						{
							wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
							if (mesh)
							{
								uint64_t materialEntity = mesh->subsets[0].materialID;
								wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
								if (pObjectMaterial)
								{
									if (pObjectMaterial->textures[0].resource) // MaterialComponent::BASECOLORMAP].resource)
									{
										wiGraphics::Texture* texture;
										//texture = (wiGraphics::Texture*) &pObjectMaterial->textures[0].resource;// pObjectMaterial->GetBaseColorMap();
										texture = (wiGraphics::Texture*) pObjectMaterial->textures[0].GetGPUResource();
										if (texture)
										{
											int width, height;
											width = (int)texture->GetDesc().Width;
											height = (int)texture->GetDesc().Height;
											cGetTextureSize = cGetTextureSize + cstr(width) + "x" + cstr(height);
										}
									}
								}
							}
						}
					}
				}
				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					//PE: Stop any running animations.
					SetObjectFrame(BackBufferObjectID, 0);
					StopObject(BackBufferObjectID);
					iHigestAnimFrame = 0;
					for (int n = 0; n < t.entityprofile[BackBufferEntityID].startofaianim; n++)
					{
						if (t.entityanim[BackBufferEntityID][n].finish > iHigestAnimFrame)
							iHigestAnimFrame = t.entityanim[BackBufferEntityID][n].finish;
					}
					//PE: Lowest in wicked is always 0 , some fpe have -1, always assume 0 as start for ALLAnimations.
					iLowestAnimFrame = 0;
				}

				fpe_current_loaded_script = -1; //Make sure dlua is loaded in next call to DisplayFPEBehavior.
				if (pObject)
				{
					Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0);
					Wicked_Set_Material_From_grideleprof((void*)pObject, 0); //Set default selected mesh , for material.
				}

				cCurrentBackDrop = "None";
				
				t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
				cFolderItem *pNewFolder = &MainEntityList;
				pNewFolder = pNewFolder->m_pNext;
				pNewFolder = pNewFolder->m_pNext;
				bool bGetOut = false;
				while (pNewFolder)
				{
					if (pNewFolder->m_pFirstFile)
					{
						cFolderItem::sFolderFiles * myfiles = NULL;
						myfiles = pNewFolder->m_pFirstFile->m_pNext;
						while (myfiles)
						{
							if (myfiles->iPreview > 0)
							{
								cstr check = myfiles->m_sPath + cstr("\\") + myfiles->m_sName;
								//if (myfiles->m_sPath == t.addentityfile_s)
								if (pestrcasestr(check.Get(), t.addentityfile_s.Get()))
								{
									//Set default backdrop.
									if (myfiles->m_Backdrop.Len() > 0 && myfiles->m_Backdrop != "None")
									{
										CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + myfiles->m_Backdrop, t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.
										cCurrentBackDrop = myfiles->m_Backdrop;
										cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
										cCurrentBackDrop = importer_getfilenameonly(cCurrentBackDrop.Get());
									}
									else
									{
										//CreateBackdropObject(false, "Blue spotlight.dds", t.addentityfile_s);
										//cCurrentBackDrop = "Blue spotlight.dds";
										CreateBackdropObject(false, "None", t.addentityfile_s);
										cCurrentBackDrop = "None";
									}
									bGetOut = true;
								}
							}
							if (bGetOut) break;
							myfiles = myfiles->m_pNext;
						}
					}
					if (bGetOut) break;
					pNewFolder = pNewFolder->m_pNext;
				}

				if (!(t.entityprofile[BackBufferEntityID].BackBufferZoom == -1.0f && t.entityprofile[BackBufferEntityID].BackBufferCamLeft == -1.0f && t.entityprofile[BackBufferEntityID].BackBufferRotateX == -1.0f))
				{
					//Found settings, set restore.
					RestoreBackBufferZoom = t.entityprofile[BackBufferEntityID].BackBufferZoom;
					RestoreBackBufferCamLeft = t.entityprofile[BackBufferEntityID].BackBufferCamLeft;
					RestoreBackBufferCamUp = t.entityprofile[BackBufferEntityID].BackBufferCamUp;
					RestoreBackBufferRotateX = t.entityprofile[BackBufferEntityID].BackBufferRotateX;
					RestoreBackBufferRotateY = t.entityprofile[BackBufferEntityID].BackBufferRotateY;
					bBackBufferRestoreCamera = true; //Restore from fpe settings in next call.
				}

				//Check if we can default to animset 1 and set pose.
				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					iAnimationSet = 0;
					bAnimationAll = false;
					//Set pose dont start anim.
					int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
					SetObjectFrame(BackBufferObjectID, iFrameStart);
				}
				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					if (t.entityprofile[BackBufferEntityID].iThumbnailAnimset >= 0 && t.entityprofile[BackBufferEntityID].iThumbnailAnimset < t.entityprofile[BackBufferEntityID].startofaianim)
					{
						// new method uses name instead of fixed values
						if (t.entityprofile[BackBufferEntityID].playanimineditor == -1)
						{
							// uses name instead of index, the negative is the ordinal into the animset
							extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
							entity_loop_using_negative_playanimineditor(0, BackBufferObjectID, t.entityprofile[BackBufferEntityID].playanimineditor_name);
						}
						else
						{
							iAnimationSet = t.entityprofile[BackBufferEntityID].iThumbnailAnimset;
							bAnimationAll = false;
							int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
							int iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
							SetObjectFrame(BackBufferObjectID, iFrameStart);
							//Start selected animation
							LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);
						}
						bStartAnimation = true;
					}
					if (bStartAnimation == true)
					{
						if (t.entityprofile[BackBufferEntityID].animspeed > 0)
						{
							SetObjectSpeed(BackBufferObjectID, t.entityprofile[BackBufferEntityID].animspeed);
						}
					}
				}

				if (cCurrentBackDrop == "None" && t.entityprofile[BackBufferEntityID].thumbnailbackdrop.Len() > 0 && t.entityprofile[BackBufferEntityID].thumbnailbackdrop != "None")
				{
					cCurrentBackDrop = t.entityprofile[BackBufferEntityID].thumbnailbackdrop;
					CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + cCurrentBackDrop, t.addentityfile_s);
				}

			}

			static bool bTriggerResize = false;
			if (bTriggerResize)
			{
				ImGui::SetNextWindowSize(ImVec2(1320.0f, 612.0f), ImGuiCond_Always);
				bTriggerResize = false;
			}
			//ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse |
			int addflags = 0;
			if (sGotoPreviewWithFile != "")
			{
				addflags = ImGuiWindowFlags_NoTitleBar;
			}
			bPopModalOpenEntity = ImGui::BeginPopupModal("##Preview##DisModalMode", &bLargePreview, ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | addflags);
			if (bPopModalOpenEntity)
			{
				if (addflags == ImGuiWindowFlags_NoTitleBar)
				{
					ImGui::Text("");
				}
				ImVec2 cur_size = ImGui::GetWindowSize();
				if (cur_size.y < 200.0f)
				{
					//Trigger resize.
					bTriggerResize = true;
				}
				grideleprof_uniqui_id = 45000; //Always use unique IDs.
				float fPreviewImgSize = 1024.0f;
		
				ImGui::Columns(2, "PreviewColumns", false);  //false no border
				ImGui::SetColumnOffset(0, 0.0f);
				ImGui::SetColumnOffset(1, fPreviewImgSize);

				if (ImageExist(iLargePreviewImageID))
				{
					bLoopFullFPS = false;
					float fMoveSpeed = 512.0f;
					float ImgX = ImageWidth(iLargePreviewImageID);
					float ImgY = ImageHeight(iLargePreviewImageID);
					float Ratio = fPreviewImgSize / ImgX;
					ImgY *= Ratio;
					ImGui::ImgBtn(iLargePreviewImageID, ImVec2(fPreviewImgSize, ImgY), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);
					if (ImGui::IsItemActive() && ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0))
					{
						//PE: Some object rotate inverted Pivot ?
						BackBufferRotateY -= ImGui::GetIO().MouseDelta.x / fMoveSpeed * (360.0f*g.timeelapsed_f);
						if (BackBufferRotateY < 0) BackBufferRotateY += 360.0;
						if (BackBufferRotateY > 360.0) BackBufferRotateY -= 360.0;

						if (t.entityprofile[BackBufferEntityID].ischaracter == 0) {
							BackBufferRotateX -= ImGui::GetIO().MouseDelta.y / fMoveSpeed * (360.0f*g.timeelapsed_f);
							if (BackBufferRotateX < 0) BackBufferRotateX += 360.0;
							if (BackBufferRotateX > 360.0) BackBufferRotateX -= 360.0;
						}
						bLoopFullFPS = true;
					}

					static float fMoveBackbufferToLeft = 0.0f, fMoveBackbufferToUp = 0.0f;
					static float BackBufferCamLeftOld = 0.0f, BackBufferCamUpOld = 0.0f;
					float fCamDistance = BackBufferCamMove * 0.5 - BackBufferZoom;
					//fCamDistance *= 0.475; //
					fCamDistance *= (0.70*g.timeelapsed_f);
					if (fCamDistance < 50.0f) fCamDistance = 50.0f;

					if (ImGui::IsMouseDown(1) && ImGui::IsItemHovered() && ImGui::IsMouseDragging(1))
					{
						//BackBufferCamLeft += ImGui::GetIO().MouseDelta.x / fMoveSpeed * 160.0f;
						//BackBufferCamUp += ImGui::GetIO().MouseDelta.y / fMoveSpeed * 160.0f;

						//PE: Use inertia slerp
						fMoveBackbufferToLeft = fMoveBackbufferToLeft + ImGui::GetIO().MouseDelta.x / fMoveSpeed * fCamDistance;
						BackBufferCamLeft = ImLerp(fMoveBackbufferToLeft, BackBufferCamLeftOld, 0.85);
						BackBufferCamLeftOld = BackBufferCamLeft;

						fMoveBackbufferToUp = fMoveBackbufferToUp + ImGui::GetIO().MouseDelta.y / fMoveSpeed * fCamDistance;
						BackBufferCamUp = ImLerp(fMoveBackbufferToUp, BackBufferCamUpOld, 0.85);
						BackBufferCamUpOld = BackBufferCamUp;

						bLoopFullFPS = true;
						ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);
					}
					else {
						fMoveBackbufferToLeft = BackBufferCamLeftOld = BackBufferCamLeft;
						fMoveBackbufferToUp = BackBufferCamUpOld = BackBufferCamUp;
					}

					if (ImGui::IsItemHovered() && ImGui::GetIO().MouseWheel != 0)
					{
						float speed = BackBufferCamMove / 30.0f; //Depent on object size. Now faster (/ 50.0f)
						if (io.KeyShift)
							speed *= 2.0; //Faster when using shift.
						speed *= g.timeelapsed_f;
						BackBufferZoom += ImGui::GetIO().MouseWheel*speed;
						bLoopFullFPS = true;
					}
					//ImGui::Text("fCamDistance: %f", fCamDistance);
					//ImGui::Text("g.timeelapsed_f: %f", g.timeelapsed_f);

				}

				ImGui::Spacing();

				ImGui::NextColumn();

				ImGui::BeginChild("##ChildNewFPEPropertiesPanel", ImVec2(0, 0), false, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNavInputs); //ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar
				
				std::string sString;
				
				if (ImGui::StyleCollapsingHeader("Backdrop", ImGuiTreeNodeFlags_DefaultOpen))
				{
					GetFilesListForLibrary("texturebank\\backdrops\\", true);
					ImGui::Indent(10);
					ImGui::TextCenter("Static Image");
					ImGui::PushItemWidth(-10);
					//cstr cRet = ListboxFilesListForLibrary(cCurrentBackDrop.Get());
					cstr cRet = ComboFilesListForLibrary(cCurrentBackDrop.Get(), 6, 120, true);
					if (cRet != cCurrentBackDrop)
					{
						t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
						cCurrentBackDrop = cRet;
						CreateBackdropObject(true, cstr("texturebank\\backdrops\\") + cCurrentBackDrop, t.addentityfile_s);
						if (!ImageExist(BACKDROPMAGE))
						{
							cCurrentBackDrop = "None";
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select static image for object backdrop");

					if (bBackbufferCubemapActive)
					{
						t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
						sString = t.addentityfile_s.Get();
						replaceAll(sString, ".fpe", "_fpe_cube.dds");
					}
					else
						sString = "";

					//#### Keywords ####
					cstr cTmp = t.entityprofile[BackBufferEntityID].keywords_s;
					cTmp = imgui_setpropertystring2_v2(0, cTmp.Get(), "Keywords", "Enter additional keywords, separated by commas.", false);
					if (cTmp != t.entityprofile[BackBufferEntityID].keywords_s)
					{
						t.entityprofile[BackBufferEntityID].keywords_s = cTmp;
					}

					ImGui::PopItemWidth();
					ImGui::Indent(-10);
				}

				ImGui::Indent(10);
				if (ImGui::StyleButton("LOD Generator Lite", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//PE: Startup Lod Generator Lite.
					std::string LODFile = "entitybank\\";
					LODFile = LODFile + t.entitybank_s[BackBufferEntityID].Get();
					char pDestinationFile[10240];
					strcpy(pDestinationFile, LODFile.c_str());
					GG_GetRealPath(pDestinationFile, 0);
					char pOldDir[MAX_PATH];
					strcpy(pOldDir, GetDir());
					SetDir("..");
					SetDir("Tools\\");
					SetDir("Lod Generator Lite");
					std::string params = "\"";
					params = params + pDestinationFile;
					params = params + "\"";
					HINSTANCE hinstance = ShellExecuteA(NULL, "open", "LODGeneratorLite.exe", params.c_str(), "", SW_SHOWDEFAULT);
					SetDir(pOldDir);
				}
				ImGui::Indent(-10);

				if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
				{
					//PE: Make sure we set anim speed. we only use parent object in this system.
					t.tanimspeed_f = t.entityprofile[BackBufferEntityID].animspeed;
					if (ObjectExist(BackBufferObjectID) == 1)
					{
						SetObjectSpeed(BackBufferObjectID, t.tanimspeed_f);
					}

					if (strstr(sGotoPreviewWithFile.Get(), "charactercreatorplus"))
						bIsCCPObject = true;
				
					if (!bIsCCPObject)
					{
						if (t.entityprofile[BackBufferEntityID].playanimineditor != -1)
						{
							if (ImGui::StyleCollapsingHeader("Animations", ImGuiTreeNodeFlags_DefaultOpen))
							{
								ImGui::Indent(10);

								static int iFrameCurrent = 0;
								float fFontSize = ImGui::GetFontSize();
								int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
								int iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
								if (bAnimationAll)
								{
									iFrameStart = iLowestAnimFrame;
									iFrameEnd = iHigestAnimFrame;
								}

								cstr sComboName = cstr("Animation ") + cstr(iAnimationSet) + " (" + cstr(iFrameStart) + "," + cstr(iFrameEnd) + ")";
								cstr sComboNameAll = cstr("All Animations ") + " (" + cstr(iLowestAnimFrame) + "," + cstr(iHigestAnimFrame) + ")";
								if (bAnimationAll)
									sComboName = sComboNameAll;

								ImGui::PushItemWidth(-10 - fFontSize - 8.0f);
								if (ImGui::BeginCombo("##animcomboselection", sComboName.Get())) // The second parameter is the label previewed before opening the combo.
								{
									if (ImGui::Selectable(sComboNameAll.Get(), bAnimationAll))
									{
										iFrameStart = iLowestAnimFrame;
										iFrameEnd = iHigestAnimFrame;
										bAnimationAll = true;
										SetObjectFrame(BackBufferObjectID, iLowestAnimFrame);
										if (bStartAnimation)
										{
											LoopObject(BackBufferObjectID, iLowestAnimFrame, iHigestAnimFrame);
										}
									}
									for (int n = 0; n < t.entityprofile[BackBufferEntityID].startofaianim; n++)
									{
										cstr sComboName = cstr("Animation ") + cstr(n) + " (" + cstr(t.entityanim[BackBufferEntityID][n].start) + "," + cstr(t.entityanim[BackBufferEntityID][n].finish) + ")";
										bool is_selected = (!bAnimationAll && iAnimationSet == n);
										if (ImGui::Selectable(sComboName.Get(), is_selected))
										{
											iAnimationSet = n;
											bAnimationAll = false;
											iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
											iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
											SetObjectFrame(BackBufferObjectID, iFrameStart);
											if (bStartAnimation)
											{
												//Start any animation
												LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);
											}
										}
										if (is_selected)
											ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
									}
									ImGui::EndCombo();
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Animation");
								ImGui::PopItemWidth();

								ImGui::SameLine();

								if (!bStartAnimation)
								{
									if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fFontSize, fFontSize), ImColor(255, 255, 255, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										//SetObjectFrame(BackBufferObjectID, iFrameStart);
										SetObjectFrame(BackBufferObjectID, iFrameCurrent);
										LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);

										bStartAnimation = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Play Animation");

								}
								else
								{
									if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(fFontSize, fFontSize), ImColor(255, 255, 255, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 128), drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
									{
										//SetObjectFrame(BackBufferObjectID, iFrameStart);
										//LoopObject(BackBufferObjectID);
										StopObject(BackBufferObjectID);
										SetObjectFrame(BackBufferObjectID, iFrameCurrent);
										bStartAnimation = false;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pause Animation");
								}


								//PE: Wicked dont stop animation by itself so.
								sObject* pObject = g_ObjectList[BackBufferObjectID];
								WickedCall_CheckAnimationDone(pObject);

								iFrameCurrent = WickedCall_GetObjectFrame(pObject);
								ImGui::TextCenter("Current Animation Frame");
								if (bStartAnimation)
								{
									ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
									ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
								}
								ImGui::PushItemWidth(-10);

								if (ImGui::MaxSliderInputInt("##AnimFrame", &iFrameCurrent, iFrameStart, iFrameEnd, "Display Current Animation Frame"))
								{
									//If changed stop anim and display directly.
									StopObject(BackBufferObjectID);
									SetObjectFrame(BackBufferObjectID, iFrameCurrent);
									bStartAnimation = false;
								}

								ImGui::PopItemWidth();
								if (bStartAnimation)
								{
									ImGui::PopItemFlag();
									ImGui::PopStyleVar();
								}

								ImGui::Indent(-10);
								ImGui::Text("");
							}
						}
					}
				}

				entityeleproftype backup_grideleprof = t.grideleprof;
				int backup_entid = t.entid;
				int backup_gridentity = t.gridentity;
				t.entid = BackBufferEntityID;
				t.gridentity = BackBufferEntityID;

				entity_fillgrideleproffromprofile();
				imgui_set_openproperty_flags(t.gridentity);
				
				//PE: Only if active.
				if (t.grideleprof.soundset_s.Len() > 0 || t.grideleprof.soundset1_s.Len() > 0 || t.grideleprof.soundset2_s.Len() > 0 || t.grideleprof.soundset3_s.Len() > 0)
				{
					if (!bIsCCPObject)
					{
						if (ImGui::StyleCollapsingHeader("Object's Media", ImGuiTreeNodeFlags_DefaultOpen))
						{
							ImGui::Indent(10);
							DisplayFPEMedia(true, BackBufferEntityID);
							ImGui::Indent(-10);
						}
					}
				}
				t.grideleprof = backup_grideleprof;
				t.gridentity = backup_gridentity;
				t.entid = backup_entid;

				// insert a keyboard shortcut component into panel
				// no shortcuts in this section!
				//UniversalKeyboardShortcut(eKST_ObjectLibrary);

				if (!bIsCCPObject)
				{
					ControlAdvancedSetting(pref.iFullscreenPreviewAdvanced, "advanced object library preview details", &bLargePreview);
					if (pref.iFullscreenPreviewAdvanced)
					{
						cstr cTmp, cOrg = (char *)sString.c_str();
						cTmp = imgui_setpropertyfile2_v2(t.group, cOrg.Get(), "Cubemap Image", "Select a cube map texture file for use as the object backdrop", "\\", false);
						if (cTmp != cOrg)
						{
							// change cube map
							t.addentityfile_s = cstr("entitybank\\") + t.entitybank_s[BackBufferEntityID];
							std::string sDestination = t.addentityfile_s.Get();
							replaceAll(sDestination, ".fpe", "_fpe_cube.dds");
							if (FileExist(cTmp.Get()))
							{
								char pDestinationFile[10240];
								strcpy(pDestinationFile, sDestination.c_str());
								GG_GetRealPath(pDestinationFile, 1);
								extern char szWriteDir[MAX_PATH];
								if (!pestrcasestr(pDestinationFile, szWriteDir))
								{
									// this is not the DocWrite folder ?
								}
								else
								{
									// copy chosen cube map to the new entity texture _cube.dds 
									bool bret = CopyFileA(cTmp.Get(), &pDestinationFile[0], false);

									// reload new textures
									cCurrentBackDrop = "None";
									t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
									CreateBackdropObject(true, "None", t.addentityfile_s);
								}
							}
						}

						if (ImGui::StyleCollapsingHeader("Attributes", ImGuiTreeNodeFlags_DefaultOpen))
						{
							ImGui::Indent(10);
							{
								ImGui::Text("Triangles: %d", iGetTriangles);
								ImGui::Text("Vertices: %d", iGetVertex);
								ImGui::Text("LODs: %d", iGetLodLevels + 1);
								ImGui::Text("%s", cGetTextureSize.Get());
							}
							ImGui::Indent(-10);
						}

						sObject* pObject = g_ObjectList[BackBufferObjectID];
						if (pObject)
						{
							if (ImGui::StyleCollapsingHeader("Textures", ImGuiTreeNodeFlags_DefaultOpen))
							{
								ImGui::Indent(10);
								{
									Wicked_Copy_Material_To_Grideleprof((void*)pObject, 0);
									t.grideleprof.WEMaterial.MaterialActive = true;
									Wicked_Change_Object_Material((void*)pObject, 5);
								}
								ImGui::Indent(-10);
							}
						}
					}
				}

				// Update/Add To Library Button
				cstr sButLabel = "Update Thumbnail";
				if (sGotoPreviewWithFile != "")
				{
					sButLabel = "Add to Object Library";
				}
				sButLabel += "##ObjectLibPreview";
				static int iUpdateFPESettings = 0;
				if (ImGui::StyleButton(sButLabel.Get(), ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					iUpdateFPESettings = 1;
				}

				if (iUpdateFPESettings > 0)
				{
					if (iUpdateFPESettings == 1)
					{
						iUpdateFPESettings++;
					}
					if (iUpdateFPESettings == 2)
					{
						iUpdateFPESettings++;
					}
					if (iUpdateFPESettings == 3)
					{
						//Update the actual FPE file.
						iUpdateFPESettings = 0;
						if (BackBufferIsGroup == true)
						{
							t.addentityfile_s = g_LastGroupSaved_s;
						}
						else
						{
							t.addentityfile_s = t.entitybank_s[BackBufferEntityID];
						}

						CreateBackBufferCacheNameEx(t.addentityfile_s.Get(), thumb_x, thumb_y, true);
						bool bGetOut = false;

						// delete old thumb image and give chance for new one to be saved (g_bThumbBankCopyMode)
						GG_SetWritablesToRoot(true);
						if (FileExist(BackBufferCacheName.Get()))
						{
							DeleteAFile(BackBufferCacheName.Get());
							g_bThumbBankCopyMode = false;
						}
						GG_SetWritablesToRoot(false);

						cFolderItem *pDontRefreshFolder = NULL;
						cFolderItem::sFolderFiles * updatefiles = NULL;
						cFolderItem *pNewFolder = &MainEntityList;
						if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
						if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
						while (pNewFolder)
						{
							if (pNewFolder->m_pFirstFile)
							{
								cFolderItem::sFolderFiles * myfiles = NULL;
								myfiles = pNewFolder->m_pFirstFile->m_pNext;
								while (myfiles)
								{
									//if (myfiles->iPreview > 0)
									//{
									cstr check = myfiles->m_sPath + cstr("\\") + myfiles->m_sName;
									//if (myfiles->m_sPath == t.addentityfile_s)
									if (pestrcasestr(check.Get(), t.addentityfile_s.Get()))
									{
										if (myfiles->iPreview > 0 && GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
											iDeleteInNextUpdate = myfiles->iPreview;
										}
										myfiles->iPreview = 0;
										myfiles->iBigPreview = 0;
										myfiles->m_Backdrop = cCurrentBackDrop;
										t.entityprofile[BackBufferEntityID].thumbnailbackdrop = cCurrentBackDrop;
										myfiles->m_sFPEKeywords = t.entityprofile[BackBufferEntityID].keywords_s;
										updatefiles = myfiles;
										bGetOut = true;
									}
									//}
									if (bGetOut) break;
									myfiles = myfiles->m_pNext;
								}
							}
							if (bGetOut) {
								pDontRefreshFolder = pNewFolder;
								break;
							}
							pNewFolder = pNewFolder->m_pNext;
						}

						//Update FPE file.
						std::vector<std::string> fpe_file;
						cstr c_fpefile = cstr("entitybank\\") + t.addentityfile_s;
						getVectorFileContent(c_fpefile.Get(), fpe_file, true);
						if (fpe_file.size() > 0)
						{
							RemoveStrStrFromVectorFile("thumbnailbackdrop=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailzoom=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailcamleft=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailcamup=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailrotatex=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailrotatey=", fpe_file, true);
							RemoveStrStrFromVectorFile("thumbnailanimset=", fpe_file, true);
							RemoveStrStrFromVectorFile("keywords=", fpe_file, true);
							RemoveStrStrFromVectorFile(";thumbnail", fpe_file, true);

							std::string add = ";thumbnail";
							fpe_file.push_back(add);
							add = std::string("thumbnailbackdrop = ") + std::string(cCurrentBackDrop.Get());
							fpe_file.push_back(add);
							add = std::string("thumbnailzoom = ") + std::to_string(BackBufferZoom);
							fpe_file.push_back(add);
							add = std::string("thumbnailcamleft = ") + std::to_string(BackBufferCamLeft);
							fpe_file.push_back(add);
							add = std::string("thumbnailcamup = ") + std::to_string(BackBufferCamUp);
							fpe_file.push_back(add);
							add = std::string("thumbnailrotatex = ") + std::to_string(BackBufferRotateX);
							fpe_file.push_back(add);
							add = std::string("thumbnailrotatey = ") + std::to_string(BackBufferRotateY);
							fpe_file.push_back(add);

							if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
							{
								if (!bAnimationAll)
								{
									//We have animations.
									add = std::string("thumbnailanimset = ") + std::to_string(iAnimationSet);
									fpe_file.push_back(add);

								}
							}
							if (t.entityprofile[BackBufferEntityID].keywords_s.Len() > 0)
							{
								add = std::string("keywords = ") + t.entityprofile[BackBufferEntityID].keywords_s.Get();
								fpe_file.push_back(add);
							}

							saveVectorFileContent(c_fpefile.Get(), fpe_file);
						}

						if (sGotoPreviewWithFile != "")
						{
							bLargePreview = false;
							sGotoPreviewWithFile = "";
						}
						cCurrentBackDropImageFile = ""; //make sure to reload when doing new thumb.

						//Also update current loaded entityprofile.
						t.entityprofile[BackBufferEntityID].BackBufferZoom = BackBufferZoom;
						t.entityprofile[BackBufferEntityID].BackBufferCamLeft = BackBufferCamLeft;
						t.entityprofile[BackBufferEntityID].BackBufferCamUp = BackBufferCamUp;
						t.entityprofile[BackBufferEntityID].BackBufferRotateX = BackBufferRotateX;
						t.entityprofile[BackBufferEntityID].BackBufferRotateY = BackBufferRotateY;
						if (!bAnimationAll)
							t.entityprofile[BackBufferEntityID].iThumbnailAnimset = iAnimationSet;
						else
							t.entityprofile[BackBufferEntityID].iThumbnailAnimset = -1;

						if (pDontRefreshFolder)
						{
							cstr path = pDontRefreshFolder->m_sFolderFullPath.Lower();
							char *findpath = (char *)pestrcasestr(path.Get(), "entitybank\\");
							if (findpath) path = findpath;

							cFolderItem *pNewFolder = &MainEntityList;
							if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
							if (pNewFolder) pNewFolder = pNewFolder->m_pNext;
							while (pNewFolder)
							{
								cstr pathcheck = pNewFolder->m_sFolderFullPath.Lower();
								char *findpath = (char *)pestrcasestr(pathcheck.Get(), "entitybank\\");
								if (findpath) pathcheck = findpath;
								if (pathcheck == path)
								{
									//PE: as we save a new fpe in a new folder DocWrite, dont refresh folder. we already have the old fpe that are updated.
									struct stat sb;
									if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0)
									{
										if (sb.st_mtime != pNewFolder->m_tFolderModify)
										{
											pNewFolder->m_tFolderModify = sb.st_mtime;

											if (updatefiles && updatefiles->bFavorite)
											{
												//PE: This is the new folder, if old was fav., add to favorite in new folder.
												cstr file = pNewFolder->m_sFolderFullPath;
												file = file + "\\" + updatefiles->m_sName.Get();
												extern std::vector<std::string> files_favorite;
												files_favorite.push_back(file.Get());
												saveVectorFileContent("favoritelist.ini", files_favorite);
											}
										}
									}
								}
								pNewFolder = pNewFolder->m_pNext;
							}
						}

						bDisplayProjectMedia = false;
						bDisplayFavorite = false;
						bViewAllFolders = false;
						bViewShowcase = false;
						bUpdateSearchSorting = true;
						bUpdateSearchScrollbar = true;

						// after make preview thumb and updated FPE, once again refresh to latest entity 
						g_iCheckExistingFilesModifiedDelayed = 50;
					}
				}
				char* tooltip = "Finish Setting the Object Library Preview";
				if (ImGui::IsItemHovered()) ImGui::SetTooltip(tooltip);

				// Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
				{
					ImGui::Text("");
					ImGui::Text("");
				}

				ImGui::EndChild();

				//When popup open , make sure we update the backbuffer all the time.
				bLoopBackBuffer = true;
				WickedCall_EnableThumbLight(true);
				ImGui::Columns(1);

				/* this is not fully possible, the object has already been created by this point - may improve in the future
				// Load the importer back up with the last imported model
				extern sImportedObjectData g_Data;
				char previewName[MAX_PATH] = { 0 };
				if (pPreviewFile)
				{
					strcpy(previewName, pPreviewFile->m_sNameFinal.Get());
				}
				if(strcmp(g_Data.cName, previewName) == 0)
				{
					ImGui::SetCursorPos(ImVec2(5, 1));
					int icon_size = ImGui::GetFontSize() * 1.75;
					ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
					ImVec2 cursor = ImGui::GetCursorPos();

					if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(1.0f, 1.0f, 1.0f, 0.5f),
						ImVec4(0.5f, 0.5f, 0.5f, 0.5f), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bExternal_Entities_Window = false;
						bLargePreview = false;
						sGotoPreviewWithFile = "";
						bImporter_Window = true;
						extern void importer_quit_for_reload(LPSTR pOptionalCopyModelFile);
						iLaunchAfterSync = 8;
						
						cstr file = cstr(g_Data.cImportPath) + t.tSourceName_s;
						strcpy(pLaunchAfterSyncPreSelectModel, file.Get());
						strcpy(pLaunchAfterSyncPreSelectModel, pLaunchAfterSyncLastImportedModel);
						importer_quit_for_reload(pLaunchAfterSyncPreSelectModel);
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Back to Importer");
				}
				*/

				//Render titlebar centered.
				cstr title = " Object Library Preview";
				if (pPreviewFile)
				{
					title = pPreviewFile->m_sNameFinal + title;
				}
				if (bIsCCPObject)
					title = "Choose your character's library thumbnail";

				float fTextSize = ImGui::CalcTextSize(title.Get()).x;
				float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
				ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
				ImGuiWindow* window = ImGui::GetCurrentWindow();

				ImGui::EndPopup();

				//Render title bar after End. end fill titlebar.
				ImGuiContext& g = *GImGui;
				window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());
			}

			if (!bLargePreview)
			{
				//Close down modal popup.
				BackBufferSaveCacheName = "";
				BackBufferObjectID = 0;
				BackBufferImageID = 0;
				bLoopBackBuffer = false;
				RevertBackbufferCubemap();
				WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
				master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
				WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y + 5000, GGORIGIN_Z, "editorProbe", 500);
				//WickedCall_EnableCameraLight(bEditorLight);
				WickedCall_EnableThumbLight(false);
				if (pPreviewFile)
					pPreviewFile->iPreview = 0;

				bImagesStillInImGuiQueue = true;
			}

		}
		else
		{
			bPopModalOpenEntity = false;
		}

		//############################
		//#### END Large preview. ####
		//############################

		//MIN 600 width
		static float fLastContentWidth = 0;
		static ImVec2 vLastWindowSize = ImVec2(0, 0);
		if (refresh_gui_docking != 0 && !bResetObjectLibrarySize)
		{
			if (fLastContentWidth > 0 && fLastContentWidth < 600.0f && vLastWindowSize.y > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(600.0f, vLastWindowSize.y), ImGuiCond_Always); //full screen.
			}
		}

		//PE: Moved here , so modal window above dont rely on this window for center position.
		if (refresh_gui_docking != 0 && !bResetObjectLibrarySize)
		{
			imgui_AddMinMaxButton(0, true); //check min max state.

			if (imgui_GetMinMaxButtonState(0))
			{
				//Fullscreen
				ex_window_flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
			}

			static int lastminstate = -1;
			if (lastminstate != imgui_GetMinMaxButtonState(0))
			{
				init_Left_Categories_Column_Width = 3;
				lastminstate = imgui_GetMinMaxButtonState(0);
			}
		}

		static cFolderItem::sFolderFiles * playingiles = NULL;
		static cFolderItem::sFolderFiles * selectedmediafile = NULL;

		if (pref.iDisableObjectLibraryViewport)
		{
			ImGuiViewport* viewport = ImGui::GetMainViewport();
			ImGui::SetNextWindowViewport(viewport->ID);
		}

		ImGui::Begin("##Object Library ExternalWindow", &bExternal_Entities_Window, ex_window_flags | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);

		static float fScaleIcons = 1.0;

		//PE: If user exit in fullscreen (it get saved) make sure to restore to default size.
		static bool bCheckFullScreenOnStartup = true;
		bResetObjectLibrarySize = false;

		if (bCheckFullScreenOnStartup)
		{
			if (imgui_CheckMinMaxStartupState(0))
			{
				//PE: Was set fullscreen, adjust columns width
				init_Left_Categories_Column_Width = 3;
			}
			bCheckFullScreenOnStartup = false;
		}

		vLastWindowSize = ImGui::GetWindowSize();

		float cwidth = ImGui::GetContentRegionAvailWidth();
		fLastContentWidth = cwidth;

		static bool bAddNewSelectionToGame = false;
		static int iAddSelectionStep = 0;
		bool bIsWeDocked = ImGui::IsWindowDocked();
		static int current_tab = -1;

		int i = 0;

		static char cAllFilters[10][MAX_PATH];
		char cHeader[MAX_PATH];

		int control_wrap_width = 90;
		strcpy(cHeader, "");

		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX()-2.0f, ImGui::GetCursorPosY() + 6.0));
		ImGui::Text(""); //"Filter: ");
		ImGui::SameLine();

		ID3D11ShaderResourceView* lpTexture = NULL;

		bool rb_change = false;
		static bool bDLUAOnly = true;

		strcpy(cAllFilters[0], "HUD Assets");
		strcpy(cAllFilters[1], "Character");
		strcpy(cAllFilters[2], "Objects");
		strcpy(cAllFilters[3], "Weapons");
		strcpy(cAllFilters[4], "User");
		if (iDisplayLibraryType == 1) strcpy(cAllFilters[0], "OGG"); //Not active
		if (iDisplayLibraryType == 2) strcpy(cAllFilters[0], "DDS"); //Not active
		if (iDisplayLibraryType == 3) strcpy(cAllFilters[0], "MP4"); //Not active
		if (iDisplayLibraryType == 4) strcpy(cAllFilters[0], "LUA"); //Not active
		if (iDisplayLibraryType == 5) strcpy(cAllFilters[0], "ARX"); //Not active

		int sortby_combo_width = 130;
		bool bLastEntityGotFocus = bEntityGotFocus;
		if (1) //Searchbar
		{
			ImGui::SameLine();

			if (ImGui::GetCursorPosX() + control_wrap_width > ImGui::GetWindowSize().x)
			{
				ImGui::Text(""); //NewLine
			}

			float fXWidth = ImGui::GetFontSize()*1.5;

			fXWidth += sortby_combo_width;

			ImGui::PushItemWidth(-10 - fXWidth);

			if (g_iDevToolsOpen != 0)
			{
				//ImGui::SameLine();
				ImGui::PushItemWidth(30);
				if (ImGui::StyleButton("Refresh##+", ImVec2(0, 0)))
				{
					// developer mode rescans every time ADD is pressed
					extern int g_iRefreshLibraryFolders;
					g_iRefreshLibraryFolders = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click to refresh all library folders (developer tools mode)");
				ImGui::PopItemWidth();
				ImGui::SameLine();
			}
			ImGui::Text(" ");

			ImGui::SameLine();

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() - 8.0, ImGui::GetCursorPosY()));
			
			bEntityGotFocus = false;
			ImGuiStyle& style = ImGui::GetStyle();
			float fOldSpacing = style.FramePadding.x;
			style.FramePadding.x = 22.0; //Make room for search icon.
			ImVec2 vSearchPos = ImGui::GetCursorPos();
			static cstr sOldSearch = &cSearchAllEntities[i][0];
			static std::string phonetic_find = "";

			// Force the keyboard focus to the input text field when the user presses the close button (below).
			static bool bStealKeyboardFocus = false;
			if (bStealKeyboardFocus)
			{
				ImGui::SetKeyboardFocusHere(0);
				bStealKeyboardFocus = false;
			}

			if (ImGui::InputText("##cSearchAllEntities", &cSearchAllEntities[i][0], MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
			{
				bUpdateSearchSorting = true;
				phonetic_find = soundexall(cSearchAllEntities[i]);

				if (strlen(cSearchAllEntities[i]) > 1)
				{
					bool already_there = false;
					for (int l = 0; l < MAXSEARCHHISTORY; l++)
					{
						if (strcmp(cSearchAllEntities[i], pref.search_history[l]) == 0)
						{
							already_there = true;
							break;
						}
					}
					if (!already_there)
					{
						bool foundspot = false;
						for (int l = 0; l < MAXSEARCHHISTORY; l++)
						{
							if (strlen(pref.search_history[l]) <= 0)
							{
								strcpy(pref.search_history[l], cSearchAllEntities[i]);
								foundspot = true;
								break;
							}
						}
						if (!foundspot)
						{
							//Move entry list.
							for (int l = 0; l < MAXSEARCHHISTORY; l++)
							{
								strcpy(pref.search_history[l], pref.search_history[l + 1]);
							}
							strcpy(pref.search_history[MAXSEARCHHISTORY - 1], cSearchAllEntities[i]);
						}
					}
				}
			}
			if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Type here to search for an object in your library");

			cstr sNewSearch = &cSearchAllEntities[i][0];
			if (sOldSearch != sNewSearch)
			{
				sOldSearch = sNewSearch;
				phonetic_find = soundexall(cSearchAllEntities[i]);
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
			}
			style.FramePadding.x = fOldSpacing;
			lpTexture = GetImagePointerView(TOOL_ENT_SEARCH);
			if (lpTexture)
			{
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImVec2 search_icon_pos = ImGui::GetWindowPos() + vSearchPos + ImVec2(3.0, 3.0);
				window->DrawList->AddImage((ImTextureID)lpTexture, search_icon_pos, search_icon_pos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
			}
			ImGui::SameLine();
			ImGui::SetItemAllowOverlap();
			if (ImGui::CloseButton(ImGui::GetCurrentWindow()->GetID("#ClearSearch"), ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(-30, 0)))
			{
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
				strcpy(cSearchAllEntities[i], "");
				bStealKeyboardFocus = true;
			}
			if (ImGui::IsItemHovered())
			{
				//mouse
				ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
				ImGui::SetTooltip("Clear search");
			}
			ImGui::PopItemWidth();
		}
					
		if (1) //Combo dropdowns. Use folder names as seach.
		{
			ImGui::SameLine();
			static char * current_combo_entry = "\0";
			int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;

			ImGui::PushItemWidth(-sortby_combo_width - 14); //- 24

			if (ImGui::BeginCombo("##combolastsearch", current_combo_entry, comboflags))
			{
				//Do we have a search history.
				bool display_history = false;
				for (int l = 0; l < MAXSEARCHHISTORY; l++) 
				{
					if (strlen(pref.search_history[l]) > 0) 
					{
						display_history = true;
						break;
					}
				}
				if (display_history) {
					ImGui::Text("Search History:");
					ImGui::Indent(10);
					for (int l = 0; l < MAXSEARCHHISTORY; l++) 
					{
						if (strlen(pref.search_history[l]) > 0) 
						{
							bool is_selected = (current_combo_entry == pref.search_history[l]);
							cstr sSelName = pref.search_history[l];
							sSelName = sSelName + "##Hist";
							if (ImGui::Selectable(sSelName.Get(), is_selected)) 
							{
								bUpdateSearchSorting = true;
								bUpdateSearchScrollbar = true;
								current_combo_entry = (char *)pref.search_history[l];
								strcpy(cSearchAllEntities[i], pref.search_history[l]);
							}
							if (is_selected)
								ImGui::SetItemDefaultFocus();
						}
					}
					ImGui::Indent(-10);
				}
				ImGui::EndCombo();
			}
			ImGui::PopItemWidth();

			ImGui::SameLine();

			ImGui::PushItemWidth(-6);

			const char* sortby_modes[] = { "Category Order", "Name A-Z", "Name Z-A", "Created Old-New", "Created New-Old", "Number of Polygons Low-", "Number of Polygons High-" };
			int iComboItems = IM_ARRAYSIZE(sortby_modes);
			if (iDisplayLibraryType == 0)
			{
				iComboItems -= 2;
			}
			else
			{
				iComboItems -= 2;
			}

			if (ImGui::Combo("##combostaticIssuesFilter", &current_sortby, sortby_modes, iComboItems))
			{
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
				// set sortby mode = current_sortby
				// 0 = showcase
				// 1 = no sorting, category order and files A-Z inside each category. 0
				// 2 = A-Z 1
				// 3 = Z-A 2
				// 4 = Date Old-New 5
				// 5 = Date New-Old 6
				// 6 = Poly low 7
				// 7 = Poly high 8
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Sorting");
			ImGui::PopItemWidth();

			ImGui::Separator();
		}

		static int total_files_displayed_in_library = 0;
		if (1) //Display what is searched for.
		{

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 10.0, ImGui::GetCursorPosY() + 3));

			cstr cViewing = "";
			bool bSearchAll = false;
			if (strlen(cSearchAllEntities[i]) > 0)
			{
				if (iDisplayLibraryType == 0)
				{
					if(iDisplayLibrarySubType==1)
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Animations from \"All\" categories using search term \"") + cstr(cSearchAllEntities[i]) + cstr("\"");
					else
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from \"All\" categories using search term \"") + cstr(cSearchAllEntities[i]) + cstr("\"");
				}
				else
				{
					cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Items from \"All\" categories using search term \"") + cstr(cSearchAllEntities[i]) + cstr("\"");
				}
				bSearchAll = true;
			}
			if (bDisplayFavorite)
			{
				cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from \"Favourite\" using \"All\" categories");
				bSearchAll = true;
			}

			if (!bSearchAll)
			{
				cViewing = "Viewing ";
				if (iDisplayLibraryType == 0)
				{
					if (iDisplayLibrarySubType == 1)
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Animations from ");
					else
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from ");
				}
				else
				{
					cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Items from ");
				}

				int iCategories = 0;
				if (iDisplayLibraryType == 2 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 1 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 3 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 4 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (iDisplayLibraryType == 5 && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else if (bCheckboxFilters[0] && bCheckboxFilters[1] && bCheckboxFilters[2] && bCheckboxFilters[3] && bCheckboxFilters[4])
				{
					cViewing = cViewing + cstr("\"All\" Categories");
				}
				else
				{
					if (bCheckboxFilters[1])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("Characters");
					}
					if (bCheckboxFilters[2])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("Scenery");
					}
					if (bCheckboxFilters[3])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("Elements");
					}

					if (iDisplayLibraryType == 0 && bCheckboxFilters[0])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("HUD Assets");
					}
					if (iDisplayLibraryType == 1 && bCheckboxFilters[0])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("OGG");
					}

					if (bCheckboxFilters[4])
					{
						if (iCategories == 0)
							cViewing = cViewing + cstr("\"");
						if (iCategories++ > 0)
							cViewing = cViewing + cstr(", ");
						cViewing = cViewing + cstr("User Generated");
					}

					if (iCategories == 0)
						cViewing = "";
					else if (iCategories == 1)
					{
						cViewing = cViewing + cstr("\" Category");
					}
					else if (iCategories > 1)
					{
						cViewing = cViewing + cstr("\" Categories");
					}
				}
			}
			if (cViewing == "" && current_sortby == 1 && total_files_displayed_in_library > 0 )
			{
				if (iDisplayLibraryType == 0)
				{
					if (iDisplayLibrarySubType == 1)
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Animations from \"Showcase\"");
					else
						cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Objects from \"Showcase\"");
				}
				else
				{
					cViewing = cstr("Viewing ") + cstr(Str(total_files_displayed_in_library)) + cstr(" Items from \"Showcase\"");
				}
			}
			//order
			if (cViewing != "")
			{
				if (current_sortby == 1)
					cViewing = cViewing + " in A-Z order";
				else if (current_sortby == 0)
					cViewing = cViewing + " in category order";
				else if (current_sortby == 2)
					cViewing = cViewing + " in Z-A order";
				else if (current_sortby == 3)
					cViewing = cViewing + " in Old-New order";
				else if (current_sortby == 4)
					cViewing = cViewing + " in New-Old order";
			}
			ImGui::SetWindowFontScale(1.25);
			ImGui::TextCenter(cViewing.Get());
			ImGui::SetWindowFontScale(1.0);

			//----------------
			ImGui::Separator();
		}
		total_files_displayed_in_library = 0;

		//PE: Generate folder view.
		static int updates = 0;
		static bool bTreeViewInit = false;
		if (!bTreeViewInit || bTreeViewInitInNextFrame )
		{
			bTreeViewInitInNextFrame = false;
			//UNPIN
			extern std::vector<std::string> files_pinned_categories;
			files_pinned_categories.clear();
			getVectorFileContent("pinnedlist.ini", files_pinned_categories);

			static folder_info * mem_list[5000];
			static int mem_list_count = 0;

			cFolderItem *pNewFolder = &MainEntityList;
			pNewFolder = pNewFolder->m_pNext;

			//Free old structures.
			for (int i = 0; i < mem_list_count; i++)
			{
				if (mem_list[i])
				{
					delete mem_list[i];
					mem_list[i] = 0;
				}
			}
			mem_list_count = 0;
			root_folders.clear();
			updates++;

			if (pNewFolder)
			{
				cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
				int ipath_remove_len = path_remove.Len();
				int count = 0;
				while (pNewFolder)
				{

					cStr path = pNewFolder->m_sFolderFullPath.Get();
					int itype = pNewFolder->iType;
					bool bDoubleEntityBank = false;
					cstr DoubleSearchName = "\\entitybank";
					if (itype == 1)
						DoubleSearchName = "\\audiobank";
					if (itype == 2)
						DoubleSearchName = "\\imagebank";
					if (itype == 3)
						DoubleSearchName = "\\videobank";
					if (itype == 4)
						DoubleSearchName = "\\scriptbank";
					if (itype == 5)
						DoubleSearchName = "\\particlesbank";
					if (itype == 6)
						DoubleSearchName = "\\charactercreatorplus\\animations";
					int DoubleSearchNameLen = DoubleSearchName.Len();

					char *finde = (char *)pestrcasestr(path.Get(), DoubleSearchName.Get()); //Support entitybank inside entitybank.
					if (finde)
					{
						finde += DoubleSearchNameLen;
						finde = (char *)pestrcasestr(finde, DoubleSearchName.Get());
						if (finde) bDoubleEntityBank = true;
					}

					if (!bDoubleEntityBank && path.Right(DoubleSearchNameLen) == DoubleSearchName)
					{
						ipath_remove_len = path.Len();
					}
					else
					{
						//char *final_name = path.Get();
						char *final_name = (char *)pestrcasestr(path.Get(), DoubleSearchName.Get()); //Support entitybank inside entitybank.

						//final_name += ipath_remove_len;
						final_name += DoubleSearchNameLen;
						if (*final_name == '\\')
							final_name++;

						bool bVisible = true;
						std::string dir_name = final_name;
						replaceAll(dir_name, "/", "\\");
						replaceAll(dir_name, ";", ""); //We will use ; for tokens later.
						int level = std::count(dir_name.begin(), dir_name.end(), '\\');
						replaceAll(dir_name, "\\", " - ");

						//PE: Hide showcase.
						if (!pestrcasestr(dir_name.c_str(), " - "))
						{
							if (pestrcasestr(dir_name.c_str(), "showcase"))
								bVisible = false;

							if (pestrcasestr(dir_name.c_str(), "_markers"))
								dir_name = "Game Elements";
						}

						if (dir_name.length() == 0)
							__debugbreak();

						int is = root_folders.size();
						if (mem_list_count < 5000 && dir_name.length() < 256 && dir_name.length() > 0 )
						{
							folder_info *fi = new folder_info;
							if (fi)
							{
								mem_list[mem_list_count++] = fi;
								fi->level = level;
								fi->type = pNewFolder->iType;
								strcpy(fi->real_name, dir_name.c_str());
								strcpy(fi->show_name, dir_name.c_str());
								
								fi->show_name[0] = toupper(fi->show_name[0]);
								fi->id = ++count;// count++;
								fi->parentid = 0;
								fi->folders = 0;
								fi->pFolder = pNewFolder;
								fi->bPinned = false;
								fi->bUsed = false;
								std::transform(dir_name.begin(), dir_name.end(), dir_name.begin(), [](unsigned char c) { return tolower(c); });
								char tmp[2];
								tmp[0] = fi->type + '0';
								tmp[1] = 0;
								std::string realname = fi->real_name;
								realname = realname + tmp;
								for (std::vector<std::string>::iterator itf = files_pinned_categories.begin(); itf != files_pinned_categories.end(); ++itf)
								{
									if (itf->size() > 0)
									{
										if (strcmp(itf->c_str(), realname.c_str() ) == 0)
										{
											fi->bPinned = true;
											//Place it at the top.
											dir_name = "!" + dir_name;
											break;
										}
									}
								}

								dir_name = dir_name + tmp; //Only uniq for each folder type.
								replaceAll(dir_name, " - ", ";"); //Make it more easy to parse later.
								root_folders.insert(std::make_pair(dir_name, fi));
								if (is == root_folders.size())
									bVisible = false;
								if (!bVisible)
								{
									//
								}
							}
						}
					}
					pNewFolder = pNewFolder->m_pNext;
				}
			}

			//PE: Find all parentID's
			for (auto it = root_folders.begin(); it != root_folders.end(); ++it) {
				std::string folder = it->first;
				if (it->second->bPinned)
				{
					//Remove '!' infront.
					folder = folder.substr(1);
				}
				if (it->second->level > 0)
				{
					int itype = it->second->type;
					folder = folder.substr(0, folder.length() - 1);
					char * pch;
					char cTmp[512];
					strcpy(cTmp, folder.c_str());
					pch = strtok(cTmp, ";");
					int current_level = 1;
					std::string parent = cTmp;
					std::string search = parent;
					while (pch != NULL)
					{
						pch = strtok(NULL, ";"); //Here as we skip the first.

						if (pch)
						{
							char tmp[2];
							tmp[0] = itype + '0';
							tmp[1] = 0;
							std::string tmpsearch = search + tmp; //Only uniq for each folder type.

							//Find token in level-1.
							for (auto it2 = root_folders.begin(); it2 != root_folders.end(); ++it2)
							{
								if (it2->second->level == current_level - 1)
								{
									if (it2->second->type == itype)
									{
										std::string check = it2->first;
										if (it2->second->bPinned)
										{
											check = check.substr(1);
										}

										if (tmpsearch == check)
										{
											it->second->parentid = it2->second->id;
											it2->second->folders++;

											strcpy(it->second->show_name, pch);
											it->second->show_name[0] = toupper(it->second->show_name[0]);
										}
									}
								}
							}
						}

						search = search + ';';
						if (pch)
							search = search + pch;

						current_level++;
					}
				}
			}
			bTreeViewInit = true;
		}

		///ImGui::Columns(2);
		ImGui::BeginColumns("##myleftcategoripanel",2, ImGuiColumnsFlags_None);
		if (init_Left_Categories_Column_Width > 0)
		{
			//PE: Must match 230 for defaults to match the exact icons on screen.
			//PE: Perhaps add the percent adjustment later.
			//float fWinX = ImGui::GetWindowSize().x;
			//float fRatio = 0.2323232323232323;
			//float fNewColW = floor(fWinX * fRatio);
			//ImGui::SetColumnWidth(0, fNewColW);
			ImGui::SetColumnWidth(0, 230.0f);
			init_Left_Categories_Column_Width--;
		}
		ImVec2 vWindowSize = ImGui::GetContentRegionAvail();


		//Display view all and favorites.
		if (seleted_tree_item >= 0)
		{
			bViewAllFolders = false;
			bDisplayFavorite = false;
			bDisplayProjectMedia = false;
		}
		if (bViewAllFolders)
		{
			bDisplayFavorite = false;
			bDisplayProjectMedia = false;
		}

		if (ImGui::Selectable("View All", bViewAllFolders) || bSelectLibraryViewAll )
		{
			bSelectLibraryViewAll = false;
			seleted_tree_item = -1;
			strcpy(cSearchAllEntities[0], "");
			//Enable all filters.
			bCheckboxFilters[0] = true;
			bCheckboxFilters[1] = true;
			bCheckboxFilters[2] = true;
			bCheckboxFilters[3] = true;
			bCheckboxFilters[4] = true;
			bDisplayProjectMedia = false;
			bDisplayFavorite = false;
			bViewShowcase = false;
			bViewPurchased = false;
			bViewAllFolders = true;
			bUpdateSearchSorting = true;
			bUpdateSearchScrollbar = true;
		}

		// only show SHOWCASE and PURCHASED as relating to objects (for now)
		if (iDisplayLibraryType == 0)
		{
			if (iDisplayLibrarySubType == 1)
			{
				// no showcase or purchased for animations for now
			}
			else
			{
				if (stricmp(cSearchAllEntities[0], "Purchased") != 0) bViewPurchased = false;
				if (ImGui::Selectable("Purchased", &bViewPurchased, 0))
				{
					// force library to purchased view, and refresh too
					process_gotopurchaedandrefreshtopurchases();
				}
			}
		}
		else
		{
			// behavior has purchased option (from asset store)
			if (iDisplayLibraryType == 4)
			{
				if (stricmp(cSearchAllEntities[0], "Purchased") != 0) bViewPurchased = false;
				if (ImGui::Selectable("Purchased", &bViewPurchased, 0))
				{
					// force library to purchased view, and refresh too
					process_gotopurchaedandrefreshtopurchases();
				}
			}
		}

		// only show project media if in a remote project now
		extern StoryboardStruct Storyboard;
		if ( strlen(Storyboard.customprojectfolder) > 0 )
		{
			bool bProjectMediaSelected = strstr(cSearchAllEntities[0], "project");
			#ifdef NEWPROJSYSWORKINPROGRESS
			if (ImGui::Selectable("Current Project##projectmedia", &bProjectMediaSelected, 0))
			#else
			if (ImGui::Selectable("Project Media##projectmedia", &bProjectMediaSelected, 0))
			#endif
			{
				seleted_tree_item = -1;
				strcpy(cSearchAllEntities[0], "");
				bDisplayProjectMedia = true;
				bDisplayFavorite = false;
				bViewAllFolders = false;
				bViewShowcase = false;
				bUpdateSearchSorting = true;
				bUpdateSearchScrollbar = true;
			}
		}

		if (ImGui::Selectable("Favorites##favourites", &bDisplayFavorite, 0))
		{
			seleted_tree_item = -1;
			strcpy(cSearchAllEntities[0], "");
			bDisplayProjectMedia = false;
			bDisplayFavorite = true;
			bViewAllFolders = false;
			bViewShowcase = false;
			bUpdateSearchSorting = true;
			bUpdateSearchScrollbar = true;
		}

		ImGui::BeginChild("##LeftPanelCategories", ImVec2(0, vWindowSize.y - 67.0f), false, iGenralWindowsFlags);

		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1)
		{
			// animations
			DoTreeNode(0, "Noncharacter", "Purchased", sTriggerCategorySelect.Get());
		}
		else
		{
			if (iDisplayLibraryType == 4)
			{
				// behaviors
				DoTreeNode(0, "AllNoneBehaviorFolders", "Community", sTriggerCategorySelect.Get());
			}
			else
			{
				// the rest
				DoTreeNode(0, "Community", "Purchased", sTriggerCategorySelect.Get());
			}
		}
		sTriggerCategorySelect = "";

		// list community folder contents separately
		DoTreeNode(0, "", "", "", "Community");

		ImGui::EndChild();
		ImGui::NextColumn();

		//PE: Begin child window.
		ImVec2 vWinSize = ImGui::GetContentRegionAvail();
		ImGui::BeginChild("##cSearchAllEntitiesBegin", ImVec2(0, vWinSize.y - 84.0f), false, iGenralWindowsFlags); //- 68.0f

		ImVec2 oldCursor = ImGui::GetCursorPos();

		int iIconVisiblePosY = ImGui::GetWindowSize().y + ImGui::GetScrollY() + media_icon_size;

		bool bFirstShiftHasBeenSeen = false;
		bool bAnySelectedItemsAvailable = false;
		static cFolderItem::sFolderFiles * firstShiftFile = NULL;
		static cFolderItem::sFolderFiles * lastShiftFile = NULL;
		static bool bInContextThumb;
		bInContextThumb = false;

		if (1)
		{
			static std::vector< std::pair<std::string, cFolderItem::sFolderFiles *>> sorted_files;
			if (sorted_files.size() == 0)
				bUpdateSearchSorting = true;

			cFolderItem *pNewFolder = &MainEntityList;

			static std::vector<cFolderItem *> all_folders;
			//Check if we got new files.
			if (all_folders.size() > 0)
			{
				for (int l = 0; l < all_folders.size(); l++)
				{
					pNewFolder = all_folders[l];
					if (pNewFolder)
					{
						//PE: Check here if we need to reload the folder, for new files.
						if (pNewFolder->m_fLastTimeUpdate < Timer())
						{
							pNewFolder->m_fLastTimeUpdate = Timer() + 4000; //Check every 4-6 sec.
							pNewFolder->m_fLastTimeUpdate += rand() % 2000; //Make sure we dont check folders in same cycle.
							struct stat sb;
							if (PathExist(pNewFolder->m_sFolderFullPath.Get()))
							{
								if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0)
								{
									if (sb.st_mtime != pNewFolder->m_tFolderModify)
									{
										pNewFolder->m_tFolderModify = sb.st_mtime;
										RefreshEntityFolder(pNewFolder->m_sFolderFullPath.Get(), pNewFolder);
										bUpdateSearchSorting = true;
									}
								}
							}
						}

					}
				}
			}


			bool bDoBackbufferUpdate = false;

			//####################################################
			//#### Check if we need to update search results. ####
			//####################################################

			pNewFolder = &MainEntityList;
			pNewFolder = pNewFolder->m_pNext;
			if ((bCheckGotoPreview || bUpdateSearchSorting || bUpdateSearchSortingNextFrame) && pNewFolder)
			{
				sorted_files.clear();
				pNewFolder = pNewFolder->m_pNext;

				cStr path_remove = pNewFolder->m_sFolderFullPath.Get();
				int ipath_remove_len = path_remove.Len();

				if (iDisplayLibraryType == 0) //Object only remember last search.
				{
					if (strlen(cSearchAllEntities[i]) < 256)
					{
						strcpy(pref.cRememberLastSearchObjects, cSearchAllEntities[0]);
					}
					for (int i = 0; i < 5; i++)
						pref.iCheckboxFilters[i] = bCheckboxFilters[i];

					//bCheckboxFilters[0] - 5 and 9=fav.
				}

				while (pNewFolder)
				{
					int iCompareType = iDisplayLibraryType;
					if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) iCompareType = 6;
					if (pNewFolder->iType == iCompareType)
					{
						//PE: Full path can now change in the middle of the list , so:
						cStr path = pNewFolder->m_sFolderFullPath.Get();

						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;


						bool isMarkers = false;
						bool bDisplayEverythingHere = false;
						bool bHideEverythingHere = false;
						bool bSentToTopOfList = false;
						if (i == 0 && strlen(cSearchAllEntities[i]) > 0)
						{
							//When search disable fixed tags search.
							bDisplayEverythingHere = false;
							bHideEverythingHere = false;
						}
						if (i == 1 && strlen(cSearchAllEntities[i]) > 0)
						{
							//When search disable fixed tags search.
							bDisplayEverythingHere = false;
							bHideEverythingHere = false;
						}

						//PE: Search only inside selected category did not work so good, if you type "box" you want all boxes.
						//PE: So here a searchterm overwrite the category checkbox selections.
						if (strlen(cSearchAllEntities[i]) == 0)
						{
							cstr cIgnoreFrom = "entitybank\\";
							if (iDisplayLibraryType == 1)
								cIgnoreFrom = "audiobank\\";
							if (iDisplayLibraryType == 2)
								cIgnoreFrom = "imagebank\\";
							if (iDisplayLibraryType == 3)
								cIgnoreFrom = "videobank\\";
							if (iDisplayLibraryType == 4)
								cIgnoreFrom = "scriptbank\\";
							if (iDisplayLibraryType == 5)
								cIgnoreFrom = "particlesbank\\";
							if (iDisplayLibraryType == 0 && iDisplayLibrarySubType==1)
								cIgnoreFrom = "charactercreatorplus\\animations\\";
							int iIgnoreLen = cIgnoreFrom.Len();

							char *find = (char *)pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cIgnoreFrom.Get());
							if (find) find += iIgnoreLen;
							else find = pNewFolder->m_sFolderFullPath.Get();

							if (find)
							{
								if (i == 0 && bCheckboxFilters[0]) //"showcase"
								{
									if (pestrcasestr(find, "hud assets"))
										bDisplayEverythingHere = true;
								}
								if (i == 0 && bCheckboxFilters[1]) //"Character"
								{
									if (pestrcasestr(find, "Character"))
										bDisplayEverythingHere = true;
									if (iDisplayLibraryType == 1)
									{
										if (pestrcasestr(find, "voices"))
											bDisplayEverythingHere = true;
									}
									if (iDisplayLibraryType == 4)
									{
										if (pestrcasestr(find, "people"))
										{
											if (!pestrcasestr(find, "people\\ai"))
												bDisplayEverythingHere = true;
										}
									}
								}
								if (i == 0 && bCheckboxFilters[2]) //"Scene"
								{
									if (pestrcasestr(find, "Objects"))
										bDisplayEverythingHere = true;
									if (pestrcasestr(find, "Weapons"))
										bDisplayEverythingHere = true;
									if (iDisplayLibraryType == 1)
									{
										//For now.
										if (pestrcasestr(find, "cellar"))
											bDisplayEverythingHere = true;
										if (pestrcasestr(find, "misc"))
											bDisplayEverythingHere = true;
									}
								}
								if (i == 0 && bCheckboxFilters[4]) //"User Generated"
								{
									if (pestrcasestr(find, "User"))
										bDisplayEverythingHere = true;
									if (iDisplayLibraryType == 1)
									{
										if (pestrcasestr(find, "recordings"))
											bDisplayEverythingHere = true;
									}
								}

								if (i == 0 && bCheckboxFilters[3]) //"elements"
								{
									bHideEverythingHere = false;
									if (!bDisplayEverythingHere)
									{
										bDisplayEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[0]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[1]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[2]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[3]))
											bHideEverythingHere = true;
										if (pestrcasestr(find, cAllFilters[4]))
											bHideEverythingHere = true;
										if (iDisplayLibraryType == 1)
										{
											if (pestrcasestr(find, "voices"))
												bHideEverythingHere = true;
											if (pestrcasestr(find, "recordings")) //"Scene"
												bHideEverythingHere = true;
											//For now.
											if (pestrcasestr(find, "cellar"))
												bHideEverythingHere = true;
											if (pestrcasestr(find, "misc"))
												bHideEverythingHere = true;
										}
									}
								}

								if (current_sortby == 1) //0 a-z now also showcase showcase
								{
									if (pestrcasestr(find, "showcase"))
									{
										bDisplayEverythingHere = true;
										bSentToTopOfList = true;
									}
								}
								else
								{
									if (!bDisplayFavorite)
									{
										if (pestrcasestr(find, "showcase"))
										{
											bHideEverythingHere = true;
										}
									}
								}
							}
						}

						if (bDisplayFavorite)
						{
							//Favorite display from all folders.
							bDisplayEverythingHere = true;
						}

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string dir_name = final_name;
						replaceAll(dir_name, "\\", " - ");

						bool bSearchGameElements = false;
						if (pestrcasestr(dir_name.c_str(), "_markers"))
							bSearchGameElements = true;

						// behavior view with search term
						if (iDisplayLibraryType == 4)
						{
							if (strlen(cSearchAllEntities[i]) > 0)
							{
								// if viewing purchased, always show them
								if (pestrcasestr("Purchased", cSearchAllEntities[i]))
								{
									bDisplayEverythingHere = true;
									if (strlen(dir_name.c_str()) == 0)										bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "ai", strlen("ai")) == NULL )			bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "animals", strlen("animals")) == NULL)	bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "effects", strlen("effects")) == NULL)	bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "gfx", strlen("gfx")) == NULL)			bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "horror", strlen("horror")) == NULL)		bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "images", strlen("images")) == NULL)		bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "markers", strlen("markers")) == NULL)	bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "objects", strlen("objects")) == NULL)	bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "people", strlen("people")) == NULL)		bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "puzzle", strlen("puzzle")) == NULL)		bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "rpg", strlen("rpg")) == NULL)			bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "user", strlen("user")) == NULL)			bDisplayEverythingHere = false;
									if (strnicmp(dir_name.c_str(), "weather", strlen("weather")) == NULL)	bDisplayEverythingHere = false;
								}
							}
						}

						if (!isMarkers && i == 0 && !bDisplayEverythingHere && !bHideEverythingHere && strlen(cSearchAllEntities[i]) > 0) 
						{
							if (iDisplayLibraryType > 0) //Other media types only search sub folder names.
							{
								if (pestrcasestr(dir_name.c_str(), cSearchAllEntities[i]))
									bDisplayEverythingHere = true;
							}
							else
							{
								if (pestrcasestr(pNewFolder->m_sFolderFullPath.Get(), cSearchAllEntities[i]))
									bDisplayEverythingHere = true;
								else if (pestrcasestr(dir_name.c_str(), cSearchAllEntities[i]))
									bDisplayEverythingHere = true;
							}
						}

						//PE: Check here if we need to reload the folder, for new files.
						if (pNewFolder->m_fLastTimeUpdate < Timer())
						{
							pNewFolder->m_fLastTimeUpdate = Timer() + 4000; //Check every 4-6 sec.
							pNewFolder->m_fLastTimeUpdate += rand() % 2000; //Make sure we dont check folders in same cycle.
							struct stat sb;
							if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
							{
								if (sb.st_mtime != pNewFolder->m_tFolderModify) 
								{
									pNewFolder->m_tFolderModify = sb.st_mtime;
									RefreshEntityFolder(pNewFolder->m_sFolderFullPath.Get(), pNewFolder);
								}
							}
						}

						if (pNewFolder->m_pFirstFile)
						{
							bool bDisplayText = true;

							cFolderItem::sFolderFiles * myfiles = NULL;

							myfiles = pNewFolder->m_pFirstFile->m_pNext;

							while (myfiles)
							{
								bool bIsVisible = true;
								bool bForceVisible = false;
								bool bIsPhonetic = false;
								int iPhoneticDistance = 999;
								if (i == 0 && isMarkers) bIsVisible = false;
								if (i == 1 && !isMarkers) bIsVisible = false;
								if (i == 0) bIsVisible = false; //Default to not visible.

								//PE: Clear any selection when updating list.
								myfiles->iFlags = 0;

								if (!bLargePreview && bCheckGotoPreview && sGotoPreviewWithFile != "")
								{
									cstr test = pNewFolder->m_sFolderFullPath + "\\" + myfiles->m_sName;
									if (pestrcasestr(test.Get(), sGotoPreviewWithFile.Get()))
									{
										sStartLibrarySearchString = "user";
										iLastDisplayLibraryType = -1;
										//Refresh with new search.
										//Load dbo and display large preview.
										pPreviewFile = myfiles;
										bLargePreview = true;
										bDoBackbufferUpdate = true;
										bIsVisible = true;
										bForceVisible = true;
									}
								}

								if (i == 0 && strlen(cSearchAllEntities[i]) > 0) {

									if (pestrcasestr(myfiles->m_sBetterSearch.Get(), cSearchAllEntities[i]))
										bIsVisible = true;
									if (!bIsVisible) // else current_sortby == 4)
									{
										if (bAdvancedFPEFeatures && myfiles->m_sFPEKeywords.Len() > 0)
										{
											if (pestrcasestr(myfiles->m_sFPEKeywords.Get(), cSearchAllEntities[i]))
												bIsVisible = true;
										}
									}

									if (!bIsVisible && bSearchGameElements)
									{
										if (pestrcasestr(cSearchAllEntities[i], "Game Elements"))
											bIsVisible = true;
									}

								}

								if (bDisplayEverythingHere)
									bIsVisible = true;
								if (bHideEverythingHere)
									bIsVisible = false;

								if (bDisplayFavorite && !myfiles->bFavorite)
								{
									bIsVisible = false;
								}

								if (bDisplayProjectMedia == true)
								{
									// if not in project folder, hide
									char pFindProjectEntityFolder[MAX_PATH];
									extern StoryboardStruct Storyboard;
									strcpy(pFindProjectEntityFolder, Storyboard.customprojectfolder);
									strcat(pFindProjectEntityFolder, Storyboard.gamename);
									LPSTR pFileFolderToCheck = pNewFolder->m_sFolderFullPath.Get();
									if (strnicmp(pFileFolderToCheck, pFindProjectEntityFolder, strlen(pFindProjectEntityFolder)) != NULL)
									{
										bIsVisible = false;
									}
								}

								uniqueId++;

								if (bAdvancedFPEFeatures && current_sortby == 5 || current_sortby == 6)
								{
									//Hide files that do not "yet" have a DBO and then no poly count.
									if (myfiles->m_iFPEDBOFileSize <= 0)
										bIsVisible = false;
								}

								// always hide files ending with "_smartchild", they are only useful to the smart objects construction
								// and no good on their own for the vast majority of cases
								if (strnicmp(myfiles->m_sNameFinal.Get() + strlen(myfiles->m_sNameFinal.Get()) - 11, "_smartchild", 11) == NULL)
								{
									bIsVisible = false;
									bForceVisible = false;
								}

								if (bIsVisible || bForceVisible)
								{
									// set sortby mode = current_sortby
									// 0 = showcase
									// 1 = no sorting, category order and files A-Z inside each category. 0
									// 2 = A-Z 1
									// 3 = Z-A 2
									// 4 = Date Old-New 5
									// 5 = Date New-Old 6
									// 6 = Poly low 7
									// 7 = Poly high 8

									//Push files entry into a sort list.
									std::string SortBy = Lower(myfiles->m_sName.Get());

									if (current_sortby == 0) //|| current_sortby == 1
									{
										//Showcase and category display.
										SortBy = dir_name + ":" + SortBy;
									}
									if (seleted_tree_item >= 0 && pestrcasestr(cSearchAllEntities[i], dir_name.c_str()))
									{
										//PE: This search is from a click on a category, sort normally.
										//SortBy = dir_name + ":" + SortBy;
									}
									else if (strlen(cSearchAllEntities[i]) > 0) // && current_sortby == 3 || current_sortby == 4
									{
										std::string AddToSort = "";
										std::string SortSearch = Lower(cSearchAllEntities[i]);

										/* LB: this confused users who found their A-Z messed up
										char * dist = (char *)pestrcasestr(myfiles->m_sBetterSearch.Get(), cSearchAllEntities[i]);
										int iDist = 99;
										if (dist)
										{
											iDist = dist - myfiles->m_sBetterSearch.Get();
										}
										if (iDist < 10)
											AddToSort = "0";
										AddToSort = AddToSort + std::to_string(iDist);
										SortBy = AddToSort + SortBy;
										*/
									}

									if (current_sortby == 3 || current_sortby == 4)
									{
										char buffer[80];
										struct tm * timeinfo = localtime(&myfiles->m_tFileModify);
										strftime(buffer, 80, "%F%H%M", timeinfo);
										SortBy = buffer;
									}

#ifdef PHONETICSEARCH
									if (bIsPhonetic) // && current_sortby == 4
									{
										//Put in bottom of results.
										std::string AddToSort = "";
										if (iPhoneticDistance < 10)
											AddToSort = "0";
										AddToSort = AddToSort + std::to_string(iPhoneticDistance);
										SortBy = "ZZZZ" + AddToSort + SortBy;
									}
#endif

									if (bSentToTopOfList)
									{
										SortBy = "0000" + SortBy;
									}


									if (bAdvancedFPEFeatures && current_sortby == 5 || current_sortby == 6)
									{
										//Sort by poly count.
										int iSize = myfiles->m_iFPEDBOFileSize;
										if (iSize > 0)
										{
											std::string AddToSort = "";
											if (iSize < 10)
												AddToSort = "0000000";
											else if (iSize < 100)
												AddToSort = "000000";
											else if (iSize < 1000)
												AddToSort = "00000";
											else if (iSize < 10000)
												AddToSort = "0000";
											else if (iSize < 100000)
												AddToSort = "000";
											else if (iSize < 1000000)
												AddToSort = "00";
											else if (iSize < 10000000)
												AddToSort = "0";
											AddToSort = AddToSort + std::to_string(iSize);
											SortBy = AddToSort + SortBy;
										}
									}

									sorted_files.push_back(std::make_pair(SortBy, myfiles));
									//Map pNewFolder to files entry.
									myfiles->pNewFolder = pNewFolder;
									//myfiles->bLoadedInNewFormat = bLoadedInNewFormat;
									//myfiles->textureId = textureId;
									myfiles->uniqueId = uniqueId;
								}

								myfiles = myfiles->m_pNext;

							}
						}
					}
					pNewFolder = pNewFolder->m_pNext;

				} // while folders.

			} //bUpdateSearchSorting

			if ((bUpdateSearchSorting || bUpdateSearchSortingNextFrame) && sorted_files.size() > 0)
			{
				// set sortby mode = current_sortby
				// 0 = showcase
				// 1 = no sorting, category order and files A-Z inside each category. 0
				// 2 = A-Z 1
				// 3 = Z-A 2
				// 4 = Date Old-New 5
				// 5 = Date New-Old 6
				// 6 = Poly low 7
				// 7 = Poly high 8

				if (current_sortby >= 0)
				{
					std::sort(sorted_files.begin(), sorted_files.end());
					if (current_sortby == 4 || current_sortby == 2 || current_sortby == 6)
						std::reverse(sorted_files.begin(), sorted_files.end());
				}
			}

			bUpdateSearchSortingNextFrame = false;
			bUpdateSearchSorting = false;

			//#####################################################
			//#### Start the actual display of the object list ####
			//#####################################################

			cwidth = ImGui::GetContentRegionAvailWidth();
			iColumnsWidth = cwidth / pref.iSetColumnsEntityLib;
			iColumnsWidth -= 8.0; //padding

			if (iColumnsWidth < 100)
				iColumnsWidth = 100;
			media_icon_size = iColumnsWidth - 6.0;
			media_icon_size_y = media_icon_size * 0.5625f; //PE: 1920x1080 ratio.


			//float fWinWidth = ImGui::GetWindowSize().x - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
			float fWinWidth = ImGui::GetContentRegionAvailWidth() - 10.0; // Flicker - ImGui::GetCurrentWindow()->ScrollbarSizes.x;
			if (iColumnsWidth >= fWinWidth && fWinWidth > media_icon_size)
			{
				iColumnsWidth = fWinWidth;
			}
			//int iColumns = (int)(ImGui::GetWindowSize().x / (iColumnsWidth));
			int iColumns = (int)(ImGui::GetContentRegionAvailWidth() / (iColumnsWidth));
			if (iColumns <= 1)
				iColumns = 1;

			ImGui::BeginColumns("##filescolumns4entities", iColumns, ImGuiColumnsFlags_NoBorder);
			//ImGui::Columns(iColumns, "filescolumns4entities", false);  //false no border

			if (bUpdateSearchScrollbar)
			{
				ImGui::SetScrollY(0);
				bUpdateSearchScrollbar = false;
			}

			//PE: Control scrollbar here.
			static bool bTriggerAnotherEndKey = false;
			if (bTriggerAnotherEndKey)
			{
				ImGui::SetScrollY(ImGui::GetScrollMaxY() * 2.0);
				bTriggerAnotherEndKey = false;
			}
			if (bLastEntityGotFocus)
			{
				//PE: https://github.com/TheGameCreators/GameGuruRepo/issues/1239

				if (!io.KeyShift)
				{
					if (!io.KeyCtrl) // CTRL+A
					{
						bool bChanged = false;
						float sy = ImGui::GetScrollY();

						if(	ImGui::IsKeyPressed(38, true) ) //UP
						{
							if (sy > 0) sy = sy - ImGui::GetFontSize();
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(40, true)) //Down
						{
							if (sy < ImGui::GetScrollMaxY()) sy = sy + ImGui::GetFontSize();
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(33, true)) //PGUP
						{
							if (sy > 0) sy = sy - (ImGui::GetContentRegionAvail().y + 9.0);
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(34, true)) //PGDOWN
						{
							if (sy < ImGui::GetScrollMaxY()) sy = sy + (ImGui::GetContentRegionAvail().y + 9.0);
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(36, true)) //HOME
						{
							sy = 0;
							bChanged = true;
						}
						if (ImGui::IsKeyPressed(35, true)) //END
						{
							sy = ImGui::GetScrollMaxY() * 2.0;
							bChanged = true;
							bTriggerAnotherEndKey = true; //PE: Needed.
						}

						if (bChanged)
						{
							if (sy < 0) sy = 0;
							ImGui::SetScrollY(sy);
						}
					}
				}
			}


			//PE: Create a list of all selected objects.
			selected_library_fpe.clear();

			//#####################################
			//#### Created selected files list ####
			//#####################################

			static int all_folders_check = 20;
			if (all_folders_check-- < 0) all_folders_check = 20;
			all_folders.clear();
			for (int iLoop = 0; iLoop < sorted_files.size(); iLoop++)
			{
				//if (myfiles->iFlags == 1)
				if (sorted_files[iLoop].second)
				{
					cFolderItem::sFolderFiles * myfiles = NULL;
					myfiles = sorted_files[iLoop].second;
					if (all_folders_check == 0 && myfiles && sorted_files[iLoop].second->pNewFolder)
					{
						if (std::find(all_folders.begin(), all_folders.end(), sorted_files[iLoop].second->pNewFolder) == all_folders.end()) {
							all_folders.push_back(sorted_files[iLoop].second->pNewFolder);
						}
					}

					if (myfiles && myfiles->iFlags == 1)
					{

						pNewFolder = sorted_files[iLoop].second->pNewFolder;
						int ipath_remove_len = pNewFolder->m_sFolderFullPath.Len();

						cStr path = pNewFolder->m_sFolderFullPath.Get();

						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						//
						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;

						std::string sFpeName = path_for_filename.c_str();
						sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
						t.addentityfile_s = sFpeName.c_str();
						selected_library_fpe.insert(std::make_pair(t.addentityfile_s.Get(), 0));
					}
				}
			}


			static bool bAddAllVisibleTriggerMessage = false;
			if (bAddAllVisibleTriggerMessage && selected_library_fpe.size() >= 100)
			{
				//Check if we need to triggerr a warning.
				if (MessageBoxA(NULL, "You have selected more then 100 object, are you sure you want to continue ?", "Warning", MB_YESNO | MB_TOPMOST) != IDYES)
				{
					//Clear all flags again.
					for (int iLoop = 0; iLoop < sorted_files.size(); iLoop++)
					{
						if (sorted_files[iLoop].second)
						{
							cFolderItem::sFolderFiles * myfiles = NULL;
							myfiles = sorted_files[iLoop].second;
							if (myfiles && myfiles->iFlags == 1)
								myfiles->iFlags = 0;
						}
					}
				}
			}

			bAddAllVisibleTriggerMessage = false;

			int ipath_remove_len = 0;
			pNewFolder = NULL;
			static bool bAddAllVisible = false;
			bAddAllVisible = false;

			static int iVideoPreviewThumbID = 0;
			static int iVideoGenerateImageID = 0;
			static cFolderItem::sFolderFiles * pVideoGeneratingFile = NULL;
			static cstr sVideoSaveName = "";

			//Check if we are generating a video preview.
			if (iDisplayLibraryType == 3 && iVideoGetFirstFrame > 0)
			{

				if (iVideoGetFirstFrame > 0) {

					UpdateAllAnimation();
					SetVideoVolume(0.1);

					if (iVideoGetFirstFrame == 1) {

						PauseAnim(iVideoPreviewThumbID);
						SetVideoVolume(100.0); //Turn back volume.
						//UpdateAllAnimation();
						//Capture frame.
						ID3D11ShaderResourceView* lpVideoTextureView = GetAnimPointerView(iVideoPreviewThumbID);
						LPGGSURFACE lpVideoTexture = GetAnimPointerTexture(iVideoPreviewThumbID);

						float fVideoW = GetAnimWidth(iVideoPreviewThumbID);
						float fVideoH = GetAnimHeight(iVideoPreviewThumbID);

						//Save image do not work on some image sizes ?
						//int rounftofour = fVideoW / 32;
						//fVideoW = rounftofour * 32;
						//rounftofour = fVideoH / 32;
						//fVideoH = rounftofour * 32;

						if (iVideoPreviewThumbID > 0 && lpVideoTexture && iVideoGenerateImageID > 0) {
							float fRatio = 1.0f / (fVideoW / fVideoH);

							LPGGSURFACE pOldBackBuffer = g_pGlob->pCurrentBitmapSurface;
							 g_pGlob->pCurrentBitmapSurface = lpVideoTexture;
							SetGrabImageMode(1);
							// delete previous thumbnail
							if (GetImageExistEx(iVideoGenerateImageID))
							{
								DeleteImage(iVideoGenerateImageID);
							}

							GrabImage(iVideoGenerateImageID, 0, 0, fVideoW, fVideoH, 0);
							SetGrabImageMode(0);
							g_pGlob->pCurrentBitmapSurface = pOldBackBuffer;

							if (GetImageExistEx(iVideoGenerateImageID))
							{
								//The thumb name will include 512x288 but we can scale it to the actual size when we know its a video.
								SaveImage(sVideoSaveName.Get(), iVideoGenerateImageID);
								pVideoGeneratingFile->iPreview = iVideoGenerateImageID;
								pVideoGeneratingFile->iBigPreview = iVideoGenerateImageID;
							}
						}

						if (AnimationExist(iVideoPreviewThumbID)) {
							if (AnimationPlaying(iVideoPreviewThumbID))
								StopAnimation(iVideoPreviewThumbID);
							DeleteAnimation(iVideoPreviewThumbID);
						}
						iVideoPreviewThumbID = 0;
						iVideoGenerateImageID = 0;
					}
					iVideoGetFirstFrame--;
				}

			}

			static int iWaitFramesBeforeProceed = 0;
			if (iDisplayLibraryType == 5 && iWaitFramesBeforeProceed > 0)
			{
				iWaitFramesBeforeProceed--;
			}

			//###################
			//#### MAIN LOOP ####
			//###################

			static bool bSecondScrollActive = false;
			bSecondScrollActive = true;

			total_files_displayed_in_library = 0;
			for (int iLoop = 0; iLoop < sorted_files.size(); iLoop++)
			{
				bool bValid = false;

				if (sorted_files.size() > 0)
				{
					if (sorted_files[iLoop].second)
					{
						pNewFolder = sorted_files[iLoop].second->pNewFolder;
						ipath_remove_len = pNewFolder->m_sFolderFullPath.Len();
						bValid = true;
					}
				}

				if (bValid)
				{

					//PE: Full path can now change in the middle of the list , so:
					cStr path = pNewFolder->m_sFolderFullPath.Get();

					if (pNewFolder->m_iEntityOffset > 0)
						ipath_remove_len = pNewFolder->m_iEntityOffset;

					bool isMarkers = false;


					char *final_name = path.Get();
					final_name += ipath_remove_len;
					if (*final_name == '\\')
						final_name++;

					std::string path_for_filename = final_name;
					std::string dir_name = final_name;
					replaceAll(dir_name, "\\", " - ");

					//if (pestrcasestr(dir_name.c_str(), "_markers"))
					//	isMarkers = true;



					bool bDisplayText = true;

					cFolderItem::sFolderFiles * myfiles = NULL;

					myfiles = sorted_files[iLoop].second;
					if (myfiles)
					{

						if (myfiles->iFlags == 1)
							multi_selections_count++;

						bool bIsVisible = true;

						uniqueId = myfiles->uniqueId;
						ImGui::PushID(uniqueId); //Already unique: +preview_count);

						bool bLoadedInNewFormat = true;
						int iDefaultTexture = TOOL_ENTITY;
						int textureId = 0;

						{
							if (iDisplayLibraryType > 0)
							{
								if (iDisplayLibraryType == 2)
								{
									//PE: Need default image if we cant load the image.
									iDefaultTexture = ABOUT_TGC;
								}
								if (iDisplayLibraryType == 1)
								{
									iDefaultTexture = FILETYPE_MP3;
									//TODO: Support loading custom thumbs for music ?
									if (pestrcasestr(myfiles->m_sName.Get(), ".ogg"))
									{
										iDefaultTexture = FILETYPE_OGG;
									}
									else if (pestrcasestr(myfiles->m_sName.Get(), ".wav"))
									{
										iDefaultTexture = FILETYPE_WAV;
									}
								}
								if (iDisplayLibraryType == 3) //Video
								{
									//PE: Need default image before we generate a video preview.
									iDefaultTexture = FILETYPE_VIDEO;
								}
								if (iDisplayLibraryType == 4) //Script
								{
									//PE: Need default image before we generate a video preview.
									iDefaultTexture = FILETYPE_SCRIPT;
								}
								if (iDisplayLibraryType == 5) //Particles
								{
									//PE: Need default image before we generate a video preview.
									iDefaultTexture = FILETYPE_PARTICLE;

								}
							}
							//FPE Files.
							bool bCheckForNewPreviewImage = true;

							//Dont check any new ones before the first is done. just use default in this case.
							if (iDisplayLibraryType == 3 )
							{
								if (iVideoGenerateImageID > 0)
								{
									bCheckForNewPreviewImage = false;
									textureId = iDefaultTexture;
								}
							}

							if (iDisplayLibraryType == 5 && BackBufferParticlesMode)
							{
								bCheckForNewPreviewImage = false;
								textureId = iDefaultTexture;
								iWaitFramesBeforeProceed = 3;
							}
							
							//PE: Make sure to init all dlua descriptions.
							if (iDisplayLibraryType == 4 && myfiles->m_sDLuaDescription == "##na##")
							{
								//Load in DLUA description.
								std::string sScriptName = myfiles->m_sPath.Get();
								sScriptName = sScriptName + "\\" + myfiles->m_sName.Get();
								entityeleproftype dluaload;
								ParseLuaScript(&dluaload, (char *)sScriptName.c_str());
								myfiles->m_sDLuaDescription = "";
								if (dluaload.PropertiesVariableActive == 1)
								{
									//Build string
									char pCaptureAnyScriptDesc[8192 + 4096];
									strcpy(pCaptureAnyScriptDesc, "");
									for (int i = 0; i < dluaload.PropertiesVariable.iVariables; i++)
									{
										if (strlen(pCaptureAnyScriptDesc) < 8192)
										{
											strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionDescription[i]);
											if (dluaload.PropertiesVariable.Variable[i] && strlen(dluaload.PropertiesVariable.Variable[i]) > 0)
											{
												//Split into segments.
												strcat(pCaptureAnyScriptDesc, "[");
												strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.Variable[i]);
												strcat(pCaptureAnyScriptDesc, "]");
											}
											if (dluaload.PropertiesVariable.VariableSectionEndDescription[i] && strlen(dluaload.PropertiesVariable.VariableSectionEndDescription[i]) > 0)
											{
												strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionEndDescription[i]);
											}
										}
									}
									myfiles->m_sDLuaDescription = pCaptureAnyScriptDesc;
								}
								else
								{
									if (dluaload.PropertiesVariable.VariableDescription.Len() > 0)
									{
										myfiles->m_sDLuaDescription = dluaload.PropertiesVariable.VariableDescription;
									}
								}
							}

							if (myfiles->iPreview <= 0 && bCheckForNewPreviewImage)
							{
								bool bDontTouchThisID = false;
								//Only Visible.
								int gcpy = ImGui::GetCursorPosY();
								if (!bReleaseIconsDynamic || ((bIsVisible || isMarkers) && (gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size || isMarkers)))
								{
									myfiles->last_used = (long)tCurrentTimeSec;
									if (!bImagesStillInImGuiQueue && !bLargePreview && max_load_persync-- > 0)
									{
										//Load preview.
										std::string sImgName = myfiles->m_sPath.Get();
										if (iDisplayLibraryType == 2)
										{
											//PE: Use image directly.
											sImgName = sImgName + "\\" + myfiles->m_sName.Get();
											//__debugbreak(); //Test file.
										}
										else if (iDisplayLibraryType > 0)
										{
											//Use .jpg as thumbs for other media. 512x288 format.
											sImgName = sImgName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
											if (iDisplayLibraryType == 4) //Script
											{
												if (pref.current_style == 25 || pref.current_style == 3)
													sImgName += ".png";
												else
													sImgName += "2.png";
											}
											else
												sImgName += ".jpg";
										}
										else
										{
											sImgName = sImgName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
											sImgName += ".bmp";
										}
										myfiles->iPreview = uniqueId;
										SetMipmapNum(1); //PE: mipmaps not needed.

										//PE: Check if we got a cached thumb in correct format.
										std::string sFpeName = path_for_filename.c_str();
										sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
										t.addentityfile_s = sFpeName.c_str();
										if (iDisplayLibraryType == 5)
										{
											//PE: Changed to support subfolders.
											sFpeName = "";
											//if (strnicmp(path_for_filename.c_str(), "projectbank", 11) != NULL) 
											sFpeName = "particlesbank\\";
											sFpeName = sFpeName + path_for_filename.c_str();
											sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
											replaceAll(sFpeName, "\\\\", "\\");
											t.addentityfile_s = sFpeName.c_str();
										}
										// perhaps make this a common define!
										CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
										GG_SetWritablesToRoot(true);
										image_setlegacyimageloading(true);
										if (FileExist(BackBufferCacheName.Get()))
										{
											LoadImage((char *)BackBufferCacheName.Get(), myfiles->iPreview);
											if (!ImageExist(myfiles->iPreview))
											{
												LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
											}
											else
											{
												//PE: Mark as ok in new format.
												myfiles->iBigPreview = iDefaultTexture;
											}
											GG_SetWritablesToRoot(false);
										}
										else 
										{
											GG_SetWritablesToRoot(false);
											//PE: Try to make a thumb here.
											if (iDisplayLibraryType == 3)
											{
												//Try custom image.
												LoadImage((char *)sImgName.c_str(), myfiles->iPreview);
												if (!ImageExist(myfiles->iPreview))
												{
													if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
													{
														//We cant do this if a video is already playing. perhaps stop in next run ?
														iStopVideoInNextFrame = iVideoThumbID;
														bDontTouchThisID = true;
													}
													else
													{
														//Only if we are not already generating a preview of video.

														std::string sVideoName = myfiles->m_sPath.Get();
														sVideoName = sVideoName + "\\" + myfiles->m_sName.Get();
														if (iVideoGetFirstFrame == 0)
														{
															if (iVideoPreviewThumbID > 0) 
															{
																if (AnimationExist(iVideoPreviewThumbID)) 
																{
																	if (AnimationPlaying(iVideoPreviewThumbID))
																		StopAnimation(iVideoPreviewThumbID);
																	DeleteAnimation(iVideoPreviewThumbID);
																	iVideoPreviewThumbID = 0;
																}
															}

															iVideoPreviewThumbID = 0;

															for (int itl = 1; itl <= 32; itl++)
															{
																if (AnimationExist(itl) == 0) { iVideoPreviewThumbID = itl; break; }
															}
															if (LoadAnimation((char *)sVideoName.c_str(), iVideoPreviewThumbID, g.videoprecacheframes, 0, 1) == false)
															{
																//Failed to load mark as ok using default thumb.
																myfiles->iPreview = iDefaultTexture;
																myfiles->iBigPreview = iDefaultTexture;
																textureId = iDefaultTexture;
																iVideoPreviewThumbID = -999;
															}

															if (iVideoPreviewThumbID > 0) {
																PlaceAnimation(iVideoPreviewThumbID, -1, -1, -1, -1);
																SetRenderAnimToImage(iVideoPreviewThumbID, true);
																//Try to get first frame.
																StopAnimation(iVideoPreviewThumbID);
																PlayAnimation(iVideoPreviewThumbID);
																void SetVideoPosition(float seconds);
																SetVideoPosition(1.0f);
																PlayAnimation(iVideoPreviewThumbID);
																//UpdateAllAnimation();
																SetRenderAnimToImage(iVideoPreviewThumbID, true);

																UpdateAllAnimation();
																Sleep(50); //Sleep so we get a video texture in the next call.
																UpdateAllAnimation();
																SetVideoVolume(0.1);
																iVideoGetFirstFrame = 8;
																iVideoGenerateImageID = myfiles->iPreview;
																pVideoGeneratingFile = myfiles;
																sVideoSaveName = BackBufferCacheName;
															}

														}
													}
												}
											}
											else if (iDisplayLibraryType == 5)
											{
												//Create particle thumb here.
												BackBufferIsGroup = false;
												BackBufferEntityID = 0;
												BackBufferObjectID = 0;
												BackBufferImageID = myfiles->iPreview;
												BackBufferSizeX = 512;
												BackBufferSizeY = 288;
												BackBufferCamLeft = 0.0f;
												bRotateBackBuffer = false;
												bBackBufferAnimated = false;
												bLoopBackBuffer = false;
												BackBufferSaveCacheName = ""; //No saving for now
												//Dont fit snapshot to rubber band.
												fLastRubberBandX1 = fLastRubberBandX2 = fLastRubberBandY1 = fLastRubberBandY2 = 0.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = true;
												bDontTouchThisID = true;
												CreateBackdropObject(false, cstr("texturebank\\backdrops\\Black backdrop.dds"), t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.

												BackBufferZoom = 800.0f;
												BackBufferCamUp = 400.0f;

												//Test
												float centerx = -1000, centery = 39000, centerz = -1000;

												std::string sParticleName = myfiles->m_sPath.Get();
												char cTmp[MAX_PATH];
												cstr savename = myfiles->m_sPath + "\\" + myfiles->m_sName;
												strcpy(cTmp, savename.Get());
												char *find = (char *) pestrcasestr(cTmp, "\\particlesbank");
												if (find)
												{
													strcpy(cTmp, find + 1);
												}
												else
												{
													strcpy(cTmp, "particlesbank\\");
													strcat(cTmp, myfiles->m_sName.Get());
												}
												CreateBackBufferCacheName(cTmp, thumb_x, thumb_y);
												BackBufferSaveCacheName = BackBufferCacheName;

												sParticleName = sParticleName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);

												if (BackBufferParticleEmitter != -1)
												{
													gpup_deleteEffect(BackBufferParticleEmitter);
													BackBufferParticleEmitter = -1;
												}

												if (BackBufferParticleEmitter == -1)
												{
													BackBufferParticleEmitter = gpup_loadEffect(sParticleName.c_str(), 0, 0, 0, 1.0);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 0);
												}
												float fLive = 10.0f;
												if (BackBufferParticleEmitter != -1)
												{
													gpup_setGlobalPosition(BackBufferParticleEmitter, centerx, centery - 30.0f, centerz);
													gpup_resetLocalPosition(BackBufferParticleEmitter);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 1);
													gpup_setEffectAnimationSpeed(BackBufferParticleEmitter, 1.0f);
													gpup_setEffectOpacity(BackBufferParticleEmitter, 1.0f);

													fLive = gpup_getEffectLifespan(BackBufferParticleEmitter);
													//gpup_emitter[enr].lifespan * 60 * 10
												}
												//We need to delay the thumb as we cant fast forward the particles.
												if (fLive < 100.0f)
													iBackBufferParticlesTrigger = 25;
												else if (fLive < 200.0f)
													iBackBufferParticlesTrigger = 110;
												else if (fLive < 300.0f)
													iBackBufferParticlesTrigger = 150;
												else
													iBackBufferParticlesTrigger = 160; //Max

												iWaitFramesBeforeProceed = 3;
											}
											else
											{
												bLoadedInNewFormat = false;
												if (FileExist((char*)sImgName.c_str()) == 1)
												{
													LoadImage((char*)sImgName.c_str(), myfiles->iPreview);
												}
												else
												{
													// when the preview image file does not exist, use default
													if (iDisplayLibraryType == 0)
													{
														// buit only for object previews, leave other media types to their default icons (i.e WAV/OFF/MP3)
														LoadImage("texturebank\\backdrops\\Black backdrop.dds", myfiles->iPreview);
													}
												}
											}
										}
										image_setlegacyimageloading(false);
										SetMipmapNum(-1);

										//##na##
										if (iDisplayLibraryType == 4)
										{
											//Load in DLUA description.
											std::string sScriptName = myfiles->m_sPath.Get();
											sScriptName = sScriptName + "\\" + myfiles->m_sName.Get();
											entityeleproftype dluaload;
											ParseLuaScript(&dluaload, (char *) sScriptName.c_str());
											myfiles->m_sDLuaDescription = "";
											if (dluaload.PropertiesVariableActive == 1)
											{
												//Build string
												char pCaptureAnyScriptDesc[8192+4096];
												strcpy(pCaptureAnyScriptDesc, "");
												for (int i = 0; i < dluaload.PropertiesVariable.iVariables; i++)
												{
													if (strlen(pCaptureAnyScriptDesc) < 8192)
													{
														strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionDescription[i]);
														if (dluaload.PropertiesVariable.Variable[i] && strlen(dluaload.PropertiesVariable.Variable[i]) > 0)
														{
															//Split into segments.
															strcat(pCaptureAnyScriptDesc, "[");
															strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.Variable[i]);
															strcat(pCaptureAnyScriptDesc, "]");
														}
														if (dluaload.PropertiesVariable.VariableSectionEndDescription[i] && strlen(dluaload.PropertiesVariable.VariableSectionEndDescription[i]) > 0)
														{
															strcat(pCaptureAnyScriptDesc, dluaload.PropertiesVariable.VariableSectionEndDescription[i]);
														}
													}
												}
												myfiles->m_sDLuaDescription = pCaptureAnyScriptDesc;
											}
											else
											{
												if (dluaload.PropertiesVariable.VariableDescription.Len() > 0)
												{
													myfiles->m_sDLuaDescription = dluaload.PropertiesVariable.VariableDescription;
												}
											}
										}
										if (!GetImageExistEx(myfiles->iPreview))
										{
											if (!bDontTouchThisID)
											{
												myfiles->iPreview = iDefaultTexture;
												textureId = iDefaultTexture;
											}
											else
											{
												textureId = iDefaultTexture;
											}
										}
										else 
										{
											loaded_images++;
											textureId = myfiles->iPreview;
										}
									}
									else
									{
										textureId = iDefaultTexture;
									}
								}
								else
								{
									textureId = iDefaultTexture;
								}
							}
							else
							{
								//PE: Only delete in first run. so we dont delete a image that has already been sent to rendering.
								if (bReleaseIconsDynamic && myfiles->iPreview > 0 ) 
								{
									//Only NOT Visible with a preview image..
									int gcpy = ImGui::GetCursorPosY();
									if (!isMarkers && (!(gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size) || !bIsVisible)) 
									{
										if ((long)tCurrentTimeSec - myfiles->last_used > 20) 
										{
											//Delete Image not visible for 20 sec.
											if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) 
											{ 
												//PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
												image_setlegacyimageloading(true);
												DeleteImage(myfiles->iPreview);
												image_setlegacyimageloading(false);
												myfiles->iPreview = 0;
												loaded_images--;
											}
											textureId = iDefaultTexture;
										}
										else
											textureId = myfiles->iPreview;
									}
									else 
									{
										//Still visible update time.
										if (bIsVisible || isMarkers) myfiles->last_used = (long)tCurrentTimeSec;
										textureId = myfiles->iPreview;
									}
								}
								else
								{
									textureId = myfiles->iPreview;
								}
							}
						}
						if (textureId == 0)
						{
							textureId = iDefaultTexture;
						}

						if (iDisplayLibraryType == 4 && bDLUAOnly)
						{
							//PE: We now preload all dlua descriptions, so just process everything.
							//if (myfiles->iPreview > 0)
							if(1)
							{
								if (myfiles->m_sDLuaDescription.Len() <= 0)
								{
									bIsVisible = false;
								}
								else
								{
									if( pestrcasestr(myfiles->m_sDLuaDescription.Get(),"do not assign to an entity") )
										bIsVisible = false;
									else if (pestrcasestr(myfiles->m_sDLuaDescription.Get(), "do not use this script"))
										bIsVisible = false;

								}
							}
						}

						//Is object visible
						// or bCheckGotoPreview
						if (bIsVisible || bCheckGotoPreview)
						{

							if (!firstvisiblefile)
							{
								if (!scrolltofile)
								{
									int gcpy = ImGui::GetCursorPosY();
									float fSPos = ImGui::GetScrollY() - (media_icon_size);
									if (fSPos < 0.0f) fSPos = 0.0f;
									if (gcpy >= fSPos)
									{
										firstvisiblefile = myfiles;
									}
								}
							}
							if (myfiles->iPreview > 0 && !GetImageExistEx(myfiles->iPreview))
							{
								myfiles->iPreview = 0;
								textureId = TOOL_ENTITY;
							}

							if (!isMarkers && i == 0)
							{
								LPSTR pFinalHeaderTitle = (LPSTR)dir_name.c_str();
								if (stricmp(pFinalHeaderTitle, "user") == NULL) pFinalHeaderTitle = "Custom Assets";
								if (stricmp(pFinalHeaderTitle, "user - charactercreatorplus") == NULL) pFinalHeaderTitle = "Custom Characters";
								if (stricmp(pFinalHeaderTitle, "user - ebestructures") == NULL) pFinalHeaderTitle = "Custom Structures";

								if (pestrcasestr(dir_name.c_str(), "_markers"))
									pFinalHeaderTitle = "Game Elements";

								strcpy(cHeader, pFinalHeaderTitle);
							}

							if (pref.iSetColumnsEntityLib <= 4)
								ImGui::SetWindowFontScale(1.0);
							else
								ImGui::SetWindowFontScale(SMALLFONTSIZE);

							float fFramePadding = (iColumnsWidth - media_icon_size)*0.5;
							float fCenterX = iColumnsWidth * 0.5;

							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(fFramePadding, 2.0f));

							if (iDisplayLibraryType == 0) //Only FPE for now.
							{
								if (iDisplayLibrarySubType == 0)
								{
									if (!io.KeyShift)
									{
										if (io.KeyCtrl) // CTRL+A
										{
											if (ImGui::IsKeyReleased(65)) //A
											{
												bAddAllVisible = true;
												bAddAllVisibleTriggerMessage = true;
											}
										}
									}
									if (bAddAllVisible)
									{
										//int gcpy = ImGui::GetCursorPosY();
										//PE: Only include visible objects.
										//if (bIsVisible && gcpy < (iIconVisiblePosY - (media_icon_size*1.1)) && gcpy >= (ImGui::GetScrollY() - (media_icon_size*0.5)))
										//PE: Include All.
										if (bIsVisible)
										{
											extern bool g_bFreeTrialVersion;
											if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
												myfiles->iFlags = 1;
										}
									}
								}
							}
							ImRect selection_bb;
							bool bVisibleOnScreen = false;
							//sMakeDefaultSelecting
							if (sMakeDefaultSelecting != "")
							{
								std::string sMediaName = "";
								//if (strnicmp(path_for_filename.c_str(), "projectbank", 11) != NULL)
								//{
									if (iDisplayLibraryType == 1) sMediaName = "audiobank\\";
									if (iDisplayLibraryType == 2) sMediaName = "imagebank\\";
									if (iDisplayLibraryType == 3) sMediaName = "videobank\\";
									if (iDisplayLibraryType == 5) sMediaName = "particlesbank\\";
									if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) sMediaName = "charactercreatorplus\\animations\\";
								//}
								sMediaName = sMediaName + path_for_filename.c_str();
								if (path_for_filename.length() == 0)
									sMediaName = sMediaName + myfiles->m_sName.Get();
								else
									sMediaName = sMediaName + "\\" + myfiles->m_sName.Get();
								if (stricmp(sMakeDefaultSelecting.Get(),sMediaName.c_str()) == 0)
								{
									selectedmediafile = myfiles;
									scrolltofile = myfiles;
									bScrollInNextFrame = true;
									sMakeDefaultSelecting = "";
								}
							}
							if (myfiles->iFlags == 1 || selectedmediafile == myfiles )
							{
								int gcpy = ImGui::GetCursorPosY();
								if (bIsVisible && gcpy < (iIconVisiblePosY ) && gcpy >= (ImGui::GetScrollY() - (media_icon_size*0.5)))
								{
									ImVec2 padding = { 0.0, 0.0 };
									ImGuiWindow* window = ImGui::GetCurrentWindow();
									float cw = ImGui::GetContentRegionAvailWidth();
									if (iDisplayLibraryType == 0)
									{
										selection_bb.Min = (window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f);
										if (pref.iSetColumnsEntityLib == 1)
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw - 1.0f, media_icon_size_y + 2.0f);
										else
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw + 6.0f, media_icon_size_y + 2.0f);
										if(bDisplayText)
											selection_bb.Max.y += ImGui::GetFontSize() + 8.0f;
									}
									else
									{
										selection_bb.Min = (window->DC.CursorPos - padding) + ImVec2(fFramePadding, 2.0f);
										if (pref.iSetColumnsEntityLib == 1)
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw - 1.0f, media_icon_size_y + 2.0f);
										else
											selection_bb.Max = (window->DC.CursorPos + padding) + ImVec2(cw + 6.0f, media_icon_size_y + 2.0f);
									}
									bAnySelectedItemsAvailable = true;
									bVisibleOnScreen = true;
								}
							}

							//std::string sFinal = Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);
							std::string sFinal = myfiles->m_sNameFinal.Get(); //PE: For speed.

							CheckTutorialAction(sFinal.c_str(), 13.0f); //Tutorial: check if we are waiting for this action

							//PE: Support Shift for selecting many items.
							if (iDisplayLibraryType == 0) //Currently only for fpe.
							{
								if (!io.KeyShift)
								{
									//firstShiftFile = NULL;
									lastShiftFile = NULL;
								}

								if (firstShiftFile && lastShiftFile) 
								{
									if (myfiles == firstShiftFile) bFirstShiftHasBeenSeen = true;
									if (!bFirstShiftHasBeenSeen && myfiles == lastShiftFile)
									{
										//Swap around, last is first.
										cFolderItem::sFolderFiles * tmpShiftFile = lastShiftFile;
										lastShiftFile = firstShiftFile;
										firstShiftFile = tmpShiftFile;
										bFirstShiftHasBeenSeen = true;
									}

									extern bool g_bFreeTrialVersion;
									static bool bStartShiftActive = false;

									myfiles->iFlags = 0;
									if (myfiles == firstShiftFile) 
									{
										bStartShiftActive = true;
										if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
											myfiles->iFlags = 1;
									}
									if (myfiles == lastShiftFile) 
									{
										bStartShiftActive = false;
										if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
											myfiles->iFlags = 1;
									}
									if (bStartShiftActive)
									{
										if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
											myfiles->iFlags = 1;
									}
								}
							}

							bool bBlockBackBufferUpdating = false;
							if (bLargePreview || bImagesStillInImGuiQueue) bBlockBackBufferUpdating = true;
							if (iDisplayLibraryType != 0) bBlockBackBufferUpdating = true;

							ImGui::SetItemAllowOverlap();
							static void* iDelayedClickFile = NULL;
							static int iDelayedImgClick = 0;
							if (iDelayedClickFile == myfiles && iDelayedImgClick > 0) iDelayedImgClick--;

							ImVec2 imgsize = ImVec2(media_icon_size, media_icon_size_y);
							ImVec2 DirectPosition = ImGui::GetCursorPos();

							if (iDisplayLibraryType == 2)
							{
								float imgw = ImageWidth(textureId);
								float imgh = ImageHeight(textureId);
								if (imgh > imgw)
								{
									float fRatio = media_icon_size_y / imgh;
									imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									if (imgsize.x > media_icon_size)
									{
										//Reverse
										float fRatio = media_icon_size / imgw;
										imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									}
								} 
								else
								{
									float fRatio = media_icon_size / imgw;
									imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									if (imgsize.y > media_icon_size_y)
									{
										//Reverse.
										float fRatio = media_icon_size_y / imgh;
										imgsize = ImVec2(imgw*fRatio, imgh*fRatio);
									}
								}
								//Clip.
								if (imgsize.y > media_icon_size_y)
									imgsize.y = media_icon_size_y;
								if (imgsize.x > media_icon_size)
									imgsize.x = media_icon_size;
								//Make room for background borders.
								imgsize.x -= 8.0f;
								imgsize.y -= 8.0f;
								//Center and use direct position.
								float fOffsetX = (media_icon_size*0.5) - (imgsize.x*0.5);
								float fOffsetY = (media_icon_size_y*0.5) - (imgsize.y*0.5);
								fOffsetX -= 2.5f; //Fit borders.
								fOffsetY -= 2.0f; //Fit borders.
								//Add filler.
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								//AddRectFilled faster ?
								ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x ,ImGui::GetCursorScreenPos().y };
								window->DrawList->AddRectFilled(vDrawPos, vDrawPos + ImVec2(media_icon_size, media_icon_size_y), ImGui::GetColorU32(ImVec4(0, 0, 0, 0.3)), 6.0f, 15);

								ImGui::SetCursorPos(DirectPosition + ImVec2(fOffsetX, fOffsetY));
							}
							
							bool bOverLayVideo = false;
							ImVec2 vVideoPos = ImGui::GetCursorPos();
							if( iDisplayLibraryType == 3 && playingiles == myfiles && iVideoThumbID > 0)
							{
								//Display video thumb.
								bOverLayVideo = true;
							}

							total_files_displayed_in_library++;
							if ((iDelayedImgClick == 1 && iDelayedClickFile == myfiles) || ImGui::ImgBtn(textureId, imgsize, drawCol_black, ImVec4(1, 1, 1, 1), ImVec4(1, 1, 1, 1), drawCol_Down, -1, 0, 0, 0, false))
							{
								iDelayedClickFile = myfiles;

								if (iDelayedImgClick == 1)
								{
									iDelayedImgClick = 0;

									if (iDisplayLibraryType == 1 || iDisplayLibraryType == 2 || iDisplayLibraryType == 3 || iDisplayLibraryType == 4 || iDisplayLibraryType == 5) //Music. , reuse selectedmediafile for images
									{
										selectedmediafile = myfiles;
									}
									else
									{
										bool bAllowSelection = true;
										extern bool g_bFreeTrialVersion;
										if (g_bFreeTrialVersion == true)
										{
											if (myfiles->bAvailableInFreeTrial == false)
											{
												bAllowSelection = false;
											}
										}
										if(bAllowSelection==true)
										{
											if (bTutorialCheckAction) TutorialNextAction(); //Clicked get next tutorial action.

											if (iDisplayLibrarySubType == 1)
											{
												// Animation Library selection simply returns choice as file path
												selectedmediafile = myfiles;
											}
											else
											{
												//If ctrl , just mark them.
												if (io.KeyShift)
												{
													if (firstShiftFile)
													{
														lastShiftFile = myfiles;
													}
													else
													{
														firstShiftFile = myfiles;
														multi_selections = true;
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
													}
												}
												else if (io.KeyCtrl)
												{
													//Mark object.
													multi_selections = true;
													if (myfiles->iFlags == 0)
													{
														if (g_bFreeTrialVersion == false || (g_bFreeTrialVersion == true && myfiles->bAvailableInFreeTrial == true))
															myfiles->iFlags = 1;
														firstShiftFile = myfiles;
													}
													else
														myfiles->iFlags = 0;
												}
												else
												{
													if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
													if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
													if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

													//Make sure we are in entity mode.
													bForceKey = true;
													csForceKey = "o";

													bBlockBackBufferUpdating = true;
													DeleteWaypointsAddedToCurrentCursor();
													//CheckTooltipObjectDelete();
													CloseDownEditorProperties();
													FreeTempImageList(); //PE: Make sure we free all not used textures before adding new objects.
													#ifdef WICKEDENGINE
													iLastEntityOnCursor = 0;
													#endif

													std::string sFpeName = path_for_filename.c_str();
													sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
													t.addentityfile_s = sFpeName.c_str();
													if (t.addentityfile_s != "")
													{
														// Special group detection system
														entity_adduniqueentity(false);
														t.tasset = t.entid;
														if (t.talreadyloaded == 0)
														{
															editor_filllibrary();
														}
													}

													iExtractMode = 0; //PE: Always start in find floor mode.

													t.inputsys.constructselection = t.tasset;

													t.gridentity = t.entid;
													t.inputsys.constructselection = t.entid;
													t.inputsys.domodeentity = 1;
													t.grideditselect = 5;

													//Make sure we use a fresh t.grideleprof
													entity_fillgrideleproffromprofile();

													editor_refresheditmarkers();
													//PE: Close window for now.
													bCheckForClosing = true;
													bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
													bDraggingActive = false;

													//PE: we loose status somewhere, so force it off after adding a entity to map.
													extern bool bCubesVisible;
													if (bCubesVisible == false) bCubesVisible = true; //Force.
												}
											}
										}
									}
								}
								else
								{
									iDelayedImgClick = 14;
								}
							}
							bool bThumbHovered = ImGui::IsItemHovered();
							
							// if free trial and object not on list
							extern bool g_bFreeTrialVersion;
							if (g_bFreeTrialVersion == true)
							{
								if (myfiles->bAvailableInFreeTrial == false)
								{
									// place grey layer on thumb to show object not available
									ImVec2 vOldPos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(DirectPosition);
									ImGui::SetItemAllowOverlap();
									ImGui::ImgBtn(FREETRIAL_NOTAVAILABLE, imgsize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors);
									ImGui::SetCursorPos(vOldPos);
								}
							}

							if (iDisplayLibraryType == 2)
							{
								//PE: Add padding ?
								float paddingy = 10.0f;
								ImGui::SetCursorPos(DirectPosition + ImVec2(0, media_icon_size_y + paddingy));
							}

							if (bWaitOnMouseRelease)
							{
								if (!ImGui::IsMouseDown(0))
									bWaitOnMouseRelease = false;
							}

							if (iDisplayLibraryType > 0 || (iDisplayLibraryType==0 && iDisplayLibrarySubType == 1))
							{
								// Drag drop from other media types - no
							}
							else
							{
								bool bAllowSelection = true;
								extern bool g_bFreeTrialVersion;
								if (g_bFreeTrialVersion == true)
								{
									if (myfiles->bAvailableInFreeTrial == false)
									{
										bAllowSelection = false;
									}
								}
								if (bAllowSelection == true)
								{
									if (!bImagesStillInImGuiQueue && !bWaitOnMouseRelease && !bLargePreview && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
									{
										CloseDownEditorProperties();
										t.inputsys.constructselection = 0;

										myfiles->m_dropptr = myfiles;

										std::string sFpeName = path_for_filename.c_str();
										sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();

										myfiles->m_sFolder = sFpeName.c_str();

										//PE: Special add all selected. for drag drop.
										myfiles->iAnimationFrom = 0;
										if (selected_library_fpe.size() > 0)
										{
											myfiles->iAnimationFrom = 200000;
										}

										ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", myfiles, sizeof(void *));
										ImGui::ImgBtn(textureId, ImVec2(media_icon_size, media_icon_size_y), drawCol_black, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
										ImGui::SetCursorPos(oldCursor);
										pDragDropFile = myfiles;
										ImGui::EndDragDropSource();
										bReadyToDropEntity = false;
										iDragDropActive = 50;
										bDraggingActive = true;
										bDraggingActiveInitial = true;
										// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
										t.gridentityposx_f = t.inputsys.localx_f;
										t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
										t.gridentityposz_f = t.inputsys.localy_f;
									}
								}
							}
							ImGui::PopID();
							ImGui::PushID(uniqueId + 20000);

							//---
							if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1)
							{
								if (bThumbHovered && ImGui::IsMouseClicked(0))
								{
									std::string sMediaName = "charactercreatorplus\\animations\\";
									sMediaName = sMediaName + path_for_filename.c_str();
									if (path_for_filename.length() == 0)
										sMediaName = sMediaName + myfiles->m_sName.Get();
									else
										sMediaName = sMediaName + "\\" + myfiles->m_sName.Get();
									sSelectedLibrarySting = sMediaName.c_str();
									iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
									bBlockBackBufferUpdating = true;
									bCheckForClosing = true;
									bImGuiRenderTargetFocus = true;
								}
							}

							//---
							if (iDisplayLibraryType > 0)
							{
								if (bThumbHovered && ImGui::IsMouseDoubleClicked(0))
								{
									//Sent selection to imgui ID that have last requested a media file.
									selectedmediafile = NULL;
									playingiles = NULL;
									if(iDisplayLibraryType == 3) iStopVideoInNextFrame = iVideoThumbID;
									//Stop anything playing.
									if (SoundExist(g.temppreviewsoundoffset) == 1)
									{
										StopSound(g.temppreviewsoundoffset);
										DeleteSound(g.temppreviewsoundoffset);
									}

									std::string sMediaName = "";
									//if (strnicmp(path_for_filename.c_str(), "projectbank", 11) != NULL)
									//{
										if (iDisplayLibraryType == 1) sMediaName = "audiobank\\";
										if (iDisplayLibraryType == 2) sMediaName = "imagebank\\";
										if (iDisplayLibraryType == 3) sMediaName = "videobank\\";
										if (iDisplayLibraryType == 5) sMediaName = "particlesbank\\";
										if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1) sMediaName = "charactercreatorplus\\animations\\";
									//}
									sMediaName = sMediaName + path_for_filename.c_str();
									if(path_for_filename.length() == 0)
										sMediaName = sMediaName + myfiles->m_sName.Get();
									else
										sMediaName = sMediaName + "\\" + myfiles->m_sName.Get();
									if (sMediaName != "")
									{
										sSelectedLibrarySting = sMediaName.c_str();
										iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
									}
									bBlockBackBufferUpdating = true;
									bCheckForClosing = true;
									bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
								}

								if (bOverLayVideo && iStopVideoInNextFrame == 0)
								{
									ImVec2 vOldPos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(vVideoPos);

									if (AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
									{
										//imgsize
										ID3D11ShaderResourceView* lpVideoTexture = GetAnimPointerView(iVideoThumbID);
										float fVideoW = GetAnimWidth(iVideoThumbID);
										float fVideoH = GetAnimHeight(iVideoThumbID);
										if (lpVideoTexture)
										{
											ImGuiWindow* window = ImGui::GetCurrentWindow();
											ImRect image_bb(window->DC.CursorPos + ImVec2(3, 2), window->DC.CursorPos + ImVec2(3, 2) + imgsize);
											float animU = GetAnimU(iVideoThumbID);
											float animV = GetAnimV(iVideoThumbID);
											ImVec2 uv0 = ImVec2(0, 0);
											ImVec2 uv1 = ImVec2(animU, animV);
											window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
										}
									}
									ImGui::SetCursorPos(vOldPos);
								}

								//Not while generating thumbs.
								if (iDisplayLibraryType == 3 && iVideoGenerateImageID == 0 )
								{
									//Play Video.
									int iImageSize = 24;
									ImVec2 opos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(ImVec2((opos.x + media_icon_size) - iImageSize - 2.0f, opos.y - 14.0f - iImageSize));
									ImGui::SetItemAllowOverlap();

									if (playingiles == myfiles)
									{
										if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
										{
											float progress = GetAnimPercentDone(iVideoThumbID) / 100.0f;
											if (progress == 0.0f)
											{
												iStopVideoInNextFrame = iVideoThumbID;
												playingiles = NULL;
											}
										}

										if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
										{
											selectedmediafile = myfiles;
											playingiles = NULL;
											//PLAY music file.
											iStopVideoInNextFrame = iVideoThumbID;
										}
										if (!bThumbHovered)
											bThumbHovered = ImGui::IsItemHovered();
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("Stop Playing Video");

										if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID) && AnimationPlaying(iVideoThumbID))
										{
											float progress = GetAnimPercentDone(iVideoThumbID) / 100.0f;
											if (progress < 0.0f) progress = 0.0f;
											if (progress > 1.0f) progress = 1.0f;
											ImVec2 opos = ImGui::GetCursorPos();
											ImVec4 backImGuiCol_PlotHistogram = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
											ImVec4 backImGuiCol_Border = ImGui::GetStyle().Colors[ImGuiCol_Border];
											ImVec4 backImGuiCol_BorderShadow = ImGui::GetStyle().Colors[ImGuiCol_BorderShadow];
											ImVec4 backImGuiCol_FrameBg = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];
											//ImVec4 newBlue = ImVec4(56.0 / 255.0, 110.0 / 255.0, 145.0 / 255.0, 1);
											ImVec4 newBlue = ImVec4(0.8f, 0.8f, 0.8f, 0.6f);
											ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = newBlue;
											ImGui::GetStyle().Colors[ImGuiCol_Border] = ImVec4(0, 0, 0, 0);
											ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = ImVec4(0, 0, 0, 0);
											ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = ImVec4(0, 0, 0, 0);
											float padding = 30.0f;
											ImGui::SetCursorPos(ImVec2(opos.x + 4.0f + padding, opos.y - 16.0f - 10.0f));
											ImGui::ProgressBar(progress, ImVec2(media_icon_size - padding - padding, 16.0f), " ");
											ImGui::SetCursorPos(opos);
											ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = backImGuiCol_PlotHistogram;
											ImGui::GetStyle().Colors[ImGuiCol_Border] = backImGuiCol_Border;
											ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = backImGuiCol_BorderShadow;
											ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = backImGuiCol_FrameBg;
										}
									}
									else if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
									{
										//PLAY video file.
										selectedmediafile = myfiles;
										playingiles = NULL;

										if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID))
										{
											iStopVideoInNextFrame = iVideoThumbID;
										}

										std::string sVideoName = myfiles->m_sPath.Get();
										sVideoName = sVideoName + "\\" + myfiles->m_sName.Get();

										sVideoLoadName = sVideoName.c_str();
										iStartVideoInNextFrame = 1;
										playingiles = myfiles;

									}
									ImGui::SetCursorPos(opos);
									if (!bThumbHovered)
										bThumbHovered = ImGui::IsItemHovered();
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Play Video");

								}

								if (iDisplayLibraryType == 1) //Music
								{
									//Play music.
									int iImageSize = 24;
									ImVec2 opos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(ImVec2((opos.x + media_icon_size) - iImageSize - 2.0f, opos.y - 14.0f - iImageSize));
									ImGui::SetItemAllowOverlap();

									if (playingiles == myfiles)
									{

										//isoundplaying
										float pos = GetSoundPosition(g.temppreviewsoundoffset);

										if (SoundExist(g.temppreviewsoundoffset) == 1 && SoundPlaying(g.temppreviewsoundoffset) == 0)
										{
											//Not playing.
											StopSound(g.temppreviewsoundoffset);
											playingiles = NULL;
										}
										if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
										{
											selectedmediafile = myfiles;
											playingiles = NULL;
											//PLAY music file.
											if (SoundExist(g.temppreviewsoundoffset) == 1)
											{
												StopSound(g.temppreviewsoundoffset);
												DeleteSound(g.temppreviewsoundoffset);
											}
										}
										if (!bThumbHovered)
											bThumbHovered = ImGui::IsItemHovered();
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("Stop Playing Music");

										//PE: Draw progress bar end
										float progress = pos / 100.0f;
										if (progress < 0.0) progress = 0.0;
										if (progress > 1.0) progress = 1.0;
										ImVec2 opos = ImGui::GetCursorPos();
										ImVec4 backImGuiCol_PlotHistogram = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
										ImVec4 backImGuiCol_Border = ImGui::GetStyle().Colors[ImGuiCol_Border];
										ImVec4 backImGuiCol_BorderShadow = ImGui::GetStyle().Colors[ImGuiCol_BorderShadow];
										ImVec4 backImGuiCol_FrameBg = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];

										//ImVec4 newBlue = ImVec4(56.0 / 255.0, 110.0 / 255.0, 145.0 / 255.0, 1);
										ImVec4 newBlue = ImVec4(0.8f, 0.8f, 0.8f, 0.6f );
										ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = newBlue;
										ImGui::GetStyle().Colors[ImGuiCol_Border] = ImVec4(0, 0, 0, 0);
										ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = ImVec4(0, 0, 0, 0);
										ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = ImVec4(0, 0, 0, 0);
										float padding = 30.0f;
										ImGui::SetCursorPos(ImVec2(opos.x + 4.0f + padding, opos.y - 16.0f - 10.0f));
										ImGui::ProgressBar(progress, ImVec2(media_icon_size - padding - padding, 16.0f), " ");
										ImGui::SetCursorPos(opos);

										ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = backImGuiCol_PlotHistogram;
										ImGui::GetStyle().Colors[ImGuiCol_Border] = backImGuiCol_Border;
										ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = backImGuiCol_BorderShadow;
										ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = backImGuiCol_FrameBg;

									}
									else if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), ImColor(255, 255, 255, 220), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
									{
										//PLAY music file.
										selectedmediafile = myfiles;
										playingiles = NULL;
										if (SoundExist(g.temppreviewsoundoffset) == 1)
										{
											StopSound(g.temppreviewsoundoffset);
											DeleteSound(g.temppreviewsoundoffset);
										}
										std::string sSoundName = "";
										//if (strnicmp(path_for_filename.c_str(), "projectbank", 11) != NULL) 
										sSoundName = "audiobank\\";
										sSoundName = sSoundName + path_for_filename.c_str();
										sSoundName = sSoundName + "\\" + myfiles->m_sName.Get();
										LoadSound((char *) sSoundName.c_str(), g.temppreviewsoundoffset);
										if (SoundExist(g.temppreviewsoundoffset) == 1)
										{
											playingiles = myfiles;
											PlaySound(g.temppreviewsoundoffset);
											SetSoundVolume(g.temppreviewsoundoffset, 100.0);
										}
									}
									ImGui::SetCursorPos(opos);
									if (!bThumbHovered)
										bThumbHovered = ImGui::IsItemHovered();
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Play Music");
								}
							}
							else
							{
								bool bShowPreviewButton = true;
								if (myfiles->m_bIsGroupObject == true)
								{
									// do not show preview button for smart objects, no easy way to construct the preview - too many moving parts
									bShowPreviewButton = false;
								}
								if (bShowPreviewButton)
								{
									int iImageSize = 24;
									ImVec2 opos = ImGui::GetCursorPos();
									ImGui::SetCursorPos(ImVec2((opos.x + media_icon_size) - iImageSize - 2.0f, opos.y - 14.0f - iImageSize));
									ImGui::SetItemAllowOverlap();

									if (ImGui::ImgBtn(KEY_MAXIMIZE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
									{
										pPreviewFile = myfiles;
										bLargePreview = true;
										bDoBackbufferUpdate = true;
									}
									ImGui::SetCursorPos(opos);
									if (!bThumbHovered)
										bThumbHovered = ImGui::IsItemHovered();
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("Fullscreen Preview");

									if (bThumbHovered && ImGui::IsMouseDoubleClicked(0))
									{
										pPreviewFile = myfiles;
										bLargePreview = true;
										bDoBackbufferUpdate = true;
										iDelayedImgClick = 0; //Cancel last btn click.
									}
								}
							}
							//---

							// hovering over an object library item
							static void* additionalcheck = NULL;
							static cstr preload_fpe_file = "";
							static bool preload_fpe_file_started = false;
							if (iDisplayLibraryType > 0)
							{
								//Hover other media.
								static bool bTriggerTimer = false;
								if (iWaitFramesBeforeProceed == 0) //No hover while generating thumbs.
								{
									if (iDisplayLibraryType == 5 && bThumbHovered)
									{
										//Enable rotation
										iTooltipHoveredTimer = Timer();
										if (!bTriggerTimer)
										{
											iTooltipTimer = iTooltipHoveredTimer;
											bTriggerTimer = true;

										}
										//Need a little timer so old images can reload before we start another.
										if (bTriggerTimer && iTooltipHoveredTimer - iTooltipTimer > 200)
										{
											//End any old.
											if (additionalcheck && additionalcheck != myfiles)
											{
												//Must reload old icon.
												cFolderItem::sFolderFiles * tmp = (cFolderItem::sFolderFiles *) additionalcheck;
												tmp->iPreview = 0;
												additionalcheck = 0;
												BackBufferSaveCacheName = "";
												BackBufferObjectID = 0;
												BackBufferImageID = 0;
												BackBufferZoom = 0.0f;
												BackBufferCamUp = 0.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = false;
												bLoopBackBuffer = false;
											}
										}
										if (bTriggerTimer && iTooltipHoveredTimer - iTooltipTimer > 500)
										{
											if (additionalcheck != myfiles)
											{
												additionalcheck = myfiles;
												iTooltipTimer = iTooltipHoveredTimer;

												//Create particle thumb here.
												BackBufferIsGroup = false;
												BackBufferEntityID = 0;
												BackBufferObjectID = 0;
												BackBufferImageID = myfiles->iPreview;
												BackBufferSizeX = 512;
												BackBufferSizeY = 288;
												BackBufferCamLeft = 0.0f;
												bRotateBackBuffer = false;
												bBackBufferAnimated = false;
												BackBufferSaveCacheName = ""; //No saving
												//Dont fit snapshot to rubber band.
												fLastRubberBandX1 = fLastRubberBandX2 = fLastRubberBandY1 = fLastRubberBandY2 = 0.0f;
												CreateBackdropObject(false, cstr("texturebank\\backdrops\\Black backdrop.dds"), t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.

												BackBufferZoom = 800.0f;
												BackBufferCamUp = 400.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = true;
												bLoopBackBuffer = true;

												float centerx = -1000, centery = 39000, centerz = -1000;
												std::string sParticleName = myfiles->m_sPath.Get();
												sParticleName = sParticleName + "\\" + Left(myfiles->m_sName.Get(), Len(myfiles->m_sName.Get()) - 4);

												if (BackBufferParticleEmitter != -1)
												{
													gpup_deleteEffect(BackBufferParticleEmitter);
													BackBufferParticleEmitter = -1;
												}

												if (BackBufferParticleEmitter == -1)
												{
													BackBufferParticleEmitter = gpup_loadEffect(sParticleName.c_str(), 0, 0, 0, 1.0);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 0);
												}
												float fLive = 10.0f;
												if (BackBufferParticleEmitter != -1)
												{
													gpup_setGlobalPosition(BackBufferParticleEmitter, centerx, centery - 30.0f, centerz);
													gpup_resetLocalPosition(BackBufferParticleEmitter);
													gpup_setGlobalScale(BackBufferParticleEmitter, 100.0f);
													gpup_emitterActive(BackBufferParticleEmitter, 1);

													gpup_setEffectAnimationSpeed(BackBufferParticleEmitter, 1.0f);
													gpup_setEffectOpacity(BackBufferParticleEmitter, 1.0f);

												}

											}
											else
											{
												//We are running
												BackBufferZoom = 700.0f;
												BackBufferCamUp = 250.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = true;
												bLoopBackBuffer = true;
											}
										}
									}
									else if (iDisplayLibraryType == 5 && !ImGui::IsItemHovered())
									{
										if (additionalcheck == myfiles)
										{
											bTriggerTimer = false;
											if (bLoopBackBuffer)
											{
												//Disable rotation
												BackBufferSaveCacheName = "";
												BackBufferObjectID = 0;
												BackBufferImageID = 0;
												BackBufferZoom = 0.0f;
												BackBufferCamUp = 0.0f;
												bSnapShotModeUseCamera = false;
												BackBufferParticlesMode = false;
												bLoopBackBuffer = false;
												myfiles->iPreview = 0; //Reload old thumb.
												additionalcheck = NULL;
												if (BackBufferParticleEmitter != -1)
												{
													gpup_deleteEffect(BackBufferParticleEmitter);
													BackBufferParticleEmitter = -1;
												}
											}
										}
									}
								}

								if (bThumbHovered)
								{
									if (iDisplayLibraryType == 1)
									{
										//ImGui::SetTooltip("Music Media");
									}
									if (iDisplayLibraryType == 2)
									{
										//PE: Show large image preview.
										float imgw = ImageWidth(textureId);
										float imgh = ImageHeight(textureId);
										float fWidth = 500.0f;
										float fRatio = fWidth / imgw;
										if (imgw < fWidth) fRatio = 1.0f;
										ImVec2 imgsize = ImVec2(imgw*fRatio, imgh*fRatio);

										ImGui::BeginTooltip();
										float icon_ratio;
										ImGui::ImgBtn(textureId, imgsize, ImVec4(0.0, 0.0, 0.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false);
										ImGui::EndTooltip();
									}
								}
							}
							else
							{
								bool bHoverGroupActive = true;
								//if (bAdvancedFPEFeatures && myfiles->m_bIsGroupObject) bHoverGroupActive = false;
								if ( myfiles->m_bIsGroupObject) bHoverGroupActive = false; // do not allow smarts to load/generate thumbs - performance hit!
								if (bHoverGroupActive && !bImagesStillInImGuiQueue && !bLargePreview && !bBlockBackBufferUpdating && !bEntity_Properties_Window && !g_bCharacterCreatorPlusActivated && !bImporter_Window && i == 0 && bThumbHovered)
								{
									iTooltipHoveredTimer = Timer();
									if (iLastTooltipSelection != textureId || (additionalcheck != myfiles))
									{
										// new thumbnail to create
										additionalcheck = myfiles;
										iTooltipTimer = iTooltipHoveredTimer;
										iLastTooltipSelection = textureId;
										iTooltipObjectReady = false;

										// object FPE name
										std::string sFpeName = path_for_filename.c_str();
										sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
										t.addentityfile_s = sFpeName.c_str();

										// if we already have it, can show right away!
										t.talreadyloaded = 0;
										for (t.t = 1; t.t <= g.entidmaster; t.t++)
										{
											if (t.entitybank_s[t.t] == t.addentityfile_s) { t.talreadyloaded = 1; t.entid = t.t; }
										}
										if (t.talreadyloaded)
										{
											//Start rotate instant.
											CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
											GG_SetWritablesToRoot(true);
											if (FileExist(BackBufferCacheName.Get()) == 0)
											{
												// only save new thumb if not exist in root
												BackBufferSaveCacheName = BackBufferCacheName;
											}
											GG_SetWritablesToRoot(false);
											bDoBackbufferUpdate = true;
											iTooltipTimer = iTooltipHoveredTimer - 750;
											iTooltipObjectReady = true;
											preload_fpe_file = "";
										}
										else
										{
											// Preload DBO and textures shortly
											preload_fpe_file = t.addentityfile_s;
											preload_fpe_file_started = false;
										}
									}
									else
									{
										if (strlen(preload_fpe_file.Get()) == 0)
										{
											if (iTooltipObjectReady)
											{
												// showing it
											}
											else
											{
												// Generate Thumbnail of object.
												std::string sFpeName = path_for_filename.c_str();
												sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
												t.addentityfile_s = sFpeName.c_str();
												CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
												GG_SetWritablesToRoot(true);
												if (FileExist(BackBufferCacheName.Get()) == 0)
												{
													// only save new thumb if not exist in root
													BackBufferSaveCacheName = BackBufferCacheName;
												}
												GG_SetWritablesToRoot(false);
												bDoBackbufferUpdate = true;
											}
										}
										else
										{
											#ifdef PRELOAD_OBJECTS_ON_HOVER
											// wait long enough to ignore incidental scrolling past the object
											if (iTooltipHoveredTimer - iTooltipTimer > 100)
											{
												if (preload_fpe_file.Len() > 0)
												{
													// trigger this object to preload its resources, ready for the actual DBO and DDS loading
													if (preload_fpe_file_started == false)
													{
														if (object_preload_files_in_progress() == false && image_preload_files_in_progress() == false)
														{
															if (entity_load_thread_prepare(preload_fpe_file.Get()) == false)
															{
																// this file do not have a dbo version, do not preload
															}
														}
														preload_fpe_file_started = true;
													}

													// only when waited full span of progress bar do we release preload_fpe_file to start thumbn generation (small delay due to Wicked)
													if (iTooltipHoveredTimer - iTooltipTimer > 750)
													{
														preload_fpe_file = "";
													}
												}
											}
											#else
											preload_fpe_file = "";
											#endif
											if (!bInContextThumb)
											{
												//PE: Draw progress bar end
												int iVal = iTooltipHoveredTimer - iTooltipTimer;
												float progress = (float)iVal / 750;// 300;//quicker 2000.0f;
												if (progress < 0.0) progress = 0.0;
												if (progress > 1.0) progress = 1.0;
												ImVec2 opos = ImGui::GetCursorPos();
												ImVec4 backImGuiCol_PlotHistogram = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
												ImVec4 backImGuiCol_Border = ImGui::GetStyle().Colors[ImGuiCol_Border];
												ImVec4 backImGuiCol_BorderShadow = ImGui::GetStyle().Colors[ImGuiCol_BorderShadow];
												ImVec4 backImGuiCol_FrameBg = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];

												ImVec4 newBlue = ImVec4(56.0 / 255.0, 110.0 / 255.0, 145.0 / 255.0, 1);
												ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = newBlue;
												ImGui::GetStyle().Colors[ImGuiCol_Border] = ImVec4(0, 0, 0, 0);
												ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = ImVec4(0, 0, 0, 0);
												ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = ImVec4(0, 0, 0, 0);

												ImGui::SetCursorPos(ImVec2(opos.x + 4.0f, opos.y - 16.0f));
												ImGui::ProgressBar(progress, ImVec2(media_icon_size - 4.0f, 6.0f), " ");
												ImGui::SetCursorPos(opos);

												ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram] = backImGuiCol_PlotHistogram;
												ImGui::GetStyle().Colors[ImGuiCol_Border] = backImGuiCol_Border;
												ImGui::GetStyle().Colors[ImGuiCol_BorderShadow] = backImGuiCol_BorderShadow;
												ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = backImGuiCol_FrameBg;
											}
										}
									}
								}
								else
								{
									if (!ImGui::IsItemHovered() && !bLargePreview && !bImagesStillInImGuiQueue)
									{
										if (textureId >= 4000 && textureId < UIV3IMAGES && BackBufferImageID == textureId)
										{
											//Disable rotation
											BackBufferSaveCacheName = "";
											BackBufferObjectID = 0;
											BackBufferImageID = 0;
											bLoopBackBuffer = false;
											RevertBackbufferCubemap();
										
											WickedCall_SetSunDirection(t.visuals.SunAngleX, t.visuals.SunAngleY, t.visuals.SunAngleZ);
											master_renderer->setBloomEnabled(t.visuals.bBloomEnabled);
											WickedCall_MoveReflectionProbe(GGORIGIN_X, GGORIGIN_Y+5000, GGORIGIN_Z, "editorProbe", 500);
											WickedCall_EnableThumbLight(false);
											myfiles->iPreview = 0;
											additionalcheck = NULL;
										}
									}
								}
							}

							//PE: Check if we need to generate a thumb or rotate a object in the thumb view.
							bool bForceUpdate = false;
							if (bCheckGotoPreview && pPreviewFile == myfiles)
								bForceUpdate = true;

							if (!bBlockBackBufferUpdating || bForceUpdate)
							{
								if (!bDoneOneThumbPerSync && bLoadedInNewFormat)
								{
									//PE: Should we try to update old thumb to new format ?
									if (myfiles->iBigPreview == 0)
									{
										//PE: Only if it is side visible area.
										int gcpy = ImGui::GetCursorPosY();
										if (gcpy < iIconVisiblePosY && gcpy >= ImGui::GetScrollY() - media_icon_size)
										{
											std::string sFpeName = path_for_filename.c_str();
											sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
											t.addentityfile_s = sFpeName.c_str();
											CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
											GG_SetWritablesToRoot(true);
											if (!FileExist(BackBufferCacheName.Get()))
											{
												bLoadedInNewFormat = false; //Try it.
											}
											GG_SetWritablesToRoot(false);
										}
									}
								}
								if ((bDoBackbufferUpdate || !bLoadedInNewFormat) && !bDoneOneThumbPerSync)
								{
									std::string sFpeName = path_for_filename.c_str();
									sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
									t.addentityfile_s = sFpeName.c_str();

									// LB: delay actual entity_load (takes >1s due to Wicked obj setup in scene!)
									bool update = true;
									if (preload_fpe_file.Len() > 0)
									{
										//PE: This ruins thumb updating we must always have update so...
										if (!bDoBackbufferUpdate && bLoadedInNewFormat)
										{
											update = false;
											if (iTooltipHoveredTimer - iTooltipTimer > 750)
											{
												// this extension allows user to hover and click without getting the freeze
												update = true;
											}
										}
									}

									if (!bDoBackbufferUpdate && !bLoadedInNewFormat)
									{
										CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
										GG_SetWritablesToRoot(true);
										if (FileExist(BackBufferCacheName.Get()) == 0)
										{
											// only save new thumb if not exist in root
											BackBufferSaveCacheName = BackBufferCacheName;
										}
										GG_SetWritablesToRoot(false);

										//PE: Triggered auto.
										if (myfiles->iBigPreview == 0)
										{
											myfiles->iBigPreview = TOOL_ENTITY;
											//PE: Update image in next run.
											if (myfiles->iPreview > 0)
											{
												if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) { //PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
													iDeleteInNextUpdate = myfiles->iPreview;
												}
											}
											myfiles->iPreview = 0;
										}
										else
										{
											update = false;
										}
									}
									if (update)
									{
										int iEntIDWas = 0;
										bool bIsGroup = false;
										cstr EntWas_s = t.addentityfile_s;
										if (iDisplayLibrarySubType == 1)
										{
											// Animations
											t.entdir_s = "charactercreatorplus\\animations\\";
										}
										else
										{
											// Objects
											t.entdir_s = "entitybank\\";
											if (cstr(Lower(Left(t.addentityfile_s.Get(), 11))) == "entitybank\\")
											{
												t.addentityfile_s = Right(t.addentityfile_s.Get(), Len(t.addentityfile_s.Get()) - 11);
											}
											if (cstr(Lower(Left(t.addentityfile_s.Get(), 8))) == "ebebank\\")
											{
												t.entdir_s = "";
											}
											#ifndef NEWPROJSYSWORKINPROGRESS
											if (cstr(Lower(Left(t.addentityfile_s.Get(), 12))) == "projectbank\\")
											{
												t.entdir_s = "";
											}
											#endif
										}

										t.talreadyloaded = 0;
										for (t.t = 1; t.t <= g.entidmaster; t.t++)
										{
											if (t.entitybank_s[t.t] == t.addentityfile_s) { t.talreadyloaded = 1; t.entid = t.t; }
										}
										if (t.talreadyloaded == 1)
										{
											//PE: Check ,if group.
											if (t.entityprofile[t.entid].model_s == "group" && t.entityprofile[t.entid].groupreference == 1)
											{
												cstr tmp = cstr("entitybank\\") + t.addentityfile_s;
												extern int GetGroupIndexFromName(cstr sLookFor);
												int groupID = GetGroupIndexFromName(tmp);
												if (groupID >= 0 && groupID < MAXGROUPSLISTS)
												{
													bIsGroup = true;
													g_LastGroupSaved_s = t.entitybank_s[t.entid];
													iEntIDWas = t.entid;


													for (int i = 0; i < vEntityGroupList[groupID].size(); i++)
													{
														// first update object from final entity element data
														int e = vEntityGroupList[groupID][i].e;
														int entid = t.entityelement[e].bankindex;
														if (t.entityprofile[entid].ismarker == 0)
														{
															// use this one!
															t.entid = entid;
															break;
														}
													}
													if (!bLargePreview)
													{
														//PE: Drop rotate if we already got the original group thumb.
														CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
														GG_SetWritablesToRoot(true);
														if (FileExist(BackBufferCacheName.Get()))
														{
															update = false;
														}
														GG_SetWritablesToRoot(false);
													}
												}
											}
										}
											
										if (t.talreadyloaded == 0)
										{
											// Allocate one more entity item in array
											if (g.entidmaster > g.entitybankmax - 4)
											{
												Dim(t.tempentitybank_s, g.entitybankmax);
												for (t.t = 0; t.t <= g.entitybankmax; t.t++) t.tempentitybank_s[t.t] = t.entitybank_s[t.t];
												++g.entitybankmax;
												UnDim(t.entitybank_s);
												Dim(t.entitybank_s, g.entitybankmax);
												for (t.t = 0; t.t <= g.entitybankmax - 1; t.t++) t.entitybank_s[t.t] = t.tempentitybank_s[t.t];
											}

											bool bAutoGenerateThumb = false;
											if (!bDoBackbufferUpdate)
											{
												bAutoGenerateThumb = true;
											}

											//  Add entity to bank
											if (!bAutoGenerateThumb)
												++g.entidmaster;

											entity_validatearraysize();

											//  Load extra entity
											t.entid = g.entidmaster;

											//PE: Try to use index 0 on all auto generated thumbs.
											if (bAutoGenerateThumb)
												t.entid = 0;

											t.entitybank_s[t.entid] = t.addentityfile_s;
											iEntIDWas = t.entid;

											if (ObjectExist(g.entitybankoffset + t.entid)) 
											{
												//PE: We use a before/after list to free all used textures later.
												DeleteObject(g.entitybankoffset + t.entid);
											}

											t.ent_s = t.entitybank_s[t.entid];
											t.entpath_s = getpath(t.ent_s.Get());

											extern bool g_bGracefulWarningAboutOldXFiles;
											extern bool g_bDisplayWarnings;
											g_bGracefulWarningAboutOldXFiles = true;
											g_bDisplayWarnings = false;
											extern cstr g_sTempGroupForThumbnail;
											if (g_sTempGroupForThumbnail.Len() > 0)
											{
												extern int GetGroupIndexFromName (cstr sLookFor);
												current_selected_group = GetGroupIndexFromName(g_sTempGroupForThumbnail);
												UnGroupSelected(true);
												gridedit_deleteentityrubberbandfrommap();
												gridedit_clearentityrubberbandlist();
												g_sTempGroupForThumbnail = "";
											}
											extern int g_iAbortedAsEntityIsGroupFileMode;
											g_iAbortedAsEntityIsGroupFileMode = 1;
											extern int thumb_selected_group;
											thumb_selected_group = -1;
											g.thumbentityrubberbandlist.clear();
											
											bool bcalledfromlibrary = true; 
											if(bLargePreview) bcalledfromlibrary = false;

											if (entity_load(bcalledfromlibrary) == false)
											{
												// entity was a group object (smart object)
												if (thumb_selected_group >= 0)
													g_sTempGroupForThumbnail = sEntityGroupListName[thumb_selected_group];
												else
													g_sTempGroupForThumbnail = "";
												bIsGroup = true;

												g_LastGroupSaved_s = t.entitybank_s[iEntIDWas];

												// undo entry, it is NOT an entity of its own!
												t.entitybank_s[iEntIDWas] = "";

												// so scan group loaded and find first object that is not a marker (to display in preview)
												for (int i = 0; i < g.thumbentityrubberbandlist.size(); i++)
												{
													// first update object from final entity element data
													int e = g.thumbentityrubberbandlist[i].e;
													int entid = t.entityelement[e].bankindex;
													if (t.entityprofile[entid].ismarker == 0)
													{
														// use this one!
														t.entid = entid;
														break;
													}
												}

												if (!bLargePreview)
												{
													//PE: Drop rotate if we already got the original group thumb.
													CreateBackBufferCacheName(t.addentityfile_s.Get(), thumb_x, thumb_y);
													GG_SetWritablesToRoot(true);
													if (FileExist(BackBufferCacheName.Get()))
													{
														update = false;
													}
													GG_SetWritablesToRoot(false);
												}
											}
											g_bDisplayWarnings = true;
											g_bGracefulWarningAboutOldXFiles = false;

											HideObject(g.entitybankoffset + t.entid);
											if (t.entityprofile[t.entid].ischaracter == 1) 
											{
												RotateObject(g.entitybankoffset + t.entid, 0, 180, 0);
											}

											//entity_load can change folder by creating a dbo , so update timestamp without refresh.
											struct stat sb;
											if (stat(pNewFolder->m_sFolderFullPath.Get(), &sb) == 0) 
											{
												if (sb.st_mtime != pNewFolder->m_tFolderModify) 
												{
													pNewFolder->m_tFolderModify = sb.st_mtime;
												}
											}
										}

										if (update)
										{
											iTooltipLastObjectId = t.entid;
											iTooltipAlreadyLoaded = t.talreadyloaded;
											iTooltipObjectReady = true;

											BackBufferIsGroup = bIsGroup;
											BackBufferEntityID = t.entid;
											BackBufferObjectID = g.entitybankoffset + t.entid;
											BackBufferImageID = g.importermenuimageoffset + 50;

											BackBufferRotateZ = ObjectAngleZ(BackBufferObjectID);
											BackBufferRotateY = ObjectAngleY(BackBufferObjectID) + 15;
											BackBufferRotateX = ObjectAngleX(BackBufferObjectID);
											BackBufferZoom = 1.0f;
											BackBufferCamLeft = 0.0f;
											BackBufferCamUp = 0.0f;

											if (bLargePreview)
											{
												iLargePreviewImageID = BackBufferImageID;
												BackBufferSizeX = thumb_x * 2.0f;
												BackBufferSizeY = thumb_y * 2.0f;
											}
											else
											{
												BackBufferSizeX = thumb_x;
												BackBufferSizeY = thumb_y;
											}
											if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
											{
												//PE: Stop any running animations. set default pose.
												int iFrameStart = t.entityanim[BackBufferEntityID][0].start;
												SetObjectFrame(BackBufferObjectID, iFrameStart);
											}
											BackBufferZoom = 1.0f;
											BackBufferCamLeft = 0.0f;
											BackBufferCamUp = 0.0f;
											bRotateBackBuffer = false;
											bBackBufferAnimated = false;
											bLoopBackBuffer = false;
											RevertBackbufferCubemap();

											//PE: We must enable editor light here, so its ready for the next frame where we grab the backbuffer.
											if (!bDoBackbufferUpdate)
											{
												WickedCall_EnableThumbLight(true);
											}

											if (bDoBackbufferUpdate)
											{
												if (textureId >= 4000 && textureId < UIV3IMAGES)
												{
													if (bLargePreview)
														bRotateBackBuffer = false;
													else
														bRotateBackBuffer = true;
												}
											}

											//PE: Prefer myfiles->m_Backdrop it has the latest changes.
											if (!(t.entityprofile[t.entid].BackBufferZoom == -1.0f && t.entityprofile[t.entid].BackBufferCamLeft == -1.0f && t.entityprofile[t.entid].BackBufferRotateX == -1.0f))
											{
												//Found settings, set restore.
												RestoreBackBufferZoom = t.entityprofile[t.entid].BackBufferZoom;
												RestoreBackBufferCamLeft = t.entityprofile[t.entid].BackBufferCamLeft;
												RestoreBackBufferCamUp = t.entityprofile[t.entid].BackBufferCamUp;
												RestoreBackBufferRotateX = t.entityprofile[t.entid].BackBufferRotateX;
												RestoreBackBufferRotateY = t.entityprofile[t.entid].BackBufferRotateY;
												bBackBufferRestoreCamera = true; //Restore from fpe settings in next call.

												if (ObjectExist(BackBufferObjectID) && GetNumberOfFrames(BackBufferObjectID) > 0 && t.entityprofile[BackBufferEntityID].animmax > 0)
												{
													if (t.entityprofile[BackBufferEntityID].iThumbnailAnimset >= 0 && t.entityprofile[BackBufferEntityID].iThumbnailAnimset < t.entityprofile[BackBufferEntityID].startofaianim)
													{
														// new method uses name instead of fixed values
														if (t.entityprofile[BackBufferEntityID].playanimineditor == -1)
														{
															// uses name instead of index, the negative is the ordinal into the animset
															extern void entity_loop_using_negative_playanimineditor(int e, int obj, cstr animname);
															entity_loop_using_negative_playanimineditor(0, BackBufferObjectID, t.entityprofile[BackBufferEntityID].playanimineditor_name);
														}
														else
														{
															int iAnimationSet = t.entityprofile[BackBufferEntityID].iThumbnailAnimset;
															int iFrameStart = t.entityanim[BackBufferEntityID][iAnimationSet].start;
															int iFrameEnd = t.entityanim[BackBufferEntityID][iAnimationSet].finish;
															SetObjectFrame(BackBufferObjectID, iFrameStart);
															LoopObject(BackBufferObjectID, iFrameStart, iFrameEnd);
														}
														bBackBufferAnimated = true;
													}
													if (bBackBufferAnimated == true)
													{
														if (t.entityprofile[BackBufferEntityID].animspeed > 0)
														{
															t.tanimspeed_f = t.entityprofile[BackBufferEntityID].animspeed;
															SetObjectSpeed(BackBufferObjectID, t.tanimspeed_f);
														}
													}
												}
											}

											if (bIsGroup == true)
											{
												CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + t.entityprofile[iEntIDWas].thumbnailbackdrop, EntWas_s);
											}
											else
											{
												if (myfiles->m_Backdrop.Len() > 0)
												{
													CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + myfiles->m_Backdrop, t.addentityfile_s); //PE: We need a extra frame, as we set the material dirty in this call.
												}
												else
												{
													if (t.entityprofile[t.entid].thumbnailbackdrop.Len() > 0)
														CreateBackdropObject(false, cstr("texturebank\\backdrops\\") + t.entityprofile[t.entid].thumbnailbackdrop, t.addentityfile_s);
													else
														CreateBackdropObject(false, "None", t.addentityfile_s);
												}
											}

											if (bDoBackbufferUpdate)
											{
												//BackBufferSizeX = 512;
												//BackBufferSizeY = 512;
												BackBufferSaveCacheName = ""; //No saving on tooltip images

												if (textureId >= 4000 && textureId < UIV3IMAGES)
												{
													BackBufferRotateZ = ObjectAngleZ(BackBufferObjectID);
													BackBufferRotateY = ObjectAngleY(BackBufferObjectID) + 15;
													BackBufferRotateX = ObjectAngleX(BackBufferObjectID);
													BackBufferZoom = 1.0f;
													BackBufferCamLeft = 0.0f;
													BackBufferCamUp = 0.0f;
													if (bLargePreview)
														bRotateBackBuffer = false;
													else
														bRotateBackBuffer = true;
													BackBufferImageID = textureId;
													iLargePreviewImageID = BackBufferImageID;
													bLoopBackBuffer = true;
												}
											}

											if (bForceUpdate)
											{
												BackBufferRotateZ = ObjectAngleZ(BackBufferObjectID);
												BackBufferRotateY = ObjectAngleY(BackBufferObjectID) + 15;
												BackBufferRotateX = ObjectAngleX(BackBufferObjectID);
												BackBufferZoom = 1.0f;
												BackBufferCamLeft = 0.0f;
												BackBufferCamUp = 0.0f;
												bRotateBackBuffer = false;
												bLoopBackBuffer = true;
											}

											bDoneOneThumbPerSync = true;
										}
										else
										{
											bRotateBackBuffer = false;
											bLoopBackBuffer = false;
										}
									}
								}
							}

							ImGui::PopStyleVar();

							ImGui::PopID();
							ImGui::PushID(uniqueId + 30000);
							ImVec2 opos = ImGui::GetCursorPos();

							if (myfiles->bFavorite)
							{
								int iImageSize = 20;
								ImGui::SetCursorPos(ImVec2(opos.x + 12.0f, opos.y - 16.0f - iImageSize));
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(MEDIA_FAVORITE, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
								{
									//Remove from favorite.
									cstr file = myfiles->m_sPath;
									file = file + "\\" + myfiles->m_sName.Get();
									file = file.Lower();
									extern std::vector<std::string> files_favorite;
									myfiles->bFavorite = false;
									for (int i = 0; i < files_favorite.size(); i++)
									{
										cstr check = cstr((char *)files_favorite[i].c_str()).Lower();
										if (file == check)
										{
											//Delete.
											files_favorite.erase(files_favorite.begin() + i);
										}
									}
									saveVectorFileContent("favoritelist.ini", files_favorite);
								}
								ImGui::SetCursorPos(opos);
								if (!bThumbHovered)
									bThumbHovered = ImGui::IsItemHovered();
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Remove From Favourite");
							}
							else
							{
								int iImageSize = 20;
								ImVec2 opos = ImGui::GetCursorPos();
								ImGui::SetCursorPos(ImVec2(opos.x + 12.0f, opos.y - 16.0f - iImageSize));
								ImGui::SetItemAllowOverlap();
								if (ImGui::ImgBtn(MEDIA_FAVORITE_DIS, ImVec2(iImageSize, iImageSize), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
								{
									//Add to favorite.
									cstr file = myfiles->m_sPath;
									file = file + "\\" + myfiles->m_sName.Get();
									extern std::vector<std::string> files_favorite;
									myfiles->bFavorite = true;
									files_favorite.push_back(file.Get());
									saveVectorFileContent("favoritelist.ini", files_favorite);
								}
								ImGui::SetCursorPos(opos);
								if (!bThumbHovered)
									bThumbHovered = ImGui::IsItemHovered();
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add to Favourite");
							}

							if (bDisplayText)
							{
								if (iDisplayLibraryType == 4)
								{
									char cDisplayName[MAX_PATH];
									strcpy (cDisplayName, sFinal.c_str());
									FormatLUAFilenameToTitle(cDisplayName);
									sFinal = cstr(cstr(cDisplayName) + myfiles->m_sNameFinalCredit.Get()).Get();
									ImGui::Text("%s", sFinal.c_str());
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", sFinal.c_str());

									if (myfiles && myfiles->m_sDLuaDescription.Get())
									{
										if (myfiles->m_sDLuaDescription != "")
										{
											//Always use same size box on all DLUA boxes. looks better.
											ImGui::BeginChild("##DLUADescriptionbox", ImVec2(media_icon_size, (ImGui::GetTextLineHeight() * 5) - 7.0f), true, ImGuiWindowFlags_NoMove); //| ImGuiWindowFlags_AlwaysUseWindowPadding
											ImGui::TextWrapped("%s", myfiles->m_sDLuaDescription.Get()); 
											ImGui::EndChild();
											ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, ImGui::GetCursorPos().y + 3.0f));
										}
									}
								}
								else
								{
									std::string sFinalForDisplay = sFinal + myfiles->m_sNameFinalCredit.Get();
									if (iDisplayLibraryType == 0)
									{
										ImGui::Text("  %s", sFinalForDisplay.c_str());
									}
									else
									{
										ImGui::Text("%s", sFinalForDisplay.c_str());
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", sFinalForDisplay.c_str());
								}
							}

							if (bSecondScrollActive && secondscrolltofile && secondscrolltofile == myfiles)
							{
								secondscrolltofile = NULL;
								//PE: Test second scrool if list is correct.
								if (imgui_GetMinMaxButtonState(0))
								{
									//Full screen.
									if (ImGui::GetCursorPosY() > (media_icon_size*0.75))
										ImGui::SetScrollY(ImGui::GetCursorPosY()); //+(media_icon_size*0.5));
									else
										ImGui::SetScrollY(0.0f);
								}
								else
								{
									float cpy = ImGui::GetCursorPosY();
									float scy = ImGui::GetScrollY();
									if (cpy > (media_icon_size*0.75))
									{
										//PE: Try DirectPosition.y;
										if (0)
										{
											ImGui::SetScrollY(DirectPosition.y);
										}
										else
										{
											if (cpy < ((media_icon_size*3.0)*0.75))
											{
												ImGui::SetScrollY(0.0);
											}
											else if (scy > 0 && cpy > (media_icon_size*2.0))
											{
												ImGui::SetScrollY(cpy - (media_icon_size*2.0));
											}
											else if (scy > 0 && cpy > (media_icon_size))
											{
												ImGui::SetScrollY(cpy - (media_icon_size));
											}
											else
											{
												ImGui::SetScrollY(DirectPosition.y + (media_icon_size*0.75));
											}
										}
									}
									else
										ImGui::SetScrollY(0.0f);
								}

							}
							//PE: Check if we need to adjust scroll after a window resize.
							if (!firstvisiblefile && scrolltofile && scrolltofile == myfiles)
							{
								if (bScrollInNextFrame)
								{
									firstvisiblefile = scrolltofile;
									bScrollInNextFrame = false;
								}
								else
								{
									firstvisiblefile = scrolltofile;
									secondscrolltofile = scrolltofile;
									bSecondScrollActive = false;
									scrolltofile = NULL;
									if (imgui_GetMinMaxButtonState(0))
									{
										//Full screen.
										if (ImGui::GetCursorPosY() > (media_icon_size*0.75))
											ImGui::SetScrollY(ImGui::GetCursorPosY()); //+(media_icon_size*0.5));
										else
											ImGui::SetScrollY(0.0f);
									}
									else
									{
										float cpy = ImGui::GetCursorPosY();
										float scy = ImGui::GetScrollY();
										if (cpy > (media_icon_size*0.75))
										{
											//PE: Try DirectPosition.y;
											if (0)
											{
												ImGui::SetScrollY(DirectPosition.y);
											}
											else
											{
												if (cpy < ((media_icon_size*3.0)*0.75))
												{
													ImGui::SetScrollY(0.0);
												}
												else if (scy > 0 && cpy > (media_icon_size*2.0))
												{
													ImGui::SetScrollY(cpy - (media_icon_size*2.0));
												}
												else if (scy > 0 && cpy > (media_icon_size))
												{
													ImGui::SetScrollY(cpy - (media_icon_size));
												}
												else
												{
													ImGui::SetScrollY(DirectPosition.y + (media_icon_size*0.75) );
												}
											}
										}
										else
											ImGui::SetScrollY(0.0f);
									}
								}
							}

							//PE: Draw selection last so we can overlap spacing.
							if( (myfiles->iFlags == 1 || selectedmediafile == myfiles) && bVisibleOnScreen)
							{
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								ImVec4 bg_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram]; // { 0.0, 0.0, 0.0, 1.0 };
								window->DrawList->AddRect(selection_bb.Min, selection_bb.Max, ImGui::GetColorU32(bg_col), 0.0f, 0, 3.0f);
							}

							//PE: Right click context menu removed from design.
							/*
							if (0)
							{
								static cFolderItem::sFolderFiles * ContextSelection = NULL;
								if (bThumbHovered || ContextSelection == myfiles)
								{
									if (!bInContextThumb || ContextSelection == myfiles)
									{
										if (ImGui::BeginPopupContextWindow())
										{
											bInContextThumb = true;
											ContextSelection = myfiles;
											if (ImGui::MenuItem("Update Thumbnail"))
											{
												std::string sFpeName = path_for_filename.c_str();
												sFpeName = sFpeName + "\\" + myfiles->m_sName.Get();
												t.addentityfile_s = sFpeName.c_str();
												CreateBackBufferCacheNameEx(t.addentityfile_s.Get(), thumb_x, thumb_y, true);
												GG_SetWritablesToRoot(true);
												if (FileExist(BackBufferCacheName.Get()))
												{
													DeleteAFile(BackBufferCacheName.Get());
													if (myfiles->iPreview > 0)
													{
														if (GetImageExistEx(myfiles->iPreview) && myfiles->iPreview >= 4000 && myfiles->iPreview < UIV3IMAGES) 
														{ 
															//PE: Need to protect system images after tool img range has changed. (myfiles->iPreview can be a system icon)
															iDeleteInNextUpdate = myfiles->iPreview;
														}
													}
													myfiles->iPreview = 0;
													myfiles->iBigPreview = 0;
												}
												GG_SetWritablesToRoot(false);
												ContextSelection = NULL;
											}

											if (myfiles->bFavorite)
											{
												if (ImGui::MenuItem("Remove Favourite"))
												{
													cstr file = myfiles->m_sPath;
													file = file + "\\" + myfiles->m_sName.Get();
													extern std::vector<std::string> files_favorite;
													myfiles->bFavorite = false;
													//Remove.
													auto itr = std::find(files_favorite.begin(), files_favorite.end(), file.Get());
													if (itr != files_favorite.end())
														files_favorite.erase(itr);
													saveVectorFileContent("favoritelist.ini", files_favorite);
													ContextSelection = NULL;
												}
											}
											else
											{
												if (ImGui::MenuItem("Add to Favourite"))
												{
													cstr file = myfiles->m_sPath;
													file = file + "\\" + myfiles->m_sName.Get();
													extern std::vector<std::string> files_favorite;
													myfiles->bFavorite = true;
													files_favorite.push_back(file.Get());
													saveVectorFileContent("favoritelist.ini", files_favorite);
													ContextSelection = NULL;
												}
											}
											ImGui::EndPopup();
										}
										else
											bInContextThumb = false;
									}
								}
							}
							*/
							ImGui::NextColumn();
						}
						ImGui::PopID();
						preview_count++;
					}
					ImGui::SetWindowFontScale(1.0);

				} //bValid

			} //#### MAIN LOOP iLoop < sorted_files.size() ####

			ImGui::EndColumns();

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) 
			{
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}
		}

		if (!bAnySelectedItemsAvailable) 
		{
			//PE: We got no selections , we can reset first shift seen.
			if (!io.KeyShift) 
			{
				firstShiftFile = NULL;
			}
		}
		ImGui::SetWindowFontScale(1.0);

		ImRect bbwinclient(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
		if (ImGui::IsMouseHoveringRect(bbwinclient.Min, bbwinclient.Max))
		{
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}
		if (ImGui::IsAnyItemFocused()) 
		{
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}
		
		ImGui::EndChild();

		ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
		if (ImGui::IsMouseHoveringRect(bbwin.Min - ImVec2(1, 1), bbwin.Max , false))
		{
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}
		if (ImGui::IsAnyItemFocused()) 
		{
			bImGuiGotFocus = true;
			bEntityGotFocus = true;
		}

		ImGui::Indent(10);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, ImGui::GetCursorPos().y+1.0f));

		ImGui::PushItemWidth(150.f);
		float fSliderPos = ImGui::GetContentRegionAvailWidth() - 150.0f - 16.0f;
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + fSliderPos, ImGui::GetCursorPos().y + 7.0f));
		ImGui::SetWindowFontScale(0.6);
		int iMaxSlider = 8;
		if (fSliderPos > 820) iMaxSlider++;
		if (fSliderPos > 1000) iMaxSlider++;
		if (pref.iSetColumnsEntityLib > iMaxSlider) pref.iSetColumnsEntityLib = iMaxSlider;
		if (pref.iSetColumnsEntityLib < 1) pref.iSetColumnsEntityLib = 1;

		ImGui::SliderInt("##fScaleIcons", &pref.iSetColumnsEntityLib, 1, iMaxSlider, " ");
		ImGui::SetWindowFontScale(1.0);
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Columns %d" , pref.iSetColumnsEntityLib);
		ImGui::PopItemWidth();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, ImGui::GetCursorPos().y +7.0f));

		//PE: Display new buttons.
		int iButtons = 3;
		if (lf_multi_selections_count > 0)
			iButtons++;

		ImVec2 vContentSize = ImGui::GetContentRegionAvail();
		float fButWidth = vContentSize.x / iButtons;
		fButWidth -= 10.0f; //But spacing.
		if (fButWidth < 30.0f)
			fButWidth = 30.0f;

		float fFontSize = ImGui::GetFontSize();
		ImGui::SetWindowFontScale(1.4);

		if (bTriggerCloseEntityWindow)
		{
			bCheckForClosing = true;
			bTriggerCloseEntityWindow = false;
		}

		if (iDisplayLibraryType > 0)
		{
			//###############
			//#### Audio ####
			//###############

			if (iDisplayLibraryType == 1) //Music
			{
				int buts = 2;
				if (selectedmediafile != NULL) buts = 3;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;
				// Marketplace
				#ifndef GGMAXEDU
				if (ImGui::StyleButton("Get More Music and Sound", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click to get more Music and Sound");
				#endif
				// Direct import here
				if (1)
				{
					static int import_process = 0;
					static cstr import_filename = "";
					static char import_name[MAX_PATH];
					if (import_process == 1)
					{
						static char import_to[MAX_PATH];
						strcpy(import_to, "audiobank\\users"); //currently fixed.

						bool bValid = true;
						if (strlen(import_name) < 1 || import_filename.Len() < 1)
						{
							bValid = false;
							import_process = 0; //Cancel.
						}
						if (bValid)
						{
							extern char g_pAbsPathToConverter[MAX_PATH];
							std::string process_name = g_pAbsPathToConverter;
							replaceAll(process_name, "\\Guru-Converter.exe", "\\ffmpeg.exe");
							HANDLE g_hConvertImportTOOggProcess = NULL;
							DARKSDK BOOL DB_ExecuteFile(HANDLE* phExecuteFileProcess, char* Operation, char* Filename, char* String, char* Path, bool bWaitForTermination);
							char parameters[MAX_PATH];
							char destination[MAX_PATH];
							strcpy(destination, "audiobank\\user\\");
							strcat(destination, import_name);

							//PE: Simple import , no options, so always to .wav
							//PE: use -y -i to always overwrite.
							if (0) //ogg
							{
								strcat(destination, ".ogg");
								GG_GetRealPath(destination, 1);
								strcpy(parameters, "-y -i \"");
								strcat(parameters, import_filename.Get());
								strcat(parameters, "\" -c:a libvorbis -q:a 4 \"");
								strcat(parameters, destination);
								strcat(parameters, "\"");
							}
							else
							{
								strcat(destination, ".wav");
								GG_GetRealPath(destination, 1);
								strcpy(parameters, "-y -i \"");
								strcat(parameters, import_filename.Get());
								strcat(parameters, "\" \"");
								strcat(parameters, destination);
								strcat(parameters, "\"");
							}

							::SetCursor(::LoadCursor(NULL, IDC_WAIT));
							DB_ExecuteFile(&g_hConvertImportTOOggProcess, "hide", (char *)process_name.c_str(), parameters, "", true);
							int iTimeout = 4000;
							int iRunning = 1;
							while (iRunning == 1)
							{
								iRunning = 0;
								DWORD dwStatus;
								if (GetExitCodeProcess(g_hConvertImportTOOggProcess, &dwStatus) == TRUE)
									if (dwStatus == STILL_ACTIVE)
										iRunning = 1;
								Sleep(1);
								if (iTimeout-- <= 0) iRunning = 0; //Timeout 4 sec.
							}
							CloseHandle(g_hConvertImportTOOggProcess);
							::SetCursor(::LoadCursor(NULL, IDC_ARROW));

							//Done close down.
							import_process = 0;
							iLastDisplayLibraryType = -1; //Update search and refresh if any new files found.
							sStartLibrarySearchString = "user";
						}
					}
					if (import_process == 2)
					{
						import_process = 1; //Need a frame for triggermessage
					}
					if (import_process == 0)
					{
						ImGui::SameLine();
						if (ImGui::StyleButton("Import Music And Sound", ImVec2(fButWidth, fFontSize*2.0)))
						{
							//Select File.
							//Select name.
							//Convert and copy to 'audiobank/users'.
							//ffmpeg can be used.
							cStr tOldDir = GetDir();
							char * cFileSelected;
							cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.mp3;*.wav;*.ogg\0mp3\0*.mp3\0wav\0*.wav\0ogg\0*.ogg\0", g.mysystem.mapbankAbs_s.Get(), NULL);
							SetDir(tOldDir.Get());
							if (cFileSelected && strlen(cFileSelected) > 0)
							{
								import_filename = cFileSelected;

								//import_name
								cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
								cstr tmp = importer_getfilenameonly(import_filename.Get());
								strcpy(import_name, tmp.Get());
								if (tmp.Len() > 4)
								{
									import_name[strlen(import_name) - 4] = 0;
								}
								import_process = 1;
								sprintf(cTriggerMessage, "Importing");
								bTriggerMessage = true;
							}
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to import Music or Sound");
					}
				}
				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						//Stop anything playing.
						if (SoundExist(MEDIA_PLAY) == 1)
						{
							StopSound(MEDIA_PLAY);
							DeleteSound(MEDIA_PLAY);
						}
						if (SoundExist(g.temppreviewsoundoffset) == 1)
						{
							StopSound(g.temppreviewsoundoffset);
							DeleteSound(g.temppreviewsoundoffset);
						}

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;


						std::string path_for_filename = final_name;
						std::string sSoundName = "";
						if (iDisplayLibraryType == 1)
						{
							//if (strnicmp(path_for_filename.c_str(), "projectbank", 11) != NULL) 
							sSoundName = "audiobank\\";
						}
						sSoundName = sSoundName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sSoundName = sSoundName + selectedmediafile->m_sName.Get();
						else
							sSoundName = sSoundName + "\\" + selectedmediafile->m_sName.Get();
						if (sSoundName != "")
						{
							sSelectedLibrarySting = sSoundName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;

							// if remote project, copy over to that
							extern bool entity_copytoremoteifnotthere(LPSTR);
							entity_copytoremoteifnotthere((LPSTR)sSoundName.c_str());
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected");
				}
			}

			//################
			//#### Images ####
			//################

			if (iDisplayLibraryType == 2) //Images
			{
				int buts = 1;
				if (selectedmediafile != NULL) buts = 2;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;

				if (ImGui::StyleButton("Import Image", ImVec2(fButWidth, fFontSize*2.0)))
				{
					static char picture_default_folder[MAX_PATH] = "\0";
					if (strlen(picture_default_folder) <= 0)
					{
						//Init. 
						if ((SHGetFolderPathA(NULL, CSIDL_COMMON_PICTURES, NULL, 0, &picture_default_folder[0])) != S_OK)
						{
							//Failed try another.
							if ((SHGetFolderPathA(NULL, CSIDL_MYPICTURES, NULL, 0, &picture_default_folder[0])) != S_OK)
							{
								//Failed try another.
								if ((SHGetFolderPathA(NULL, CSIDL_COMMON_DOCUMENTS, NULL, 0, &picture_default_folder[0])) != S_OK)
								{
									strcpy(picture_default_folder, "c:\\");
								}
							}
						}
					}
					//
					cStr tOldDir = GetDir();
					char * cFileSelected;
					cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "all\0*.*\0png\0*.png\0jpg\0*.jpg\0jpeg\0*.jpeg\0dds\0*.dds\0bmp\0*.bmp\0jpeg\0*.jpeg\0", picture_default_folder, NULL ,true);
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0)
					{
						cstr import_filename = cFileSelected;
						strcpy(picture_default_folder, cFileSelected);
						//import_name
						cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
						cstr tmp = importer_getfilenameonly(import_filename.Get());

						char destination[MAX_PATH];
						strcpy(destination, "imagebank\\user\\");
						strcat(destination, tmp.Get());
						GG_GetRealPath(destination, 1);
						CopyFileA(import_filename.Get(), destination, false);

						iLastDisplayLibraryType = -1; //Update search and refresh if any new files found.
						sSelectedLibrarySting = "";
						sStartLibrarySearchString = "user";
					}
				}
				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected Image", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string sImageName = "";

						sImageName = "imagebank\\";
						sImageName = sImageName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sImageName = sImageName + selectedmediafile->m_sName.Get();
						else
							sImageName = sImageName + "\\" + selectedmediafile->m_sName.Get();
						if (sImageName != "")
						{
							sSelectedLibrarySting = sImageName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;

							// if remote project, copy over to that
							extern bool entity_copytoremoteifnotthere(LPSTR);
							entity_copytoremoteifnotthere((LPSTR)sImageName.c_str());
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Image");
				}
			}

			//###############
			//#### Video ####
			//###############

			if (iDisplayLibraryType == 3) //Video
			{
				int buts = 1;
				if (selectedmediafile != NULL) buts = 2;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;


				if (ImGui::StyleButton("Import Video", ImVec2(fButWidth, fFontSize * 2.0)))
				{
					static char video_default_folder[MAX_PATH] = "\0";
					if (strlen(video_default_folder) <= 0)
					{
						//Init. 
						if ((SHGetFolderPathA(NULL, CSIDL_COMMON_VIDEO, NULL, 0, &video_default_folder[0])) != S_OK)
						{
							//Failed try another.
							if ((SHGetFolderPathA(NULL, CSIDL_MYVIDEO, NULL, 0, &video_default_folder[0])) != S_OK)
							{
								//Failed try another.
								if ((SHGetFolderPathA(NULL, CSIDL_COMMON_DOCUMENTS, NULL, 0, &video_default_folder[0])) != S_OK)
								{
									strcpy(video_default_folder, "c:\\");
								}
							}
						}
					}
					//
					cStr tOldDir = GetDir();
					char* cFileSelected;
					//WMV,MP4
					cFileSelected = (char*)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "all\0*.*\0MP4\0*.MP4\0WMV\0*.WMV\0", video_default_folder, NULL, true);
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0)
					{
						cstr import_filename = cFileSelected;
						strcpy(video_default_folder, cFileSelected);
						//import_name
						cstr importer_getfilenameonly(LPSTR pFileAndPossiblePath);
						cstr tmp = importer_getfilenameonly(import_filename.Get());

						char destination[MAX_PATH];
						strcpy(destination, "videobank\\user\\");
						strcat(destination, tmp.Get());
						GG_GetRealPath(destination, 1);
						CopyFileA(import_filename.Get(), destination, false);
						iLastDisplayLibraryType = -1; //Update search and refresh if any new files found.
						sSelectedLibrarySting = "";
						sStartLibrarySearchString = "user";
					}
				}
				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected Video", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string sVideoName = "";
						if (iDisplayLibraryType == 3)
						{
							//if (strnicmp(path_for_filename.c_str(), "projectbank", 11) != NULL) 
							sVideoName = "videobank\\";
						}
						sVideoName = sVideoName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sVideoName = sVideoName + selectedmediafile->m_sName.Get();
						else
							sVideoName = sVideoName + "\\" + selectedmediafile->m_sName.Get();
						if (sVideoName != "")
						{
							sSelectedLibrarySting = sVideoName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;

							// if remote project, copy over to that
							extern bool entity_copytoremoteifnotthere(LPSTR);
							entity_copytoremoteifnotthere((LPSTR)sVideoName.c_str());
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Video");
				}
			}

			//################
			//#### Script ####
			//################
			char pChosenSelectedBehaviorFile[MAX_PATH];
			strcpy (pChosenSelectedBehaviorFile, "");
			if (iDisplayLibraryType == 4) //Script
			{
				// get more
				int buts = 1;
				if (pref.iEnableDeveloperProperties)
				{
					if (selectedmediafile != NULL) buts = 2;
				}
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;

				// create new
				if (pref.iEnableDeveloperProperties)
				{
					//ImGui::SameLine();
					if (ImGui::StyleButton("Create New Behavior", ImVec2(fButWidth, fFontSize*2.0)))
					{
						// trigger entry of unique behavior name
						library_createbehavior = true;
						strcpy (library_newbehaviorname, "");
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Create a new blank behavior script, ready for editing with the behavior editor");
					ImGui::SameLine();
				}

				// create a new state with unique name
				if (library_createbehavior == true)
				{
					// Can create new behvaior
					ImGui::SetNextWindowSize(ImVec2(26 * ImGui::GetFontSize(), 8 * ImGui::GetFontSize()), ImGuiCond_Once);
					ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
					cstr sUniqueWinName = cstr("Enter A Name for your New Behavior##BehaviorEditorNew");
					ImGui::Begin(sUniqueWinName.Get(), &library_createbehavior, 0);
					ImGui::Indent(10);
					cstr sUniqueInputName = cstr("##Behavior Name") + cstr(1);
					ImGui::PushItemWidth(-10);
					ImGui::Text("");
					ImGui::Text("Type a name for your new Behavior and press ENTER:");
					if (ImGui::IsRootWindowOrAnyChildFocused() && !ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0)) ImGui::SetKeyboardFocusHere(0);
					if (ImGui::InputText(sUniqueInputName.Get(), library_newbehaviorname, 250, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						// cannot contain spaces
						bool bContainsASpace = false;
						for (int n = 0; n < strlen(library_newbehaviorname); n++)
						{
							if (library_newbehaviorname[n] == ' ')
								bContainsASpace = true;
						}
						if (bContainsASpace == true)
						{
							sprintf(cTriggerMessage, "The behavior name cannot contain spaces");
							bTriggerMessage = true;
						}
						else
						{
							// create a behavior script in the user folder
							char pNewScriptPath[MAX_PATH];
							sprintf(pNewScriptPath, "%s\\Files\\scriptbank\\user\\%s.lua", g.fpscrootdir_s.Get(),library_newbehaviorname);
							GG_GetRealPath(pNewScriptPath, 1);
							if (FileExist(pNewScriptPath) == 1)
							{
								sprintf(cTriggerMessage, "This behavior name already exists");
								bTriggerMessage = true;
							}
							else
							{
								// temp
								char pLine[2048];

								// generate a blank LUA script
								OpenToWrite(1, pNewScriptPath);
								WriteString(1, "-- DESCRIPTION: This is a custom behavior, and can be configured with [customvalue1=0(0,100)], [customvalue2=0(0,100)] and [customvalue3=0(0,100)].");
								sprintf(pLine, "master_interpreter_core = require \"scriptbank\\\\masterinterpreter\""); WriteString(1, pLine);
								
								WriteString(1, "");
								sprintf(pLine, "g_%s = {}", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "g_%s_behavior = {}", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "g_%s_behavior_count = 0", library_newbehaviorname); WriteString(1, pLine);

								WriteString(1, "");
								sprintf(pLine, "function %s_init(e)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e] = {}", library_newbehaviorname); WriteString(1, pLine);

								sprintf(pLine, " g_%s[e][\"bycfilename\"] = \"scriptbank\\\\user\\\\%s.byc\"", library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s_behavior_count = master_interpreter_core.masterinterpreter_load (g_%s[e], g_%s_behavior )", library_newbehaviorname, library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " %s_properties(e,0,0,0)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "end"); WriteString(1, pLine);

								WriteString(1, "");
								sprintf(pLine, "function %s_properties(e, customvalue1, customvalue2, customvalue3)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e]['customvalue1'] = customvalue1", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e]['customvalue2'] = customvalue2", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " g_%s[e]['customvalue3'] = customvalue3", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " master_interpreter_core.masterinterpreter_restart (g_%s[e], g_Entity[e])", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "end"); WriteString(1, pLine);

								WriteString(1, "");
								sprintf(pLine, "function %s_main(e)", library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " if g_%s[e] ~= nil and g_%s_behavior_count > 0 then", library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, "  g_%s_behavior_count = master_interpreter_core.masterinterpreter (g_%s_behavior, g_%s_behavior_count, e, g_%s[e], g_Entity[e])", library_newbehaviorname, library_newbehaviorname, library_newbehaviorname, library_newbehaviorname); WriteString(1, pLine);
								sprintf(pLine, " end"); WriteString(1, pLine);
								sprintf(pLine, "end"); WriteString(1, pLine);
								WriteString(1, "");
								CloseFile(1);

								// create a blank thumbnail for script
								char pBlankFile[MAX_PATH];
								sprintf(pBlankFile, "scriptbank\\user\\blank_icon.jpg");
								char pThumbFile[MAX_PATH];
								sprintf(pThumbFile, "%s\\Files\\scriptbank\\user\\%s.jpg", g.fpscrootdir_s.Get(), library_newbehaviorname);
								GG_GetRealPath(pThumbFile, 1);
								CopyFileA(pBlankFile, pThumbFile, TRUE);

								// when created, auto select this for the object
								char pRelativePathToScript[MAX_PATH];
								sprintf(pRelativePathToScript, "user\\%s.lua", library_newbehaviorname);
								strcpy (pChosenSelectedBehaviorFile, pRelativePathToScript);
							}
						}

						// finished here
						library_createbehavior = false;
						strcpy(library_newbehaviorname, "");
					}
					ImGui::PopItemWidth();
					ImGui::Indent(-10);
					bImGuiGotFocus = true;
					ImGui::End();
				}

				// add selected
				if (selectedmediafile != NULL)
				{
					if (ImGui::StyleButton("Add Selected Behavior", ImVec2(fButWidth, fFontSize*2.0)))
					{
						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;

						std::string sScriptName = "";
						sScriptName = sScriptName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sScriptName = sScriptName + selectedmediafile->m_sName.Get();
						else
							sScriptName = sScriptName + "\\" + selectedmediafile->m_sName.Get();

						// trigger selected
						strcpy (pChosenSelectedBehaviorFile, sScriptName.c_str());

						// if remote project, copy over to that
						if (sScriptName != "")
						{
							extern bool entity_copytoremoteifnotthere(LPSTR);
							std::string sScriptBankScriptName = "scriptbank\\" + sScriptName;
							entity_copytoremoteifnotthere((LPSTR)sScriptBankScriptName.c_str());
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Behavior");
				}
			}

			// if cxeated/selected behavior
			if (strlen(pChosenSelectedBehaviorFile)>0)
			{
				// created or added
				//Sent selection to imgui ID that have last requested a media file.
				playingiles = NULL;
				sSelectedLibrarySting = pChosenSelectedBehaviorFile;
				iSelectedLibraryStingReturnID = iLibraryStingReturnToID;
				bCheckForClosing = true;
				bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.
				selectedmediafile = NULL;
			}

			//###################
			//#### Particles ####
			//###################

			if (iDisplayLibraryType == 5)
			{
				int buts = 1;
				if (selectedmediafile != NULL) buts = 2;
				fButWidth = vContentSize.x / buts;
				fButWidth -= 10.0f;
				LPSTR pParticleEditorTitle = "Particle Editor";
				LPSTR pParticleEditorTooltip = "Update GameGuru MAX to the latest version to get the Particle Editor Tool";
				extern bool g_bParticleEditorPresent;
				if (g_bParticleEditorPresent == true)
				{
					pParticleEditorTitle = "Create New Particles";
					pParticleEditorTooltip = "Create More Particles using the Particle Editor";
				}
				if (ImGui::StyleButton(pParticleEditorTitle, ImVec2(fButWidth, fFontSize*2.0)))
				{
					if (g_bParticleEditorPresent == true)
					{
						extern void launchOrShowParticleEditor(void);
						launchOrShowParticleEditor();
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip(pParticleEditorTooltip);

				if (selectedmediafile != NULL)
				{
					ImGui::SameLine();
					if (ImGui::StyleButton("Add Selected Particle", ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Sent selection to imgui ID that have last requested a media file.
						playingiles = NULL;

						cFolderItem *pNewFolder = selectedmediafile->pNewFolder;
						cStr path = pNewFolder->m_sFolderFullPath.Get();
						int ipath_remove_len = path.Len();
						if (pNewFolder->m_iEntityOffset > 0)
							ipath_remove_len = pNewFolder->m_iEntityOffset;

						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						std::string sParticlesName = "";

						sParticlesName = "particlesbank\\";
						sParticlesName = sParticlesName + path_for_filename.c_str();
						if (path_for_filename.length() == 0)
							sParticlesName = sParticlesName + selectedmediafile->m_sName.Get();
						else
							sParticlesName = sParticlesName + "\\" + selectedmediafile->m_sName.Get();
						if (sParticlesName != "")
						{
							sSelectedLibrarySting = sParticlesName.c_str();
							iSelectedLibraryStingReturnID = iLibraryStingReturnToID;

							// if remote project, copy over to that
							extern bool entity_copytoremoteifnotthere(LPSTR);
							entity_copytoremoteifnotthere((LPSTR)sParticlesName.c_str());
						}
						bCheckForClosing = true;
						bImGuiRenderTargetFocus = true; //PE: needed for window overlap check.

						selectedmediafile = NULL;
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Selected Particles");
				}	
			}
		}
		else
		{
			if (iDisplayLibrarySubType == 0)
			{
				#ifdef GGMAXEDU
				if (ImGui::StyleButton("Building Editor", ImVec2(fButWidth, fFontSize * 2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					extern void launchOrShowBuildingEditor(void);
					launchOrShowBuildingEditor();
				}
				#else
				if (ImGui::StyleButton("Get More Objects", ImVec2(fButWidth, fFontSize * 2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					bMarketplace_Window = true;
				}
				#endif
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Get More Objects from the Marketplace");

				ImGui::SameLine();
				if (ImGui::StyleButton("Import 3D Model", ImVec2(fButWidth, fFontSize*2.0)))
				{
					// copied from marketplace import
					DeleteWaypointsAddedToCurrentCursor();
					CloseDownEditorProperties();
					CloseAllOpenTools();
					iLaunchAfterSync = 8; //Import model
					iSkibFramesBeforeLaunch = 5;
					bMarketplace_Window = false;
					bTriggerCloseEntityWindow = true;
					bCheckForClosingForce = true; //Force window to close.
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Import 3D Model in the OBJ, FBX, GLTF or DBO format");

				ImGui::SameLine();
				if (ImGui::StyleButton("Character Creator", ImVec2(fButWidth, fFontSize*2.0)))
				{
					DeleteWaypointsAddedToCurrentCursor();
					//CheckTooltipObjectDelete();
					CloseDownEditorProperties();
					CloseAllOpenTools();

					//g_bCharacterCreatorPlusActivated = true;
					iLaunchAfterSync = 82; //Start Character Creator
					iSkibFramesBeforeLaunch = 2;
					strcpy(cTriggerMessage, "Loading Character Creator");
					bTriggerMessage = true;

					bCheckForClosing = true;
					bEnableWeather = false;
				}

				if (lf_multi_selections_count > 0)
				{
					ImGui::SameLine();
					std::string insert_text;
					//Display insert button.
					insert_text = " Add ";
					insert_text += std::to_string(lf_multi_selections_count);
					insert_text += " Objects to Level ";
					if (ImGui::StyleButton(insert_text.c_str(), ImVec2(fButWidth, fFontSize*2.0)))
					{
						//Insert all selected items.
						bAddNewSelectionToGame = true;
						iAddSelectionStep = 0;
					}
				}
			}
		}
		ImGui::SetWindowFontScale(1.0);

		ImGui::Indent(-10);
#ifdef DYNAMICLOADUNLOAD
		max_load_persync = 10; // 15 to slow try 10
#endif
		lf_multi_selections_count = multi_selections_count; //Use last frames count.

		if (!bImagesStillInImGuiQueue && !bLargePreview && bAddNewSelectionToGame)
		{
			extern cstr g_sTempGroupForThumbnail;
			if (g_sTempGroupForThumbnail.Len() > 0 )
			{
				//hmm
				//extern int GetGroupIndexFromName (cstr sLookFor);
				//current_selected_group = GetGroupIndexFromName(g_sTempGroupForThumbnail);
				g_sTempGroupForThumbnail = "";
			}

			DeleteWaypointsAddedToCurrentCursor();
			CloseDownEditorProperties();

			//Remove any selections.
			t.inputsys.constructselection = 0;
			if (t.gridentityobj > 0)
			{
				DeleteObject(t.gridentityobj);
				t.gridentityobj = 0;
			}

			//PE: Make sure we free all not used textures-objects before adding new objects.
			FreeTempImageList();

			t.refreshgrideditcursor = 1;
			t.gridentity = 0;
			t.gridentityposoffground = 0;
			t.gridentityusingsoftauto = 0;
			editor_refresheditmarkers();

			cFolderItem *pSearchFolder = &MainEntityList;
			pSearchFolder = pSearchFolder->m_pNext;
			cStr path_remove;
			int ipath_remove_len;
			if (pSearchFolder) {
				path_remove = pSearchFolder->m_sFolderFullPath.Get();
				ipath_remove_len = path_remove.Len();
			}

			bool bOneFound = false;

			iAddSelectionStep++;
			while(pSearchFolder)
			{
				cStr path = pSearchFolder->m_sFolderFullPath.Get();
				bool bDoubleEntityBank = false;
				char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
				if (finde)
				{
					finde += 11;
					finde = (char *)pestrcasestr(finde, "\\entitybank");
					if (finde) bDoubleEntityBank = true;
				}
				if (!bDoubleEntityBank && path.Right(11) == "\\entitybank") {
					ipath_remove_len = path.Len();
				}
				else
				{
					if (pSearchFolder->m_pFirstFile) {

						cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
						while (searchfiles)
						{
							if (searchfiles->iFlags == 1)
							{
								bOneFound = true;
								if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
								if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
								if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;

								//Insert.
								cStr path = pSearchFolder->m_sFolderFullPath.Get();
								char *final_name = path.Get();
								final_name += ipath_remove_len;
								if (*final_name == '\\')
									final_name++;
								std::string path_for_filename = final_name;

								std::string sFpeName = path_for_filename.c_str();
								sFpeName = sFpeName + "\\" + searchfiles->m_sName.Get();
								#ifdef WICKEDENGINE
								iLastEntityOnCursor = 0;
								#endif

								char adding[256];
								strcpy(adding, searchfiles->m_sName.Get());
								if (strlen(adding) > 4)
									adding[strlen(adding) - 4] = 0;
								
								iMessageTimer = 0; //Restart fading.
								sprintf(cTriggerMessage, "Adding \"%s\" to Level", adding);
								bTriggerMessage = true;

								t.addentityfile_s = sFpeName.c_str();
								if (t.addentityfile_s != "")
								{
									entity_adduniqueentity(false);
									t.tasset = t.entid;
									if (t.talreadyloaded == 0)
									{
										editor_filllibrary();
									}
								}

								searchfiles->iFlags = 0;
							}
							if (bOneFound) break;
							searchfiles = searchfiles->m_pNext;
						}
					}
				}
				if (bOneFound) break;
				pSearchFolder = pSearchFolder->m_pNext;
			}
			if (iAddSelectionStep > 0 && !bOneFound)
			{
				bCheckForClosing = true;
				bAddNewSelectionToGame = false;
				iAddSelectionStep = 0;
			}
		}

		bool bAreWeOverLapping = false;
		if (!bIsWeDocked) 
		{
			//If we are over the rendertarget hide window.
			float itmptopmousex = ImGui::GetWindowPos().x;
			float itmptopmousey = ImGui::GetWindowPos().y;
			int iSecureZone = 4;

			if (bImGuiRenderTargetFocus && itmptopmousex >= (renderTargetAreaPos.x + iSecureZone) && itmptopmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmptopmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmptopmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			float itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			float itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmptopmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmptopmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x + ImGui::GetWindowSize().x;
			itmpmousey = ImGui::GetWindowPos().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
			itmpmousex = ImGui::GetWindowPos().x;
			itmpmousey = ImGui::GetWindowPos().y + ImGui::GetWindowSize().y;
			if (bExternal_Entities_Window && bImGuiRenderTargetFocus && itmpmousex >= (renderTargetAreaPos.x + iSecureZone) && itmpmousey >= (renderTargetAreaPos.y + iSecureZone) &&
				itmpmousex <= renderTargetAreaPos.x + (renderTargetAreaSize.x - iSecureZone) && itmpmousey <= renderTargetAreaPos.y + (renderTargetAreaSize.y - ImGuiStatusBar_Size - iSecureZone))
			{
				bAreWeOverLapping = true;
			}
		}
		if (!bIsWeDocked && bCheckForClosing) {
			if (bAreWeOverLapping || bCheckForClosingForce)
			{
				bExternal_Entities_Window = false;
			}
		}

		//Remove window on right click if we are overlapping.
		if (bAreWeOverLapping && t.inputsys.mclick == 2)
			bExternal_Entities_Window = false;

		bCheckForClosingForce = false;
		bCheckForClosing = false;

		CheckMinimumDockSpaceSize(250.0f);

		//Render titlebar centered.
		cstr title = "Object Library - What do you want to add to your level?";
		cstr titlesmall = "Object Library";
		if (iDisplayLibraryType == 0 && iDisplayLibrarySubType == 1)
		{
			title = "Animation Library - What do you want to add to your object?";
			titlesmall = "Animation Library";
		}
		if (iDisplayLibraryType > 0)
		{
			if (iDisplayLibraryType == 1)
			{
				title = "Music and Sound Library - What do you want to add to your level?";
				titlesmall = "Music and Sound Library";
			}
			if (iDisplayLibraryType == 2)
			{
				title = "Image Library - What do you want to add to your level?";
				titlesmall = "Image Library";
			}
			if (iDisplayLibraryType == 3)
			{
				title = "Video Library - What do you want to add to your level?";
				titlesmall = "Video Library";
			}
			if (iDisplayLibraryType == 4)
			{
				title = "Behavior Library - What do you want to add to your level?";
				titlesmall = "Behavior Library";
			}
			if (iDisplayLibraryType == 5)
			{
				title = "Particle Library - What do you want to add to your level?";
				titlesmall = "Particle Library";

				// very special case to monitor the legacy writables area where
				// the particle editor tool exports its MAX particles, and if there is
				// a file count difference, force the new file to copy over to the
				// remote project area, and also force a refresh of the particle library
				if (strlen(Storyboard.customprojectfolder) > 0)
				{
					static int iParticleLastKnownFileCount = 0;
					static std::vector<cStr> vParticleLastKnownFiles;
					static unsigned long iParticleCheckerTimer = 0;
					if (iParticleCheckerTimer < timeGetTime())
					{
						// regular checking
						cstr pOldDir = GetDir();
						iParticleCheckerTimer = timeGetTime() + 1000;

						// check the particle editor writables area
						char pParticleWriteAreaPath[MAX_PATH];
						sprintf(pParticleWriteAreaPath, "%s\\Files\\particlesbank\\user", g.fpscrootdir_s.Get());
						GG_SetWritablesToRoot(true);
						GG_GetRealPath(pParticleWriteAreaPath, 0);
						GG_SetWritablesToRoot(false);
						SetDir(pParticleWriteAreaPath);

						// count latest particle files
						int iParticleEditorFileCount = 0;
						ChecklistForFiles();
						for (int f = 1; f <= ChecklistQuantity(); f++)
						{
							cstr tfile_s = ChecklistString(f);
							LPSTR pFilename = tfile_s.Get();
							if (tfile_s != "." && tfile_s != "..")
							{
								if (strnicmp(pFilename + strlen(pFilename) - 4, ".arx", 4) == NULL || strnicmp(pFilename + strlen(pFilename) - 4, ".png", 4) == NULL)
								{
									iParticleEditorFileCount++;
								}
							}
						}

						// if different, copy over and refresh
						if (iParticleEditorFileCount != iParticleLastKnownFileCount)
						{
							std::vector<cStr> vParticleThisKnownFiles;
							vParticleThisKnownFiles.clear();
							for (int f = 1; f <= ChecklistQuantity(); f++)
							{
								cstr tfile_s = ChecklistString(f);
								LPSTR pFilename = tfile_s.Get();
								if (tfile_s != "." && tfile_s != "..")
								{
									if (strnicmp(pFilename + strlen(pFilename) - 4, ".arx", 4) == NULL || strnicmp(pFilename + strlen(pFilename) - 4, ".png", 4) == NULL)
									{
										bool bDidItAlreadyExist = false;
										for (int i = 0; i < vParticleLastKnownFiles.size(); i++)
										{
											if (vParticleLastKnownFiles[i] == tfile_s)
											{
												bDidItAlreadyExist = true;
												break;
											}
										}
										if (bDidItAlreadyExist == false)
										{
											// copy over to remote project
											// only if additions since first checked
											//if (iParticleLastKnownFileCount > 0) may have created it when not in remote project, must copy them over!
											//{
											// ensure user folder exists
											char pUserFolder[MAX_PATH];
											sprintf(pUserFolder, "%s\\Files\\particlesbank\\user", g.fpscrootdir_s.Get());
											GG_GetRealPath(pUserFolder, 1);
												
											char pRemotePath[MAX_PATH];
											sprintf(pRemotePath, "%s\\Files\\particlesbank\\user\\%s", g.fpscrootdir_s.Get(), pFilename);
											GG_GetRealPath(pRemotePath, 1);
											if (FileExist(pRemotePath) == 0)
											{
												CopyFileA(pFilename, pRemotePath, TRUE);
											}
											//}

											// force a refresh so user can see their particle right away!
											extern int g_iRefreshLibraryFolders;
											g_iRefreshLibraryFolders = 1;
										}

										// record for next time when current list is last list next time
										vParticleThisKnownFiles.push_back(tfile_s);
									}
								}
							}

							// when complete, copy this list to last known
							vParticleLastKnownFiles.clear();
							vParticleLastKnownFiles = vParticleThisKnownFiles;
							iParticleLastKnownFileCount = iParticleEditorFileCount;
						}

						// restore current folder now file ops finished
						SetDir(pOldDir.Get());
					}
				}
			}
		}
		float fTextSize = ImGui::CalcTextSize(title.Get()).x;
		if (ImGui::GetWindowSize().x < fTextSize)
		{
			title = titlesmall;
			fTextSize = ImGui::CalcTextSize(title.Get()).x;
			if (ImGui::GetWindowSize().x < fTextSize)
			{
				title = "";
				fTextSize = 0.0f;
			}
		}
		float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
		ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		if (imgui_AddMinMaxButton(0, false))
		{
			//Record where to scroll to after a window resize.
			if (firstvisiblefile)
			{
				scrolltofile = firstvisiblefile;
				bScrollInNextFrame = true;
			}
		}

		//ImGui::Columns(1);
		ImGui::EndColumns();

		ImGui::End();

		//Render title bar after End. end fill titlebar.
		ImGuiContext& g = *GImGui;
		window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());

	}
	else 
	{
		//Window closed.
		FreeTempImageList();
		if (iVideoThumbID > 0 && AnimationExist(iVideoThumbID))
		{
			iStopVideoInNextFrame = iVideoThumbID;
			iVideoThumbID = 0;
		}
		// free any temp groups created for Smart Object previews
		extern cstr g_sTempGroupForThumbnail;
		if(g_sTempGroupForThumbnail.Len()>0 )
		{
			int store_current_selected_group = current_selected_group;
			extern int GetGroupIndexFromName (cstr sLookFor);
			current_selected_group = GetGroupIndexFromName(g_sTempGroupForThumbnail);
			UnGroupSelected(true);
			gridedit_deleteentityrubberbandfrommap();
			gridedit_clearentityrubberbandlist();
			g_sTempGroupForThumbnail = "";
			if (store_current_selected_group != -1 )
				g.entityrubberbandlist = vEntityGroupList[store_current_selected_group];
		}
	}

	static bool bExternal_Entities_Window_Last = false;
	if (bExternal_Entities_Window != bExternal_Entities_Window_Last)
	{
		//PE: Rick was so fast he could click one object and start a rotate on another thumb in the same loop, this fix it :)
		bExternal_Entities_Window_Last = bExternal_Entities_Window;
		if (!bExternal_Entities_Window)
		{
			//PE: If just closed, disable any thumb grab.
			bLoopBackBuffer = false;
			BackBufferImageID = 0;
		}
	}

	if (sGotoPreviewWithFile != "")
	{
		if (!bLargePreview && bCheckGotoPreview)
		{
			//We failed to find the char, cancel request.
			sGotoPreviewWithFile = "";
		}
	}
}


#define MINMAX_WINDOWS 10
ImRect rRetoreWindowSize[MINMAX_WINDOWS];
bool rMinMaxState[MINMAX_WINDOWS];
bool rMinMaxTrigger[MINMAX_WINDOWS];
bool rMinMaxInit[MINMAX_WINDOWS] = { false,false,false,false,false,false,false,false,false,false };
bool bMinMaxGlobalInit = false;
bool imgui_GetMinMaxButtonState(int win) { return rMinMaxState[win]; }
bool imgui_CheckMinMaxStartupState(int win)
{
	ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
	ImVec2 viewPortSize = ImGui::GetMainViewport()->Size * 0.95;
	ImVec2 vCurSize = ImGui::GetWindowSize();
	if (vCurSize.x >= viewPortSize.x && vCurSize.y >= viewPortSize.y)
	{
		//bResetObjectLibrarySize = true;
		//PE: Instead of resetting window to default , set it as maximized.
		rMinMaxState[win] = true;
		//ImGui::SetNextWindowSize(ImVec2(66 * ImGui::GetFontSize(), (43 * ImGui::GetFontSize()) + 19.0), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		ImVec2 vSize = ImVec2(66 * ImGui::GetFontSize(), (43 * ImGui::GetFontSize()) + 19.0);
		ImVec2 vCenter = viewPortPos + (ImGui::GetMainViewport()->Size*0.5);
		vCenter -= vSize * 0.5;
		rRetoreWindowSize[win].Min = vCenter;
		rRetoreWindowSize[win].Max = vSize;
		return true;
	}
	return false;
}

bool imgui_AddMinMaxButton(int win, bool bRestore)
{
	bool bRet = false;
	if (win >= MINMAX_WINDOWS || win < 0) return bRet;

	if (!bMinMaxGlobalInit)
	{
		for (int i = 0;i < MINMAX_WINDOWS; i++)
		{
			rMinMaxInit[i] = false;
		}
		bMinMaxGlobalInit = true;
	}
	if (!rMinMaxInit[win])
	{
		rRetoreWindowSize[win].Min = ImGui::GetWindowPos();
		rRetoreWindowSize[win].Max = ImGui::GetWindowSize();
		rMinMaxState[win] = false;
		rMinMaxTrigger[win] = false;
		rMinMaxInit[win] = true;
	}

	if (!bRestore)
	{
		//Display buttons.
		ImRect avail_window_rect;
		avail_window_rect.Min = ImGui::GetWindowPos();
		avail_window_rect.Max = ImGui::GetWindowPos() + ImGui::GetWindowSize();
		//avail_window_rect.Min.y -= 15.0f;
		#define USEARROWBUTTON
		ImGui::PushClipRect(avail_window_rect.Min, avail_window_rect.Max, false);
		#ifdef USEARROWBUTTON
			ImVec2 vMinMaxButton = ImVec2(ImGui::GetWindowSize().x - 38.0f, 4.0);
		#else
			ImVec2 vMinMaxButton = ImVec2(ImGui::GetWindowSize().x - 44.0f, -2.0);
		#endif
		ImGui::SetCursorPos(vMinMaxButton);
		ImGui::SetItemAllowOverlap();
		int iIcon = MEDIA_MINIMIZE;
		int iDirection = ImGuiDir_Down;
		if (rMinMaxState[win] == false) {
			iIcon = MEDIA_MAXIMIZE;
			iDirection = ImGuiDir_Up;
		}

		ImVec4 col = ImGui::GetStyleColorVec4(ImGuiCol_Text);
		ImU32 text_col = ImGui::GetColorU32(ImGuiCol_Text);

		#ifdef USEARROWBUTTON
		auto *style = &ImGui::GetStyle();
		float ioldframe = style->FrameBorderSize;
		ImVec2 oldpadding = style->FramePadding;
		style->FrameBorderSize = 0.0f;
		style->FramePadding.x = 0;
		style->FramePadding.y = 0;
		if (ImGui::MinMaxButtonEx("##minmaxSelection", iDirection))
		#else
		if (ImGui::ImgBtn(iIcon, ImVec2(20, 20), ImColor(255, 255, 255, 0), ImColor(255, 255, 255, 255), drawCol_hover, drawCol_Down, -1, 0, 0, 0, true, false, false, false, false, bBoostIconColors))
		#endif
		{
			if (rMinMaxState[win] == false)
				rMinMaxState[win] = true;
			else
				rMinMaxState[win] = false;
			rMinMaxTrigger[win] = true;
			if (rMinMaxState[win])
			{
				//Update size pos with current windows settings.
				rRetoreWindowSize[win].Min = ImGui::GetWindowPos();
				rRetoreWindowSize[win].Max = ImGui::GetWindowSize();
			}
			bRet = true;
		}
		#ifdef USEARROWBUTTON
		style->FramePadding = oldpadding;
		style->FrameBorderSize = ioldframe;
		#endif
		ImGui::PopClipRect();
	}
	else
	{
		if (rMinMaxTrigger[win])
		{
			if (rMinMaxState[win])
			{
				//Set max size, but keep old size.
				ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
				ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
				ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
				ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always); //full screen.
			}
			else
			{
				//Restore old settings.
				ImGui::SetNextWindowPos(rRetoreWindowSize[win].Min, ImGuiCond_Always);
				ImGui::SetNextWindowSize(rRetoreWindowSize[win].Max, ImGuiCond_Always);
			}
			rMinMaxTrigger[win] = false;
		}
	}
	return bRet;
}

void FreeTempImageList(void)
{
	if (g_TempimageList.size() > 0)
	{
		//t.entid = 0 ; is used for automated generating of thumbs, so delete this.
		if (ObjectExist(g.entitybankoffset)) 
		{
			DeleteObject(g.entitybankoffset);
		}
		if (iRestoreEntidMaster >= 0 && g.entidmaster > iRestoreEntidMaster)
		{
			//PE: Free loaded objects
			for (int i = iRestoreEntidMaster;i < g.entidmaster; i++)
			{
				int iEntId = i + 1;
				cstr sFree = t.entitybank_s[iEntId];
				if (ObjectExist(g.entitybankoffset + iEntId)) 
				{
					//PE: We use a before/after list to free all used textures later.
					DeleteObject(g.entitybankoffset + iEntId);
				}
			}
		}

		// restore g.entidmaster
		if (iRestoreEntidMaster >= 0)
		{
			g.entidmaster = iRestoreEntidMaster;
		}
		iRestoreEntidMaster = -1;

		//PE: TODO check legacy loaded images is part of g_imageList, should not be a problem as they are not actually inside wicked, check anyway.

		//PE: Compare the lists and check if we need to delete any textures.
		for (int i = 0; i < g_imageList.size(); i++)
		{
			sImageList* pImage = NULL;
			if (i >= g_TempimageList.size())
			{
				pImage = &g_imageList[i];
			}
			else
			{
				if (g_imageList[i].image != g_TempimageList[i].image)
				{
					pImage = &g_imageList[i];
				}
			}
			if (pImage)
			{
				// free texture
				WickedCall_FreeImage(pImage);
			}
		}

		// clear temp image list
		g_TempimageList.clear();
	}
}

bool DeleteEntityFromLists(int e)
{
	bool bFound = false;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (vEntityGroupList[l].size() > 0)
		{

			for (int i = 0; i < vEntityGroupList[l].size(); i++)
			{
				if (e == vEntityGroupList[l][i].e)
				{
					vEntityGroupList[l].erase(vEntityGroupList[l].begin() + i);
					bFound = true;
					break;
				}
			}
		}
		if(bFound)
			break;
	}
	if (!bFound)
	{
		for (int i = 0; i < vEntityLockedList.size(); i++)
		{
			if (e == vEntityLockedList[i].e)
			{
				vEntityLockedList.erase(vEntityLockedList.begin() + i);
				bFound = true;
				break;
			}
		}
	}
	//Recursive as list's is changing.
	if (bFound)
		DeleteEntityFromLists(e);
	return(bFound);
}


void AddGroupListToRubberBand(int l)
{
	bool bFound = false;
	if (g.entityrubberbandlist.size() <= 0) {
		g.entityrubberbandlist = vEntityGroupList[l];
		return;
	}

	if (vEntityGroupList[l].size() > 0)
	{
		for (int i = 0; i < vEntityGroupList[l].size(); i++)
		{
			int e = vEntityGroupList[l][i].e;
			bool found = false;
			for (int l = 0; l < g.entityrubberbandlist.size(); l++)
			{
				if (g.entityrubberbandlist[l].e == e) {
					found = true;
				}
			}
			if (!found)
			{
				sRubberBandType rubberbandItem;
				rubberbandItem.e = e;
				rubberbandItem.x = t.entityelement[e].x;
				rubberbandItem.y = t.entityelement[e].y;
				rubberbandItem.z = t.entityelement[e].z;
				#ifdef WICKEDENGINE
				rubberbandItem.px = t.entityelement[e].x;
				rubberbandItem.py = t.entityelement[e].y;
				rubberbandItem.pz = t.entityelement[e].z;
				rubberbandItem.rx = t.entityelement[e].rx;
				rubberbandItem.ry = t.entityelement[e].ry;
				rubberbandItem.rz = t.entityelement[e].rz;			
				rubberbandItem.quatmode = t.entityelement[e].quatmode;
				rubberbandItem.quatx = t.entityelement[e].quatx;
				rubberbandItem.quaty = t.entityelement[e].quaty;
				rubberbandItem.quatz = t.entityelement[e].quatz;
				rubberbandItem.quatw = t.entityelement[e].quatw;
				rubberbandItem.scalex = t.entityelement[e].scalex;
				rubberbandItem.scaley = t.entityelement[e].scaley;
				rubberbandItem.scalez = t.entityelement[e].scalez;
				#endif
				g.entityrubberbandlist.push_back(rubberbandItem);
			}
		}
	}
	return;
}

void CheckGroupListForRubberbandSelections(int entityindex)
{
	int grouplist = isEntityInGroupList(entityindex);
	if (grouplist >= 0)
	{
		//Check all objects in the current rubberband if they belong to a group.
		for (int i = 0; i < g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			if (e > 0)
			{
				int group = isEntityInGroupList(e, grouplist);
				if (group >= 0)
					AddGroupListToRubberBand(group);
			}
		}

		//PE: We must add to current rubberband.
		AddGroupListToRubberBand(grouplist);
	}
	
	//Scan entityindex in all groups.
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (l != grouplist)
		{
			int group = isEntityInGroupListDirect(entityindex, l);
			if (group >= 0) {
				AddGroupListToRubberBand(group);
			}
		}
	}

	//Recheck new rubberband if any new entity is in other lists.
	for (int i = 0; i < g.entityrubberbandlist.size(); i++)
	{
		int e = g.entityrubberbandlist[i].e;
		if (e > 0)
		{
			//Check all groups.
			for (int l = 0; l < MAXGROUPSLISTS; l++)
			{
				int group = isEntityInGroupListDirect(e, l);
				if (group >= 0) {
					AddGroupListToRubberBand(group);
				}
			}
		}
	}
}

void ClearAllGroupLists(void)
{
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		sEntityGroupListName[l] = "";
		vEntityGroupList[l].clear();
		iEntityGroupListImage[l] = 0;
	}
	for (int i = 0; i < vEntityLockedList.size(); i++)
	{
		int e = vEntityLockedList[i].e;
		t.entityelement[e].editorlock = 0;
		sObject* pObject;
		if (t.entityelement[e].obj > 0) {
			pObject = g_ObjectList[t.entityelement[e].obj];
			if (pObject) {
				WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
			}
		}
	}
	vEntityLockedList.clear();
	g.entityrubberbandlist.clear();
}


void ReplaceEntityInGroupList(int e, int eto)
{
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (vEntityGroupList[l].size() > 0)
		{

			for (int i = 0; i < vEntityGroupList[l].size(); i++)
			{
				if (e == vEntityGroupList[l][i].e)
				{
					vEntityGroupList[l][i].e = eto;
				}
			}
		}
	}
}

int isEntityInGroupList(int e,int ignoregroup)
{
	bool bFound = false;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (!(ignoregroup >= 0 && ignoregroup == l))
		{
			if (vEntityGroupList[l].size() > 0)
			{
				for (int i = 0; i < vEntityGroupList[l].size(); i++)
				{
					if (e == vEntityGroupList[l][i].e)
					{
						//found return list.
						return(l);
					}
				}
			}
		}
	}
	return(-1);
}

int isEntityInGroupListDirect(int e, int group)
{
	if (vEntityGroupList[group].size() > 0)
	{
		for (int i = 0; i < vEntityGroupList[group].size(); i++)
		{
			if (e == vEntityGroupList[group][i].e)
			{
				//found return list.
				return(group);
			}
		}
	}

	return(-1);
}

int g_iCopiedLogicConnectionsCount = 0;
struct sCopiedLogicConnections
{
	int iObjectLinkID[999];
	int iObjectRelationships[999][10];
	int iObjectRelationshipsType[999][10];
	int iObjectRelationshipsData[999][10];
};
std::vector<sCopiedLogicConnections> g_copiedLogicConnectionList;

void DuplicateLogicConnectionsCopyOriginal (std::vector<sRubberBandType> vEntityDuplicateList, int iOriginalGroupIndexSpecified)
{
	if (iOriginalGroupIndexSpecified > -1)
	{
		// the size of the list 
		g_iCopiedLogicConnectionsCount = (int)vEntityDuplicateList.size();

		// expand storage to include iOriginalGroupIndexSpecified index
		while (g_copiedLogicConnectionList.size() <= iOriginalGroupIndexSpecified)
		{
			sCopiedLogicConnections item;
			g_copiedLogicConnectionList.push_back(item);
		}

		// store data for group list
		sCopiedLogicConnections item;
		for (int listindex = 0; listindex < g_iCopiedLogicConnectionsCount; listindex++)
		{
			// original connection data
			int iOriginalE = vEntityDuplicateList[listindex].e;
			item.iObjectLinkID[listindex] = t.entityelement[iOriginalE].eleprof.iObjectLinkID;;
			for (int i = 0; i < 10; i++)
			{
				item.iObjectRelationships[listindex][i] = t.entityelement[iOriginalE].eleprof.iObjectRelationships[i];
				item.iObjectRelationshipsType[listindex][i] = t.entityelement[iOriginalE].eleprof.iObjectRelationshipsType[i];
				item.iObjectRelationshipsData[listindex][i] = t.entityelement[iOriginalE].eleprof.iObjectRelationshipsData[i];
			}
		}
		g_copiedLogicConnectionList[iOriginalGroupIndexSpecified] = item;
	}
}

void DuplicateLogicConnections (std::vector<sRubberBandType> vEntityDuplicateList, int iOriginalGroupIndexSpecified)
{
	if (g_iCopiedLogicConnectionsCount > 0)
	{
		// have 'vEntityDuplicateList' which is the original and g.entityrubberbandlist which is the duplicated copy
		sCopiedLogicConnections item = g_copiedLogicConnectionList[iOriginalGroupIndexSpecified];
		
		/* preserve linkIDs as can link to external entities using older IDs
		// generate new LinkIDs in duplicate
		for (int listindex = 0; listindex < g_iCopiedLogicConnectionsCount; listindex++)
		{
			int iDuplicateE = g.entityrubberbandlist[listindex].e;
			t.entityelement[iDuplicateE].eleprof.iObjectLinkID = 0;
			if (item.iObjectLinkID[listindex] != 0)
			{
				t.entityelement[iDuplicateE].eleprof.iObjectLinkID = GenerateRelationshipUniqueLinkID();
			}
		}
		*/
		if (g_iCopiedLogicConnectionsCount != g.entityrubberbandlist.size())
		{
			//PE: Somehow g_iCopiedLogicConnectionsCount is larger then g.entityrubberbandlist.size() and you end up with a crash.
			//@Lee: is g_iCopiedLogicConnectionsCount used any more.
			//PE: Anyway protect it for now. Happens if you have one large group add another small group and save.
			g_iCopiedLogicConnectionsCount = g.entityrubberbandlist.size();
		}
		// scan old data, find old LinkIDs and replace with new ones
		for (int listindex = 0; listindex < g_iCopiedLogicConnectionsCount; listindex++)
		{
			// for each entity relationships, assign new LinkIDs
			int iDuplicateE = g.entityrubberbandlist[listindex].e;
			t.entityelement[iDuplicateE].eleprof.iObjectLinkID = item.iObjectLinkID[listindex];
			for (int i = 0; i < 10; i++)
			{
				t.entityelement[iDuplicateE].eleprof.iObjectRelationships[i] = item.iObjectRelationships[listindex][i];
				t.entityelement[iDuplicateE].eleprof.iObjectRelationshipsType[i] = item.iObjectRelationshipsType[listindex][i];
				t.entityelement[iDuplicateE].eleprof.iObjectRelationshipsData[i] = item.iObjectRelationshipsData[listindex][i];
			}
		}
		/*
		else
		{
			// clear all logic connections
			t.grideleprof.iObjectLinkID = 0;
			for (int i = 0; i < 10; i++)
			{
				t.grideleprof.iObjectRelationships[i] = 0;
				t.grideleprof.iObjectRelationshipsData[i] = 0;
				t.grideleprof.iObjectRelationshipsType[i] = 0;
			}
		}
		*/

		// completed logic duplication
		g_iCopiedLogicConnectionsCount = 0;
	}
}

int DuplicateFromListToCursor(std::vector<sRubberBandType> vEntityDuplicateList, bool bRandomShiftXZ, int iOriginalGroupIndexForChild, bool bAttachToCursor)
{
	// anchor to a single object for dragging
	int iAnchorEntityIndex = -1;

	// Dublicate all from a list.
	if (vEntityDuplicateList.size() > 0)
	{
		// a small offset so user can see new pasted entity
		float fShiftOffsetForPasteX = 0.0f;
		float fShiftOffsetForPasteZ = 0.0f;
		if (bRandomShiftXZ == true)
		{
			fShiftOffsetForPasteX = 50.0f + rand() % 50;
			fShiftOffsetForPasteZ = 50.0f + rand() % 50;
			if (rand() % 2 == 0) fShiftOffsetForPasteX = -fShiftOffsetForPasteX;
			if (rand() % 2 == 0) fShiftOffsetForPasteZ = -fShiftOffsetForPasteZ;
		}

		// we are also going to move rubber band selection to new pasted group
		g.entityrubberbandlist.clear();

		float higesty = -999999.0f, lowesty = 999999.0;
		// for each entity, create a duplicate and offset slightly so we can see it
		for (int i = 0; i < (int)vEntityDuplicateList.size(); i++)
		{
			// duplicate new entity as clone of relevant original clipboard entity
			int e = vEntityDuplicateList[i].e;
			bool bLowestFound = false;
			t.gridentity = t.entityelement[e].bankindex;
			#ifdef WICKEDENGINE
			//PE: all t.gridentity... need to be set for this to work correctly.
			t.entid = t.gridentity;
			entity_fillgrideleproffromprofile();  // t.entid
			t.gridentityposx_f = t.entityelement[e].x;
			t.gridentityposy_f = t.entityelement[e].y;
			if (higesty < t.gridentityposy_f) higesty = t.gridentityposy_f;
			if (lowesty > t.gridentityposy_f)
			{
				lowesty = t.gridentityposy_f;
				bLowestFound = true;
			}
			t.gridentityposz_f = t.entityelement[e].z;
			t.gridentityrotatex_f = t.entityelement[e].rx;
			t.gridentityrotatey_f = t.entityelement[e].ry;
			t.gridentityrotatez_f = t.entityelement[e].rz;
			t.gridentityrotatequatmode = t.entityelement[e].quatmode;
			t.gridentityrotatequatx_f = t.entityelement[e].quatx;
			t.gridentityrotatequaty_f = t.entityelement[e].quaty;
			t.gridentityrotatequatz_f = t.entityelement[e].quatz;
			t.gridentityrotatequatw_f = t.entityelement[e].quatw;
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.gridentityscalex_f = 100.0f + t.entityelement[e].scalex;
				t.gridentityscaley_f = 100.0f + t.entityelement[e].scaley;
				t.gridentityscalez_f = 100.0f + t.entityelement[e].scalez;
			}
			else
			{
				t.gridentityscalex_f = ObjectScaleX(t.entityelement[e].obj);
				t.gridentityscaley_f = ObjectScaleY(t.entityelement[e].obj);
				t.gridentityscalez_f = ObjectScaleZ(t.entityelement[e].obj);
			}
			// this seems to wipe out what "entity_fillgrideleproffromprofile" did!
			t.grideleprof = t.entityelement[e].eleprof;
			entity_cleargrideleprofrelationshipdata();
			#endif

			// add object to the level
			#ifdef WICKEDENGINE
			//PE: InstanceObject - Cursor,Object Tools - objects must always be real clones.
			extern bool bNextObjectMustBeClone;
			bNextObjectMustBeClone = true;
			#endif

			gridedit_addentitytomap();

			#ifdef WICKEDENGINE
			bNextObjectMustBeClone = false;
			#endif

			//PE: Always use the lowest Y object in list.
			if (iAnchorEntityIndex == -1 || bLowestFound ) iAnchorEntityIndex = t.e;
			t.entityelement[t.e].x = t.entityelement[e].x + fShiftOffsetForPasteX;
			t.entityelement[t.e].y = t.entityelement[e].y;
			t.entityelement[t.e].z = t.entityelement[e].z + fShiftOffsetForPasteZ;
			t.entityelement[t.e].rx = t.entityelement[e].rx;
			t.entityelement[t.e].ry = t.entityelement[e].ry;
			t.entityelement[t.e].rz = t.entityelement[e].rz;
			t.entityelement[t.e].quatmode = t.entityelement[e].quatmode;
			t.entityelement[t.e].quatx = t.entityelement[e].quatx;
			t.entityelement[t.e].quaty = t.entityelement[e].quaty;
			t.entityelement[t.e].quatz = t.entityelement[e].quatz;
			t.entityelement[t.e].quatw = t.entityelement[e].quatw;
			t.entityelement[t.e].editorfixed = t.entityelement[e].editorfixed;
			t.entityelement[t.e].staticflag = t.entityelement[e].staticflag;
			t.entityelement[t.e].scalex = t.entityelement[e].scalex;
			t.entityelement[t.e].scaley = t.entityelement[e].scaley;
			t.entityelement[t.e].scalez = t.entityelement[e].scalez;
			t.entityelement[t.e].soundset = t.entityelement[e].soundset;
			t.entityelement[t.e].soundset1 = t.entityelement[e].soundset1;
			t.entityelement[t.e].soundset2 = t.entityelement[e].soundset2;
			t.entityelement[t.e].soundset3 = t.entityelement[e].soundset3;
			t.entityelement[t.e].soundset4 = t.entityelement[e].soundset4;
			t.entityelement[t.e].soundset5 = t.entityelement[e].soundset5;
			t.entityelement[t.e].soundset6 = t.entityelement[e].soundset6;

			//LB: destructive for auto flatten IDs
			//t.entityelement[t.e].eleprof = t.entityelement[e].eleprof;
			int iStoreFlattenID = t.entityelement[t.e].eleprof.iFlattenID;
			t.entityelement[t.e].eleprof = t.entityelement[e].eleprof;
			t.entityelement[t.e].eleprof.iFlattenID = iStoreFlattenID;

			PositionObject(t.entityelement[t.e].obj, t.entityelement[t.e].x, t.entityelement[t.e].y, t.entityelement[t.e].z);
			RotateObject(t.entityelement[t.e].obj, t.entityelement[t.e].rx, t.entityelement[t.e].ry, t.entityelement[t.e].rz);

			// need to generate new particles
			if (t.entityprofile[t.gridentity].ismarker == 0)
			{
				entity_updateautoflatten(t.e);
			}
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.entityelement[t.e].eleprof.newparticle.emitterid = -1;
				entity_updateparticleemitter(t.e);
			}

			//LB: in order to determine when last of smart objects deleted from level, so the smart object parent can be removed from entitybank, mark
			// the entity elements with the group ID as they are created here
			int iUniqueGroupID = vEntityDuplicateList[i].iGroupID;
			t.entityelement[t.e].creationOfGroupID = iUniqueGroupID;

			// and add to new rubber band group
			sRubberBandType rubberbandItem;
			rubberbandItem.e = t.e;
			rubberbandItem.x = t.entityelement[t.e].x;
			rubberbandItem.y = t.entityelement[t.e].y;
			rubberbandItem.z = t.entityelement[t.e].z;
			#ifdef WICKEDENGINE
			rubberbandItem.px = t.entityelement[t.e].x;
			rubberbandItem.py = t.entityelement[t.e].y;
			rubberbandItem.pz = t.entityelement[t.e].z;
			rubberbandItem.rx = t.entityelement[t.e].rx;
			rubberbandItem.ry = t.entityelement[t.e].ry;
			rubberbandItem.rz = t.entityelement[t.e].rz;
			rubberbandItem.quatmode = t.entityelement[t.e].quatmode;
			rubberbandItem.quatx = t.entityelement[t.e].quatx;
			rubberbandItem.quaty = t.entityelement[t.e].quaty;
			rubberbandItem.quatz = t.entityelement[t.e].quatz;
			rubberbandItem.quatw = t.entityelement[t.e].quatw;
			rubberbandItem.scalex = t.entityelement[t.e].scalex;
			rubberbandItem.scaley = t.entityelement[t.e].scaley;
			rubberbandItem.scalez = t.entityelement[t.e].scalez;
			#endif
			g.entityrubberbandlist.push_back(rubberbandItem);
		}

		// clone all the logic connections
		DuplicateLogicConnections(vEntityDuplicateList, iOriginalGroupIndexForChild);

		// Select and add first entity to cursor, along with the rubberband.
		if (iAnchorEntityIndex != -1 && bAttachToCursor == true)
		{
			//PE: Need to set scale from group settings. t.entityelement[iAnchorEntityIndex].scalex
			AddEntityToCursor(iAnchorEntityIndex, false);

			//Change to just place under cursor.
			t.inputsys.dragoffsetx_f = 0;
			t.inputsys.dragoffsety_f = 0;
			fHitPointX = 0;
			fHitPointY = HITPOINTYSTARTPOS;
			fHitPointZ = 0;
			fHitOffsetX = 0;
			fHitOffsetY = 0;
			fHitOffsetZ = 0;

			g_bHoldGridEntityPosWhenManaged = true;
			g_fHoldGridEntityPosX = t.gridentityposx_f;
			g_fHoldGridEntityPosY = t.gridentityposy_f;
			g_fHoldGridEntityPosZ = t.gridentityposz_f;

			//LB: should not change modes without users permission
			//PE: Always start in horizontal mode.
			//iObjectMoveMode = 0;
			//LB: When dragging in groups, need to be in smart mode to handle object placement on terrain/surface
			iObjectMoveMode = 2; // not happy to change users preference, need better solution for release
		}

		//LB: when duplicate, we create a child group spawned from the parent, use unique "iParentGroupID" to keep track of parent and children
		CreateNewGroup(vEntityDuplicateList[0].iGroupID, false, "", false, iOriginalGroupIndexForChild);

		//LB: when duplicate, clear last selected so do not double highlight and mess up correct group selection list!
		iLastSelectedEntityGroup = -1;
		iLastSelectedEntity = -1;
	}
	if (bAttachToCursor == false)
	{
		// reset any attachments
		current_selected_group = -1;
		t.gridentity = 0;
	}
	return iAnchorEntityIndex;
}

void ListGroupContextMenu(bool bPickedOnly, int iEntityId)
{
	int iEntid = t.widget.pickedEntityIndex;
	if (iEntityId > 0)
		iEntid = iEntityId;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (vEntityGroupList[l].size() > 0 )
		{
			cstr sContextMenuString = cstr("Add to Group") + cstr(l + 1);
			if (ImGui::MenuItem(sContextMenuString.Get()))
			{
				if ( (g.entityrubberbandlist.size() > 0 && !bPickedOnly) || iEntid > 0)
				{
					int iLoop = 1;
					if (g.entityrubberbandlist.size() > 0 && !bPickedOnly)
						iLoop = g.entityrubberbandlist.size();
					for (int i = 0; i < (int)iLoop; i++)
					{
						int e = iEntid;
						if (g.entityrubberbandlist.size() > 0 && !bPickedOnly)
							e = g.entityrubberbandlist[i].e;
						bool bAlreadyThere = false;
						for (int il = 0; il < (int)vEntityGroupList[l].size(); il++)
						{
							if (e == vEntityGroupList[l][il].e)
							{
								bAlreadyThere = true;
								break;
							}
						}
						if (!bAlreadyThere)
						{
							sRubberBandType newItem;
							newItem.e = e;
							newItem.x = t.entityelement[e].x;
							newItem.y = t.entityelement[e].y;
							newItem.z = t.entityelement[e].z;
							vEntityGroupList[l].push_back(newItem);
						}
					}
					if (!bPickedOnly)
					{
						g.entityrubberbandlist.clear();
						widget_switchoff();
					}
				}
			}
		}
	}
}

int GetGroupIndexFromName (cstr sLookFor)
{
	int iParentGroupID = -1;
	for (int l = 0; l < MAXGROUPSLISTS; l++)
	{
		if (sEntityGroupListName[l].Len() > 0)
		{
			if (stricmp (sEntityGroupListName[l].Get(), sLookFor.Get()) == NULL)
			{
				iParentGroupID = l;
				break;
			}
		}
	}
	return iParentGroupID;
}

void UnGroupSelected(bool bRetainRubberBandList)
{
	//Ungroup to cursor and delete current group.
	if (current_selected_group >= 0)
	{
		entity_createundoaction(eUndoSys_Object_UnGroup, current_selected_group);
		g.entityrubberbandlist = vEntityGroupList[current_selected_group];
		//Set widget on first item in list.
		int e = g.entityrubberbandlist[0].e;
		if (e > 0)
		{
			if (t.entityelement[e].editorlock == 0)
			{
				t.widget.pickedEntityIndex = e;
				t.widget.pickedObject = t.entityelement[e].obj;
			}
		}
		vEntityGroupList[current_selected_group].clear();
		if (ImageExist(iEntityGroupListImage[current_selected_group]))
		{
			//Image is already on screen. so dont delete before its reused.
			//It will get the same id next time so we can do this.
			iEntityGroupListImage[current_selected_group] = 0;
		}
		sEntityGroupListName[current_selected_group] = "";
		current_selected_group = -1;

		// Also ensure objects not still rubberband highlighted as the user may think they are still grouped when the 
		// primary object in the old group is dragged about
		if (bRetainRubberBandList == false )
			g.entityrubberbandlist.clear();
	}
}

void UnGroupUndoSys(int index)
{
	//Ungroup to cursor and delete current group.
	if (index >= 0)
	{
		g.entityrubberbandlist = vEntityGroupList[index];
		//Set widget on first item in list.
		int e = g.entityrubberbandlist[0].e;
		if (e > 0)
		{
			if (t.entityelement[e].editorlock == 0)
			{
				t.widget.pickedEntityIndex = e;
				t.widget.pickedObject = t.entityelement[e].obj;
			}
		}
		vEntityGroupList[index].clear();
		if (ImageExist(iEntityGroupListImage[index]))
		{
			//Image is already on screen. so dont delete before its reused.
			//It will get the same id next time so we can do this.
			iEntityGroupListImage[index] = 0;
		}
		sEntityGroupListName[index] = "";
		current_selected_group = -1;

		// Also ensure objects not still rubberband highlighted 
		g.entityrubberbandlist.clear();
	}
}
void GroupUndoSys(int index, std::vector<sRubberBandType> groupData)
{
	// Add the entities from the undo event to the rubberband list and then create a group from the rubberband
	g.entityrubberbandlist.clear();
	for (int i = 0; i < groupData.size(); i++)
	{
		g.entityrubberbandlist.push_back(groupData[i]);
	}

	CreateNewGroup(-1, true, "", false);
}

void CreateNewGroup(int iParentGroupID, bool bSnapshotGroupThumb, cstr GroupName_s, bool bGenerateUndo, int iForceIntoIndex)
{
	if (g.entityrubberbandlist.size() > 0)
	{
		GetRubberbandLowHighValues();
		if (iForceIntoIndex == -1)
		{
			//Check for duplicate.
			for (int i = 0; i < MAXGROUPSLISTS; i++)
			{
				if (vEntityGroupList[i].size() > 0)
				{
					if (vEntityGroupList[i].size() == g.entityrubberbandlist.size())
					{
						bool bAllFound = true;
						for (int ir = 0; ir < g.entityrubberbandlist.size(); ir++)
						{
							int e = g.entityrubberbandlist[ir].e;
							bool bfound = false;

							for (int il = 0; il < vEntityGroupList[i].size(); il++)
							{
								if (vEntityGroupList[i][il].e == e)
								{
									bfound = true;
									break;
								}
							}
							if (!bfound)
								bAllFound = false;
						}
						if (bAllFound) //All found in group.
							return;
					}

				}
			}

			//Remove empty.
			int dest = 0;
			for (int i = 0; i < MAXGROUPSLISTS; i++)
			{
				if (vEntityGroupList[i].size() > 0)
				{
					if (i != dest)
					{
						//move
						vEntityGroupList[dest] = vEntityGroupList[i];
						if (current_selected_group == dest)
							current_selected_group = dest;
						iEntityGroupListImage[dest] = iEntityGroupListImage[i];
						iEntityGroupListImage[i] = 0;
						sEntityGroupListName[dest] = sEntityGroupListName[i];
						sEntityGroupListName[i] = "";
						vEntityGroupList[i].clear();
					}
					dest++;
				}
			}

			//Move list down.
			for (int l = MAXGROUPSLISTS - 1; l > 0; l--)
			{
				if (vEntityGroupList[l - 1].size() > 0)
				{
					vEntityGroupList[l] = vEntityGroupList[l - 1];
					if (current_selected_group == l - 1)
						current_selected_group = l;
					iEntityGroupListImage[l] = iEntityGroupListImage[l - 1];
					sEntityGroupListName[l] = sEntityGroupListName[l - 1];
				}
			}
			vEntityGroupList[0].clear();
			sEntityGroupListName[0] = "";
		}

		// only create a thumbnail for parent groups, child groups are never shown
		int iImageID = 0;
		if (iParentGroupID == -1)
		{
			//Find free image id.
			for (int i = 0; i < MAXGROUPSLISTS; i++)
			{
				bool bAlreadyUsed = false;
				int iNewImageID = BACKBUFFERIMAGE + i;
				for (int l = MAXGROUPSLISTS; l > 0; l--)
				{
					if (iEntityGroupListImage[l] == iNewImageID)
					{
						bAlreadyUsed = true;
						break;
					}
				}
				if (!bAlreadyUsed) 
				{
					iImageID = iNewImageID;
					break;
				}
			}
			if (iImageID == 0) return; //No free imageID.
		}

		//Find free list or force a specific index
		int iChosenGroupIndex = iForceIntoIndex;
		if (iChosenGroupIndex == -1)
		{
			for (int l = 0; l < MAXGROUPSLISTS; l++)
			{
				if (vEntityGroupList[l].size() <= 0)
				{
					iChosenGroupIndex = l;
					break;
				}
			}
		}
		else
		{
			vEntityGroupList[iChosenGroupIndex].clear();
		}
		if ( iChosenGroupIndex != -1 )
		{
			int l = iChosenGroupIndex;
			if (vEntityGroupList[l].size() <= 0)
			{
				//Free, copy rubberband.
				vEntityGroupList[l] = g.entityrubberbandlist;
				widget_switchoff();

				//PE: Generate tumbnail of group.
				iEntityGroupListImage[l] = iImageID;
				if (bSnapshotGroupThumb == true)
				{
					// creating a group with NEW GROUP
					BackBufferIsGroup = false;
					BackBufferEntityID = 0;
					BackBufferObjectID = 0;
					BackBufferImageID = iEntityGroupListImage[l];
					BackBufferSizeX = 512 * 2.0f;
					BackBufferSizeY = 288 * 2.0f;
					BackBufferZoom = 1.0f;
					BackBufferCamLeft = 0.0f;
					BackBufferCamUp = 0.0f;
					bRotateBackBuffer = false;
					bBackBufferAnimated = false;
					bLoopBackBuffer = false;
					BackBufferSnapShotMode = true;
					if (BitmapExist(99))
					{
						DeleteBitmapEx(99);
					}
					bFullScreenBackbuffer = true;
					extern int bStopBackbufferGrab;
					bStopBackbufferGrab = 1;
				}
				else
				{
					// creating a group when we ADDED from Object Library
					int entid = 0;
					for (int i = 0; i < g.entityrubberbandlist.size(); i++)
					{
						// first update object from final entity element data
						int e = g.entityrubberbandlist[i].e;
						entid = t.entityelement[e].bankindex;
						if (t.entityprofile[entid].ismarker == 0)
						{
							// use this one!
							break;
						}
					}
					if (entid > 0)
					{
						BackBufferIsGroup = true;
						BackBufferEntityID = entid;
						BackBufferObjectID = g.entitybankoffset + entid;
						BackBufferImageID = iEntityGroupListImage[l];
						BackBufferSizeX = 512 * 2.0f;
						BackBufferSizeY = 288 * 2.0f;
						BackBufferZoom = 1.0f;
						BackBufferCamLeft = 0.0f;
						BackBufferCamUp = 0.0f;
						bRotateBackBuffer = false;
						bBackBufferAnimated = false;
						bLoopBackBuffer = false;
						if (BitmapExist(99))
						{
							DeleteBitmapEx(99);
						}
						bFullScreenBackbuffer = true;
						extern int bStopBackbufferGrab;
						bStopBackbufferGrab = 1;
					}
				}

				// assign name to group
				sEntityGroupListName[l] = GroupName_s;

				//Set selection on last created group.
				current_selected_group = l;
			}
		}

		//LB: if creating a child group, assign the parentID to it
		if (iParentGroupID == -1)
		{
			// creating a parent group
			if (current_selected_group >= 0)
			{
				g_iUniqueGroupID++;
				for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
				{
					vEntityGroupList[current_selected_group][n].iGroupID = g_iUniqueGroupID;
					vEntityGroupList[current_selected_group][n].iParentGroupID = -1;
				}

				// only "switch" to group tab if a parent group created, user will never see child groups being created here!
				if (sEntityGroupListName[current_selected_group].Len() == 0)
				{
					// Display group tab only for non smart objects
					i_switch_group_tab = 2;
				}
			}
		}
		else
		{
			// creating a child group of passed in iParentGroupID
			if (current_selected_group >= 0)
			{
				for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
				{
					vEntityGroupList[current_selected_group][n].iGroupID = -1;
					vEntityGroupList[current_selected_group][n].iParentGroupID = iParentGroupID;
				}
			}
		}

		if(bGenerateUndo)
			entity_createundoaction(eUndoSys_Object_Group, current_selected_group);
	}
}

void MakeFPELine (LPSTR pLine, LPSTR pFieldName, int iOptionalIndex, cstr str)
{
	// we want to have aligned spaced fields
	memset(pLine, 0, MAX_PATH);
	strcpy(pLine, "                 = ");

	// final field name
	char pFinalFieldName[MAX_PATH];
	strcpy (pFinalFieldName, pFieldName);
	if (iOptionalIndex > 0)
	{
		cstr pOptionalNum = cstr(iOptionalIndex);
		strcat(pFinalFieldName, pOptionalNum.Get());
	}

	// fill with field name
	if (strlen(pFinalFieldName) <= 17)//pFieldName) <= 17)
	{
		memcpy(pLine, pFinalFieldName, strlen(pFinalFieldName));
	}
	else
	{
		strcpy (pLine, pFinalFieldName);
		strcat (pLine, " = ");
	}

	// add value for field
	strcat (pLine, str.Get());
}

bool SaveGroup(int iGroupID, LPSTR pObjectSavedFilename)
{
	if (current_selected_group < 0) return false;
	// collect all objects in this group
	g.entityrubberbandlist = vEntityGroupList[current_selected_group];
	if (g.entityrubberbandlist.size() == 0)
	{
		strcpy(cTriggerMessage, "Group failed to save - no objects in group");
		bTriggerMessage = true;
		return false;
	}

	// save default location
	char pEntityBankFolder[MAX_PATH];
	strcpy (pEntityBankFolder, g.fpscrootdir_s.Get());
	strcat (pEntityBankFolder, "\\Files\\entitybank\\");
	GG_GetRealPath(pEntityBankFolder, true);
	char pSaveDefaultLocation[MAX_PATH];
	strcpy (pSaveDefaultLocation, pEntityBankFolder);
	strcat (pSaveDefaultLocation, "user\\");

	// select filename to save as or have one passed in
	char pFileSelectedEntered[MAX_PATH];
	char* cFileSelectedEntered = NULL;
	if (strlen(pObjectSavedFilename) > 0)
	{
		strcpy ( pFileSelectedEntered, pSaveDefaultLocation);
		strcat ( pFileSelectedEntered, pObjectSavedFilename);
		cFileSelectedEntered = pFileSelectedEntered;
	}
	else
	{
		cStr tOldDir = GetDir();
		cFileSelectedEntered = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_SAVE, "fpe\0*.fpe\0", pSaveDefaultLocation, NULL);
		SetDir(tOldDir.Get());
	}

	if (cFileSelectedEntered == NULL)
	{
		strcpy(cTriggerMessage, "Group failed to save - you must specify a location inside entitybank");
		bTriggerMessage = true;
		return false;
	}

	// ensure entered filename has the .fpoe extension
	char cFileSelected[MAX_PATH];
	strcpy (cFileSelected, cFileSelectedEntered);
	if (strnicmp (cFileSelected + strlen(cFileSelected) - 4, ".fpe", 4) != NULL)
		strcat (cFileSelected, ".fpe");

	// can only save into entitybank
	if (strnicmp (cFileSelected, pEntityBankFolder, strlen(pEntityBankFolder)) != NULL)
	{
		strcpy(cTriggerMessage, "Group failed to save - you must specify a location inside entitybank");
		bTriggerMessage = true;
		return false;
	}

	// extract name from file chosen
	char pGroupObjectName[MAX_PATH];
	strcpy (pGroupObjectName, cFileSelected + strlen(pSaveDefaultLocation));
	pGroupObjectName[strlen(pGroupObjectName) - 4] = 0;

	// group object filename
	char pGroupObjectFilename[MAX_PATH];
	strcpy (pGroupObjectFilename, cFileSelected);
	GG_GetRealPath(pGroupObjectFilename, false);

	// gather grouip info
	int iGroupCount = g.entityrubberbandlist.size();

	// create FPE file (Group Object)
	char pLine[MAX_PATH];

	// check if one already exists of this name
	if (FileExist(pGroupObjectFilename) == 1)
	{
		strcpy(cTriggerMessage, "Group failed to save - an object of this name already exists!");
		bTriggerMessage = true;
		return false;
	}

	// write smart object
	if (FileOpen(1) == 1) CloseFile (1);
	OpenToWrite (1, pGroupObjectFilename);
	if (FileOpen(1) == 1)
	{
		WriteString (1, "; Group Object (Smart Object)");
		WriteString (1, "; header");
		MakeFPELine(pLine, "desc", 0, cstr(pGroupObjectName)); WriteString (1, pLine);
		WriteString (1, "");
		WriteString (1, "; group details");
		MakeFPELine(pLine, "isgroupobject", 0, cstr(1)); WriteString (1, pLine);
		MakeFPELine(pLine, "groupobjcount", 0, cstr(iGroupCount)); WriteString (1, pLine);
		WriteString (1, "");
		WriteString (1, "; group list");
		int e = g.entityrubberbandlist[0].e;
		float fBaseX = t.entityelement[e].x;
		float fBaseY = t.entityelement[e].y;
		float fBaseZ = t.entityelement[e].z;
		for (int i = 1; i <= iGroupCount; i++)
		{
			e = g.entityrubberbandlist[i - 1].e;
			int entid = t.entityelement[e].bankindex;
			LPSTR pEntityName = t.entitybank_s[entid].Get();

			MakeFPELine(pLine, "objname", i, cstr(pEntityName)); WriteString (1, pLine);
			MakeFPELine(pLine, "objoffx", i, cstr(t.entityelement[e].x - fBaseX)); WriteString (1, pLine);
			MakeFPELine(pLine, "objoffy", i, cstr(t.entityelement[e].y - fBaseY)); WriteString (1, pLine);
			MakeFPELine(pLine, "objoffz", i, cstr(t.entityelement[e].z - fBaseZ)); WriteString (1, pLine);
			MakeFPELine(pLine, "objrotx", i, cstr(t.entityelement[e].rx)); WriteString (1, pLine);
			MakeFPELine(pLine, "objroty", i, cstr(t.entityelement[e].ry)); WriteString (1, pLine);
			MakeFPELine(pLine, "objrotz", i, cstr(t.entityelement[e].rz)); WriteString (1, pLine);

			MakeFPELine(pLine, "objquatmode", i, cstr(t.entityelement[e].quatmode)); WriteString(1, pLine);
			MakeFPELine(pLine, "objquatx", i, cstr(t.entityelement[e].quatx)); WriteString(1, pLine);
			MakeFPELine(pLine, "objquaty", i, cstr(t.entityelement[e].quaty)); WriteString(1, pLine);
			MakeFPELine(pLine, "objquatz", i, cstr(t.entityelement[e].quatz)); WriteString(1, pLine);
			MakeFPELine(pLine, "objquatw", i, cstr(t.entityelement[e].quatw)); WriteString(1, pLine);

			MakeFPELine(pLine, "objscalex", i, cstr(t.entityelement[e].scalex)); WriteString (1, pLine);
			MakeFPELine(pLine, "objscaley", i, cstr(t.entityelement[e].scaley)); WriteString (1, pLine);
			MakeFPELine(pLine, "objscalez", i, cstr(t.entityelement[e].scalez)); WriteString (1, pLine);
			MakeFPELine(pLine, "objphysicsmode", i, cstr(t.entityelement[e].eleprof.physics)); WriteString (1, pLine);
			MakeFPELine(pLine, "objstaticmode", i, cstr(t.entityelement[e].staticflag)); WriteString (1, pLine);
			MakeFPELine(pLine, "objisimmobile", i, cstr(t.entityelement[e].eleprof.isimmobile)); WriteString (1, pLine);
			MakeFPELine(pLine, "objcollisionmode", i, cstr(t.entityelement[e].eleprof.iOverrideCollisionMode)); WriteString (1, pLine);

			if (t.entityprofile[entid].ismarker == 10)
			{
				MakeFPELine(pLine, "objshowstart", i, cstr(t.entityelement[e].eleprof.newparticle.bParticle_Show_At_Start)); WriteString (1, pLine);
			}
			else
			{
				MakeFPELine(pLine, "objshowstart", i, cstr(t.entityelement[e].eleprof.spawnatstart)); WriteString (1, pLine);
			}

			if (t.entityprofile[entid].ismarker == 10)
			{
				LPSTR pParticleName = t.entityelement[e].eleprof.newparticle.emittername.Get();
				MakeFPELine(pLine, "objpartname", i, cstr(pParticleName)); WriteString (1, pLine);
				MakeFPELine(pLine, "objpartloop", i, cstr(t.entityelement[e].eleprof.newparticle.bParticle_Looping_Animation)); WriteString (1, pLine);
				MakeFPELine(pLine, "objpartspeed", i, cstr(t.entityelement[e].eleprof.newparticle.fParticle_Speed)); WriteString (1, pLine);
				MakeFPELine(pLine, "objpartopacity", i, cstr(t.entityelement[e].eleprof.newparticle.fParticle_Opacity)); WriteString (1, pLine);
			}
			if (t.entityprofile[entid].ismarker == 2)
			{
				int lightindex = t.entityelement[e].eleprof.light.index;
				MakeFPELine(pLine, "objlighttype", i, cstr(t.entityelement[e].eleprof.light.index)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightcolor", i, cstr((int)t.entityelement[e].eleprof.light.color)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightdist", i, cstr(t.entityelement[e].eleprof.light.range)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightradius", i, cstr(t.entityelement[e].eleprof.light.offsetup)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightcast", i, cstr(t.entityelement[e].eleprof.castshadow)); WriteString (1, pLine);
				LPSTR pBehaviorName = t.entityelement[e].eleprof.aimain_s.Get();
				MakeFPELine(pLine, "objlightlogic", i, cstr(pBehaviorName)); WriteString (1, pLine);
				MakeFPELine(pLine, "objlightspot", i, cstr(t.entityelement[e].eleprof.usespotlighting)); WriteString(1, pLine);
			}
		}
		WriteString (1, "");
		WriteString (1, "; thumbnail");
		WriteString (1, "thumbnailbackdrop = Blue showroom.dds");
		CloseFile (1);

		//PE: If we got a generated thumb use this.
		if (ImageExist(iEntityGroupListImage[current_selected_group]))
		{
			char *find = (char *) pestrcasestr(cFileSelected, "entitybank\\");
			if (find)
			{
				cstr fname = (find + 11);
				CreateBackBufferCacheNameEx(fname.Get(), 512, 288, true);
				GG_SetWritablesToRoot(true);
				SaveImage(BackBufferCacheName.Get(), iEntityGroupListImage[current_selected_group]);
				GG_SetWritablesToRoot(false);
			}
		}
	}
	else
	{
		strcpy(cTriggerMessage, "Group failed to save - could not write the new object file");
		bTriggerMessage = true;
		return false;
	}

	// success
	strcpy (pObjectSavedFilename, pGroupObjectFilename + strlen(pEntityBankFolder));
	return true;
}

bool ReadFPELine (LPSTR pTryField, LPSTR pThisField, int* piOptionalIndex)
{
	if (strnicmp (pThisField, pTryField, strlen(pTryField)) == NULL)
	{
		char pNumberPart[32];
		strcpy (pNumberPart, pThisField + strlen(pTryField));
		if (pNumberPart[0] != ' ')
		{
			*piOptionalIndex = atoi(pNumberPart);
		}
		return true;
	}
	else
	{
		return false;
	}
}

struct sObjTable
{
	int entid;
	int e;
};

bool g_bCreatingHiddenGroupInstance = false;
std::vector<int> g_smartObjectDummyEntities;

bool LoadGroup(LPSTR pAbsFilename)
{
	// init vars and clear rubberband list
	cstr sGroupObjectName;
	int iGroupCount = 0;
	bool bGroupFileValid = false;
	g.entityrubberbandlist.clear();
	sObjTable* pObjTable = NULL;
	std::vector<int> entityIDsNewlyCreated;

	// parse group file to get all objects
	if (FileExist(pAbsFilename) == 1)
	{
		//LB: any instances created from group will be hidden and should not use autoflatten!
		g_bCreatingHiddenGroupInstance = true;

		// parse group file
		std::vector <cstr> groupdata_s;
		Dim (groupdata_s, 9999);
		LoadArray (pAbsFilename, groupdata_s);
		for (int groupline = 0; groupline < 9999; groupline++)
		{
			cstr line_s = groupdata_s[groupline];
			if (Len(line_s.Get()) > 0)
			{
				LPSTR pLine = line_s.Get();
				if (pLine[0] != ';')
				{
					// take fieldname and values
					for (t.c = 0; t.c < Len(pLine); t.c++)
					{
						if (pLine[t.c] == '=') { t.mid = t.c + 1; break; }
					}
					t.field_s = Lower(removeedgespaces(Left(pLine, t.mid - 1)));
					t.value_s = removeedgespaces(Right(pLine, Len(pLine) - t.mid));
					for (t.c = 0; t.c < Len(t.value_s.Get()); t.c++)
					{
						if (t.value_s.Get()[t.c] == ',') { t.mid = t.c + 1; break; }
					}
					t.value1 = ValF(removeedgespaces(Left(t.value_s.Get(), t.mid - 1)));
					t.value2_s = removeedgespaces(Right(t.value_s.Get(), Len(t.value_s.Get()) - t.mid));
					if (Len(t.value2_s.Get()) > 0)  t.value2 = ValF(t.value2_s.Get()); else t.value2 = -1;

					// populate with values found
					t.tryfield_s = "desc"; if (t.field_s == t.tryfield_s)  sGroupObjectName = t.value_s;
					t.tryfield_s = "isgroupobject"; if (t.field_s == t.tryfield_s)  bGroupFileValid = t.value1;
					t.tryfield_s = "groupobjcount";
					if (t.field_s == t.tryfield_s)
					{
						iGroupCount = t.value1;
						pObjTable = new sObjTable[iGroupCount + 1];
						memset(pObjTable, 0, sizeof(pObjTable));
					}
					if (iGroupCount > 0 && bGroupFileValid == true)
					{
						int iOptionalIndex = 0;
						if (ReadFPELine("objname", t.field_s.Get(), &iOptionalIndex))
						{
							// load this entity or find existing entid
							t.entid = 0;
							t.addentityfile_s = t.value_s.Get();
							if (t.addentityfile_s != "")
							{
								// allow filename only to be specified indicating file is local to main smart object FPE
								bool bNameOnlyNoPath = true;
								char pEntityFilePath[MAX_PATH];
								strcpy(pEntityFilePath, t.addentityfile_s.Get());
								for (int n = 0; n < strlen(pEntityFilePath); n++)
								{
									if (pEntityFilePath[n] == '\\' || pEntityFilePath[n] == '/')
									{
										bNameOnlyNoPath = false;
										break;
									}
								}
								if (bNameOnlyNoPath == true)
								{
									// get path of main smart object file
									char pMainSmartFilePath[MAX_PATH];
									strcpy(pMainSmartFilePath, pAbsFilename);
									for (int n = strlen(pMainSmartFilePath) - 1; n > 0; n--)
									{
										if (pMainSmartFilePath[n] == '\\' || pMainSmartFilePath[n] == '/')
										{
											pMainSmartFilePath[n] = 0;
											break;
										}
									}

									// add a path to this local smaert object to load child of smart object
									strcpy(pEntityFilePath, pMainSmartFilePath);
									strcat(pEntityFilePath, "\\");
									strcat(pEntityFilePath, t.addentityfile_s.Get());
									t.addentityfile_s = pEntityFilePath;
								}
								entity_adduniqueentity(false);

								// using this list to assign child states to them
								entityIDsNewlyCreated.push_back(t.entid);

								// we want to interrogate the group to get the entity profiles added,
								if (g_iAbortedAsEntityIsGroupFileModeStubOnly == 1)
								{
									// but not create entities at this stage
									continue;
								}
							}
							else
							{
								// could not load this object in the group!
								t.entid = 0;
							}
							pObjTable[iOptionalIndex].entid = t.entid;

							// entity details
							t.gridentity = t.entid;
							t.gridentityeditorfixed = 0;
							t.entitymaintype = 1;
							t.entitybankindex = t.entid;
							t.gridentitystaticmode = 0;
							t.gridentityhasparent = 0;
							t.gridentityposx_f = 0;
							t.gridentityposz_f = 0;
							t.gridentityposy_f = 0;
							t.gridentityrotatex_f = 0;
							t.gridentityrotatey_f = 0;
							t.gridentityrotatez_f = 0;
							t.gridentityrotatequatmode = 1;
							t.gridentityrotatequatx_f = 0;
							t.gridentityrotatequaty_f = 0;
							t.gridentityrotatequatz_f = 0;
							t.gridentityrotatequatw_f = 1;
							t.gridentityscalex_f = 100;
							t.gridentityscaley_f = 100;
							t.gridentityscalez_f = 100;
							entity_fillgrideleproffromprofile();

							// add new entity element (certain modes never reach here, see above code)
							t.e = 0; entity_addentitytomap();

							// add to rubberband list (e for now, rest populated later)
							int e = t.e;
							sRubberBandType rubberbandItem;
							rubberbandItem.e = e;
							g.entityrubberbandlist.push_back(rubberbandItem);

							// add reference to object table (for rest of objxxx parsing)
							pObjTable[iOptionalIndex].e = e;
							pObjTable[iOptionalIndex].entid = t.entid;

							// no leftover fields from entity loaddata (called above)
							t.field_s = "";
						}
						if (g_iAbortedAsEntityIsGroupFileModeStubOnly != 1)
						{
							if (ReadFPELine("objoffx", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].x = t.value1;
							if (ReadFPELine("objoffy", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].y = t.value1;
							if (ReadFPELine("objoffz", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].z = t.value1;
							if (ReadFPELine("objrotx", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].rx = t.value1;
							if (ReadFPELine("objroty", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].ry = t.value1;
							if (ReadFPELine("objrotz", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].rz = t.value1;
							if (ReadFPELine("objscalex", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].scalex = t.value1;
							if (ReadFPELine("objscaley", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].scaley = t.value1;
							if (ReadFPELine("objscalez", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].scalez = t.value1;
							if (ReadFPELine("objphysicsmode", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.physics = t.value1;
							if (ReadFPELine("objstaticmode", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].staticflag = t.value1;
							if (ReadFPELine("objisimmobile", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.isimmobile = t.value1;
							if (ReadFPELine("objshowstart", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.bParticle_Show_At_Start = t.value1;
							if (ReadFPELine("objshowstart", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.spawnatstart = t.value1;
							if (ReadFPELine("objpartname", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.emittername = t.value_s;
							if (ReadFPELine("objpartloop", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.bParticle_Looping_Animation = t.value1;
							if (ReadFPELine("objpartspeed", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.fParticle_Speed = t.value1;
							if (ReadFPELine("objpartopacity", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.newparticle.fParticle_Opacity = t.value1;
							if (ReadFPELine("objlighttype", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.index = t.value1;
							if (ReadFPELine("objlightcolor", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.color = t.value1;
							if (ReadFPELine("objlightdist", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.range = t.value1;
							if (ReadFPELine("objlightradius", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.light.offsetup = t.value1;
							if (ReadFPELine("objlightcast", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.castshadow = t.value1;
							if (ReadFPELine("objlightlogic", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.aimain_s = t.value_s;
							if (ReadFPELine("objlightspot", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.usespotlighting = t.value1;
							if (ReadFPELine("objquatmode", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].quatmode = t.value1;
							if (ReadFPELine("objquatx", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].quatx = t.value1;
							if (ReadFPELine("objquaty", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].quaty = t.value1;
							if (ReadFPELine("objquatz", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].quatz = t.value1;
							if (ReadFPELine("objquatw", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].quatw = t.value1;
							if (ReadFPELine("objcollisionmode", t.field_s.Get(), &iOptionalIndex)) t.entityelement[pObjTable[iOptionalIndex].e].eleprof.iOverrideCollisionMode = t.value1;
						}
					}
				}
			}
		}
		UnDim(groupdata_s);

		// in this mode we just want the entity profiles from any groups, no need to instantiate entity elements yet
		if (g_iAbortedAsEntityIsGroupFileModeStubOnly == 1)
			return true;

		// location to place the entityelements for this group load
		float fBaseX = 0;
		float fBaseY = -500000; //PE: Hide master group.
		float fBaseZ = 0;

		// raise baseY so lowest object in the group is one floor
		float fLowest = 0.0f;
		for (int i = 0; i < g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			if (t.entityelement[e].y < fLowest)
				fLowest = t.entityelement[e].y;
		}
		if (fLowest < 0.0f) fBaseY -= fLowest;

		// populate rubberband list items
		for (int i = 0; i < g.entityrubberbandlist.size(); i++)
		{
			// first update object from final entity element data
			int e = g.entityrubberbandlist[i].e;

			// place entity so can be seen
			t.entityelement[e].x += fBaseX;
			t.entityelement[e].y += fBaseY;
			t.entityelement[e].z += fBaseZ;

			// update entity object from its new settings
			t.tupdatee = e; entity_updateentityobj();

			t.entityelement[e].iIsSmarkobjectDummyObj = 1; //PE: We need a way so we dont display these, in the detailed object list.

			// update lights and particles too
			int entid = t.entityelement[e].bankindex;
			if (t.entityprofile[entid].ismarker == 0)
			{
				entity_updateautoflatten(t.tupdatee);
			}
			if (t.entityprofile[entid].ismarker == 2 || t.entityprofile[entid].ismarker == 5 || t.entityelement[t.e].eleprof.usespotlighting)
			{
				t.entityelement[e].eleprof.light.index = 0;
				lighting_refresh();
				entity_updatelightobj(e, t.entityelement[e].obj);
			}
			if (t.entityprofile[entid].ismarker == 10)
			{
				t.entityelement[e].eleprof.newparticle.emitterid = -1;
				entity_updateparticleemitter(t.tupdatee);
			}

			// and then add correct values to rubberband list
			g.entityrubberbandlist[i].x = t.entityelement[e].x;
			g.entityrubberbandlist[i].y = t.entityelement[e].y;
			g.entityrubberbandlist[i].z = t.entityelement[e].z;
			g.entityrubberbandlist[i].px = t.entityelement[e].x;
			g.entityrubberbandlist[i].py = t.entityelement[e].y;
			g.entityrubberbandlist[i].pz = t.entityelement[e].z;
			g.entityrubberbandlist[i].rx = t.entityelement[e].rx;
			g.entityrubberbandlist[i].ry = t.entityelement[e].ry;
			g.entityrubberbandlist[i].rz = t.entityelement[e].rz;

			// calculate quat from ROTXYZ in smart object child
			//if(t.entityelement[e].quatmode == 0) // seems quatmode set to 1 but has no quat in there for BE objects
			entity_updatequatfromeuler(e);

			g.entityrubberbandlist[i].quatmode = t.entityelement[e].quatmode;
			g.entityrubberbandlist[i].quatx = t.entityelement[e].quatx;
			g.entityrubberbandlist[i].quaty = t.entityelement[e].quaty;
			g.entityrubberbandlist[i].quatz = t.entityelement[e].quatz;
			g.entityrubberbandlist[i].quatw = t.entityelement[e].quatw;
			g.entityrubberbandlist[i].scalex = t.entityelement[e].scalex;
			g.entityrubberbandlist[i].scaley = t.entityelement[e].scaley;
			g.entityrubberbandlist[i].scalez = t.entityelement[e].scalez;

			g.entityrubberbandlist[i].iGroupID = -1;
			g.entityrubberbandlist[i].iParentGroupID = -1;
		}

		if (g_iAbortedAsEntityIsGroupFileModeStubOnly > 0)
		{
			// group data and entities already loaded, we can skip a new group creation here
			if (g_iAbortedAsEntityIsGroupFileModeStubOnly > 1)
			{
				int iParentGroupIndex = g_iAbortedAsEntityIsGroupFileModeStubOnly - 2;
				if (iParentGroupIndex != -1)
				{
					vEntityGroupList[iParentGroupIndex] = g.entityrubberbandlist;
				}
			}
		}
		else
		{
			// create group from list
			CreateNewGroup(-1, false, cstr(pAbsFilename));

			// populate newly created hidden elements of group with associated groupID
			int iUniqueGroupID = -1;
			int iGroupIndex = GetGroupIndexFromName(pAbsFilename);
			if (vEntityGroupList[iGroupIndex].size() > 0)
			{
				iUniqueGroupID = vEntityGroupList[iGroupIndex][0].iGroupID;
			}
			for (int i = 0; i < g.entityrubberbandlist.size(); i++)
			{
				// first update object from final entity element data
				int ee = g.entityrubberbandlist[i].e;
				t.entityelement[ee].creationOfGroupID = iUniqueGroupID;
			}
		}

		//LB: back to regular mode, instances can be autoflatten again!
		g_bCreatingHiddenGroupInstance = false;

		// any entities created here should be assigned current_selected_group
		for (auto& entityID : entityIDsNewlyCreated)
		{
			t.entityprofile[entityID].ischildofgroup = 1;
		}
		entityIDsNewlyCreated.clear();
	}
	else
	{
		strcpy(cTriggerMessage, "Group failed to load - no file found");
		return false;
	}

	// success
	return true;
}

void AddEntityToCursor(int e, bool bDuplicate)
{
	if (e <= 0) return;

	if (t.gridentityinzoomview > 0) return; //Return if we are in "properties".

	if (!bDuplicate && t.entityelement[e].editorlock) return; //Dont allow selection of locked entity.


	//PE: we loose status somewhere, so force it off after adding a entity to map.
	extern bool bCubesVisible;
	if (bCubesVisible == false) bCubesVisible = true; //Force.

	if (!bDuplicate)
		iLastEntityOnCursor = e;
	else
		iLastEntityOnCursor = 0;

	//PE: Check if we can do a valid offset.
	float clickx = 0.0f, clickz = 0.0f, fPickedYAxis = 0.0f;
	// PE: Mixed system

	bDetectTerrainOnly = false;

	if (!bDuplicate)
	{
		int iObj = t.entityelement[e].obj;
		bool bVisible = false;
		if (iObj > 0)
		{
			if (ObjectExist(iObj) == 1)
			{
				sObject* pObject = g_ObjectList[iObj];
				bVisible = pObject->bVisible;
				HideObject(iObj);
			}
		}
		//Sent ray with the object visible.
		WickedCall_GetPick(&clickx, &fPickedYAxis, &clickz, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL);

		if (bVisible)
		{
			ShowObject(iObj);
		}
	}

	if (!bDuplicate)
	{
		if (g.entityrubberbandlist.size() > 0)
		{
			bool bEntityOk = false;
			//Only allow selection/move if within rubberband.
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int ent = g.entityrubberbandlist[i].e;
				if (ent == e)
				{
					bEntityOk = true;
					break;
				}
			}
			if (!bEntityOk) return;
		}
	}
	if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
	if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
	if (bImporter_Window) { importer_quit(); bImporter_Window = false; }

	DeleteWaypointsAddedToCurrentCursor();
	//CheckTooltipObjectDelete();
	CloseDownEditorProperties();

	//LB: Only when not in shooter mode
	//LB: shooter now a filter mode if (!Shooter_Tools_Window)
	{
		//Make sure we are in entity mode.
		bForceKey = true;
		csForceKey = "o";
	}

	t.tentitytoselect = e;
	t.widget.duplicatebuttonselected = 0;
	t.gridentityautofind = 7;

	t.onetimeentitypickup = 1;

	//  extract entity from the map
	if (t.tentitytoselect > 0)
	{
		if (t.entityelement[t.tentitytoselect].editorfixed == 0)
		{
			fExtractYValue = t.entityelement[t.tentitytoselect].y;

			t.gridentityeditorfixed = t.entityelement[t.tentitytoselect].editorfixed;
			t.gridentity = t.entityelement[t.tentitytoselect].bankindex;
			t.ttrygridentitystaticmode = t.entityelement[t.tentitytoselect].staticflag;
			t.ttrygridentity = t.gridentity; editor_validatestaticmode();
			t.gridedit.autoflatten = t.entityprofile[t.gridentity].autoflatten;
			//t.gridedit.entityspraymode = 0; //PE: spray checkbox.
			if (t.gridentityautofind == 7)
			{
				//  widget extracts without forcing entity to Floor
				t.gridentityautofind = 0;
				t.gridentityposoffground = 1;
				t.gridentityusingsoftauto = 0;
			}
			else
			{
				t.gridentityposoffground = 0;
				t.gridentityusingsoftauto = 1;
				#ifdef WICKEDENGINE
				// MAX handles its own positioning system
				#else
				if (t.entityprofile[t.gridentity].defaultstatic == 0 && t.entityprofile[t.gridentity].isimmobile == 1)
				{
					t.gridentityautofind = 1;
				}
				else
				#endif
				{
					t.gridentityautofind = 0;
				}
			}
			t.gridentitysurfacesnap = 0; // surfacesnap off as messes up extract offset for entity
			t.gridentityextractedindex = t.tentitytoselect;
			t.gridentityhasparent = 0;//t.entityelement[t.tentitytoselect].iHasParentIndex; 210317 - break association when extract so can place free of parent
			t.gridentityposx_f = t.entityelement[t.tentitytoselect].x;
			t.gridentityposy_f = t.entityelement[t.tentitytoselect].y;
			t.gridentityposz_f = t.entityelement[t.tentitytoselect].z;
			t.gridentityrotatex_f = t.entityelement[t.tentitytoselect].rx;
			t.gridentityrotatey_f = t.entityelement[t.tentitytoselect].ry;
			t.gridentityrotatez_f = t.entityelement[t.tentitytoselect].rz;
			t.gridentityrotatequatmode = t.entityelement[t.tentitytoselect].quatmode;
			t.gridentityrotatequatx_f = t.entityelement[t.tentitytoselect].quatx;
			t.gridentityrotatequaty_f = t.entityelement[t.tentitytoselect].quaty;
			t.gridentityrotatequatz_f = t.entityelement[t.tentitytoselect].quatz;
			t.gridentityrotatequatw_f = t.entityelement[t.tentitytoselect].quatw;
			if (t.entityprofile[t.gridentity].ismarker == 10)
			{
				t.gridentityscalex_f = 100.0f + t.entityelement[t.tentitytoselect].scalex;
				t.gridentityscaley_f = 100.0f + t.entityelement[t.tentitytoselect].scaley;
				t.gridentityscalez_f = 100.0f + t.entityelement[t.tentitytoselect].scalez;
			}
			else
			{
				t.gridentityscalex_f = ObjectScaleX(t.entityelement[t.tentitytoselect].obj);
				t.gridentityscaley_f = ObjectScaleY(t.entityelement[t.tentitytoselect].obj);
				t.gridentityscalez_f = ObjectScaleZ(t.entityelement[t.tentitytoselect].obj);
			}
			t.grideleprof = t.entityelement[t.tentitytoselect].eleprof;
			t.grideleproflastname_s = t.grideleprof.name_s;

			//  Transfer any waypoint association
			t.waypointindex = t.entityelement[t.tentitytoselect].eleprof.trigger.waypointzoneindex;
			t.grideleprof.trigger.waypointzoneindex = t.waypointindex;
			t.waypoint[t.waypointindex].linkedtoentityindex = 0;

			//Just place under cursor.
			t.inputsys.dragoffsetx_f = 0;
			t.inputsys.dragoffsety_f = 0;

			float lowy = 0.0f;

			if (bDuplicate)
			{
				//PE: New object need a unique particle id.
				t.grideleprof.newparticle.emitterid = -1;
			}

			// get object size before we delete it
			float fObjectRealSize = 0.0f;
			if (t.tentitytoselect > 0) 
				fObjectRealSize = ObjectSize(t.entityelement[t.tentitytoselect].obj, 1);

			if (!bDuplicate) 
			{
				lowy = GetLowestY(t.entityelement[t.tentitytoselect].obj);
				g_UndoSysObjectIsBeingMoved = true; // this is not a real delete, just a step in highlighting the entity
				t.gridentitypreferelementindex = t.tentitytoselect; // set a preference where we want object put back into element index
				gridedit_deleteentityfrommap();
				g_UndoSysObjectIsBeingMoved = false;
				t.onetimeentitypickup = 0;
				//PE: If this is a light ,
				if (t.entityprofile[t.gridentity].ismarker == 2 || t.entityprofile[t.gridentity].ismarker == 5)
				{
					//Add the light.
					if (t.gridentitywickedlightindex == 0)
					{
						int iLightType = 1;
						if (t.grideleprof.usespotlighting) iLightType = 2;
						t.gridentitywickedlightindex = WickedCall_AddLight(iLightType);
					}
					if (t.gridentitywickedlightindex > 0)
					{
						float lightx = t.gridentityposx_f;
						float lighty = t.gridentityposy_f;
						float lightz = t.gridentityposz_f;
						float lightax = t.gridentityrotatex_f;
						float lightay = t.gridentityrotatey_f;
						float lightaz = t.gridentityrotatez_f;
						float lightrange = t.grideleprof.light.range;
						float lightspotradius = t.grideleprof.light.offsetup;
						int colr = ((t.grideleprof.light.color & 0x00ff0000) >> 16);
						int colg = ((t.grideleprof.light.color & 0x0000ff00) >> 8);
						int colb = (t.grideleprof.light.color & 0x000000ff);
						bool bCastShadow = true;
						if (t.grideleprof.castshadow == 1) bCastShadow = false;
						WickedCall_UpdateLight(t.gridentitywickedlightindex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, lightspotradius, colr, colg, colb, bCastShadow);
					}
				}
			}

			fHitPointX = 0;
			fHitPointY = HITPOINTYSTARTPOS;
			fHitPointZ = 0;
			fHitOffsetX = 0;
			fHitOffsetY = 0;
			fHitOffsetZ = 0;
			iStartMouseX = (int)ImGui::GetMousePos().x;
			iStartMouseY = (int)ImGui::GetMousePos().y;
			iLastHitObjectID = 0;

			g_bHoldGridEntityPosWhenManaged = true;
			g_fHoldGridEntityPosX = t.gridentityposx_f;
			g_fHoldGridEntityPosY = t.gridentityposy_f;
			g_fHoldGridEntityPosZ = t.gridentityposz_f;

			if (!bDuplicate)
			{
				// LB: get the first hit XYZ when click an object to move about
				fHitPointX = t.inputsys.localx_f;
				fHitPointY = t.inputsys.localcurrentterrainheight_f;
				fHitPointZ = t.inputsys.localy_f;
				fHitOffsetX = fHitPointX - t.gridentityposx_f;
				fHitOffsetY = fHitPointY - t.gridentityposy_f;
				fHitOffsetZ = fHitPointZ - t.gridentityposz_f;

				//PE: Need to start rubberbandmove with same values.
				t.fOldGridEntityX = t.gridentityposx_f;
				t.fOldGridEntityY = t.gridentityposy_f;
				t.fOldGridEntityZ = t.gridentityposz_f;
				t.fOldGridEntityRX = t.gridentityrotatex_f;
				t.fOldGridEntityRY = t.gridentityrotatey_f;
				t.fOldGridEntityRZ = t.gridentityrotatez_f;
				t.fOldGridEntityQuatMode = t.gridentityrotatequatmode;
				t.fOldGridEntityQuatX = t.gridentityrotatequatx_f;
				t.fOldGridEntityQuatY = t.gridentityrotatequaty_f;
				t.fOldGridEntityQuatZ = t.gridentityrotatequatz_f;
				t.fOldGridEntityQuatW = t.gridentityrotatequatw_f;
			}
			else
			{
				g.entityrubberbandlist.clear();
			}

			// get size of object selected, to determine if to use drop system (only used for larger objects)
			iObjectMoveModeDropSystemUsing = 0;
			int iForwardFacing = t.entityprofile[t.gridentity].forwardfacing;
			float fUpDownAngle = WrapValue(CameraAngleX(0));
			if (fUpDownAngle > 10.0f && fUpDownAngle < 91.0f)
			{
				// down is fine for ghost drop
				if (t.tentitytoselect > 0 && fObjectRealSize > 20.0f && iForwardFacing == 0 && g_iStackToSurfaceMode == 1)
				{
					bool bJustForInitialDragIn = false;
					if (bDraggingActive == false && fHitOffsetX == 0 && fHitOffsetY == 0 && fHitOffsetZ == 0) bJustForInitialDragIn = true;
					if (bDraggingActive == true && t.gridentityposx_f == 0 && t.gridentityposz_f == 0) bJustForInitialDragIn = true;
					if (bDraggingActiveInitial == true)	bJustForInitialDragIn = true;
					if (bJustForInitialDragIn == true || g.entityrubberbandlist.size() <= 1)
					{
						iObjectMoveModeDropSystemUsing = 1;
					}
				}
			}
			else
			{
				// looking up and to side, drop system not a good idea
			}

			if (!bDuplicate) 
			{
				// find surface height (terrain is surface for now)
				//float fHitX, fHitY, fHitZ;
				//float fSurfaceFloorHeight = GGORIGIN_Y;
				//if (WickedCall_SentRay(t.entityelement[t.tentitytoselect].x, t.entityelement[t.tentitytoselect].y, t.entityelement[t.tentitytoselect].z, 0, -1.0f, 0, &fHitX, &fHitY, &fHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_TERRAIN))
				//{
				//	fSurfaceFloorHeight = fHitY;
				//}

				// in smart positning mode, always find surface when drop into level
				if (iObjectMoveMode == 2 && iObjectMoveModeDropSystem == 0)
				{
					if (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false)
					{
						iObjectMoveModeDropSystem = 1;
						t.inputsys.dragoffsetx_f = 0.0f;
						t.inputsys.dragoffsety_f = 0.0f;
					}
				}
				else
				{
					// positioning mode horiz and vert do not seek surface adjustment, so keep as is
					t.inputsys.dragoffsetx_f = t.entityelement[t.tentitytoselect].x - clickx;
					t.inputsys.dragoffsety_f = t.entityelement[t.tentitytoselect].z - clickz;
				}
			}
			else
			{
				// in smart positning mode, always find surface when drop into level
				if (iObjectMoveMode == 2 && iObjectMoveModeDropSystem == 0)
				{
					if (iObjectMoveModeDropSystemUsing == 1 && g_bHoldGridEntityPosWhenManaged == false)
					{
						iObjectMoveModeDropSystem = 1;
						t.inputsys.dragoffsetx_f = 0.0f;
						t.inputsys.dragoffsety_f = 0.0f;
					}
				}
			}

			t.widget.pickedObject = 0;
			widget_updatewidgetobject();
			t.refreshgrideditcursor = 1;
		}
	}
}


void BeginDragDropFPE(char *fpe, int textureid, bool bToolTipActive, ImVec2 vISize)
{
	if (bWaitOnMouseRelease)
	{
		if (!ImGui::IsMouseDown(0))
			bWaitOnMouseRelease = false;
	}

	if (bToolTipActive && pref.iEnableDragDropEntityMode && !bWaitOnMouseRelease && t.gridentity == 0 && t.gridentityobj == 0 && ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
	{

		cstr find = fpe;

		cFolderItem *pSearchFolder = &MainEntityList;
		cFolderItem::sFolderFiles * foundfiles = NULL;
		pSearchFolder = pSearchFolder->m_pNext;
		cStr path = "";
		cStr path_remove = pSearchFolder->m_sFolderFullPath.Get();
		std::string sFpeName;
		int ipath_remove_len = path_remove.Len();
		bool bFound = false;
		while (pSearchFolder)
		{
			if (pSearchFolder->iType == 0)
			{
				cStr path = pSearchFolder->m_sFolderFullPath.Get();

				bool bDoubleEntityBank = false;
				char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
				if (finde)
				{
					finde += 11;
					finde = (char *)pestrcasestr(finde, "\\entitybank");
					if (finde) bDoubleEntityBank = true;
				}

				if (!bDoubleEntityBank && path.Right(11) == "\\entitybank")
				{
					ipath_remove_len = path.Len();
				}
				else
				{
					if (pSearchFolder->m_pFirstFile) {
						cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
						while (searchfiles) {
							foundfiles = searchfiles;
							path = pSearchFolder->m_sFolderFullPath.Get();
							char *final_name = path.Get();
							final_name += ipath_remove_len;
							if (*final_name == '\\')
								final_name++;

							std::string path_for_filename = final_name;
							sFpeName = path_for_filename.c_str();
							sFpeName = sFpeName + "\\" + foundfiles->m_sName.Get();
							if (stricmp(find.Get(), sFpeName.c_str()) == 0)
								bFound = true;
							if (bFound)
								break;
							searchfiles = searchfiles->m_pNext;
						}
					}
				}
				if (bFound)
					break;
			}
			pSearchFolder = pSearchFolder->m_pNext;
		}

		if (bFound && foundfiles)
		{
			CloseDownEditorProperties();
			t.inputsys.constructselection = 0;

			foundfiles->m_dropptr = foundfiles;
			foundfiles->iAnimationFrom = 0;

			foundfiles->m_sFolder = sFpeName.c_str();
			ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", foundfiles, sizeof(void *));
			ImGui::ImgBtn(textureid, vISize, drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
			//ImGui::Text("%s", myfiles->m_sName.Get());
			//ImGui::SetCursorPos(oldCursor);
			pDragDropFile = foundfiles;
			/*ImGui::EndDragDropSource();*/
			bReadyToDropEntity = false;
			iDragDropActive = 50;
			bDraggingActive = true;
			bDraggingActiveInitial = true;
			// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
			t.gridentityposx_f = t.inputsys.localx_f;
			t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
			t.gridentityposz_f = t.inputsys.localy_f;
		}
		// ZJ: Moved this here, to prevent the icons being dragged in release, and assertion error in debug, when bFound is false 
		ImGui::EndDragDropSource();
	}
}


void DisplayFPEMedia(bool readonly, int entid, entityeleproftype *edit_grideleprof)
{
	int tflagtext = 0, tflagimage = 0; //PE: These is not used in VRTECH ?
	bool mediaactive[6] = { true,true,true,true,true,true };
	int iActiveMedia = 0;

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	if (readonly)
	{
		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
	}

	if (readonly)
	{
		if (edit_grideleprof->soundset_s.Len() <= 0)
		{
			mediaactive[0] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset1_s.Len() <= 0)
		{
			mediaactive[1] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset2_s.Len() <= 0)
		{
			mediaactive[2] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset3_s.Len() <= 0)
		{
			mediaactive[3] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset5_s.Len() <= 0)
		{
			mediaactive[4] = false;
			iActiveMedia++;
		}
		if (edit_grideleprof->soundset6_s.Len() <= 0)
		{
			mediaactive[5] = false;
			iActiveMedia++;
		}
	}
	
	// Sound
	if (t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1)
	{
		cstr group_text;
		if (tflagtext == 1 || tflagimage == 1)
		{
			if (tflagtext == 1) group_text = "Text";
			if (tflagimage == 1) group_text = "Image";
		}
		else
		{
			group_text = "Media";
		}


		//ImGui::TextCenter(group_text.Get());

		if (g.fpgcgenre == 1)
		{
			if (t.entityprofile[entid].ischaracter > 0)
			{
				if(mediaactive[0])
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[254].Get(), "audiobank\\",readonly);
			}
			else
			{
				if (g.vrqcontrolmode != 0)
				{
					if (t.tflagsound == 1 && t.tflagsoundset != 1)
					{
						//PE: changed from 469 to 467 , should be sound0
						if(mediaactive[0])
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
					}
				}
				else
				{
					if (t.tflagsound == 1 && t.tflagsoundset != 1)
					{
						if (mediaactive[0])
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
					}
				}
				if (t.tflagsoundset == 1)
				{
					if (mediaactive[0])
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
				}
				if (tflagtext == 1)
				{
					if (mediaactive[0])
						edit_grideleprof->soundset_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Text to Appear", "Enter text to appear in-game",readonly);
				}
				if (tflagimage == 1)
				{
					if (mediaactive[0])
					{
						#ifdef WICKEDENGINE
						#define IMGFILEID (PROPERTIES_CACHE_ICONS+998)
						static cstr imgfile = "";
						static int imgfile_preview_id = 0;
						if (edit_grideleprof->soundset_s != imgfile)
						{
							//Load new image preview.
							imgfile_preview_id = 0;
							if (edit_grideleprof->soundset_s != "")
							{
								image_setlegacyimageloading(true);
								LoadImage((char *)edit_grideleprof->soundset_s.Get(), IMGFILEID);
								image_setlegacyimageloading(false);
								imgfile_preview_id = IMGFILEID;
								if (!GetImageExistEx(IMGFILEID))
								{
									imgfile_preview_id = 0;
								}
							}
							imgfile = edit_grideleprof->soundset_s;
						}

						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "imagebank\\", readonly);

						if (imgfile_preview_id > 0 && GetImageExistEx(imgfile_preview_id))
						{
							float w = ImGui::GetContentRegionAvailWidth();
							float iwidth = w;
							float ImgW = ImageWidth(imgfile_preview_id);
							float ImgH = ImageHeight(imgfile_preview_id);
							float fHighRatio = ImgH / ImgW;
							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (iwidth*0.5), 0.0f));
							ImGui::ImgBtn(imgfile_preview_id, ImVec2(iwidth - 18.0f, (iwidth - 18.0f) * fHighRatio), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
						}
						#else
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "scriptbank\\images\\imagesinzone\\", readonly);
						#endif
					}
				}
			}

			if (t.tflagnosecond == 0)
			{
				if (t.tflagsound == 1 || t.tflagsoundset == 1)
				{
					//We got some missing translations.
					if (t.strarr_s[468] == "") t.strarr_s[468] = "Sound1";
					if (t.strarr_s[480] == "") t.strarr_s[480] = "Sound2";
					if (t.strarr_s[481] == "") t.strarr_s[481] = "Sound3";
					if (t.strarr_s[482] == "") t.strarr_s[482] = "Sound4";
					if (mediaactive[1])
						edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
					if (mediaactive[2])
						edit_grideleprof->soundset2_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset2_s.Get(), t.strarr_s[480].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
					if (mediaactive[3])
						edit_grideleprof->soundset3_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset3_s.Get(), t.strarr_s[481].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
					//if (mediaactive[4])
					//	edit_grideleprof->soundset5_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset5_s.Get(), t.strarr_s[482].Get(), t.strarr_s[254].Get(), "audiobank\\", readonly);
					if (mediaactive[4])
						edit_grideleprof->soundset6_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset5_s.Get(), "Sound5", t.strarr_s[254].Get(), "audiobank\\", readonly);
					if (mediaactive[5])
						edit_grideleprof->soundset6_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset6_s.Get(), "Sound6", t.strarr_s[254].Get(), "audiobank\\", readonly);
				}
			}
		}
		else
		{
			if (t.tflagsoundset == 1)
			{
				if (mediaactive[0])
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
			}
			else
			{
				if (mediaactive[0])
					edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly); ++t.controlindex;
			}
			if (mediaactive[1])
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly); ++t.controlindex;
		}

	}

	// Video
	if (t.tflagvideo == 1)
	{
		//t.strarr_s[597].Get()
		if (mediaactive[1])
			edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\",readonly);
	}

	if (readonly)
	{
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
}

void DisplayFPEPhysics(bool readonly, int entid, entityeleproftype *edit_grideleprof)
{
	if (readonly)
	{
		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
	}

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	//Physics
	cstr desc ="";
	if (t.entityprofile[entid].ismarker == 0 && t.entityprofile[entid].islightmarker == 0)
	{
		ImGui::PushItemWidth(-10);

		if (edit_grideleprof->physics != 1)  edit_grideleprof->physics = 0;

		//t.grideleprof.physics = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.physics), t.strarr_s[580].Get(), t.strarr_s[581].Get(), 0);
		bool btmp = edit_grideleprof->physics;
		ImGui::Checkbox("Object Uses Physics?", &btmp);
		edit_grideleprof->physics = btmp;
		desc = t.strarr_s[581];
		if (ImGui::IsItemHovered() && desc.Len() > 0)
		{
			//When using checkbox, change text.
			std::string newtext = desc.Get();
			replaceAll(newtext, "Set to YES", "If set");
			replaceAll(newtext, " to YES", "");
			ImGui::SetTooltip("%s", newtext.c_str());
		}

		btmp = edit_grideleprof->phyalways;
		ImGui::Checkbox("Always Active?", &btmp);
		edit_grideleprof->phyalways = btmp;
		desc = t.strarr_s[583];
		if (ImGui::IsItemHovered() && desc.Len() > 0)
		{
			//When using checkbox, change text.
			std::string newtext = desc.Get();
			replaceAll(newtext, "Set to YES", "If set");
			replaceAll(newtext, " to YES", "");
			ImGui::SetTooltip("%s", newtext.c_str());
		}

		//t.grideleprof.phyweight = atol(imgui_setpropertystring2(t.group, Str(t.grideleprof.phyweight), t.strarr_s[584].Get(), t.strarr_s[585].Get()));
		ImGui::TextCenter("Weight of Object");
		desc = t.strarr_s[585];
		ImGui::MaxSliderInputInt("##weightphysics", &edit_grideleprof->phyweight, 0, 1000, desc.Get());
		
		ImGui::TextCenter("Object's Friction");
		desc = t.strarr_s[587];
		ImGui::MaxSliderInputInt("##frictionphysics", &edit_grideleprof->phyfriction, 0, 1000, desc.Get());
	
		if (t.tflagsimpler == 0)
		{
			//t.grideleprof.explodable = imgui_setpropertylist2(t.group, t.controlindex, Str(t.grideleprof.explodable), t.strarr_s[592].Get(), t.strarr_s[593].Get(), 0);
			btmp = edit_grideleprof->explodable;
			ImGui::Checkbox("Explodable Object?", &btmp);
			edit_grideleprof->explodable = btmp;
			desc = t.strarr_s[593];
			if (ImGui::IsItemHovered() && desc.Len() > 0)
			{
				//When using checkbox, change text.
				std::string newtext = desc.Get();
				replaceAll(newtext, "Set to YES", "If set");
				replaceAll(newtext, " to YES", "");
				ImGui::SetTooltip("%s", newtext.c_str());
			}

			// Explosion Properties
			ImGui::TextCenter("Explosion Damage");
			ImGui::MaxSliderInputInt("##damagephysics", &edit_grideleprof->explodedamage, 0, 1000, t.strarr_s[595].Get());
			ImGui::TextCenter("Explosion Height");
			ImGui::MaxSliderInputInt("##damagephysicsheight", &edit_grideleprof->explodeheight, 0, 100, "Set the optional height at which the explosion occurs above default object center");
		}

		ImGui::PopItemWidth();
	}

	if (readonly)
	{
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
}

void gridedit_makelighthybrid ( void )
{
	// create a single object that has multiple meshes inside it to represent different light types
	LPSTR pHybridLightModel = "entitybank\\_markers\\hybridlight.dbo";
	if (FileExist(pHybridLightModel) == 0)
	{
		// load in point light
		LoadObject ("entitybank\\_markers\\light.dbo", g.tempobjectoffset+0);
		RotateLimb(g.tempobjectoffset + 0, 0, 90, 0, 0);

		// load in spot light
		LoadObject ("entitybank\\_markers\\spotlight.dbo", g.tempobjectoffset+1);
		RotateObject(g.tempobjectoffset + 1, -90, 0, 0);
		MakeMeshFromObject(g.tempobjectoffset + 1, g.tempobjectoffset + 1);

		// add spot to point
		sObject* pObject = GetObjectData(g.tempobjectoffset+0);
		int iFrameCount = pObject->iFrameCount;
		AddLimb(g.tempobjectoffset+0, iFrameCount, g.tempobjectoffset + 1);

		// remove unneeded resources
		DeleteMesh(g.tempobjectoffset + 1);
		DeleteObject(g.tempobjectoffset + 1);

		//PE: saved object only have 3 frames ?
		// save new hybrid light for use by all new light markers
		SaveObject (pHybridLightModel, g.tempobjectoffset);
	}
}

entityeleproftype *lua_grideleprof;
entityeleproftype lua_readonly_grideleprof; //Temp for readonly dynamic lua parsing.

void DisplayFPEBehavior(bool readonly, int entid, entityeleproftype* edit_grideleprof, int elementID)
{
	//FPE Properties.
	bool bIsLightProbe = false;
	bool bDisplaySmallIcon = false;
	bool bDisplayName = false;
	static int fpe_current_selected_script = 0;
	static bool fpe_current_loaded_script_has_dlua = false;
	int media_icon_size = 64;
	LPSTR pAIRoot = "scriptbank\\";

	// flag if a probe
	if (entid > 0 && t.entityprofile[entid].ismarker == 2 && edit_grideleprof->light.fLightHasProbe >= 50.0f)
	{
		bIsLightProbe = true;
	}

	if (readonly)
	{
		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
	}

	if (readonly)
		lua_grideleprof = &lua_readonly_grideleprof;
	else {
		if (!edit_grideleprof)
			lua_grideleprof = &t.grideleprof;
		else
			lua_grideleprof = edit_grideleprof;
	}

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	if (t.tflagai == 1)
	{
		if (g.quickparentalcontrolmode == 2)
		{
			if (t.entityprofile[entid].ismarker == 0)
			{
				if (t.tflagchar == 1)
					pAIRoot = "scriptbank\\people\\";
				else
					pAIRoot = "scriptbank\\objects\\";
			}
			else
			{
				pAIRoot = "scriptbank\\markers\\";
			}
		}
	}

	fPropertiesColoumWidth = ImGui::GetCursorPosX() + 90.0f;

	#ifdef USENEWMEDIASELECTWINDOWS
	char cDisplayName[MAX_PATH];
	strcpy(cDisplayName, edit_grideleprof->aimain_s.Get());
	char * find = (char *)pestrcasestr(cDisplayName, "\\");
	while (find)
	{
		find++;
		strcpy(cDisplayName, find);
		find = (char *)pestrcasestr(cDisplayName, "\\");
	}
	// special format for LUA titles
	FormatLUAFilenameToTitle(cDisplayName);
	#endif

	if (t.entityprofile[entid].ischaracter > 0)
	{
		//"Character Properties"
		if (bDisplaySmallIcon)
		{
			//Display icon.
			if (t.entityprofile[entid].iThumbnailSmall > 0) {
				float w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
				ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
			}
		}
		//Display name.
		if(bDisplayName)
			edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(), readonly);


		int speech_entries = 0;
		bool bUpdateMainString = false;

		for (int speech_loop = 0; speech_loop < 5; speech_loop++)
			speech_ids[speech_loop] = -1;
		
		//"Character Behavior"
		//ImGui::TextCenter("Behaviors");

		ImGui::PushItemWidth(-10);

		// scan PEOPLE folder for complete list of script
		std::vector<cstr> scriptList_s; scriptList_s.clear();
		std::vector<cstr> scriptListTitle_s; scriptListTitle_s.clear();
		cstr oldDir_s = GetDir();
		SetDir(g.fpscrootdir_s.Get());
		SetDir("Files\\scriptbank\\people");
		ChecklistForFiles();
		for (int f = 1; f <= ChecklistQuantity(); f++)
		{
			cstr tfile_s = ChecklistString(f);
			LPSTR pFilename = tfile_s.Get();
			if (tfile_s != "." && tfile_s != "..")
			{
				if (strnicmp(pFilename + strlen(pFilename) - 4, ".lua", 4) == NULL)
				{
					// create a readable title from file
					char pTitleName[256];
					strcpy(pTitleName, pFilename);
					pTitleName[strlen(pTitleName) - 4] = 0;
					for (int n = 0; n < strlen(pTitleName); n++)
					{
						if (n == 0)
						{
							if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z')
								pTitleName[n] -= ('a' - 'A');
						}
						else
						{
							if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z')
								pTitleName[n] += ('a' - 'A');
						}
						if (pTitleName[n] == '_') pTitleName[n] = ' ';
					}

					// add script and title to list
					scriptList_s.push_back(cstr("people\\") + tfile_s);
					scriptListTitle_s.push_back(cstr(pTitleName));
				}
			}
		}
		scriptList_s.push_back(cstr(""));
		scriptListTitle_s.push_back(cstr("Custom"));
		SetDir(oldDir_s.Get());

		// and create items list
		static int g_scriptpeople_item_count = 0;
		static char** g_scriptpeople_items = NULL;
		if (g_scriptpeople_item_count != scriptList_s.size())
		{
			if (g_scriptpeople_items)
			{
				for (int i = 0; i < g_scriptpeople_item_count; i++) SAFE_DELETE(g_scriptpeople_items[i]);
				SAFE_DELETE(g_scriptpeople_items);
			}
			g_scriptpeople_item_count = scriptList_s.size();
			g_scriptpeople_items = new char*[g_scriptpeople_item_count];
			for (int i = 0; i < g_scriptpeople_item_count; i++)
			{
				g_scriptpeople_items[i] = new char[256];
				strcpy(g_scriptpeople_items[i], scriptListTitle_s[i].Get());
			}
		}

		int item_current_type_selection = g_scriptpeople_item_count - 1; //Default Custom.
		for (int i = 0; i < g_scriptpeople_item_count - 1; i++)
		{
			// with workshop items updating core scripts, need to check entire path now!
			//if (pestrcasestr(edit_grideleprof->aimain_s.Get(), scriptList_s[i].Get()))
			if (stricmp (edit_grideleprof->aimain_s.Get(), scriptList_s[i].Get()) == NULL)
			{
				item_current_type_selection = i;
				break;
			}
		}

		if (fpe_current_loaded_script != item_current_type_selection)
		{
			//Load in lua and check for custom properties.
			cstr script_name_append = "";
			if (item_current_type_selection < g_scriptpeople_item_count - 1)
				script_name_append += (char *)scriptList_s[item_current_type_selection].Get();
			else
				script_name_append += edit_grideleprof->aimain_s;

			cstr script_name = "";
			//if (strnicmp(script_name_append.Get(), "projectbank", 11) != NULL) 
			script_name = "scriptbank\\";
			script_name += script_name_append;

			#ifdef USENEWMEDIASELECTWINDOWS
			fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
			if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0; //Make sure we dont have a old image already displayed inside imgui.
			std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
			if (pref.current_style == 25 || pref.current_style == 3)
				sImgName += ".png";
			else
				sImgName += "2.png";
			image_setlegacyimageloading(true);
			LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
			image_setlegacyimageloading(false);
			if (!GetImageExistEx(fpe_current_loaded_script_image))
			{
				if (!(pref.current_style == 25 || pref.current_style == 3))
				{
					sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
					sImgName += ".png";
					image_setlegacyimageloading(true);
					LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
					image_setlegacyimageloading(false);
					if (!GetImageExistEx(fpe_current_loaded_script_image))
					{
						fpe_current_loaded_script_image = FILETYPE_SCRIPT;
					}
				}
				else
					fpe_current_loaded_script_image = FILETYPE_SCRIPT;
			}
			#endif

			//Try to parse script.
			int iObjID = t.entityelement[elementID].obj;
			if (iObjID == 0 && t.gridentityobj>0) iObjID = t.gridentityobj;
			ParseLuaScriptWithElementID(lua_grideleprof, script_name.Get(), iObjID);
			fpe_current_loaded_script = item_current_type_selection;

			if (lua_grideleprof->PropertiesVariableActive == 1)
			{
				bUpdateMainString = true;
				fpe_current_loaded_script_has_dlua = true;
			}
			else
			{
				if (fpe_current_loaded_script_has_dlua)
				{
					//Reset t.grideleprof.soundset4_s that contain the dlua calls.
					lua_grideleprof->soundset4_s = "";
					fpe_current_loaded_script_has_dlua = false;
				}
			}
		}

		#ifdef USENEWMEDIASELECTWINDOWS
		float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
		float ImgW = ImageWidth(fpe_current_loaded_script_image);
		float ImgH = ImageHeight(fpe_current_loaded_script_image);
		float fRatio = w/ImgW;

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
		{
			//Update Script.
			if (sSelectedLibrarySting != "")
			{
				if ( stricmp (edit_grideleprof->aimain_s.Get(), sSelectedLibrarySting.Get()) != NULL )
				{
					// changed behavior of object, ensure any behavior specific properties are cleared (as they cannot be set if new behavior does not expose them)
					edit_grideleprof->overrideanimset_s = "";
					edit_grideleprof->hasweapon_s = t.entityprofile[entid].hasweapon_s;
					edit_grideleprof->hasweapon = 0;
					extern bool g_bNowPopulateWithCorrectAnimSet;			
					g_bNowPopulateWithCorrectAnimSet = true;
				}
				edit_grideleprof->aimain_s = sSelectedLibrarySting;
				sSelectedLibrarySting = "";
				iSelectedLibraryStingReturnID = -1; //disable.
				fpe_current_loaded_script = -1; //Reload image and DLUA.
			}
		}
		if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false))
		{
			//Select script.
			sStartLibrarySearchString = "People";
			iLastDisplayLibraryType = -1;
			bExternal_Entities_Window = true;
			iDisplayLibraryType = 4;
			iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
			if (edit_grideleprof->aimain_s.Len() > 0)
				sMakeDefaultSelecting = edit_grideleprof->aimain_s;

		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Character Behavior");

		ImGui::TextCenter(cDisplayName);

		#else
		if (ImGui::Combo("##BehavioursSimpleInput", &item_current_type_selection, g_scriptpeople_items, g_scriptpeople_item_count, 20))
		{
			if (item_current_type_selection < g_scriptpeople_item_count - 1)
			{
				edit_grideleprof->aimain_s = scriptList_s[item_current_type_selection].Get();
			}
			else
			{
				edit_grideleprof->aimain_s = "";
			}
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Character Behavior");
		#endif

		ImGui::PopItemWidth();

		#ifndef USENEWMEDIASELECTWINDOWS
		if (item_current_type_selection == g_scriptpeople_item_count - 1)
		{
			//Custom script , display directly.
			std::string ms = t.strarr_s[417].Get();
			ms = "Script";
			cstr aim = edit_grideleprof->aimain_s;
			edit_grideleprof->aimain_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->aimain_s.Get(), (char *)ms.c_str(), t.strarr_s[207].Get(), pAIRoot,readonly);
			if (aim != edit_grideleprof->aimain_s)
				fpe_current_loaded_script = -1;
		}
		#endif

		if (lua_grideleprof->PropertiesVariableActive == 1) 
		{
			speech_entries = DisplayLuaDescription(lua_grideleprof);
		}
		else 
		{
			if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) 
			{
				if(edit_grideleprof->aimain_s != "default.lua") //No need to display.
					DisplayLuaDescriptionOnly(lua_grideleprof);
			}
		}

		#ifdef WICKEDENGINE
		bool bUseSoundVariants = lua_grideleprof->iUseSoundVariants;
		if (ImGui::Checkbox("Use Sound Variants", &bUseSoundVariants))
		{
			lua_grideleprof->iUseSoundVariants = bUseSoundVariants;
		}
		
		#endif

		if (speech_entries > 0)
		{
			//@Lee all SPEECH control is moved to this function.
			//PE: need this to point to lua_grideleprof.
			SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
		}

		// removed from MAX, we want all pertinant values through the DLUA system!
		#ifndef WICKEDENGINE
		ImGui::TextCenter("Move Speed");
		ImGui::PushItemWidth(-10);
		//ImGui::SliderInt("##Movement SpeedSimpleInput", &edit_grideleprof->speed, 1, 500);
		ImGui::MaxSliderInputInt("##Movement SpeedSimpleInput", &edit_grideleprof->speed, 1, 500, "Set Movement Speed");
		//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Movement Speed");
		if (t.playercontrol.thirdperson.enabled == 1) t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
		else t.tanimspeed_f = edit_grideleprof->animspeed;
		ImGui::PopItemWidth();
		ImGui::TextCenter("Anim Speed");
		ImGui::PushItemWidth(-10);
		int tmpint = t.tanimspeed_f;
		//ImGui::SliderInt("##Animation SpeedSimpleInput", &tmpint, 1, 500);
		ImGui::MaxSliderInputInt("##Animatin SpeedSimpleInput", &tmpint, 1, 500, "Set Animation Speed");
		//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Animation Speed");
		t.tanimspeed_f = tmpint;
		ImGui::PopItemWidth();
		if (t.playercontrol.thirdperson.enabled == 1) t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed = t.tanimspeed_f;
		else edit_grideleprof->animspeed = t.tanimspeed_f;
		#endif
	}
	else if (t.tflaglight == 1)
	{
		bool bLightChanged = false;
		bool bLightTypeChanged = false;
		bool bNoLightRotate = false;
		bool bUpdateMainString = false;
		int speech_entries = 0;

		#ifdef WICKEDENGINE

		//PE: Add dynamic lua to the light.
		static cstr current_loaded_script = "";
		if (fpe_current_loaded_script == -1 || current_loaded_script != edit_grideleprof->aimain_s)
		{
			//Load in lua and check for custom properties.
			cstr script_name = "";
			//if (strnicmp(edit_grideleprof->aimain_s.Get(), "projectbank", 11) != NULL) 
			script_name = "scriptbank\\";
			script_name += edit_grideleprof->aimain_s;

			fpe_current_loaded_script = 9999;
			current_loaded_script = edit_grideleprof->aimain_s;

			#ifdef USENEWMEDIASELECTWINDOWS
			fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
			if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0; //Make sure we dont have a old image already displayed inside imgui.
			std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
			if (pref.current_style == 25 || pref.current_style == 3)
				sImgName += ".png";
			else
				sImgName += "2.png";
			image_setlegacyimageloading(true);
			LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
			image_setlegacyimageloading(false);
			if (!GetImageExistEx(fpe_current_loaded_script_image))
			{
				if (!(pref.current_style == 25 || pref.current_style == 3))
				{
					sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
					sImgName += ".png";
					image_setlegacyimageloading(true);
					LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
					image_setlegacyimageloading(false);
					if (!GetImageExistEx(fpe_current_loaded_script_image))
					{
						fpe_current_loaded_script_image = FILETYPE_SCRIPT;
					}
				}
				else
					fpe_current_loaded_script_image = FILETYPE_SCRIPT;
			}
			#endif

			//Try to parse script.

			ParseLuaScript(lua_grideleprof, script_name.Get());

			if (lua_grideleprof->PropertiesVariableActive == 1)
			{
				bUpdateMainString = true;
				fpe_current_loaded_script_has_dlua = true;
			}
			else
			{
				if (fpe_current_loaded_script_has_dlua)
				{
					//Reset t.grideleprof.soundset4_s that contain the dlua calls.
					lua_grideleprof->soundset4_s = "";
					fpe_current_loaded_script_has_dlua = false;
				}
			}
		}
		//END DLUA.

		#endif

		//Display icon.
		if (bDisplaySmallIcon)
		{
			if (t.entityprofile[entid].iThumbnailSmall > 0) 
			{
				float w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
				ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
			}
		}

		//#########################################
		//#### Display predefined light setup. ####
		//#########################################
		if (bIsLightProbe == true)
		{
			// control base range which is then later scaled XYZ
			ImGui::TextCenter("Probe Range");
			ImGui::PushItemWidth(-10);
			int iLightProbeRange = (int)edit_grideleprof->light.fLightHasProbe;
			if (ImGui::MaxSliderInputInt("##fLightProbeScaleSimpleInput", &iLightProbeRange, 50, 500, "Specify the internal range of the environment probe, defaults to 50"))
			{
				edit_grideleprof->light.fLightHasProbe = iLightProbeRange;
				g_bLightProbeScaleChanged = true;
				bLightChanged = true;
			}
			ImGui::PopItemWidth();

			ImGui::TextCenter("Probe Size X");
			ImGui::PushItemWidth(-10);
			iLightProbeRange = (int)edit_grideleprof->light.fLightHasProbeX;
			if (ImGui::MaxSliderInputInt("##fLightProbeScaleXSimpleInput", &iLightProbeRange, 50, 500, "Specify the X dimension of the environment probe"))
			{
				edit_grideleprof->light.fLightHasProbeX = iLightProbeRange;
				g_bLightProbeScaleChanged = true;
				bLightChanged = true;
			}
			ImGui::PopItemWidth();

			ImGui::TextCenter("Probe Size Y");
			ImGui::PushItemWidth(-10);
			iLightProbeRange = (int)edit_grideleprof->light.fLightHasProbeY;
			if (ImGui::MaxSliderInputInt("##fLightProbeScaleYSimpleInput", &iLightProbeRange, 50, 500, "Specify the Y dimension of the environment probe"))
			{
				edit_grideleprof->light.fLightHasProbeY = iLightProbeRange;
				g_bLightProbeScaleChanged = true;
				bLightChanged = true;
			}
			ImGui::PopItemWidth();

			ImGui::TextCenter("Probe Size Z");
			ImGui::PushItemWidth(-10);
			iLightProbeRange = (int)edit_grideleprof->light.fLightHasProbeZ;
			if (ImGui::MaxSliderInputInt("##fLightProbeScaleZSimpleInput", &iLightProbeRange, 50, 500, "Specify the Z dimension of the environment probe"))
			{
				edit_grideleprof->light.fLightHasProbeZ = iLightProbeRange;
				g_bLightProbeScaleChanged = true;
				bLightChanged = true;
			}
			ImGui::PopItemWidth();

			// and done
			return;
		}

		//Palette.
		#define MAXPREDEFINEDSETUPS 32
		#define LIGHTTYPEPOINT 0
		#define LIGHTTYPESPOT 1
		static bool PredefinedLightInit = false;
		static int iPredefinedLights = 16;
		int iPredefinedSetups = 16;
		static ImVec4 vPredefined_Light_Palette[MAXPREDEFINEDSETUPS];
		static int iPredefined_Light_Type[MAXPREDEFINEDSETUPS];
		static int iPredefined_Light_Range[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_ProbeScale[MAXPREDEFINEDSETUPS];

		static int iPredefined_Light_Radius[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_AngX[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_AngY[MAXPREDEFINEDSETUPS];
		static float fPredefined_Light_AngZ[MAXPREDEFINEDSETUPS];

		static int current_light_selected = -1;
		static bool bSetUpDefaultPAletteWithDefaultColors = true;
		static bool bFirstTimeInFindBestChoice = false;
		static int iLastEntityElementIDHere = -1;
		if (elementID != iLastEntityElementIDHere)
		{
			iLastEntityElementIDHere = elementID;
			bFirstTimeInFindBestChoice = true;
		}

		float fOne = 1.0f / 255.0f;
		if (!PredefinedLightInit)
		{
			// Mix POINT , SPOT with same palette
			if (bSetUpDefaultPAletteWithDefaultColors == true)
			{
				for (int i = 0; i < 16;i++)
				{
					fPredefined_Light_ProbeScale[i] = 2.0f; //PE: Was 1
					iPredefined_Light_Radius[i] = 45;
					fPredefined_Light_AngX[i] = 90;
					fPredefined_Light_AngY[i] = 0;
					fPredefined_Light_AngZ[i] = 0;
				}
				bSetUpDefaultPAletteWithDefaultColors = false;
				vPredefined_Light_Palette[0] = ImVec4(255 * fOne, 255 * fOne, 255 * fOne, 1.0f);
				iPredefined_Light_Type[0] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[0] = 300.0f / 3.0;

				vPredefined_Light_Palette[1] = ImVec4(255 * fOne, 255 * fOne, 255 * fOne, 1.0f);
				iPredefined_Light_Type[1] = LIGHTTYPESPOT;
				iPredefined_Light_Range[1] = 600.0f / 3.0;
				fPredefined_Light_AngX[1] = 45;

				vPredefined_Light_Palette[2] = ImVec4(110.0f * fOne, 110.0f * fOne, 110.0f * fOne, 1.0f);
				iPredefined_Light_Type[2] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[2] = 300.0f / 3.0;

				vPredefined_Light_Palette[3] = ImVec4(110.0f * fOne, 110.0f * fOne, 110.0f * fOne, 1.0f);
				iPredefined_Light_Type[3] = LIGHTTYPESPOT;
				iPredefined_Light_Range[3] = 600.0f / 3.0;
				fPredefined_Light_AngX[3] = 45;

				vPredefined_Light_Palette[4] = ImVec4(78 * fOne, 144 * fOne, 236 * fOne, 1.0f);
				iPredefined_Light_Type[4] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[4] = 300.0f / 3.0;

				vPredefined_Light_Palette[5] = ImVec4(78 * fOne, 144 * fOne, 236 * fOne, 1.0f);
				iPredefined_Light_Type[5] = LIGHTTYPESPOT;
				iPredefined_Light_Range[5] = 600.0f / 3.0;
				fPredefined_Light_AngX[5] = 45;

				vPredefined_Light_Palette[6] = ImVec4(192 * fOne, 73 * fOne, 223 * fOne, 1.0f);
				iPredefined_Light_Type[6] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[6] = 300.0f / 3.0;

				vPredefined_Light_Palette[7] = ImVec4(192 * fOne, 73 * fOne, 223 * fOne, 1.0f);
				iPredefined_Light_Type[7] = LIGHTTYPESPOT;
				iPredefined_Light_Range[7] = 600.0f / 3.0;
				fPredefined_Light_AngX[7] = 45;

				vPredefined_Light_Palette[8] = ImVec4(224 * fOne, 50 * fOne, 42 * fOne, 1.0f);
				iPredefined_Light_Type[8] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[8] = 300.0f / 3.0;

				vPredefined_Light_Palette[9] = ImVec4(224 * fOne, 50 * fOne, 42 * fOne, 1.0f);
				iPredefined_Light_Type[9] = LIGHTTYPESPOT;
				iPredefined_Light_Range[9] = 600.0f / 3.0;
				fPredefined_Light_AngX[9] = 45;

				vPredefined_Light_Palette[10] = ImVec4(245 * fOne, 234 * fOne, 65 * fOne, 1.0f);
				iPredefined_Light_Type[10] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[10] = 300.0f / 3.0;

				vPredefined_Light_Palette[11] = ImVec4(245 * fOne, 234 * fOne, 65 * fOne, 1.0f);
				iPredefined_Light_Type[11] = LIGHTTYPESPOT;
				iPredefined_Light_Range[11] = 600.0f / 3.0;
				fPredefined_Light_AngX[11] = 45;

				vPredefined_Light_Palette[12] = ImVec4(0 * fOne, 207 * fOne, 99 * fOne, 1.0f);
				iPredefined_Light_Type[12] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[12] = 300.0f / 3.0;

				vPredefined_Light_Palette[13] = ImVec4(0 * fOne, 207 * fOne, 99 * fOne, 1.0f);
				iPredefined_Light_Type[13] = LIGHTTYPESPOT;
				iPredefined_Light_Range[13] = 600.0f / 3.0;
				fPredefined_Light_AngX[13] = 45;

				vPredefined_Light_Palette[14] = ImVec4(250 * fOne, 168 * fOne, 50 * fOne, 1.0f);
				iPredefined_Light_Type[14] = LIGHTTYPEPOINT;
				iPredefined_Light_Range[14] = 300.0f / 3.0;

				vPredefined_Light_Palette[15] = ImVec4(250 * fOne, 168 * fOne, 50 * fOne, 1.0f);
				iPredefined_Light_Type[15] = LIGHTTYPESPOT;
				iPredefined_Light_Range[15] = 600.0f / 3.0;
				fPredefined_Light_AngX[15] = 45;

			}
			iPredefinedSetups = 16;
			iPredefinedLights = 16;

			//Pack all colors to the top of the list.
			int iDest = 0;
			for (int il = 0;il < 16; il++)
			{
				if (pref.iSaved_Light_Type[il] != -1)
				{
					pref.iSaved_Light_Type[iDest] = pref.iSaved_Light_Type[il];
					pref.vSaved_Light_Palette_R[iDest] = pref.vSaved_Light_Palette_R[il];
					pref.vSaved_Light_Palette_G[iDest] = pref.vSaved_Light_Palette_G[il];
					pref.vSaved_Light_Palette_B[iDest] = pref.vSaved_Light_Palette_B[il];
					pref.iSaved_Light_Range[iDest] = pref.iSaved_Light_Range[il];
					pref.fSaved_Light_ProbeScale[iDest] = pref.fSaved_Light_ProbeScale[il];

					pref.iSaved_Light_Radius[iDest] = pref.iSaved_Light_Radius[il];
					pref.fSaved_Light_AngX[iDest] = pref.fSaved_Light_AngX[il];
					pref.fSaved_Light_AngY[iDest] = pref.fSaved_Light_AngY[il];
					pref.fSaved_Light_AngZ[iDest] = pref.fSaved_Light_AngZ[il];

					if (il > iDest) pref.iSaved_Light_Type[il] = -1;
					iDest++;
				}
			}
			for (int il = 0;il < 16; il++)
			{
				if (pref.iSaved_Light_Type[il] != -1)
				{
					vPredefined_Light_Palette[iPredefinedLights] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
					vPredefined_Light_Palette[iPredefinedLights].x = pref.vSaved_Light_Palette_R[il];
					vPredefined_Light_Palette[iPredefinedLights].y = pref.vSaved_Light_Palette_G[il];
					vPredefined_Light_Palette[iPredefinedLights].z = pref.vSaved_Light_Palette_B[il];
					iPredefined_Light_Type[iPredefinedLights] = pref.iSaved_Light_Type[il];
					iPredefined_Light_Range[iPredefinedLights] = pref.iSaved_Light_Range[il];
					fPredefined_Light_ProbeScale[iPredefinedLights] = pref.fSaved_Light_ProbeScale[il];

					iPredefined_Light_Radius[iPredefinedLights] = pref.iSaved_Light_Radius[il];
					fPredefined_Light_AngX[iPredefinedLights] = pref.fSaved_Light_AngX[il];
					fPredefined_Light_AngY[iPredefinedLights] = pref.fSaved_Light_AngY[il];
					fPredefined_Light_AngZ[iPredefinedLights] = pref.fSaved_Light_AngZ[il];

					iPredefinedLights++;
				}
			}
			current_light_selected = -1;
			PredefinedLightInit = true;
		}

		// LB: this starts the picking of the best index (if any)
		if (bFirstTimeInFindBestChoice == true)
			current_light_selected = -1;

		int light_icons_columns = 4;
		float light_w = ImGui::GetContentRegionAvailWidth() - 10.0f;
		float light_image_size = light_w / (float)light_icons_columns;
		light_image_size -= ((2.0f) * light_icons_columns) - 2.0f;
		ImVec4 IconColor = { 1.0f,1.0f,1.0f,1.0f };
		int iSelections = 0;

		#ifdef INCLUDEPREDEFINEDLIGHTS

		for (int i = 0; i < iPredefinedLights; i++)
		{
			ImVec4 background = vPredefined_Light_Palette[i];

			int iTextureID = LIGHT_POINT;
			if (iPredefined_Light_Type[i] == LIGHTTYPESPOT) iTextureID = LIGHT_SPOT;

			ImRect image_bb;
			ImVec2 padding = { 1.0, 1.0 };
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];

			// LB: This picks best index
			if (bFirstTimeInFindBestChoice == true)
			{
				if (edit_grideleprof->usespotlighting == iPredefined_Light_Type[i] &&
					edit_grideleprof->light.range == iPredefined_Light_Range[i] )//&&
					//edit_grideleprof->light.fLightHasProbe == fPredefined_Light_ProbeScale[i])
				{
					DWORD color = 0xff000000 + ((unsigned int)(vPredefined_Light_Palette[i].x * 255.0f) << 16) + ((unsigned int)(vPredefined_Light_Palette[i].y * 255.0f) << 8) + +((unsigned int)(vPredefined_Light_Palette[i].z * 255.0f));
					if (color == edit_grideleprof->light.color)
					{
						current_light_selected = i;
						bFirstTimeInFindBestChoice = false;
					}
				}
			}

			if (current_light_selected == i)
			{
				image_bb= ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(light_image_size, light_image_size) );
			}

			ImGui::PushID(LIGHT_POINT + i);
			if (ImGui::ImgBtn(iTextureID, ImVec2(light_image_size, light_image_size), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors))
			{
				//change
				current_light_selected = i;

				float fr = vPredefined_Light_Palette[i].x * 255.0f;
				float fg = vPredefined_Light_Palette[i].y * 255.0f;
				float fb = vPredefined_Light_Palette[i].z * 255.0f;
				edit_grideleprof->light.color = 0xff000000 + ((unsigned int)fr << 16) + ((unsigned int)fg << 8) + +((unsigned int)fb);
				
				//edit_grideleprof->usespotlighting now follow the same types, if we should add area,sphere.
				if (edit_grideleprof->usespotlighting != iPredefined_Light_Type[i])
				{
					bLightTypeChanged = true;
					edit_grideleprof->usespotlighting = iPredefined_Light_Type[i];
				}

				edit_grideleprof->light.range = iPredefined_Light_Range[i]; //PE: Cant do it here, custom will fail. / 3.0f; // more sensible 
				edit_grideleprof->light.fLightHasProbe = fPredefined_Light_ProbeScale[i]; //PE: Cant do it here, custom will fail. *2.0f; // more sensible 

				edit_grideleprof->light.offsetup = iPredefined_Light_Radius[i];
				if (elementID > 0)
				{
					t.entityelement[elementID].rx = fPredefined_Light_AngX[i];
					t.entityelement[elementID].ry = fPredefined_Light_AngY[i];
					t.entityelement[elementID].rz = fPredefined_Light_AngZ[i];

					if (t.entityelement[elementID].obj > 0)
					{
						RotateObject(t.entityelement[elementID].obj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
					}

					if (g.entityrubberbandlist.size() == 0)
					{
						int iActiveObj = t.widget.activeObject;
						if (iActiveObj > 0)
						{
							RotateObject(iActiveObj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
							g_bRefreshRotationValuesFromObjectOnce = true;
						}
					}
					bNoLightRotate = true;
				}

				bLightChanged = true;
				g_bLightProbeScaleChanged = true;
			}
			ImGui::PopID();
			if (current_light_selected == i)
			{
				if (iSelections++ > 0)
				{
					//Mark dublicates.
					tool_selected_col.w = 0.2;
				}

				window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Light Preference");
			
			ImVec2 restore_cursorpos = ImGui::GetCursorPos();
			if ((i + 1) % light_icons_columns != 0 && i != iPredefinedLights - 1)
				ImGui::SameLine();
		}
		bFirstTimeInFindBestChoice = false;

		if (ImGui::StyleButton("Add Light", ImVec2((light_w*0.5f) - 4.0f, 0)))
		{
			ImGui::OpenPopup("##pickV2LightType");
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add a New Custom Light Using The Current Settings.");

		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		if (ImGui::BeginPopup("##pickV2LightType", ImGuiWindowFlags_NoMove))
		{
			float popupwidth = 224.0f;
			ImGui::SetCursorPosX(popupwidth);
			ImGui::SetCursorPosX(0.0f);

			int type_selection = edit_grideleprof->usespotlighting;
			ImVec4 background = { 0.0f,0.0f,0.0f,0.0f };
			ImRect image_bb;
			ImVec2 padding = { 1.0, 1.0 };
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];

			ImGui::TextCenter("Choose a Light Type");
			ImGui::Text("");
			float spacer = 64.0f;
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(spacer*0.5, 0.0f));
			if(type_selection == 0) image_bb = ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(spacer, spacer));

			if (ImGui::ImgBtn(LIGHT_POINT, ImVec2(spacer, spacer), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				edit_grideleprof->usespotlighting = 0;
				bLightTypeChanged = true;
				bLightChanged = true;
				bNoLightRotate = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Point Light");

			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(spacer*0.5, 0.0f));
			if (type_selection != 0) image_bb = ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(spacer, spacer));
			if (ImGui::ImgBtn(LIGHT_SPOT, ImVec2(spacer, spacer), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				edit_grideleprof->usespotlighting = 1;
				bLightTypeChanged = true;
				bLightChanged = true;
				bNoLightRotate = true;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Spot Light");
			window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);

			ImGui::Text("");
			ImGui::Text("");
			if (ImGui::StyleButton("Cancel", ImVec2(96, 0)))
			{
				ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Cancel");

			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(popupwidth-96-96, 0.0f));

			if (ImGui::StyleButton("Add Light", ImVec2(96, 0)))
			{
				int iFreeEntry = -1;
				bool bIsDuplicate = false;
				if (!bIsDuplicate)
				{
					for (int il = 0;il < 16; il++)
					{
						if (pref.iSaved_Light_Type[il] == -1)
						{
							iFreeEntry = il;
							break;
						}
					}
					if (iFreeEntry != -1)
					{
						pref.vSaved_Light_Palette_R[iFreeEntry] = ((edit_grideleprof->light.color & 0x00ff0000) >> 16) / 255.0f;
						pref.vSaved_Light_Palette_G[iFreeEntry] = ((edit_grideleprof->light.color & 0x0000ff00) >> 8) / 255.0f;
						pref.vSaved_Light_Palette_B[iFreeEntry] = (edit_grideleprof->light.color & 0x000000ff) / 255.0f;
						pref.iSaved_Light_Type[iFreeEntry] = edit_grideleprof->usespotlighting;
						pref.iSaved_Light_Range[iFreeEntry] = edit_grideleprof->light.range;
						pref.fSaved_Light_ProbeScale[iFreeEntry] = edit_grideleprof->light.fLightHasProbe;
						PredefinedLightInit = false; //Setup everything again.

						pref.iSaved_Light_Radius[iFreeEntry] = edit_grideleprof->light.offsetup;
						if (elementID > 0)
						{
							pref.fSaved_Light_AngX[iFreeEntry] = t.entityelement[elementID].rx;
							pref.fSaved_Light_AngY[iFreeEntry] = t.entityelement[elementID].ry;
							pref.fSaved_Light_AngZ[iFreeEntry] = t.entityelement[elementID].rz;
						}

					}
				}
				ImGui::CloseCurrentPopup();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add Light");

			ImGui::EndPopup();
		}

		ImGui::SameLine(); 
		bool bDisableButton = true;
		if (current_light_selected != -1 && current_light_selected > 15) bDisableButton = false;
		if (ImGui::StyleButtonEx("Delete Light", ImVec2((light_w*0.5f) - 4.0f, 0), bDisableButton))
		{
			if (current_light_selected >= iPredefinedSetups)
			{
				pref.iSaved_Light_Type[current_light_selected - iPredefinedSetups] = -1;
				PredefinedLightInit = false; //Setup everything again.
			}
		}
		if (ImGui::IsItemHovered())
		{
			if (bDisableButton == true)
				ImGui::SetTooltip("Cannot delete first 16 default lights");
			else
				ImGui::SetTooltip("Delete selected custom light");
		}

		if (ImGui::StyleButton("Reset to Default Light", ImVec2(light_w, 0)) )
		{
			current_light_selected = -1;
			bLightTypeChanged = true;
			bLightChanged = true;
			g_bLightProbeScaleChanged = true;
			bSetUpDefaultPAletteWithDefaultColors = true;
			PredefinedLightInit = false; //Setup everything again.
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset Light to The Default Settings");


		#endif

		//Name and color setup only.
		//ImGui::Text("");
		if(bDisplayName)
			edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(),readonly);

		ImGui::TextCenter("Light Distance");

		ImGui::PushItemWidth(-10);
		if (ImGui::MaxSliderInputInt("##LightRangeSimpleInput", &edit_grideleprof->light.range, 0, 1000, t.strarr_s[250].Get()))
		{
			current_light_selected = -1;
			bLightChanged = true;
		}
		float fTmp = edit_grideleprof->light.range*100;
		ImGui::PopItemWidth();

		if (edit_grideleprof->usespotlighting != 0)
		{
			ImGui::TextCenter("Spotlight Radius");
			ImGui::PushItemWidth(-10);
			if (ImGui::MaxSliderInputInt("##SpotlightRangeSimpleInput", &edit_grideleprof->light.offsetup, 3, 170, "Sets the spotlight radius"))
			{
				if (edit_grideleprof->light.offsetup < 3) edit_grideleprof->light.offsetup = 3;
				if (edit_grideleprof->light.offsetup > 170) edit_grideleprof->light.offsetup = 170;
				current_light_selected = -1;
				bLightChanged = true;
			}
			ImGui::PopItemWidth();
		}

		ImGui::TextCenter("Light Color");
		float colors[5];
		colors[3] = ((edit_grideleprof->light.color & 0xff000000) >> 24) / 255.0f;
		colors[0] = ((edit_grideleprof->light.color & 0x00ff0000) >> 16) / 255.0f;
		colors[1] = ((edit_grideleprof->light.color & 0x0000ff00) >> 8) / 255.0f;
		colors[2] = (edit_grideleprof->light.color & 0x000000ff) / 255.0f;

		ImVec4 mycolor = ImVec4(colors[0], colors[1], colors[2], 1.0);
		float w = ImGui::GetContentRegionAvailWidth();
		extern bool bUseOrgHue;
		bUseOrgHue = true;
		bool open_popup = ImGui::ColorButton("##NewV2LightColor", mycolor, 0, ImVec2(w - 10.0, 0));
		if (open_popup) ImGui::OpenPopup("##pickV2LightColor");
		if (ImGui::BeginPopup("##pickV2LightColor", ImGuiWindowFlags_NoMove))
		{
			if (ImGui::ColorPicker4("##pickerV2LightColor", (float*)&mycolor, ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview))
			{
				//LB: team decided the select light is being actively reconfigured
				//current_light_selected = -1; (see bwlow)
				bLightChanged = true;
			}
			ImGui::EndPopup();
		}
		bUseOrgHue = false;
		colors[0] = mycolor.x * 255.0f;
		colors[1] = mycolor.y * 255.0f;
		colors[2] = mycolor.z * 255.0f;
		edit_grideleprof->light.color = 0xff000000 + ((unsigned int)colors[0] << 16) + ((unsigned int)colors[1] << 8) + +((unsigned int)colors[2]);

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_PENCIL);
		ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
		window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set Light Color");

		//LB: Grr, seems all castshadows up to now (Feb2022) are zero, and we need them to be
		// casting by default, so we will assume 'castshadow==0 or -1' is CAST and 'castshadow==1' is NO CAST
		bool bCastShadow = true;
		if (edit_grideleprof->castshadow == 1 ) bCastShadow = false;
		if (ImGui::Checkbox("Cast Shadow", &bCastShadow))
		{
			if (bCastShadow == true)
				edit_grideleprof->castshadow = -1;
			else
				edit_grideleprof->castshadow = 1;
			bLightChanged = true;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set whether a shadow is cast");

		//LB: whatever the current palette selection, it will be changed!
		if (current_light_selected != -1)
		{
			vPredefined_Light_Palette[current_light_selected].x = mycolor.x;
			vPredefined_Light_Palette[current_light_selected].y = mycolor.y;
			vPredefined_Light_Palette[current_light_selected].z = mycolor.z;
		}

		//#### Light Behaviour ####
		ImGui::TextCenter("Light Behaviour");

		#ifdef USENEWLIGHTBEHAVIOUR
		w = ImGui::GetContentRegionAvailWidth() - 16.0f;
		float ImgW = ImageWidth(fpe_current_loaded_script_image);
		float ImgH = ImageHeight(fpe_current_loaded_script_image);
		float fRatio = w / ImgW;

		if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
		{
			//Update Script.
			if (sSelectedLibrarySting != "")
			{
				edit_grideleprof->aimain_s = sSelectedLibrarySting;
				sSelectedLibrarySting = "";
				iSelectedLibraryStingReturnID = -1; //disable.
				fpe_current_loaded_script = -1; //Reload image and DLUA.
			}
		}
		if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false))
		{
			//Select script.
			sStartLibrarySearchString = "Light";
			iLastDisplayLibraryType = -1;
			bExternal_Entities_Window = true;
			iDisplayLibraryType = 4;
			iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
			if (edit_grideleprof->aimain_s.Len() > 0)
				sMakeDefaultSelecting = edit_grideleprof->aimain_s;

		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Light Behavior");

		ImGui::TextCenter(cDisplayName);
		#else

		//Combo light script selection.

		const char* light_behaviour[] = { "None" , "Flicker", "Strobe", "Rotate" };
		const char* light_scripts[] = { "markers\\light1.lua" , "markers\\lightflicker.lua", "markers\\lightstrobe.lua", "markers\\lightrotate.lua" };
		int iBehaviourItems = IM_ARRAYSIZE(light_behaviour);
		int current_light_behaviour = -1;
		for (int i = 0; i < iBehaviourItems; i++)
		{
			if (stricmp(light_scripts[i], edit_grideleprof->aimain_s.Get()) == 0)
			{
				current_light_behaviour = i;
				break;
			}
		}
		if (current_light_behaviour < 0) current_light_behaviour = 0; //default None.

		ImGui::PushItemWidth(-10);
		if (ImGui::Combo("##comboLightBehaviour", &current_light_behaviour, light_behaviour, iBehaviourItems))
		{
			edit_grideleprof->aimain_s = light_scripts[current_light_behaviour];
			fpe_current_loaded_script = -1; //Reload image and DLUA.
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Light Behavior");
		ImGui::PopItemWidth();
		#endif	

		if (lua_grideleprof->PropertiesVariableActive == 1) {
			speech_entries = DisplayLuaDescription(lua_grideleprof);
		}
		else
		{
			if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) 
			{
				if (edit_grideleprof->aimain_s != "default.lua" )//&& edit_grideleprof->aimain_s != "markers\\light1.lua") //No need to display.
					DisplayLuaDescriptionOnly(lua_grideleprof);
			}
		}

		if (speech_entries > 0)
		{
			// all SPEECH control is moved to this function.
			SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
		}

		// update the light live
		#ifdef WICKEDENGINE

		bool bAllowProbeUpdate = false;

		if (!readonly)
		{
			// update light if change angles
			static float fLastLightXAngle = -1.0f;
			static float fLastLightYAngle = -1.0f;
			static float fLastLightZAngle = -1.0f;
			if (elementID > 0)
			{
				if (t.entityelement[elementID].rx != fLastLightXAngle || t.entityelement[elementID].ry != fLastLightYAngle || t.entityelement[elementID].rz != fLastLightZAngle)
				{
					fLastLightXAngle = t.entityelement[elementID].rx;
					fLastLightYAngle = t.entityelement[elementID].ry;
					fLastLightZAngle = t.entityelement[elementID].rz;
					bLightChanged = true;
				}
			}

			// check if light needs updating in the engine
			if (bLightChanged)
			{
				int ilightIndex = 0;
				float lightx, lighty, lightz, lightax, lightay, lightaz;
				if (elementID > 0)
				{
					ilightIndex = t.entityelement[elementID].eleprof.light.index;
				}
				if (!bNoLightRotate && bLightTypeChanged && elementID > 0)
				{
					if (edit_grideleprof->usespotlighting == LIGHTTYPESPOT)
						t.entityelement[elementID].rx = 45.0f; //Default to 45 angle x so we can see the spot on terrain.
					else
					{
						#ifdef WICKEDENGINE
						t.entityelement[elementID].rx = 90.0f; //PE: Wicked object default to angle x 90.
						#else
						t.entityelement[elementID].rx = 0.0f;
						#endif
					}

					if (t.entityelement[elementID].obj > 0)
					{
						RotateObject(t.entityelement[elementID].obj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
					}

					if (g.entityrubberbandlist.size() == 0)
					{
						int iActiveObj = t.widget.activeObject;
						if (iActiveObj > 0)
						{
							RotateObject(iActiveObj, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
							g_bRefreshRotationValuesFromObjectOnce = true;
						}
					}
				}

				if (elementID > 0 && ilightIndex > 0)
				{
					// any light probes destroy the effect of the light sibling
					float fLightHasProbe = edit_grideleprof->light.fLightHasProbe;
					if (fLightHasProbe >= 50.0f)
					{
						colors[0] = 0;
						colors[1] = 0;
						colors[2] = 0;
						edit_grideleprof->light.color = 255<<24;
						edit_grideleprof->light.range = 0;
						edit_grideleprof->castshadow = 1;
					}

					int iWickedLightIndex = t.infinilight[ilightIndex].wickedlightindex;
					if (bLightTypeChanged)
					{
						//Recreate light.
						WickedCall_DeleteLight(iWickedLightIndex);
						int iLightType = 1;
						if (edit_grideleprof->usespotlighting) iLightType = 2;
						iWickedLightIndex = WickedCall_AddLight(iLightType);
						t.infinilight[ilightIndex].wickedlightindex = iWickedLightIndex;
						bLightTypeChanged = false;
					}
					lightx = t.entityelement[elementID].x;
					lighty = t.entityelement[elementID].y;
					lightz = t.entityelement[elementID].z;
					lightax = t.entityelement[elementID].rx;
					lightay = t.entityelement[elementID].ry;
					lightaz = t.entityelement[elementID].rz;
					float lightrange = edit_grideleprof->light.range;
					float spotlightradius = edit_grideleprof->light.offsetup;
					int colr = colors[0];
					int colg = colors[1];
					int colb = colors[2];
					bool bCastShadow = true;
					if (edit_grideleprof->castshadow == 1) bCastShadow = false;

					//PE: Also update infinilight.
					t.infinilight[ilightIndex].f_angle_x = lightax;
					t.infinilight[ilightIndex].f_angle_y = lightay;
					t.infinilight[ilightIndex].f_angle_z = lightaz;
					t.infinilight[ilightIndex].x = lightx;
					t.infinilight[ilightIndex].y = lighty;
					t.infinilight[ilightIndex].z = lightz;
					t.infinilight[ilightIndex].range = lightrange;
					t.infinilight[ilightIndex].spotlightradius = spotlightradius;
					t.infinilight[ilightIndex].colrgb.r = colr;
					t.infinilight[ilightIndex].colrgb.g = colg;
					t.infinilight[ilightIndex].colrgb.b = colb;
					t.infinilight[ilightIndex].fLightHasProbe = fLightHasProbe;
					t.infinilight[ilightIndex].bCanShadow = bCastShadow;
					WickedCall_UpdateLight(iWickedLightIndex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, spotlightradius, colr, colg, colb, bCastShadow);
				}
				else
				{
					if (bLightTypeChanged)
					{
						//Recreate light.
						if(t.gridentitywickedlightindex > 0)
							WickedCall_DeleteLight(t.gridentitywickedlightindex);
						t.gridentitywickedlightindex = 0;
						bLightTypeChanged = false;
					}
					if (t.gridentitywickedlightindex == 0)
					{
						int iLightType = 1;
						if (edit_grideleprof->usespotlighting) iLightType = 2;
						t.gridentitywickedlightindex = WickedCall_AddLight(iLightType);
					}
					if (t.gridentitywickedlightindex > 0)
					{
						lightx = t.gridentityposx_f;
						lighty = t.gridentityposy_f;
						lightz = t.gridentityposz_f;
						lightax = t.gridentityrotatex_f;
						lightay = t.gridentityrotatey_f;
						lightaz = t.gridentityrotatez_f;
						float lightrange = edit_grideleprof->light.range;
						float spotlightradius = edit_grideleprof->light.offsetup;
						int colr = colors[0];
						int colg = colors[1];
						int colb = colors[2];
						bool bCastShadow = true;
						if (edit_grideleprof->castshadow == 1) bCastShadow = false;
						WickedCall_UpdateLight(t.gridentitywickedlightindex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, spotlightradius, colr, colg, colb, bCastShadow);
					}
				}

				// ensure the light object itself is updated
				int obj = t.entityelement[elementID].obj;
				entity_updatelightobj(elementID,obj);
			}
		}
		#endif

	}
	#ifdef USENEWPARTICLESETUP
	else if (t.entityprofile[entid].ismarker == 10)
	{
		//Particles.
		#define MAXPREDEFINEDPARTICLESETUPS 32

		static bool bPredefinedParticleInit = false;

		static int iPredefinedParticles = 9;
		int iPredefinedParticleSetups = 9;
		static cstr Predefined_Particle_Name[MAXPREDEFINEDPARTICLESETUPS];
		static int Predefined_Particle_Image[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Preview[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Show_At_Start[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Looping_Animation[MAXPREDEFINEDPARTICLESETUPS];
		static bool Predefined_bParticle_Full_Screen[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Fullscreen_Duration[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Fullscreen_Fadein[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Fullscreen_Fadeout[MAXPREDEFINEDPARTICLESETUPS];
		static cstr Predefined_Particle_Fullscreen_Transition[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Speed[MAXPREDEFINEDPARTICLESETUPS];
		static float Predefined_fParticle_Opacity[MAXPREDEFINEDPARTICLESETUPS];


		newparticletype newparticle_init[MAXPREDEFINEDPARTICLESETUPS];

		if (!bPredefinedParticleInit)
		{
			//Init.
			for (int i = 0; i < iPredefinedParticleSetups; i++)
			{
				if (ImageExist(Predefined_Particle_Image[i]))
				{
					if(Predefined_Particle_Image[i] != FILETYPE_PARTICLE)
						DeleteImage(Predefined_Particle_Image[i]);
				}
				Predefined_Particle_Image[i] = 0;
			}

			for (int i = 0; i < iPredefinedParticleSetups; i++)
			{
				//Defaults
				Predefined_bParticle_Preview[i] = true;
				Predefined_bParticle_Show_At_Start[i] = true;
				Predefined_bParticle_Looping_Animation[i] = true;
				Predefined_bParticle_Full_Screen[i] = false;
				Predefined_fParticle_Fullscreen_Duration[i] = 10.0f;
				Predefined_fParticle_Fullscreen_Fadein[i] = 1.0f;
				Predefined_fParticle_Fullscreen_Fadeout[i] = 1.0f;
				Predefined_Particle_Fullscreen_Transition[i] = "";
				Predefined_fParticle_Speed[i] = 1.0f;
				Predefined_fParticle_Opacity[i] = 1.0f;

				if (i == 0) Predefined_Particle_Name[i] = "particlesbank\\default";
				if (i == 1) Predefined_Particle_Name[i] = "particlesbank\\portal5";
				if (i == 2) Predefined_Particle_Name[i] = "particlesbank\\stylized_poisonring";
				if (i == 3) Predefined_Particle_Name[i] = "particlesbank\\smoke_billowy";
				if (i == 4) Predefined_Particle_Name[i] = "particlesbank\\fountain_directional";
				if (i == 5) Predefined_Particle_Name[i] = "particlesbank\\fire_tornado_3";
				if (i == 6) Predefined_Particle_Name[i] = "particlesbank\\fire_and_smoke";
				if (i == 7) Predefined_Particle_Name[i] = "particlesbank\\explosion";
				if (i == 8) Predefined_Particle_Name[i] = "particlesbank\\smoke_thick";

				if (i == 7) Predefined_bParticle_Looping_Animation[i] = false;

				Predefined_Particle_Image[i] = MARKETPLACE_ICONS + 50 + i;

				cstr img = Predefined_Particle_Name[i] + cstr(".arx");
				CreateBackBufferCacheName(img.Get(), 512, 288);
				SetMipmapNum(1); //PE: mipmaps not needed.
				image_setlegacyimageloading(true);
				GG_SetWritablesToRoot(true);
				if (FileExist(BackBufferCacheName.Get()))
				{
					LoadImage((char *)BackBufferCacheName.Get(), Predefined_Particle_Image[i]);
					if (!ImageExist(Predefined_Particle_Image[i]))
					{
						Predefined_Particle_Image[i] = FILETYPE_PARTICLE;
					}
				}
				else
				{
					Predefined_Particle_Image[i] = FILETYPE_PARTICLE;
				}
				image_setlegacyimageloading(false);
				SetMipmapNum(-1);
				GG_SetWritablesToRoot(false);
			}

			iPredefinedParticles = iPredefinedParticleSetups;

			//Pack to top of list.
			int iDest = 0;
			for (int i = 0;i < 16; i++)
			{
				if (strlen(pref.Saved_Particle_Name[i]) > 0)
				{
					strcpy(pref.Saved_Particle_Name[iDest],pref.Saved_Particle_Name[i]);
					pref.Saved_bParticle_Preview[iDest] = pref.Saved_bParticle_Preview[i];
					pref.Saved_bParticle_Show_At_Start[iDest] = pref.Saved_bParticle_Show_At_Start[i];
					pref.Saved_bParticle_Looping_Animation[iDest] = pref.Saved_bParticle_Looping_Animation[i];
					pref.Saved_bParticle_Full_Screen[iDest] = pref.Saved_bParticle_Full_Screen[i];
					pref.Saved_fParticle_Fullscreen_Duration[iDest] = pref.Saved_fParticle_Fullscreen_Duration[i];
					pref.Saved_fParticle_Fullscreen_Fadein[iDest] = pref.Saved_fParticle_Fullscreen_Fadein[i];
					pref.Saved_fParticle_Fullscreen_Fadeout[iDest] = pref.Saved_fParticle_Fullscreen_Fadeout[i];
					strcpy(pref.Saved_Particle_Fullscreen_Transition[iDest],pref.Saved_Particle_Fullscreen_Transition[i]);
					pref.Saved_fParticle_Speed[iDest] = pref.Saved_fParticle_Speed[i];
					pref.Saved_fParticle_Opacity[iDest] = pref.Saved_fParticle_Opacity[i];

					if (i > iDest) strcpy(pref.Saved_Particle_Name[i],"");
					iDest++;
				}
			}

			//Add saved from prefs.
			for (int i = 0; i < 16; i++)
			{
				if (strlen(pref.Saved_Particle_Name[i]) > 0)
				{
					Predefined_Particle_Image[iPredefinedParticles] = MARKETPLACE_ICONS + 50 + iPredefinedParticles + i;
					Predefined_Particle_Name[iPredefinedParticles] = pref.Saved_Particle_Name[i];
					Predefined_bParticle_Preview[iPredefinedParticles] = pref.Saved_bParticle_Preview[i];
					Predefined_bParticle_Show_At_Start[iPredefinedParticles] = pref.Saved_bParticle_Show_At_Start[i];
					Predefined_bParticle_Looping_Animation[iPredefinedParticles] = pref.Saved_bParticle_Looping_Animation[i];
					Predefined_bParticle_Full_Screen[iPredefinedParticles] = pref.Saved_bParticle_Full_Screen[i];
					Predefined_fParticle_Fullscreen_Duration[iPredefinedParticles] = pref.Saved_fParticle_Fullscreen_Duration[i];
					Predefined_fParticle_Fullscreen_Fadein[iPredefinedParticles] = pref.Saved_fParticle_Fullscreen_Fadein[i];
					Predefined_fParticle_Fullscreen_Fadeout[iPredefinedParticles] = pref.Saved_fParticle_Fullscreen_Fadeout[i];
					Predefined_Particle_Fullscreen_Transition[iPredefinedParticles] = pref.Saved_Particle_Fullscreen_Transition[i];
					Predefined_fParticle_Speed[iPredefinedParticles] = pref.Saved_fParticle_Speed[i];
					Predefined_fParticle_Opacity[iPredefinedParticles] = pref.Saved_fParticle_Opacity[i];

					cstr img = Predefined_Particle_Name[iPredefinedParticles];
					if (strlen(pref.Saved_Particle_Name[i]) > 4)
					{
						if (strnicmp(img.Get() + strlen(img.Get()) - 4, ".arx", 4) == NULL)
						{
							img = Left(img.Get(), Len(img.Get()) - 4);
						}
					}
					img = img + cstr(".arx");

					CreateBackBufferCacheName(img.Get(), 512, 288);
					GG_SetWritablesToRoot(true);
					SetMipmapNum(1); //PE: mipmaps not needed.
					image_setlegacyimageloading(true);
					if (FileExist(BackBufferCacheName.Get()))
					{
						LoadImage((char *)BackBufferCacheName.Get(), Predefined_Particle_Image[iPredefinedParticles]);
						if (!ImageExist(Predefined_Particle_Image[iPredefinedParticles]))
						{
							Predefined_Particle_Image[iPredefinedParticles] = FILETYPE_PARTICLE;
						}
					}
					else
					{
						Predefined_Particle_Image[iPredefinedParticles] = FILETYPE_PARTICLE;
					}
					image_setlegacyimageloading(false);
					SetMipmapNum(-1);
					GG_SetWritablesToRoot(false);

					iPredefinedParticles++;
				}
			}

			bPredefinedParticleInit = true;
		}


		static int current_particle_selected = -1;
		bool bUpdateParticle = false;

		//static bool bSetUpDefaultPAletteWithDefaultColors = true;
		static bool bFindBestParticleChoice = false;
		static int iLastParticleEntityElementIDHere = -1;
		if (elementID != iLastParticleEntityElementIDHere)
		{
			iLastParticleEntityElementIDHere = elementID;
			current_particle_selected = -1;
			bFindBestParticleChoice = true;
		}

		if (bFindBestParticleChoice)
		{
			bFindBestParticleChoice = false;

			//Try to locate a matching particle setup.
			for (int i = 0; i < iPredefinedParticles; i++)
			{
				bool bValid = true;
				std::string sString = t.entityelement[elementID].eleprof.newparticle.emittername.Get();
				replaceAll(sString, "/", "\\");
				if ( stricmp(sString.c_str() , Predefined_Particle_Name[i].Get()) != 0 ) bValid = false;
				//if (t.entityelement[elementID].eleprof.newparticle.emittername != Predefined_Particle_Name[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.bParticle_Preview != Predefined_bParticle_Preview[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start != Predefined_bParticle_Show_At_Start[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation != Predefined_bParticle_Looping_Animation[i]) bValid = false;
				if (t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition != Predefined_Particle_Fullscreen_Transition[i]) bValid = false;

				//Float roundings so cant just compare. just use int's.
				if ( (int) t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen != (int) Predefined_bParticle_Full_Screen[i]) bValid = false;
				if ( (int) t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration != (int) Predefined_fParticle_Fullscreen_Duration[i]) bValid = false;
				if ( (int) t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein != (int) Predefined_fParticle_Fullscreen_Fadein[i]) bValid = false;
				if ( (int) t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout != (int) Predefined_fParticle_Fullscreen_Fadeout[i]) bValid = false;
				//Remove precision so we get the best match.
				if ( (int) (t.entityelement[elementID].eleprof.newparticle.fParticle_Speed*5) != (int) (Predefined_fParticle_Speed[i]*5) ) bValid = false;
				if ( (int) (t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity*5) != (int) (Predefined_fParticle_Opacity[i]*5) ) bValid = false;

				if (bValid)
				{
					current_particle_selected = i;
					bUpdateParticle = true;
					break;
				}

			}
		}

		#define USEPARTICLECOLUMNS
		int particle_icons_columns = 3;
		float particle_w = ImGui::GetContentRegionAvailWidth() - 10.0f;
		float particle_image_size = particle_w / (float)particle_icons_columns;
		#ifdef USEPARTICLECOLUMNS
		particle_image_size -= 3; //Border of 1
		#endif
		float fRatio = 288.0f / 512.0f;
		particle_image_size -= ((2.0f) * particle_icons_columns) - 2.0f;
		ImVec4 IconColor = { 1.0f,1.0f,1.0f,1.0f };
		ImVec4 background = { 0.0f,0.0f,0.0f,1.0f };
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		#ifdef USEPARTICLECOLUMNS
		ImVec2 iOldWindowPadding = ImGui::GetStyle().WindowPadding;
		ImGui::GetStyle().WindowPadding = { 1.0f,1.0f };
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 4));
		ImGui::Columns(3, "mycolumns3particles", false);  //false no border
		if (particle_image_size < 200)
		{
		}
		#endif

		ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
		bool bDrawsSelection = false;
		ImRect image_draw_bb;
		for (int i = 0; i < iPredefinedParticles; i++)
		{
			ImRect image_bb;
			ImVec2 padding = { 0.0, 1.0 };

			//Auto pick ?

			if (current_particle_selected == i)
			{
				image_bb = ImRect((window->DC.CursorPos - padding), window->DC.CursorPos + padding + ImVec2(particle_image_size, particle_image_size * fRatio));
			}

			//ImGui::BeginChildFrame(ImGui::GetID("particleframe"), ImVec2(particle_image_size, particle_image_size * fRatio + ImGui::GetTextLineHeightWithSpacing()), ImGuiWindowFlags_NoMove| ImGuiWindowFlags_NoResize| ImGuiWindowFlags_NoScrollbar);

			ImGui::PushID(FILETYPE_PARTICLE + i);
			if (ImGui::ImgBtn(Predefined_Particle_Image[i], ImVec2(particle_image_size, particle_image_size * fRatio), background, IconColor, ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, true, false)) //bBoostIconColors
			{
				//Change selection.
				current_particle_selected = i;
				//Setup default parameters.
				bUpdateParticle = true;

				if (elementID > 0)
				{
					int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
					if (iParticleEmitter != -1)
					{
						gpup_deleteEffect(iParticleEmitter);
					}
					t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
					t.entityelement[elementID].eleprof.newparticle.emittername = Predefined_Particle_Name[current_particle_selected];

					t.entityelement[elementID].eleprof.newparticle.bParticle_Preview = Predefined_bParticle_Preview[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start = Predefined_bParticle_Show_At_Start[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation = Predefined_bParticle_Looping_Animation[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen = Predefined_bParticle_Full_Screen[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration = Predefined_fParticle_Fullscreen_Duration[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein = Predefined_fParticle_Fullscreen_Fadein[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout = Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition = Predefined_Particle_Fullscreen_Transition[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Speed = Predefined_fParticle_Speed[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity = Predefined_fParticle_Opacity[current_particle_selected];

					edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;
				}
			}
			ImGui::PopID();

			if (current_particle_selected == i)
			{
				//if (iSelections++ > 0)
				//{
				//	//Mark dublicates.
				//	tool_selected_col.w = 0.2;
				//}
				#ifndef USEPARTICLECOLUMNS
				window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				#else
				image_draw_bb = image_bb;
				bDrawsSelection = true;
				#endif
			}
			#ifndef USEPARTICLECOLUMNS
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Particle Preference");
			#endif

			#ifdef USEPARTICLECOLUMNS
			char *find = (char *)pestrcasestr(Predefined_Particle_Name[i].Get(), "particlesbank\\");
			if (find) find += 14;
			if (particle_image_size > 130)
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Particle Preference");
				if (find)
				{
					ImGui::TextCenter(find);
				}
			}
			else if(find)
			{
				cstr tooltip = cstr("Select Particle (") + cstr(find) + cstr(")");
				if (ImGui::IsItemHovered()) ImGui::SetTooltip(tooltip.Get());
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Select Particle Preference");
			}
			#endif

			#ifdef USEPARTICLECOLUMNS
			ImGui::NextColumn();
			#else	
			if ((i + 1) % particle_icons_columns != 0 && i != iPredefinedParticles - 1)
				ImGui::SameLine();
			#endif

		}
		#ifdef USEPARTICLECOLUMNS
		ImGui::Columns(1);
		if (bDrawsSelection)
		{
			window->DrawList->AddRect(image_draw_bb.Min, image_draw_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
		}

		ImGui::GetStyle().WindowPadding = iOldWindowPadding;
		ImGui::PopStyleVar();

		#endif
		ImGui::Text("");

		if (ImGui::StyleButton("Add New Particle##+", ImVec2((particle_w*0.5f) - 4.0f, 0)) || iSelectedLibraryStingReturnID == window->GetID("Add New Particle##+"))
		{
			if (iSelectedLibraryStingReturnID == window->GetID("Add New Particle##+"))
			{
				//This goes to the saved in pref. find free.
				int iSaveTo = -1;
				for (int i = 0; i < 16; i++)
				{
					if (strlen(pref.Saved_Particle_Name[i]) <= 0)
					{
						iSaveTo = i;
						break;
					}
				}
				if (iSaveTo > -1)
				{
					if (strnicmp(sSelectedLibrarySting.Get() + strlen(sSelectedLibrarySting.Get()) - 4, ".arx", 4) == NULL) sSelectedLibrarySting = Left(sSelectedLibrarySting.Get(), Len(sSelectedLibrarySting.Get()) - 4);
					strcpy(pref.Saved_Particle_Name[iSaveTo], sSelectedLibrarySting.Get());

					current_particle_selected = iSaveTo + iPredefinedParticleSetups;

					if (current_particle_selected >= 0 && current_particle_selected < 32)
						Predefined_Particle_Name[current_particle_selected] = sSelectedLibrarySting;

				}

				sSelectedLibrarySting = "";
				iSelectedLibraryStingReturnID = -1; //disable.

				//PE: Add new settings to current particle.
				if (iSaveTo > -1 && elementID > 0)
				{
					int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
					if (iParticleEmitter != -1)
					{
						gpup_deleteEffect(iParticleEmitter);
					}
					t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
					t.entityelement[elementID].eleprof.newparticle.emittername = Predefined_Particle_Name[current_particle_selected];
					//Setup defaults.
					Predefined_bParticle_Preview[current_particle_selected] = true;
					Predefined_bParticle_Show_At_Start[current_particle_selected] = true;
					Predefined_bParticle_Looping_Animation[current_particle_selected] = true;
					Predefined_bParticle_Full_Screen[current_particle_selected] = false;
					Predefined_fParticle_Fullscreen_Duration[current_particle_selected] = 10.0f;
					Predefined_fParticle_Fullscreen_Fadein[current_particle_selected] = 1.0f;
					Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected] = 1.0f;
					Predefined_Particle_Fullscreen_Transition[current_particle_selected] = "";
					Predefined_fParticle_Speed[current_particle_selected] = 1.0f;
					Predefined_fParticle_Opacity[current_particle_selected] = 1.0f;
					//Add new settings to eleprof.
					t.entityelement[elementID].eleprof.newparticle.bParticle_Preview = Predefined_bParticle_Preview[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start = Predefined_bParticle_Show_At_Start[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation = Predefined_bParticle_Looping_Animation[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen = Predefined_bParticle_Full_Screen[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration = Predefined_fParticle_Fullscreen_Duration[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein = Predefined_fParticle_Fullscreen_Fadein[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout = Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition = Predefined_Particle_Fullscreen_Transition[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Speed = Predefined_fParticle_Speed[current_particle_selected];
					t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity = Predefined_fParticle_Opacity[current_particle_selected];

					edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;

					bUpdateParticle = true; //Start new effect.
				}

				bPredefinedParticleInit = false; //Setup everything again.

			}
			else
			{
				//Open select particle window.
				bExternal_Entities_Window = true;
				iDisplayLibraryType = 5;
				iLibraryStingReturnToID = window->GetID("Add New Particle##+");
			}
		}

		ImGui::SameLine();
		bool bDisableButton = true;
		if (current_particle_selected != -1 && current_particle_selected > iPredefinedParticleSetups-1) bDisableButton = false;
		if (ImGui::StyleButtonEx("Delete Particle", ImVec2((particle_w*0.5f) - 4.0f, 0), bDisableButton))
		{
			if (current_particle_selected >= iPredefinedParticleSetups)
			{
				strcpy(pref.Saved_Particle_Name[current_particle_selected - iPredefinedParticleSetups], "");
				bPredefinedParticleInit = false; //Setup everything again.
			}
		}
		if (ImGui::IsItemHovered())
		{
			if (bDisableButton == true)
				ImGui::SetTooltip("Cannot delete first 9 default particles");
			else
				ImGui::SetTooltip("Delete selected custom particle");
		}

		//PE: Not very useful , you can just click the "default particle" in the list, removed for now.
		/*
		if (ImGui::StyleButton("Reset to Default Particles", ImVec2(particle_w, 0)))
		{
			//Dont reset saved.
			bPredefinedParticleInit = false; //Setup everything again.
			bFindBestParticleChoice = true;
			iLastParticleEntityElementIDHere = -1;
			current_particle_selected = 0;
			int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
			if (iParticleEmitter != -1)
			{
				gpup_deleteEffect(iParticleEmitter);
			}
			Predefined_bParticle_Preview[current_particle_selected] = true;
			Predefined_bParticle_Show_At_Start[current_particle_selected] = true;
			if (current_particle_selected == 7)
				Predefined_bParticle_Looping_Animation[current_particle_selected] = false;
			else
				Predefined_bParticle_Looping_Animation[current_particle_selected] = true;
			Predefined_bParticle_Full_Screen[current_particle_selected] = false;
			Predefined_fParticle_Fullscreen_Duration[current_particle_selected] = 10.0f;
			Predefined_fParticle_Fullscreen_Fadein[current_particle_selected] = 1.0f;
			Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected] = 1.0f;
			Predefined_Particle_Fullscreen_Transition[current_particle_selected] = "";
			Predefined_fParticle_Speed[current_particle_selected] = 1.0f;
			Predefined_fParticle_Opacity[current_particle_selected] = 1.0f;

			t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
			t.entityelement[elementID].eleprof.newparticle.emittername = Predefined_Particle_Name[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.bParticle_Preview = Predefined_bParticle_Preview[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.bParticle_Show_At_Start = Predefined_bParticle_Show_At_Start[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation = Predefined_bParticle_Looping_Animation[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.bParticle_Full_Screen = Predefined_bParticle_Full_Screen[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Duration = Predefined_fParticle_Fullscreen_Duration[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadein = Predefined_fParticle_Fullscreen_Fadein[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.fParticle_Fullscreen_Fadeout = Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.Particle_Fullscreen_Transition = Predefined_Particle_Fullscreen_Transition[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.fParticle_Speed = Predefined_fParticle_Speed[current_particle_selected];
			t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity = Predefined_fParticle_Opacity[current_particle_selected];
			edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;
			current_particle_selected = -1;

		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reset Particles to The Default Settings");
		*/

		ImGui::TextCenter("Particle Values");

		bool btmp = edit_grideleprof->newparticle.bParticle_Preview;
		if( ImGui::Checkbox("Preview Particle Effect", &btmp) )
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Preview = btmp;
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle whether the particle effect shows in the editor");

		btmp = edit_grideleprof->newparticle.bParticle_Show_At_Start;
		if (ImGui::Checkbox("Show at start of level", &btmp))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Show_At_Start = btmp;
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggle whether the particle effect shows at the start of the level");

		btmp = edit_grideleprof->newparticle.bParticle_Looping_Animation;
		if (ImGui::Checkbox("Looping Animation", &btmp))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.bParticle_Looping_Animation = btmp;
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose whether the particle repeats, or plays once only");

		ImGui::TextCenter("Animation Speed");
		ImGui::PushItemWidth(-10);
		int tmpint = edit_grideleprof->newparticle.fParticle_Speed * 100.0f; // 1.0 = normal.
		if (ImGui::MaxSliderInputInt("##Animation Speed", &tmpint, 0, 200, "Animation Speed"))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.fParticle_Speed = (float) tmpint/100.0f;
		ImGui::PopItemWidth();
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the global speed of the particle effect");

		ImGui::TextCenter("Opacity");
		ImGui::PushItemWidth(-10);
		tmpint = edit_grideleprof->newparticle.fParticle_Opacity * 100.0f; // 1.0 = normal.
		if (ImGui::MaxSliderInputInt("##OpacityParticle", &tmpint, 0, 200, "Opacity"))
		{
			bUpdateParticle = true;
		}
		edit_grideleprof->newparticle.fParticle_Opacity = (float)tmpint / 100.0f;
		ImGui::PopItemWidth();
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the global opacity of the particle effect");

		sObject* pObject = GetObjectData(t.entityelement[elementID].obj);
		if (bUpdateParticle && elementID > 0 && pObject)
		{
			t.entityelement[elementID].eleprof.newparticle = edit_grideleprof->newparticle;
			if (current_particle_selected >= 0)
			{
				//Update predefined values.
				Predefined_bParticle_Preview[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Preview;
				Predefined_bParticle_Show_At_Start[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Show_At_Start;
				Predefined_bParticle_Looping_Animation[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Looping_Animation;
				Predefined_bParticle_Full_Screen[current_particle_selected] = edit_grideleprof->newparticle.bParticle_Full_Screen;
				Predefined_fParticle_Fullscreen_Duration[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Fullscreen_Duration;
				Predefined_fParticle_Fullscreen_Fadein[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadein;
				Predefined_fParticle_Fullscreen_Fadeout[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadeout;
				Predefined_Particle_Fullscreen_Transition[current_particle_selected] = edit_grideleprof->newparticle.Particle_Fullscreen_Transition;
				Predefined_fParticle_Speed[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Speed;
				Predefined_fParticle_Opacity[current_particle_selected] = edit_grideleprof->newparticle.fParticle_Opacity;
			}

			if (current_particle_selected >= iPredefinedParticleSetups)
			{
				//This is a pref setup so update new settings.
				int icust = current_particle_selected - iPredefinedParticleSetups;
				if (icust >= 0 && icust < 16)
				{
					//pref.Saved_Particle_Name[icust] never change.
					pref.Saved_bParticle_Preview[icust] = edit_grideleprof->newparticle.bParticle_Preview;
					pref.Saved_bParticle_Show_At_Start[icust] = edit_grideleprof->newparticle.bParticle_Show_At_Start;
					pref.Saved_bParticle_Looping_Animation[icust] = edit_grideleprof->newparticle.bParticle_Looping_Animation;
					pref.Saved_bParticle_Full_Screen[icust] = edit_grideleprof->newparticle.bParticle_Full_Screen;
					pref.Saved_fParticle_Fullscreen_Duration[icust] = edit_grideleprof->newparticle.fParticle_Fullscreen_Duration;
					pref.Saved_fParticle_Fullscreen_Fadein[icust] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadein;
					pref.Saved_fParticle_Fullscreen_Fadeout[icust] = edit_grideleprof->newparticle.fParticle_Fullscreen_Fadeout;
					strcpy(pref.Saved_Particle_Fullscreen_Transition[icust], edit_grideleprof->newparticle.Particle_Fullscreen_Transition.Get());
					pref.Saved_fParticle_Speed[icust] = edit_grideleprof->newparticle.fParticle_Speed;
					pref.Saved_fParticle_Opacity[icust] = edit_grideleprof->newparticle.fParticle_Opacity;
				}
			}

			int iParticleEmitter = t.entityelement[elementID].eleprof.newparticle.emitterid;
			if (iParticleEmitter == -1)
			{
				iParticleEmitter = gpup_loadEffect(t.entityelement[elementID].eleprof.newparticle.emittername.Get(), 0, 0, 0, 1.0);
				gpup_emitterActive(iParticleEmitter, 0);
				t.entityelement[elementID].eleprof.newparticle.emitterid = iParticleEmitter;
			}
			if (iParticleEmitter != -1)
			{
				gpup_setGlobalPosition(iParticleEmitter, t.entityelement[elementID].x, t.entityelement[elementID].y, t.entityelement[elementID].z);
				gpup_resetLocalPosition(iParticleEmitter);
				float fSpeedX, fSpeedY, fSpeedZ;
				gpup_getEmitterSpeedAngleAdjustment(iParticleEmitter, &fSpeedX, &fSpeedY, &fSpeedZ);
				GGVECTOR3 vecSpeedDirection = GGVECTOR3(fSpeedX - 0.5f, fSpeedY - 0.5f, fSpeedZ - 0.5f);
				GGVec3TransformCoord(&vecSpeedDirection, &vecSpeedDirection, &pObject->position.matRotation);
				gpup_setEmitterSpeedAngleAdjustment(iParticleEmitter, 0.5f + vecSpeedDirection.x, 0.5f + vecSpeedDirection.y, 0.5f + vecSpeedDirection.z);
				gpup_setGlobalRotation(iParticleEmitter, t.entityelement[elementID].rx, t.entityelement[elementID].ry, t.entityelement[elementID].rz);
				gpup_setGlobalScale(iParticleEmitter, 100.0f + t.entityelement[elementID].scalex);
				gpup_emitterActive(iParticleEmitter, t.entityelement[elementID].eleprof.newparticle.bParticle_Preview);
				gpup_setEffectAnimationSpeed(iParticleEmitter, t.entityelement[elementID].eleprof.newparticle.fParticle_Speed);
				gpup_setEffectOpacity(iParticleEmitter, t.entityelement[elementID].eleprof.newparticle.fParticle_Opacity);

				if(!t.entityelement[elementID].eleprof.newparticle.bParticle_Looping_Animation)
					gpup_emitterFire(iParticleEmitter);
			}
			edit_grideleprof->newparticle = t.entityelement[elementID].eleprof.newparticle;
		}
	}
	#endif
	else if (t.entityprofile[entid].ismarker == 1)
	{
		//Start Marker.
		//Display icon.
		if (bDisplaySmallIcon)
		{
			if (t.entityprofile[entid].iThumbnailSmall > 0) {
				float w = ImGui::GetContentRegionAvailWidth();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
				ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
			}
		}

		//Name only.
		//ImGui::Text("");
		if(bDisplayName)
			edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(),readonly);


		// DLUA support added here.
		int speech_entries = 0;
		bool bUpdateMainString = false;
		for (int speech_loop = 0; speech_loop < 5; speech_loop++)
			speech_ids[speech_loop] = -1;
		if (fpe_current_loaded_script != fpe_current_selected_script)
		{
			//Load in lua and check for custom properties.
			cstr script_name = "";
			//if (strnicmp(edit_grideleprof->aimain_s.Get(), "projectbank", 11) != NULL) 
			script_name = "scriptbank\\";
			script_name += edit_grideleprof->aimain_s;

			//Try to parse script.
			ParseLuaScript(lua_grideleprof, script_name.Get());
			fpe_current_loaded_script = fpe_current_selected_script;

			if (lua_grideleprof->PropertiesVariableActive == 1) {
				bUpdateMainString = true;
				fpe_current_loaded_script_has_dlua = true;
			}
			else {
				if (fpe_current_loaded_script_has_dlua) {
					//Reset edit_grideleprof->soundset4_s that contain the dlua calls.
					edit_grideleprof->soundset4_s = "";
					fpe_current_loaded_script_has_dlua = false;
				}
			}
		}

		#ifdef USENEWMEDIASELECTWINDOWS
		if (pref.current_style == 25 || pref.current_style == 3)
		{
			fpe_current_loaded_script_image = PLAYER_START;
		}
		else
		{
			fpe_current_loaded_script_image = PLAYER_START2;
		}
		//Display only no selections.
		ImGui::PushItemWidth(-10);
		float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
		float ImgW = ImageWidth(fpe_current_loaded_script_image);
		float ImgH = ImageHeight(fpe_current_loaded_script_image);
		float fRatio = w / ImgW;
		ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false);
		//ImGui::TextCenter(cDisplayName);
		ImGui::PopItemWidth();
		#endif

		// Markers behaviours
		if (lua_grideleprof->PropertiesVariableActive == 1 || lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0)
		{
			//"Behaviors"
			if (lua_grideleprof->PropertiesVariableActive == 1) {
				speech_entries = DisplayLuaDescription(lua_grideleprof);
			}
			else {
				if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) {
					if (edit_grideleprof->aimain_s != "default.lua") //No need to display.
						DisplayLuaDescriptionOnly(lua_grideleprof);
				}
			}
		}

		if (speech_entries > 0)
		{
			// all SPEECH control is moved to this function.
			SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
		}

		// Player Has Weapon
		if (t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2)
		{
			// weapon selection
			LPSTR pAttachmentTitle = "Weapon";
			edit_grideleprof->hasweapon_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, edit_grideleprof->hasweapon_s.Get(), pAttachmentTitle, t.strarr_s[209].Get(), 1, readonly, false, true, true, 0);
			t.findgun_s = Lower(edit_grideleprof->hasweapon_s.Get()); gun_findweaponindexbyname();
			if (t.foundgunid > 0)
			{
				// hands selection (if using new weapon system)
				if (t.gun[t.foundgunid].newweaponsystem==1)
				{
					pAttachmentTitle = "Hands";
					edit_grideleprof->texaltd_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, edit_grideleprof->texaltd_s.Get(), pAttachmentTitle, "Choose the style of hands for the player", 3, readonly, false, true, true, 0);
				}
				else
				{
					ImGui::TextCenter("(Hands Fixed For Legacy Weapons)");
				}

				// any ammo used
				int iPoolIndex = g.firemodes[t.foundgunid][0].settings.poolindex;
				if (iPoolIndex > 0)
				{
					ImGui::TextCenter("Ammo Quantity");
					ImGui::MaxSliderInputInt("##AmmoQuantity", &edit_grideleprof->quantity, 0, 1000, "Amount of ammo the player starts with");
				}
			}

			// multipliers
			ImGui::TextCenter("Weapon Damage Multiplier");
			int iModifier = edit_grideleprof->weapondamagemultiplier * 100;
			if (ImGui::MaxSliderInputInt("##WeaponDamageM", &iModifier, 1, 1000, "Percent of weapon damage that the player does compared to enemies"))
			{
				edit_grideleprof->weapondamagemultiplier = iModifier * 0.01f;
			}
			ImGui::TextCenter("Melee Damage Multiplier");
			iModifier = edit_grideleprof->meleedamagemultiplier * 100;
			if (ImGui::MaxSliderInputInt("##MeleeDamageM", &iModifier, 1, 1000, "Percent of melee damage that the player does compared to enemies"))
			{
				edit_grideleprof->meleedamagemultiplier = iModifier * 0.01f;
			}

			// configure weapon slots for player (functionality exists from Classic)
			ImGui::TextCenter("Preferred Weapon Slots");
			for (int key = 1; key <= 9; key++)
			{
				char pLabel[32];
				sprintf(pLabel, "Key %d", key);
				char pLabelTokenName[32];
				sprintf(pLabelTokenName, "weapprefkey1%d", key);
				ImGui::Text(pLabel);
				ImGui::SameLine();
				cstr slot_s = "";

				for (int gunid = 1; gunid <= g.gunmax; gunid++)
				{
					if (t.weaponSlotPreferrenceSettings[key - 1] > 0 && t.weaponSlotPreferrenceSettings[key - 1] == gunid)
					{
						slot_s = t.gun[gunid].name_s;
						break;
					}
				}

				cstr lastslot = slot_s;
				slot_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, slot_s.Get(), pLabelTokenName, t.strarr_s[209].Get(), 61, readonly, false, true, true, 0);
				if (stricmp(slot_s.Get(), lastslot.Get()) != NULL)
				{
					// assign a new preference
					if (stricmp(slot_s.Get(), "") == NULL) // when "No Preference" option is selected slot_s is set to ""
					{
						t.weaponSlotPreferrenceSettings[key - 1] = 0;
						t.weaponslot[key].pref = 0;
					}
					else
					{
						int iFoundGunID = -1;
						for (int gunid = 1; gunid <= g.gunmax; gunid++)
						{
							if (stricmp(slot_s.Get(), t.gun[gunid].name_s.Get()) == NULL)
							{
								iFoundGunID = gunid;
								break;
							}
						}
						if (iFoundGunID != -1)
						{
							// if not a slot blocker
							if (stricmp(t.gun[iFoundGunID].name_s.Get(), "Slot Not Used") != NULL)
							{
								// erase old preference if already assigned
								for (int n = 0; n < 9; n++)
								{
									if (n != (key - 1) && t.weaponSlotPreferrenceSettings[n] == iFoundGunID)
									{
										t.weaponSlotPreferrenceSettings[n] = 0;
										t.weaponslot[1 + n].pref = 0;
									}
								}
							}

							// add new preference
							t.weaponSlotPreferrenceSettings[key - 1] = iFoundGunID;
							t.weaponslot[key].pref = iFoundGunID;
						}
					}

					// and save out the new layout
					extern void gun_gatherslotorder_save (void);
					gun_gatherslotorder_save();
				}
			}
		}
		ImGui::Spacing();

		ImGui::TextCenter("Player Settings");
		ImGui::TextCenter("Speed");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##Movement SpeedSimpleInput", &edit_grideleprof->speed, 1, 500, 0);
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Player Speed");
		if (t.playercontrol.thirdperson.enabled == 1) t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
		else t.tanimspeed_f = edit_grideleprof->animspeed;
		ImGui::PopItemWidth();

		ImGui::TextCenter("Swimming Speed");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##SwimSpeedSimpleInput", &edit_grideleprof->iSwimSpeed, 1, 100, "Modifies how much distance is travelled with each swimming stroke");
		ImGui::PopItemWidth();
	
		ImGui::TextCenter("Health");
		static int iPlayerNormalStrength = 500;
		int iPlayerInvincible = 0;
		if (edit_grideleprof->strength == 99999) iPlayerInvincible = 1;
		if (iPlayerInvincible == 0)
		{
			ImGui::PushItemWidth(-10);
			ImGui::MaxSliderInputInt("##PlayerHealthSimpleInput", &edit_grideleprof->strength, 1, 1000, 0);
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Set Player Health");
			ImGui::PopItemWidth();
		}
		int iLastPlayerInvincible = iPlayerInvincible;
		iPlayerInvincible = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(iPlayerInvincible), "Invulnerable", "Controls whether the player has infinite health", 0, readonly);
		if (iLastPlayerInvincible != iPlayerInvincible)
		{
			if (iPlayerInvincible == 1)
			{
				iPlayerNormalStrength = edit_grideleprof->strength;
				edit_grideleprof->strength = 99999;
			}
			else
			{
				edit_grideleprof->strength = iPlayerNormalStrength;
			}
		}

		// health regeneration
		ImGui::TextCenter("Health Regeneration");
		ImGui::TextCenter("Amount");
		ImGui::MaxSliderInputInt("##RegenRate", &t.playercontrol.regenrate, 0, 1000, "Sets the amount of health to be regenerated at a time");
		ImGui::TextCenter("Rate");
		ImGui::MaxSliderInputInt("##RegenSpeed", &t.playercontrol.regenspeed, 0, 1000, "Sets how often health will be regenerated (in milliseconds)");
		ImGui::TextCenter("Delay");
		ImGui::MaxSliderInputInt("##RegenDelay", &t.playercontrol.regendelay, 0, 5000, "Sets the amount of time to wait  (in milliseonds) after taking damage, until health starts regenerating");
		ImGui::Spacing();
		
		ImGui::TextCenter("Effects");
		bool bHeartbeatSound = edit_grideleprof->perentityflags & 1;
		bHeartbeatSound = !bHeartbeatSound;
		bool bScreenBlood = edit_grideleprof->perentityflags & (1 << 1);
		bScreenBlood = !bScreenBlood;
		if (ImGui::Checkbox("Heartbeat Sound", &bHeartbeatSound))
		{
		}
		if(ImGui::IsItemHovered()) ImGui::SetTooltip("Controls whether a heartbeat sound is looped when the player is hurt");
		if (ImGui::Checkbox("Screen Blood", &bScreenBlood))
		{
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Controls whether blood is rendered on screen when the player is hurt");

		DWORD flags = !bHeartbeatSound;
		int iScreenBloodOff = !bScreenBlood;
		flags |= (iScreenBloodOff << 1);
		edit_grideleprof->perentityflags = flags;

		bool bDamageIndicator = t.huddamage.damageindicatoron;
		if (ImGui::Checkbox("Damage Indicator", &bDamageIndicator))
		{
			t.huddamage.damageindicatoron = bDamageIndicator;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sets whether a damage indicator appears when the player gets hurt");

		bool bFlashlightDisabled = edit_grideleprof->usespotlighting;
		if (ImGui::Checkbox("Flashlight Disabled", &bFlashlightDisabled))
		{
			edit_grideleprof->usespotlighting = bFlashlightDisabled;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sets whether the flashlight is disabled for the player");

	}
	else
	{
		//#################
		//#### Objects ####
		//################# 

		t.tokay = 1;
		if (ObjectExist(g.entitybankoffset + entid) == 1)
		{
			if (GetNumberOfFrames(g.entitybankoffset + entid) > 0)
			{
				t.tokay = 0;
			}
		}

		int speech_entries = 0;
		bool bUpdateMainString = false;

		for (int speech_loop = 0; speech_loop < 5; speech_loop++)
			speech_ids[speech_loop] = -1;

		//health.lua
		cstr aimain = edit_grideleprof->aimain_s.Lower();
		//new: trigger anyting not a marker.
		if (t.entityprofile[entid].ismarker == 0)// || aimain == "key.lua" || aimain == "objects\\key.lua" || aimain == "door.lua" || aimain == "default.lua" || aimain == "health.lua" || aimain == "pickuppable.lua" ) ) 
		{
			//"Name"
			//Display icon.
			if (bDisplaySmallIcon)
			{
				if (t.entityprofile[entid].iThumbnailSmall > 0) {
					float w = ImGui::GetContentRegionAvailWidth();
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (media_icon_size*0.5), 0.0f));
					ImGui::ImgBtn(t.entityprofile[entid].iThumbnailSmall, ImVec2(media_icon_size, media_icon_size), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
				}
			}
			if(bDisplayName)
				edit_grideleprof->name_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->name_s.Get(), "Name", t.strarr_s[204].Get(),readonly);

			// Object behaviours "Behaviors"
			// scan OBJECTS folder for complete list of script
			std::vector<cstr> scriptList_s; scriptList_s.clear();
			std::vector<cstr> scriptListTitle_s; scriptListTitle_s.clear();
			cstr oldDir_s = GetDir();
			SetDir(g.fpscrootdir_s.Get());
			SetDir("Files\\scriptbank\\objects");
			ChecklistForFiles();
			for (int f = 1; f <= ChecklistQuantity(); f++)
			{
				cstr tfile_s = ChecklistString(f);
				LPSTR pFilename = tfile_s.Get();
				if (tfile_s != "." && tfile_s != "..")
				{
					if (strnicmp(pFilename + strlen(pFilename) - 4, ".lua", 4) == NULL)
					{
						// create a readable title from file
						char pTitleName[256];
						strcpy(pTitleName, pFilename);
						pTitleName[strlen(pTitleName) - 4] = 0;
						for (int n = 0; n < strlen(pTitleName); n++)
						{
							if (n == 0)
							{
								if (pTitleName[n] >= 'a' && pTitleName[n] <= 'z')
									pTitleName[n] -= ('a' - 'A');
							}
							else
							{
								if (pTitleName[n] >= 'A' && pTitleName[n] <= 'Z')
									pTitleName[n] += ('a' - 'A');
							}
							if (pTitleName[n] == '_') pTitleName[n] = ' ';
						}

						// add script and title to list
						scriptList_s.push_back(cstr("objects\\") + tfile_s);
						scriptListTitle_s.push_back(cstr(pTitleName));
					}
				}
			}
			scriptList_s.push_back(cstr(""));
			scriptListTitle_s.push_back(cstr("Custom"));
			SetDir(oldDir_s.Get());

			// and create items list
			static int g_scriptobjects_item_count = 0;
			static char** g_scriptobjects_items = NULL;
			if (g_scriptobjects_item_count != scriptList_s.size())
			{
				if (g_scriptobjects_items)
				{
					for (int i = 0; i < g_scriptobjects_item_count; i++) SAFE_DELETE(g_scriptobjects_items[i]);
					SAFE_DELETE(g_scriptobjects_items);
				}
				g_scriptobjects_item_count = scriptList_s.size();
				g_scriptobjects_items = new char*[g_scriptobjects_item_count];
				for (int i = 0; i < g_scriptobjects_item_count; i++)
				{
					g_scriptobjects_items[i] = new char[256];
					strcpy(g_scriptobjects_items[i], scriptListTitle_s[i].Get());
				}
			}

			// find selection
			int item_current_type_selection = g_scriptobjects_item_count - 1; //Default Custom.
			for (int i = 0; i < g_scriptobjects_item_count - 1; i++)
			{
				// with workshop items updating core scripts, need to check entire path now!
				//if (pestrcasestr(edit_grideleprof->aimain_s.Get(), scriptList_s[i].Get()))
				if(stricmp (edit_grideleprof->aimain_s.Get(), scriptList_s[i].Get()) == NULL )
				{
					item_current_type_selection = i;
					break;
				}
			}

			if (fpe_current_loaded_script != item_current_type_selection)
			{
				//Load in lua and check for custom properties.
				cstr script_name_appendage = "";
				if (item_current_type_selection < g_scriptobjects_item_count - 1) //PE: Need to check for custom
					script_name_appendage += scriptList_s[item_current_type_selection];
				else
					script_name_appendage += edit_grideleprof->aimain_s;
				cstr script_name = "";
				//if (strnicmp(script_name_appendage.Get(), "projectbank", 11) != NULL) 
				script_name = "scriptbank\\";
				script_name += script_name_appendage;

				#ifdef USENEWMEDIASELECTWINDOWS
				fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
				if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0;
				std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
				if (pref.current_style == 25 || pref.current_style == 3)
					sImgName += ".png";
				else
					sImgName += "2.png";
				image_setlegacyimageloading(true);
				LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
				image_setlegacyimageloading(false);
				if (!GetImageExistEx(fpe_current_loaded_script_image))
				{
					if (!(pref.current_style == 25 || pref.current_style == 3))
					{
						sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
						sImgName += ".png";
						image_setlegacyimageloading(true);
						LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
						image_setlegacyimageloading(false);
						if (!GetImageExistEx(fpe_current_loaded_script_image))
						{
							fpe_current_loaded_script_image = FILETYPE_SCRIPT;
						}
					}
					else
						fpe_current_loaded_script_image = FILETYPE_SCRIPT;
				}
				#endif

				//Try to parse script.
				ParseLuaScriptWithElementID(lua_grideleprof, script_name.Get(),t.entityelement[elementID].obj);
				fpe_current_loaded_script = item_current_type_selection;

				if (lua_grideleprof->PropertiesVariableActive == 1)
				{
					bUpdateMainString = true;
					fpe_current_loaded_script_has_dlua = true;
				}
				else
				{
					if (fpe_current_loaded_script_has_dlua)
					{
						//Reset edit_grideleprof->soundset4_s that contain the dlua calls.
						edit_grideleprof->soundset4_s = "";
						fpe_current_loaded_script_has_dlua = false;
					}
				}
			}

			if (t.entityprofile[entid].bIsDecal)
			{
				if (elementID > 0)
				{
					ImGui::TextCenter("Decal Speed");
					ImGui::PushItemWidth(-10);
					int tmpint = t.entityelement[elementID].fDecalSpeed * 100.0; // 1.0 = normal.
					if (ImGui::MaxSliderInputInt("##Decal Speed", &tmpint, 1, 200, "Decal Speed"))
					{
						t.entityelement[elementID].fDecalSpeed = (float)tmpint / 100.0;
						SetupDecalObject(t.tobj, elementID);
					}
					t.entityelement[elementID].fDecalSpeed = (float)tmpint / 100.0;
					ImGui::PopItemWidth();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the speed of the decal effect");

					ImGui::TextCenter("Decal Opacity");
					ImGui::PushItemWidth(-10);
					tmpint = t.entityelement[elementID].fDecalOpacity * 100.0; // 1.0 = normal.
					if (ImGui::MaxSliderInputInt("##DecalOpacity", &tmpint, 0, 100, "Decal Opacity"))
					{
						if (tmpint > 100) tmpint = 100;
						if (tmpint < 0) tmpint = 0;
						t.entityelement[elementID].fDecalOpacity = (float)tmpint / 100.0;
						SetupDecalObject(t.tobj, elementID);
					}
					t.entityelement[elementID].fDecalOpacity = (float)tmpint / 100.0;
					ImGui::PopItemWidth();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the opacity of the decal effect");
				}
			}

			#ifdef USENEWMEDIASELECTWINDOWS
			ImGui::PushItemWidth(-10);
			float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
			float ImgW = ImageWidth(fpe_current_loaded_script_image);
			float ImgH = ImageHeight(fpe_current_loaded_script_image);
			float fRatio = w / ImgW;

			ImGuiWindow* window = ImGui::GetCurrentWindow();
			if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
			{
				//Update Script.
				if (sSelectedLibrarySting != "")
				{
					edit_grideleprof->aimain_s = sSelectedLibrarySting;
					sSelectedLibrarySting = "";
					iSelectedLibraryStingReturnID = -1; //disable.
					fpe_current_loaded_script = -1; //Reload image and DLUA.
					if(!pestrcasestr(edit_grideleprof->aimain_s.Get(), "default.lua"))
					{
						//PE: When selecting a script, disable static so script will run.
						if (elementID > 0) t.entityelement[elementID].staticflag = 0;
					}
				}
			}
			//if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true))
			if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0,false))
			{
				//Select script.
				if (t.entityprofile[entid].bIsDecal)
					sStartLibrarySearchString = "Decal";
				else
					sStartLibrarySearchString = "Objects";
				iLastDisplayLibraryType = -1;
				bExternal_Entities_Window = true;
				iDisplayLibraryType = 4;
				iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
				if ( edit_grideleprof->aimain_s.Len() > 0)
					sMakeDefaultSelecting = edit_grideleprof->aimain_s;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Object Behavior");
			ImGui::TextCenter(cDisplayName);
			ImGui::PopItemWidth();
			#else
			ImGui::PushItemWidth(-10);
			if (ImGui::Combo("##Behaviours2SimpleInput", &item_current_type_selection, g_scriptobjects_items, g_scriptobjects_item_count, 20))
			{
				if (item_current_type_selection >= 0) {
					edit_grideleprof->aimain_s = scriptList_s[item_current_type_selection];
					//PE: When selecting a script, disable static so script will run.
					if (elementID > 0) t.entityelement[elementID].staticflag = 0;
				}
				else
					edit_grideleprof->aimain_s = "default.lua";
				aimain = edit_grideleprof->aimain_s.Lower();
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Select Object Behavior");
			ImGui::PopItemWidth();
			#endif

			#ifndef USENEWMEDIASELECTWINDOWS
			if (item_current_type_selection == g_scriptobjects_item_count - 1)
			{
				//Custom Behaviours , display directly.
				std::string ms = t.strarr_s[417].Get();
				ms = "Script";
				cstr aim = edit_grideleprof->aimain_s;
				edit_grideleprof->aimain_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->aimain_s.Get(), (char *)ms.c_str(), t.strarr_s[207].Get(), pAIRoot,readonly);
				aimain = edit_grideleprof->aimain_s.Lower();
				if (aim != edit_grideleprof->aimain_s)
				{
					fpe_current_loaded_script = -1;
					//PE: When selecting a script, disable static so script will run.
					if (elementID > 0) t.entityelement[elementID].staticflag = 0;
				}
			}
			#endif

			if (lua_grideleprof->PropertiesVariableActive == 1)
			{
				speech_entries = DisplayLuaDescription(lua_grideleprof);
			}
			else
			{
				if (lua_grideleprof->PropertiesVariable.VariableDescription.Len() > 0)
				{
					if (edit_grideleprof->aimain_s != "default.lua") //No need to display.
						DisplayLuaDescriptionOnly(lua_grideleprof);
				}
			}


			if (speech_entries > 0)
			{
				// all SPEECH control is moved to this function.
				SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
			}
		}
		else
		{
			//PE: Support markers > 1 here.
			if (t.entityprofile[entid].ismarker > 1) 
			{
				//ismarker = 1 has its own function.
				//DLUA support added here.
				bool bUpdateMainString = false;
				for (int speech_loop = 0; speech_loop < 5; speech_loop++)
					speech_ids[speech_loop] = -1;
				if (fpe_current_loaded_script != fpe_current_selected_script) 
				{
					//Load in lua and check for custom properties.
					cstr script_name = "";
					//if (strnicmp(edit_grideleprof->aimain_s.Get(), "projectbank", 11) != NULL) 
					script_name = "scriptbank\\";
					script_name += edit_grideleprof->aimain_s;

					#ifdef USENEWMEDIASELECTWINDOWS
					fpe_current_loaded_script_image = PROPERTIES_CACHE_ICONS + fpe_current_loaded_script_image_count;
					if (fpe_current_loaded_script_image_count++ > 10) fpe_current_loaded_script_image_count = 0;
					std::string sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
					if (pref.current_style == 25 || pref.current_style == 3)
						sImgName += ".png";
					else
						sImgName += "2.png";
					image_setlegacyimageloading(true);
					LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
					image_setlegacyimageloading(false);
					if (!GetImageExistEx(fpe_current_loaded_script_image))
					{
						if (!(pref.current_style == 25 || pref.current_style == 3))
						{
							sImgName = Left(script_name.Get(), Len(script_name.Get()) - 4);
							sImgName += ".png";
							image_setlegacyimageloading(true);
							LoadImage((char *)sImgName.c_str(), fpe_current_loaded_script_image);
							image_setlegacyimageloading(false);
							if (!GetImageExistEx(fpe_current_loaded_script_image))
							{
								fpe_current_loaded_script_image = FILETYPE_SCRIPT;
							}
						}
						else
							fpe_current_loaded_script_image = FILETYPE_SCRIPT;
					}
					#endif

					//Try to parse script.
					ParseLuaScript(edit_grideleprof, script_name.Get());
					fpe_current_loaded_script = fpe_current_selected_script;

					if (edit_grideleprof->PropertiesVariableActive == 1) {
						bUpdateMainString = true;
						fpe_current_loaded_script_has_dlua = true;
					}
					else 
					{
						if (fpe_current_loaded_script_has_dlua) 
						{
							//Reset edit_grideleprof->soundset4_s that contain the dlua calls.
							edit_grideleprof->soundset4_s = "";
							fpe_current_loaded_script_has_dlua = false;
						}
					}
				}

				#ifdef USENEWMEDIASELECTWINDOWS
				//Display only no selections.
				ImGui::PushItemWidth(-10);
				float w = ImGui::GetContentRegionAvailWidth() - 16.0f;
				float ImgW = ImageWidth(fpe_current_loaded_script_image);
				float ImgH = ImageHeight(fpe_current_loaded_script_image);
				float fRatio = w / ImgW;

				//LB: Do allow TRIGGER ZONE script to change
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				if (t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 2)
				{
					if (iSelectedLibraryStingReturnID == window->GetID("ScriptSelector##+"))
					{
						//Update Script.
						if (sSelectedLibrarySting != "")
						{
							edit_grideleprof->aimain_s = sSelectedLibrarySting;
							sSelectedLibrarySting = "";
							iSelectedLibraryStingReturnID = -1;
							fpe_current_loaded_script = -1;
						}
					}
				}
				if (ImGui::ImgBtn(fpe_current_loaded_script_image, ImVec2(ImgW*fRatio, ImgH*fRatio), drawCol_black, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, false))
				{
					//LB: But do allow TRIGGER ZONE script to change
					if (t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 2)
					{
						//Select script.
						sStartLibrarySearchString = "Markers";
						iLastDisplayLibraryType = -1;
						bExternal_Entities_Window = true;
						iDisplayLibraryType = 4;
						iLibraryStingReturnToID = window->GetID("ScriptSelector##+");
						if (edit_grideleprof->aimain_s.Len() > 0)
						{
							sMakeDefaultSelecting = edit_grideleprof->aimain_s;
						}
					}
				}
				ImGui::TextCenter(cDisplayName);
				ImGui::PopItemWidth();
				#endif


				if (edit_grideleprof->PropertiesVariableActive == 1 || edit_grideleprof->PropertiesVariable.VariableDescription.Len() > 0)
				{
					//ImGui::Indent(10);

					if (edit_grideleprof->PropertiesVariableActive == 1) {
						speech_entries = DisplayLuaDescription(edit_grideleprof);
					}
					else {
						if (edit_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) {
							DisplayLuaDescriptionOnly(edit_grideleprof);
						}
					}

					//ImGui::Indent(-10);
				}

				if (speech_entries > 0)
				{
					// all SPEECH control is moved to this function.
					SpeechControls(speech_entries, bUpdateMainString, edit_grideleprof);
				}

			}

		}
	}

	// All objects need 'certain fields' as pretty commmon  to have it for the script
	//PE: Markers also have these fields. So anything with dlua active.
	if (edit_grideleprof->PropertiesVariable.VariableDescription.Len() > 0) //t.entityprofile[entid].ismarker == 0) // so as not to interfere with markers
	{
		bool bSound0Mentioned = false;
		bool bSound1Mentioned = false;
		bool bSound2Mentioned = false;
		bool bSound3Mentioned = false;
		bool bVideoSlotMentioned = false;
		bool bIfUsedMentioned = false;
		bool bUseKeyMentioned = false;
		bool bShootingWeaponMentioned = false;
		bool bMeleeWeaponMentioned = false;
		bool bUnarmedMentioned = false;
		int iAnimationSetMentioned = 0;
		char pCaptureAnyScriptDesc[10240 + (80 * 300) + (80 * 300)];

		strcpy(pCaptureAnyScriptDesc, edit_grideleprof->PropertiesVariable.VariableDescription.Get());
		for (int i = 0; i < edit_grideleprof->PropertiesVariable.iVariables; i++)
		{
			strcat(pCaptureAnyScriptDesc, edit_grideleprof->PropertiesVariable.VariableSectionDescription[i]);
		}
		for (int i = 0; i < edit_grideleprof->PropertiesVariable.iVariables; i++)
		{
			strcat(pCaptureAnyScriptDesc, edit_grideleprof->PropertiesVariable.VariableSectionEndDescription[i]);
		}
		if (strstr(pCaptureAnyScriptDesc, "<Sound0>") != 0) bSound0Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Sound1>") != 0) bSound1Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Sound2>") != 0) bSound2Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Sound3>") != 0) bSound3Mentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Video Slot>") != 0) bVideoSlotMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<If Used>") != 0) bIfUsedMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Use Key>") != 0) bUseKeyMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Shooting Weapon>") != 0) bShootingWeaponMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Melee Weapon>") != 0) bMeleeWeaponMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Any Weapon>") != 0) { bShootingWeaponMentioned = true; bMeleeWeaponMentioned = true; }
		if (strstr(pCaptureAnyScriptDesc, "<Unarmed>") != 0) bUnarmedMentioned = true;
		if (strstr(pCaptureAnyScriptDesc, "<Soldier Animations>") != 0) iAnimationSetMentioned = 1;
		if (strstr(pCaptureAnyScriptDesc, "<Melee Animations>") != 0) iAnimationSetMentioned = 2;
		if (strstr(pCaptureAnyScriptDesc, "<Zombie Animations>") != 0) iAnimationSetMentioned = 3;
		if (strstr(pCaptureAnyScriptDesc, "<Default Animations>") != 0) iAnimationSetMentioned = 4;		

		if (bSound0Mentioned || bSound1Mentioned || bSound2Mentioned || bSound3Mentioned || bVideoSlotMentioned || bIfUsedMentioned || bUseKeyMentioned || bShootingWeaponMentioned || bMeleeWeaponMentioned || iAnimationSetMentioned>0)
		{
			if (bVideoSlotMentioned == true)
			{
				#ifdef WICKEDENGINE
				#define VIDEOFILEID (PROPERTIES_CACHE_ICONS+997)
				static cstr videofile = "";
				static int videofile_preview_id = 0;
				if (edit_grideleprof->soundset1_s != videofile)
				{
					//Load new image preview.
					videofile_preview_id = 0;
					if (edit_grideleprof->soundset1_s != "")
					{
						videofile_preview_id = VIDEOFILEID;

						std::string stmp = edit_grideleprof->soundset1_s.Get();
						replaceAll(stmp, "videobank", ""); //Video thumbs stored without videobank.
						replaceAll(stmp, "\\\\", "\\"); //Remove double backslash.

						bool CreateBackBufferCacheName(char *file, int width, int height);
						extern cstr BackBufferCacheName;
						CreateBackBufferCacheName((char *)stmp.c_str(), 512, 288);
						GG_SetWritablesToRoot(true);
						SetMipmapNum(1); //PE: mipmaps not needed.
						image_setlegacyimageloading(true);
						if (FileExist(BackBufferCacheName.Get()))
						{
							LoadImage((char *)BackBufferCacheName.Get(), videofile_preview_id);
						}
						image_setlegacyimageloading(false);
						SetMipmapNum(-1);
						GG_SetWritablesToRoot(false);
						if (!GetImageExistEx(VIDEOFILEID))
						{
							videofile_preview_id = 0;
						}
					}
					videofile = edit_grideleprof->soundset1_s;
				}
				#endif
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", "Choose a movie file (mp4 format) to play when the player enters this zone", "videobank\\", readonly);
				if (videofile_preview_id > 0 && GetImageExistEx(videofile_preview_id))
				{
					extern ImVec4 drawCol_back;
					extern ImVec4 drawCol_normal;
					extern ImVec4 drawCol_hover;
					extern ImVec4 drawCol_Down;

					float w = ImGui::GetContentRegionAvailWidth();
					float iwidth = w;
					float ImgW = ImageWidth(videofile_preview_id);
					float ImgH = ImageHeight(videofile_preview_id);
					float fHighRatio = ImgH / ImgW;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (iwidth*0.5), 0.0f));
					ImGui::ImgBtn(videofile_preview_id, ImVec2(iwidth - 18.0f, (iwidth - 18.0f) * fHighRatio), drawCol_back, drawCol_normal, drawCol_normal, drawCol_normal, -1, 0, 0, 0, true);
				}
			}
			if (bSound0Mentioned == true && bVideoSlotMentioned == false) edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[253].Get(), "audiobank\\",readonly);
			if (bSound1Mentioned == true) edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Sound1", t.strarr_s[254].Get(), "audiobank\\", readonly);
			if (bSound2Mentioned == true) edit_grideleprof->soundset2_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset2_s.Get(), "Sound2", t.strarr_s[254].Get(), "audiobank\\", readonly);
			if (bSound3Mentioned == true) edit_grideleprof->soundset3_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset3_s.Get(), "Sound3", t.strarr_s[254].Get(), "audiobank\\", readonly);
			if (bIfUsedMentioned == true) edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get(), readonly);
			if (bUseKeyMentioned == true) edit_grideleprof->usekey_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get(), readonly);
			bool readonly = false;
			if (bShootingWeaponMentioned == true || bMeleeWeaponMentioned == true)
			{
				//if (t.entityprofile[entid].ischaracter == 1) any behavior can show a weapon choice now!
				//{
					extern void animsystem_weaponproperty (int, bool, entityeleproftype*, bool, bool);
					animsystem_weaponproperty(t.entityprofile[entid].characterbasetype, readonly, edit_grideleprof, bShootingWeaponMentioned, bMeleeWeaponMentioned);
				//}
			}
			else if (bUnarmedMentioned)
			{
				//if (t.entityprofile[entid].ischaracter == 1) any behavior can show a weapon choice now!
				//{
					if (edit_grideleprof->hasweapon_s.Len() > 0)
					{
						edit_grideleprof->hasweapon_s = "";
						edit_grideleprof->overrideanimset_s = "";
						extern bool g_bNowPopulateWithCorrectAnimSet;
						g_bNowPopulateWithCorrectAnimSet = true;
					}
				//}
			}
			if (iAnimationSetMentioned > 0)
			{
				extern void animsystem_animationsetproperty (int, bool, entityeleproftype*, int, int);
				animsystem_animationsetproperty(t.entityprofile[entid].characterbasetype, readonly, edit_grideleprof, iAnimationSetMentioned, elementID);
			}
			if (t.entityprofile[entid].ischaracter == 1)
			{
				extern void animsystem_dropcollectablesetproperty(bool, entityeleproftype*);
				animsystem_dropcollectablesetproperty(readonly, edit_grideleprof);
			}
		}
	}
	if (readonly)
	{
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
}

void DisplayFPEGeneral(bool readonly, int entid, entityeleproftype *edit_grideleprof, int elementID)
{
	ImGui::Indent(10);

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}
	t.group = 0;

	bool bRubberbandActive = false;
	if (g.entityrubberbandlist.size() > 0) bRubberbandActive = true;
	bool bAllGotPhysics = false;

	// Character allegiance.
	if (t.entityprofile[entid].ischaracter)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 6.0f));
		ImGui::Text("Allegiance");
		ImGui::SameLine();
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
		ImGui::PushItemWidth(-10);

		if (g.entityrubberbandlist.size() == 0)
		{
			const char* items_combo[] = { "Enemy", "Ally", "Neutral" };
			ImGui::Combo("##ShooteriCharAlliance", &edit_grideleprof->iCharAlliance, items_combo, IM_ARRAYSIZE(items_combo));
			if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Allegiance");
			ImGui::PopItemWidth();
		}
		else
		{
			const char* items_combo[] = { "(change all)", "Enemies", "Allies", "Neutral" };

			int new_selection = t.entityelement[g.entityrubberbandlist[0].e].eleprof.iCharAlliance;
			bool bGotSameSelection = true;
			//Check if all selection are the same.
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int e = g.entityrubberbandlist[i].e;
				if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
				{
					if (t.entityelement[e].eleprof.iCharAlliance != new_selection)
					{
						bGotSameSelection = false;
						break;
					}
				}
			}
			if (bGotSameSelection)
				new_selection++;
			else
				new_selection = 0;

			if (ImGui::Combo("##ShooteriCharAlliancem", &new_selection, items_combo, IM_ARRAYSIZE(items_combo)))
			{
				if (new_selection > 0)
				{
					new_selection--;
					for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
					{
						int e = g.entityrubberbandlist[i].e;
						if (e > 0 && t.entityprofile[t.entityelement[e].bankindex].ischaracter > 0)
						{
							t.entityelement[e].eleprof.iCharAlliance = new_selection;
						}
					}
				}
			}
			if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Set Character Allegiance");
		}
	}

	if (t.entityprofile[entid].ismarker == 0 || t.entityprofile[entid].islightmarker == 1)
	{
		if (g.gentitytogglingoff == 0)
		{
			int iShape = t.entityprofile[entid].collisionmode;
			if (edit_grideleprof->iOverrideCollisionMode != -1) iShape = edit_grideleprof->iOverrideCollisionMode;
			if (iShape == 9 || iShape == 10 )
			{
				// static only - hulls cannot be made dynamic at this time!
				const char* items[] = { "Static Hull" };
				int item_current = 0;
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text("Static mode");
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
				ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
				ImGui::PushItemWidth(-10);
				if (ImGui::Combo("##combostaticPhysics3", &item_current, items, IM_ARRAYSIZE(items)))
				{
					// nothing to choose
				}
				ImGui::PopItemWidth();
			}
			else
			{
				t.tokay = 1;
				if (ObjectExist(g.entitybankoffset + entid) == 1)
				{
					if (GetNumberOfFrames(g.entitybankoffset + entid) > 0)
					{
						t.tokay = 0;
					}
				}
				if (t.tokay == 1 || bRubberbandActive)
				{
					//Static , physics on , physics off.
					const char* items[] = { "Static", "Physics on", "Physics off" };
					const char* itemsAll[] = { "Change All To" , "Static", "Physics on", "Physics off" };
					const char** Selected = items;
					int iArraySize = 3;
					int item_current = 0;
					if (t.entityelement[elementID].staticflag == 1)
						item_current = 0;
					else if (edit_grideleprof->physics)
						item_current = 1;
					else
						item_current = 2;

					int iIndexCount = 0;
					bool bAllTheSame = true;
					if (bRubberbandActive)
					{
						//Check if all selected have the same settings.
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							int item_test = 0;
							if (t.entityelement[e].staticflag == 1)
								item_test = 0;
							else if (t.entityelement[e].eleprof.physics)
								item_test = 1;
							else
								item_test = 2;
							if (item_test != item_current)
							{
								bAllTheSame = false;
								iIndexCount = 1;
								Selected = itemsAll;
								iArraySize = 4;
								item_current = 0;
								break;
							}
						}
					}
					if (bAllTheSame && item_current == 1) bAllGotPhysics = true;

					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

					ImGui::Text("Static mode");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
					ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
					ImGui::PushItemWidth(-10);
					if (ImGui::Combo("##combostaticPhysics", &item_current, Selected, iArraySize))
					{
						//Change.
						if (iIndexCount == 1 && item_current == 0)
						{
							//Ignore change all.
						}
						else if (item_current == 0 + iIndexCount && t.tokay == 1) //Only non animated can get static.
						{
							t.entityelement[elementID].staticflag = 1;
							edit_grideleprof->physics = 1;
						}
						else if (item_current == 0 + iIndexCount && t.tokay == 0)
						{
							//Ignore Animated and Static.
						}
						else if (item_current == 1 + iIndexCount)
						{
							t.entityelement[elementID].staticflag = 0;
							edit_grideleprof->physics = 1;
						}
						else
						{
							//No physics
							t.entityelement[elementID].staticflag = 0;
							edit_grideleprof->physics = 0;
						}

						if (bRubberbandActive)
						{
							//Check if all selected have the same settings.
							for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
							{
								int e = g.entityrubberbandlist[i].e;
								int masterid = t.entityelement[e].bankindex;
								int ok = 1;
								if (ObjectExist(g.entitybankoffset + masterid) == 1)
								{
									if (GetNumberOfFrames(g.entitybankoffset + masterid) > 0)
									{
										ok = 0;
									}
								}
								if (iIndexCount == 1 && item_current == 0)
								{
									//Ignore change all.
								}
								else if (item_current == 0 + iIndexCount && ok == 1) //Only non animated can get static.
								{
									t.entityelement[e].staticflag = 1;
									t.entityelement[e].eleprof.physics = 1;
								}
								else if (item_current == 0 + iIndexCount && ok == 0)
								{
									//Ignore Animated and Static.
								}
								else if (item_current == 1 + iIndexCount)
								{
									t.entityelement[e].staticflag = 0;
									t.entityelement[e].eleprof.physics = 1;
								}
								else
								{
									//No physics
									t.entityelement[e].staticflag = 0;
									t.entityelement[e].eleprof.physics = 0;
								}

							}
						}
					}
					ImGui::PopItemWidth();
				}
				else
				{
					
					// Only display physics for characters in advanced mode.
					bool bDisplayPhysics = true;
					if (t.entityprofile[entid].ischaracter == 1)
						bDisplayPhysics = false;

					if (bDisplayPhysics)
					{
						//Animated Only physics on/off cant be static.
						const char* items[] = { "Physics on", "Physics off" };
						int item_current = 0;
						if (edit_grideleprof->physics)
							item_current = 0;
						else
							item_current = 1;

						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
						ImGui::Text("Physics");
						ImGui::SameLine();
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
						ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
						ImGui::PushItemWidth(-10);
						if (ImGui::Combo("##combostaticPhysics2", &item_current, items, IM_ARRAYSIZE(items)))
						{
							//Change.
							if (item_current == 0)
							{
								t.entityelement[elementID].staticflag = 0;
								edit_grideleprof->physics = 1;
							}
							else
							{
								//No physics
								t.entityelement[elementID].staticflag = 0;
								edit_grideleprof->physics = 0;
							}
						}
						ImGui::PopItemWidth();
					}
				}
			}
		}
	}

	if (t.tflagspawn == 1)
	{
		if (bRubberbandActive)
		{
			bool bAllTheSame = true;
			//Check if all selected have the same settings.
			for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
			{
				int e = g.entityrubberbandlist[i].e;
				if (t.entityelement[e].eleprof.spawnatstart != edit_grideleprof->spawnatstart)
				{
					bAllTheSame = false;
					break;
				}
			}
			if (bAllTheSame)
			{
				int spawnatstart = edit_grideleprof->spawnatstart;
				edit_grideleprof->spawnatstart = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->spawnatstart), "Show at start of level (Change All)", t.strarr_s[563].Get(), 0, readonly); //t.strarr_s[562].Get()
				if (spawnatstart != edit_grideleprof->spawnatstart)
				{
					for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
					{
						int e = g.entityrubberbandlist[i].e;
						t.entityelement[e].eleprof.spawnatstart = edit_grideleprof->spawnatstart;
					}
				}
			}
		}
		else
		{
			edit_grideleprof->spawnatstart = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->spawnatstart), "Show at start of level", t.strarr_s[563].Get(), 0, readonly); //t.strarr_s[562].Get()
		}
	}

#ifdef WICKEDENGINE
	if (g_bEnableAutoFlattenSystem && t.entityprofile[entid].autoflatten != 0 && !bRubberbandActive)
	{
		bool bOld = edit_grideleprof->bAutoFlatten;
		edit_grideleprof->bAutoFlatten = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->bAutoFlatten), "Auto Flatten", "Flattens the terrain under the object and clears any trees and grass", 0, readonly);
		if (bOld != edit_grideleprof->bAutoFlatten)
		{
			if (elementID > 0)
			{
				if (!edit_grideleprof->bAutoFlatten && edit_grideleprof->iFlattenID != -1)
				{
					//PE: Disabled remove any flatten.
					GGTerrain_RemoveFlatArea(edit_grideleprof->iFlattenID);
					t.entityelement[elementID].eleprof.iFlattenID = edit_grideleprof->iFlattenID = -1;
				}
				if (edit_grideleprof->bAutoFlatten)
				{
					if (edit_grideleprof->iFlattenID == -1)
						entity_autoFlattenWhenAdded(elementID);
					else
						entity_updateautoflatten(elementID);
					edit_grideleprof->iFlattenID = t.entityelement[elementID].eleprof.iFlattenID;
					g.projectmodified = 1;
				}
			}
		}
	}
#endif

	if (edit_grideleprof->physics == 1 && t.entityelement[elementID].staticflag == 0)
	{
		bool bDisplayPhysics = true;
		if (t.entityprofile[entid].ischaracter == 1)
			bDisplayPhysics = false;

		if (bDisplayPhysics)
		{
			//Affected by gravity
			if (bRubberbandActive)
			{
				if (bAllGotPhysics)
				{
					int iAffectedByGravity = edit_grideleprof->iAffectedByGravity;
					edit_grideleprof->iAffectedByGravity = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->iAffectedByGravity), "Affected by gravity (Change All)", "If set this object will be affected by gravity", 0, readonly); //t.strarr_s[562].Get()
					if (edit_grideleprof->iAffectedByGravity != iAffectedByGravity)
					{
						for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
						{
							int e = g.entityrubberbandlist[i].e;
							t.entityelement[e].eleprof.iAffectedByGravity = edit_grideleprof->iAffectedByGravity;
						}
					}
				}
			}
			else
				edit_grideleprof->iAffectedByGravity = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->iAffectedByGravity), "Affected by gravity", "If set this object will be affected by gravity", 0, readonly); //t.strarr_s[562].Get()
		}
	}

	// strength of an entity is standard
	#ifdef WICKEDENGINE
	if (t.entityprofile[entid].ischaracter == 0)
	{
		ImGui::TextCenter("Strength");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##StrengthSimpleInput", &edit_grideleprof->strength, 1, 500, "Sets the strength of the object");
		ImGui::PopItemWidth();
	}
	else
	{
		// Only for characters do we need these.
		ImGui::TextCenter("Health");
		ImGui::PushItemWidth(-10);
		ImGui::MaxSliderInputInt("##HealthSimpleInput", &edit_grideleprof->strength, 1, 500, "Sets the health of the character");
		ImGui::PopItemWidth();

		if (pref.iObjectEnableAdvanced)
		{
			ImGui::TextCenter("Speed");
			ImGui::PushItemWidth(-10);
			ImGui::MaxSliderInputInt("##AnimationSpeedSimpleInput", &edit_grideleprof->iMoveSpeed, 1, 500, "Sets the animation and/or move speed of the character");
			ImGui::PopItemWidth();

			ImGui::TextCenter("Turn Speed");
			ImGui::PushItemWidth(-10);
			ImGui::MaxSliderInputInt("##TurnSpeedSimpleInput", &edit_grideleprof->iTurnSpeed, 1, 500, "Sets the turn speed of the character");
			ImGui::PopItemWidth();
		}
		
		ImGui::TextCenter("View Angle");
		ImGui::PushItemWidth(-10);
		int iValue = edit_grideleprof->coneangle;
		ImGui::MaxSliderInputInt("##ViewAngleSimpleInput", &iValue, 1, 180, "Sets the viewing angle of the character");
		edit_grideleprof->coneangle = iValue;
		ImGui::PopItemWidth();
		ImGui::TextCenter("View Range");
		ImGui::PushItemWidth(-10);
		iValue = edit_grideleprof->conerange;
		ImGui::MaxSliderInputInt("##ViewRangeSimpleInput", &iValue, 100, 2000, "Sets the range at which the character can see");
		edit_grideleprof->conerange = iValue;
		ImGui::PopItemWidth();
	}

	if (!t.entityprofile[entid].ischaracter)
	{
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 15));
		ImGui::Text("Collision Shape");
		ImGui::SameLine();
		ImGui::Indent(100);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
		ImGui::PushItemWidth(-10);
		char* pCollisionShapes[10] = { "Box","Polygon","Sphere","Cylinder","Convex Hull","Character Collision","Tree Collision","No Collision","Hull Decomp","Collision Mesh" };
		char pSelectedCollision[64];

		ImGui::PushItemFlag(ImGuiItemFlags_Disabled, false);
		ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 1.0f);

		int iShape = t.entityprofile[entid].collisionmode;
		if (edit_grideleprof->iOverrideCollisionMode != -1)	iShape = edit_grideleprof->iOverrideCollisionMode;
		switch (iShape)
		{
		case 0:
			strcpy(pSelectedCollision, pCollisionShapes[0]);
			break;
		case 1:
			strcpy(pSelectedCollision, pCollisionShapes[1]);
			break;
		case 2:
			strcpy(pSelectedCollision, pCollisionShapes[2]);
			break;
		case 3:
			strcpy(pSelectedCollision, pCollisionShapes[3]);
			break;
		case 9:
			strcpy(pSelectedCollision, pCollisionShapes[4]);
			break;
		case 21:
			strcpy(pSelectedCollision, pCollisionShapes[5]);
			break;
		case 50:
			strcpy(pSelectedCollision, pCollisionShapes[6]);
			break;
		case 11:
			strcpy(pSelectedCollision, pCollisionShapes[7]);
			break;
		case 10:
			strcpy(pSelectedCollision, pCollisionShapes[8]);
			break;
		case 8:
			strcpy(pSelectedCollision, pCollisionShapes[9]);
			break;
		default:
			break;
		}
		if (ImGui::BeginCombo("##ImporterCollisionShape", &pSelectedCollision[0], ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge))
		{
			for (int i = 0; i < 10; i++)
			{
				// Don't display "Polygon" collision for dynamic objects.
				if (i == 1 && t.entityelement[elementID].staticflag == 0) continue;

				// get collision shape name
				char* pCollisionShapeName = pCollisionShapes[i];

				// assign correct item based on pSelectedCollision
				bool is_selected = false;
				if (strcmp(pSelectedCollision, pCollisionShapeName) == NULL)
				{
					is_selected = true;
				}
				if (ImGui::Selectable(pCollisionShapeName, is_selected))
				{
					strcpy(pSelectedCollision, pCollisionShapeName);
					int iCollisionSelection = -1;
					switch (i)
					{
						case 0: iCollisionSelection = 0; break;
						case 1: iCollisionSelection = 1; break;
						case 2: iCollisionSelection = 2; break;
						case 3: iCollisionSelection = 3; break;
						case 4: iCollisionSelection = 9; break;
						case 5: iCollisionSelection = 21; break;
						case 6: iCollisionSelection = 50; break;
						case 7: iCollisionSelection = 11; break;
						case 8: iCollisionSelection = 10; break;
						case 9: iCollisionSelection = 8; break;
					}
					edit_grideleprof->iOverrideCollisionMode = iCollisionSelection;
					if (iCollisionSelection == 8 || iCollisionSelection == 9 || iCollisionSelection == 10)
					{
						t.entityelement[elementID].staticflag = 1;
						edit_grideleprof->physics = 1;
					}
				}
				if (is_selected) ImGui::SetItemDefaultFocus();
			}
			ImGui::EndCombo();
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("Set the collision type the object will use for physics");
		ImGui::Indent(-100);
		ImGui::PopItemWidth();
		ImGui::PopItemFlag();
		ImGui::PopStyleVar();
	}
	ImGui::Indent(-10);
	#endif

	// Is Immobile a useful tick to have in general and especially for freezing character positions in place for specific animations to work
	ImGui::Indent(10);
	edit_grideleprof->isimmobile = imgui_setpropertylist2(t.group, t.controlindex, Str(edit_grideleprof->isimmobile), t.strarr_s[457].Get(), t.strarr_s[247].Get(), 0);
	ImGui::Indent(-10);

	// Character Has Weapon
	// moved to detection within LUA script via 'bShootingWeaponMentioned'
	if (ImGui::IsAnyItemFocused()) bImGuiGotFocus = true;

	// if not static, we may explode it
	if (t.entityelement[elementID].staticflag == 0)
	{
		ImGui::Indent(10);
		edit_grideleprof->explodable = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->explodable), "Explodable", "If set this object will explode when destroyed", 0, readonly);
		if (edit_grideleprof->explodable != 0)
		{
			ImGui::TextCenter("Explosion Damage");
			ImGui::MaxSliderInputInt("##ExplodeDamageSimpleInput", &edit_grideleprof->explodedamage, 0, 500, "Sets the damage dealt when this object explodes");
			ImGui::TextCenter("Explosion Height");
			ImGui::MaxSliderInputInt("##damagephysicsheight", &edit_grideleprof->explodeheight, 0, 100, "Set the optional height at which the explosion occurs above default object center");
		}
		ImGui::Indent(-10);
	}

	// Moved Always Active to general properties
	ImGui::Indent(10);
	bool btmp = edit_grideleprof->phyalways;
	ImGui::Checkbox("Always Active?", &btmp);
	edit_grideleprof->phyalways = btmp;
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("If set the object will always be active, no matter how far away the player might be");
	ImGui::Indent(-10);

	ImGui::Indent(10);
	bool bObjective = false;
	if (edit_grideleprof->isobjective != 0) bObjective = true;
	ImGui::Checkbox("Is Objective?", &bObjective);
	if (bObjective == true)
	{
		if (t.entityprofile[entid].ismarker == 3)
			edit_grideleprof->isobjective = 2;
		else
			edit_grideleprof->isobjective = 1;
	}
	else
	{
		edit_grideleprof->isobjective = 0;
	}
	if (ImGui::IsItemHovered()) ImGui::SetTooltip("If set the object will be an objective for the player");
	ImGui::Indent(-10);

	// Is Collectable general properties (if dynamic)
	if (t.entityelement[elementID].staticflag == 0)
	{
		ImGui::Indent(10);
		bool bCollectable = false;
		if (edit_grideleprof->iscollectable != 0) bCollectable = true;
		if (ImGui::Checkbox("Is Collectable?", &bCollectable))
		{
			if (bCollectable == true)
				edit_grideleprof->iscollectable = 1;
			else
				edit_grideleprof->iscollectable = 0;
		}
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("If set the object will be collectable by the player and added to the inventory");
		ImGui::Indent(-10);

		if (edit_grideleprof->iscollectable != 0)
		{
			ImGui::Indent(10);
			bool bCollectableResource = false;
			if (edit_grideleprof->iscollectable == 2) bCollectableResource = true;
			if (ImGui::Checkbox("Is Resource?", &bCollectableResource))
			{
				if (bCollectableResource == true)
					edit_grideleprof->iscollectable = 2;
				else
					edit_grideleprof->iscollectable = 1;
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("If set the collectable is a resource and can be merged with similar objects");
			ImGui::Indent(-10);
		}
	}
	else
	{
		ImGui::Indent(10);
		ImGui::Text("NOTE: Static objects are always immobile");
		ImGui::Text("and cannot be collected by the player");
		if (ImGui::IsItemHovered()) ImGui::SetTooltip("When the object is set to static, it cannot be set as a collectable or move in any way");
		ImGui::Indent(-10);
	}
}

void DisplayFPEAdvanced(bool readonly, int entid, entityeleproftype *edit_grideleprof, int elementID)
{
	int tflagtext = 0, tflagimage = 0; //PE: These is not used in VRTECH ?
	if (t.entityprofile[entid].ismarker == 3)
	{
		if (!t.entityprofile[entid].markerindex <= 1)
		{
			#ifdef VRTECH
			#else
			if (t.entityprofile[entid].markerindex == 2) tflagtext = 1;
			if (t.entityprofile[entid].markerindex == 3) tflagimage = 1;
			#endif
		}
	}

	if (!edit_grideleprof)
	{
		edit_grideleprof = &t.grideleprof;
	}

	int adv_flasgs = ImGuiTreeNodeFlags_DefaultOpen;
	if (g.vrqcontrolmode > 0)
	{
		//Simple version.
		adv_flasgs = ImGuiTreeNodeFlags_None;
	}

	bool bAdvencedOpen = true;
	if (bAdvencedOpen)
	{
		ImGui::Indent(10);

		t.group = 0;

		static int current_loaded_script = -1;
		static int current_selected_script = 0;
		static bool current_loaded_script_has_dlua = false;
		int speech_entries = 0;

		t.group = 0;
		if (t.tflagchar == 0 && t.tflagvis == 1 && t.tflagsimpler == 0)
		{
			//if (ImGui::StyleCollapsingHeader(t.strarr_s[412].Get(), ImGuiTreeNodeFlags_DefaultOpen))
			ImGui::TextCenter(t.strarr_s[412].Get());
			{
				// 101016 - Additional General Parameters
				edit_grideleprof->isocluder = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isocluder), "Occluder", "Set to YES makes this object an occluder", 0, readonly);
				edit_grideleprof->isocludee = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isocludee), "Occludee", "Set to YES makes this object an occludee", 0, readonly);
			}

			// these will be back when EBE needs doors and windows
			//setpropertystring2(t.group,Str(t.grideleprof.parententityindex),"Parent Index","Selects another entity element to be a parent") ; ++t.controlindex;
			//setpropertystring2(t.group,Str(t.grideleprof.parentlimbindex),"Parent Limb","Specifies the limb index of the parent to connect with") ; ++t.controlindex;
		}

		t.group = 1;
		//if (ImGui::StyleCollapsingHeader(t.strarr_s[415].Get(), ImGuiTreeNodeFlags_DefaultOpen))
		//if (t.entityprofile[entid].lives == 0)
		ImGui::TextCenter(t.strarr_s[415].Get());
		{
			//  Basic AI
			if (t.tflagai == 1)
			{
				// can redirect to better folders if in g.quickparentalcontrolmode
				LPSTR pAIRoot = "scriptbank\\";
				if (g.quickparentalcontrolmode == 2)
				{
					if (t.entityprofile[entid].ismarker == 0)
					{
						if (t.tflagchar == 1)
							pAIRoot = "scriptbank\\people\\";
						else
							pAIRoot = "scriptbank\\objects\\";
					}
					else
					{
						pAIRoot = "scriptbank\\markers\\";
					}
				}
				cstr tmpvalue;
				tmpvalue = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->aimain_s.Get(), t.strarr_s[417].Get(), t.strarr_s[207].Get(), pAIRoot,readonly);
				if (edit_grideleprof->aimain_s != tmpvalue)
				{
					edit_grideleprof->aimain_s = tmpvalue;
					current_loaded_script = -1;
				}
			}
			
			// Has Weapon
			if (t.tflaghasweapon == 1 && t.playercontrol.thirdperson.enabled == 0 && g.quickparentalcontrolmode != 2 )//&& edit_grideleprof->lives == 0)
			{
				edit_grideleprof->hasweapon_s = imgui_setpropertylist2c_v2(t.group, t.controlindex, edit_grideleprof->hasweapon_s.Get(), t.strarr_s[419].Get(), t.strarr_s[209].Get(), 1,readonly, true, true, true, 0);
			}

			//  Is Weapon (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre)
			if (t.tflagweap == 1 && g.fpgcgenre == 1)
			{
				edit_grideleprof->damage = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->damage), t.strarr_s[420].Get(), t.strarr_s[210].Get(), readonly));
				edit_grideleprof->accuracy = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->accuracy), t.strarr_s[421].Get(), "Increases the inaccuracy of conical distribution by 1/100th of t.a degree", readonly));
				if (edit_grideleprof->weaponisammo == 0)
				{
					edit_grideleprof->reloadqty = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->reloadqty), t.strarr_s[422].Get(), t.strarr_s[212].Get(),readonly));
					edit_grideleprof->fireiterations = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->fireiterations), t.strarr_s[423].Get(), t.strarr_s[213].Get(),readonly));
					edit_grideleprof->range = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->range), "Range", "Maximum range of bullet travel",readonly));
					edit_grideleprof->dropoff = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->dropoff), "Dropoff", "Amount in inches of vertical dropoff per 100 feet of bullet travel",readonly));
					edit_grideleprof->clipcapacity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->clipcapacity), "Clip Capacity", "The total maximum number of clips the player can carry for this weapon", readonly));
					//int weaponpropres1;
					//int weaponpropres2;
				}
				else
				{
					edit_grideleprof->lifespan = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->lifespan), t.strarr_s[424].Get(), t.strarr_s[214].Get(),readonly));
					edit_grideleprof->throwspeed = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->throwspeed), t.strarr_s[425].Get(), t.strarr_s[215].Get(),readonly));
					edit_grideleprof->throwangle = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->throwangle), t.strarr_s[426].Get(), t.strarr_s[216].Get(),readonly));
					edit_grideleprof->bounceqty = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->bounceqty), t.strarr_s[427].Get(), t.strarr_s[217].Get(),readonly));
					edit_grideleprof->explodeonhit = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->explodeonhit), t.strarr_s[428].Get(), t.strarr_s[218].Get(), 0,readonly);
				}
				if (t.tflagsimpler == 0)
				{
					edit_grideleprof->usespotlighting = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->usespotlighting), "Spot Lighting", "Set whether emits dynamic spot lighting", 0,readonly);
				}
			}

			//  Is Character
			if (t.tflagchar == 1)
			{
				if (t.tflagsimpler == 0)
				{
					// special check to avoid offering can take weapon if no HUD.X
					t.tfile_s = cstr("gamecore\\guns\\") + edit_grideleprof->hasweapon_s + cstr("\\HUD.X");
					if (FileExist(t.tfile_s.Get()) == 1)
					{
						edit_grideleprof->cantakeweapon = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->cantakeweapon), t.strarr_s[429].Get(), t.strarr_s[219].Get(), 0,readonly);
						//Take Weapon's Ammo
						cstr fieldname = t.strarr_s[430];
						if (fieldname == "Take Weapon's Ammo") fieldname = "Take Weapon Ammo"; //Need to be shorter.
						edit_grideleprof->quantity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->quantity), fieldname.Get(), t.strarr_s[220].Get(),readonly));
					}
					edit_grideleprof->rateoffire = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->rateoffire), t.strarr_s[431].Get(), t.strarr_s[221].Get(),readonly));
				}
			}
			if (t.tflagquantity == 1 && g.quickparentalcontrolmode != 2 )//&& edit_grideleprof->lives == 0)
			{
				edit_grideleprof->quantity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->quantity), t.strarr_s[432].Get(), t.strarr_s[222].Get(),readonly));
			}

			//  AI Extra
			if (t.tflagvis == 1 && t.tflagai == 1)
			{
				if (t.tflagchar == 1)
				{
					edit_grideleprof->coneangle = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->coneangle), t.strarr_s[434].Get(), t.strarr_s[224].Get(),readonly));
					edit_grideleprof->conerange = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->conerange), "View Range", "The range within which the AI may see the player. Zero triggers the characters default range.",readonly));
					edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get(),readonly);
					edit_grideleprof->hasweapon_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->hasweapon_s.Get(), "Has Weapon", "The weapon assigned to this object", readonly);
					if (g.quickparentalcontrolmode != 2)
						edit_grideleprof->isviolent = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isviolent), "Blood Effects", "Sets whether blood and screams should be used", 0,readonly);
					if (t.tflagsimpler == 0)
					{
						edit_grideleprof->colondeath = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->colondeath), "End Collision", "Set to NO switches off collision when die", 0,readonly);
					}
				}
				else
				{
					if (t.tflagweap == 0 && t.tflagammo == 0)
					{
						//t.propfield[t.group] = t.controlindex;
						//++t.group; startgroup(t.strarr_s[435].Get()); t.controlindex = 0;
						edit_grideleprof->usekey_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get(),readonly);
						if (t.tflagsimpler != 0 & t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 1)
						{
							// only one level - no winzone chain option
						}
						else
						{
							edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[437].Get(), t.strarr_s[226].Get(),readonly);
						}
					}
				}
			}
			if (t.tflagifused == 1)
			{
				if (t.tflagusekey == 1)
				{
					edit_grideleprof->usekey_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->usekey_s.Get(), t.strarr_s[436].Get(), t.strarr_s[225].Get(),readonly);
				}
				if (t.tflagsimpler != 0 & t.entityprofile[entid].ismarker == 3 && t.entityprofile[entid].trigger.stylecolor == 1)
				{
					// only one level - no winzone chain option
				}
				else
				{
					edit_grideleprof->ifused_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->ifused_s.Get(), t.strarr_s[438].Get(), t.strarr_s[227].Get(),readonly);
				}
			}

		}

		if (t.tflagspawn == 1)
		{
			t.group = 1;
			//if (ImGui::StyleCollapsingHeader(t.strarr_s[439].Get(), ImGuiTreeNodeFlags_DefaultOpen)) 
			ImGui::TextCenter(t.strarr_s[439].Get());
			{
				edit_grideleprof->spawnatstart = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->spawnatstart), t.strarr_s[562].Get(), t.strarr_s[563].Get(), 0,readonly);
			}
		}


		//  Statistics
		if ((t.tflagvis == 1 || t.tflagobjective == 1 || t.tflaglives == 1 || t.tflagstats == 1) && t.tflagweap == 0 && t.tflagammo == 0)
		{
			t.group = 1;
			ImGui::TextCenter(t.strarr_s[451].Get());
			{
				if (t.tflaglives == 1)
				{
					// see if this level has any checkpoints to stave off lives logic
					bool bUsingCheckpoint = false;
					for ( int e = 1; e <= g.entityelementlist; e++)
					{
						int entid = t.entityelement[e].bankindex;
						if (t.entityprofile[entid].ismarker == 6)
						{
							bUsingCheckpoint = true;
							break;
						}
					}
					if (bUsingCheckpoint==true)
					{
						ImGui::TextCenter("Lives");
						ImGui::TextCenter("NOTE: Checkpoint detected, infinite retries");
						edit_grideleprof->lives = 0;
					}
					else
					{
						edit_grideleprof->lives = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->lives), t.strarr_s[452].Get(), "Specifies how many lives the player starts with. Enter zero for infinite lives.", readonly));
					}
				}
				if (t.tflagvis == 1 || t.tflagstats == 1)
				{
					if (t.tflaglives == 1)
					{
						edit_grideleprof->strength = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->strength), t.strarr_s[453].Get(), t.strarr_s[243].Get(),readonly));
					}
					else
					{
						if (t.tflagnotionofhealth == 1)
						{
							edit_grideleprof->strength = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->strength), t.strarr_s[454].Get(), t.strarr_s[244].Get(),readonly));
						}
					}
					if (t.tflagplayersettings == 1)
					{
						if (g.quickparentalcontrolmode != 2)
						{
							edit_grideleprof->isviolent = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isviolent), "Blood Effects", "Sets whether blood and screams should be used", 0,readonly);
						}
						if (t.tflagnotionofhealth == 1 )//&& edit_grideleprof->lives == 0)
						{
							t.playercontrol.regenrate = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.regenrate), "Regeneration Rate", "Sets the increase value at which the players health will restore",readonly));
							t.playercontrol.regenspeed = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.regenspeed), "Regeneration Speed", "Sets the speed in milliseconds at which the players health will regenerate",readonly));
							t.playercontrol.regendelay = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.regendelay), "Regeneration Delay", "Sets the delay in milliseconds after last damage hit before health starts regenerating",readonly));
						}
						edit_grideleprof->usespotlighting = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->usespotlighting), "Flashlight Disabled", "Sets whether the flashlight is disabled for the player", 0, readonly);
					}

					edit_grideleprof->speed = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->speed), t.strarr_s[455].Get(), t.strarr_s[245].Get(),readonly));
					if (t.playercontrol.thirdperson.enabled == 1)
					{
						t.tanimspeed_f = t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed;
					}
					else
					{
						t.tanimspeed_f = edit_grideleprof->animspeed;
					}
					t.tanimspeed_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.tanimspeed_f), "Anim Speed", "Sets the default speed of any animation associated with this entity",readonly));

					if (t.playercontrol.thirdperson.enabled == 1)
					{
						t.entityelement[t.playercontrol.thirdperson.charactere].eleprof.animspeed = t.tanimspeed_f;
					}
					else
					{
						edit_grideleprof->animspeed = t.tanimspeed_f;
					}
				}
				if (t.tflaghurtfall == 1) 
				{
					edit_grideleprof->hurtfall = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->hurtfall), t.strarr_s[456].Get(), t.strarr_s[246].Get(),readonly));
				}
				if (t.tflagplayersettings == 1)
				{
					t.playercontrol.jumpmax_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.jumpmax_f), "Jump Speed", "Sets the jump speed of the player which controls overall jump height",readonly));
					t.playercontrol.gravity_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.gravity_f), "Gravity", "Sets the modified force percentage of the players own gravity",readonly));
					t.playercontrol.fallspeed_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.fallspeed_f), "Fall Speed", "Sets the maximum speed percentage at which the player will fall",readonly));
					t.playercontrol.fFallDamageMultiplier = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.fFallDamageMultiplier), "Fall Damage Multiplier", "Modifies the damage dealt to the player when landing from a fall", readonly));
					t.playercontrol.climbangle_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.climbangle_f), "Climb Angle", "Sets the maximum angle permitted for the player to ascend a slope",readonly));
					if (t.playercontrol.thirdperson.enabled == 0)
					{
						t.playercontrol.wobblespeed_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.wobblespeed_f), "Wobble Speed", "Sets the rate of motion applied to the camera when moving",readonly));
						t.playercontrol.wobbleheight_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.wobbleheight_f * 100), "Wobble Height", "Sets the degree of motion applied to the camera when moving",readonly)) / 100.0f;
						t.playercontrol.footfallpace_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.footfallpace_f * 100), "Footfall Pace", "Sets the rate at which the footfall sound is played when moving",readonly)) / 100.0f;
					}
					t.playercontrol.accel_f = atof(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.accel_f * 100), "Acceleration", "Sets the acceleration curve used when t.moving from t.a stood position",readonly)) / 100.0f;
				}
				if (t.tflagmobile == 1)
				{
					edit_grideleprof->isimmobile = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->isimmobile), t.strarr_s[457].Get(), t.strarr_s[247].Get(), 0,readonly);
				}
				if (t.tflagmobile == 1)
				{
					if (t.tflagsimpler == 0)
					{
						edit_grideleprof->lodmodifier = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->lodmodifier), "LOD Modifier", "Modify when the LOD transition takes effect. The default value is 0, increase this to a percentage reduce the LOD effect.",readonly));
					}
				}
			}
		}

		// physics for FPE
		DisplayFPEPhysics(false, entid, edit_grideleprof);

		//  Ammo data (FPGC - 280809 - filtered fpgcgenre=1 is shooter genre
		if (g.fpgcgenre == 1)
		{
			if (t.tflagammo == 1 || t.tflagammoclip == 1)
			{
				//if (ImGui::StyleCollapsingHeader(t.strarr_s[459].Get(), ImGuiTreeNodeFlags_DefaultOpen)) 
				ImGui::TextCenter(t.strarr_s[459].Get());
				{
					edit_grideleprof->quantity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->quantity), t.strarr_s[460].Get(), t.strarr_s[249].Get(),readonly));
				}

			}
		}

		//  Light data
		if (t.tflaglight == 1)
		{
			bool bIsLightProbe = false;
			if (edit_grideleprof->light.fLightHasProbe >= 50.0f) bIsLightProbe = true;
			if (bIsLightProbe == false)
			{
				int iPrevValue = -1;
				bool bUpdateLight = false;
				float colors[5];

				ImGui::TextCenter(t.strarr_s[461].Get());
				iPrevValue = edit_grideleprof->light.range;
				edit_grideleprof->light.range = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->light.range), t.strarr_s[462].Get(), t.strarr_s[250].Get(), readonly)); //PE: 462=Light Range
				if (iPrevValue != edit_grideleprof->light.range)
					bUpdateLight = true;

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::Text(t.strarr_s[463].Get());
				ImGui::SameLine();
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3));
				ImGui::SetCursorPos(ImVec2(fPropertiesColoumWidth, ImGui::GetCursorPosY()));
				ImGui::PushItemWidth(-10);

				colors[3] = ((edit_grideleprof->light.color & 0xff000000) >> 24) / 255.0f;
				colors[0] = ((edit_grideleprof->light.color & 0x00ff0000) >> 16) / 255.0f;
				colors[1] = ((edit_grideleprof->light.color & 0x0000ff00) >> 8) / 255.0f;
				colors[2] = (edit_grideleprof->light.color & 0x000000ff) / 255.0f;
				if (ImGui::ColorEdit3("##LightColorSetupField", colors, 0))
				{
					colors[0] *= 255.0f;
					colors[1] *= 255.0f;
					colors[2] *= 255.0f;
					colors[3] *= 255.0f;
					edit_grideleprof->light.color = 0xff000000 + ((unsigned int)colors[0] << 16) + ((unsigned int)colors[1] << 8) + +((unsigned int)colors[2]);
					bUpdateLight = true;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", t.strarr_s[251].Get());
				ImGui::PopItemWidth();

				if (t.tflagsimpler == 0)
				{
					iPrevValue = edit_grideleprof->usespotlighting;
					edit_grideleprof->usespotlighting = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->usespotlighting), "Spot Lighting", "Change dynamic light to spot lighting", 0, readonly);
					if (edit_grideleprof->usespotlighting != iPrevValue)
						bUpdateLight = true;
				}
				if (bUpdateLight)
				{
					float lightx = t.entityelement[elementID].x;
					float lighty = t.entityelement[elementID].y;
					float lightz = t.entityelement[elementID].z;
					float lightax = t.entityelement[elementID].rx;
					float lightay = t.entityelement[elementID].ry;
					float lightaz = t.entityelement[elementID].rz;
					float lightrange = edit_grideleprof->light.range;
					float spotlightradius = edit_grideleprof->light.offsetup;
					float fLightHasProbe = edit_grideleprof->light.fLightHasProbe;
					int colr = colors[0];
					int colg = colors[1];
					int colb = colors[2];
					bool bCanShadow = edit_grideleprof->castshadow;
					int iLightIndex = edit_grideleprof->light.index;
					t.infinilight[iLightIndex].x = lightx;
					t.infinilight[iLightIndex].y = lighty;
					t.infinilight[iLightIndex].z = lightz;
					t.infinilight[iLightIndex].f_angle_x = lightax;
					t.infinilight[iLightIndex].f_angle_y = lightay;
					t.infinilight[iLightIndex].f_angle_z = lightaz;
					t.infinilight[iLightIndex].range = lightrange;
					t.infinilight[iLightIndex].spotlightradius = spotlightradius;
					t.infinilight[iLightIndex].fLightHasProbe = fLightHasProbe;
					t.infinilight[iLightIndex].colrgb.r = colr;
					t.infinilight[iLightIndex].colrgb.g = colg;
					t.infinilight[iLightIndex].colrgb.b = colb;
					t.infinilight[iLightIndex].bCanShadow = bCanShadow;
					uint64_t iWickedLightIndex = t.infinilight[iLightIndex].wickedlightindex;
					WickedCall_UpdateLight(iWickedLightIndex, lightx, lighty, lightz, lightax, lightay, lightaz, lightrange, spotlightradius, colr, colg, colb, bCanShadow);
				}
			}
		}

		//  Decal data
		if (t.tflagtdecal == 1)
		{
			t.propfield[t.group] = t.controlindex;

			//  FPGC - 300710 - could never change base decal, so comment out this property (entity denotes decal choice)
			//     `inc group ; startgroup(strarr$(464)) ; controlindex=0
			//     `setpropertyfile2(group,grideleprof.basedecal$,strarr$(465),strarr$(252),"gamecore\\decals\\") ; inc controlindex

			//  Decal Particle data
			if (t.tflagdecalparticle == 1)
			{
				//++t.group; startgroup("Decal Particle"); t.controlindex = 0;
				//if (ImGui::StyleCollapsingHeader("Decal Particle", ImGuiTreeNodeFlags_DefaultOpen)) 
				ImGui::TextCenter("Decal Particle");
				{
					edit_grideleprof->particleoverride = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->particleoverride), "Custom Settings", "Whether you wish to override default settings", 0,readonly);
					edit_grideleprof->particle.offsety = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.offsety), "OffsetY", "Vertical adjustment of start position",readonly));
					edit_grideleprof->particle.scale = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.scale), "Scale", "A value from 0 to 100, denoting size of particle",readonly));
					edit_grideleprof->particle.randomstartx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randomstartx), "Random Start X", "Random start area",readonly));
					edit_grideleprof->particle.randomstarty = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randomstarty), "Random Start Y", "Random start area",readonly));
					edit_grideleprof->particle.randomstartz = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randomstartz), "Random Start Z", "Random start area",readonly));
					edit_grideleprof->particle.linearmotionx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.linearmotionx), "Linear Motion X", "Constant motion direction",readonly));
					edit_grideleprof->particle.linearmotiony = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.linearmotiony), "Linear Motion Y", "Constant motion direction",readonly));
					edit_grideleprof->particle.linearmotionz = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.linearmotionz), "Linear Motion Z", "Constant motion direction",readonly));
					edit_grideleprof->particle.randommotionx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randommotionx), "Random Motion X", "Random motion direction",readonly));
					edit_grideleprof->particle.randommotiony = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randommotiony), "Random Motion Y", "Random motion direction",readonly));
					edit_grideleprof->particle.randommotionz = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.randommotionz), "Random Motion Z", "Random motion direction",readonly));
					edit_grideleprof->particle.mirrormode = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.mirrormode), "Mirror Mode", "Set to one to reverse the particle",readonly));
					edit_grideleprof->particle.camerazshift = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.camerazshift), "Camera Z Shift", "Shift t.particle towards camera",readonly));
					edit_grideleprof->particle.scaleonlyx = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.scaleonlyx), "Scale Only X", "Percentage X over Y scale",readonly));
					edit_grideleprof->particle.lifeincrement = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.lifeincrement), "Life Increment", "Control lifespan of particle",readonly));
					edit_grideleprof->particle.alphaintensity = atol(imgui_setpropertystring2_v2(t.group, Str(edit_grideleprof->particle.alphaintensity), "Alpha Intensity", "Control alpha percentage of particle",readonly));
					//  V118 - 060810 - knxrb - Decal animation setting (Added animation choice setting).
					edit_grideleprof->particle.animated = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(edit_grideleprof->particle.animated), "Animated Particle", "Sets whether the t.particle t.decal Texture is animated or static.", 0,readonly);
				}
			}
		}

		// New Particle Component
		if (t.tflagnewparticle == 1)
		{
			cstr newfile_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->newparticle.emittername.Get(), "Particle File", "Select a particle file (this is temporary and not the final design)", "particlesbank\\",readonly);
			if (strnicmp(newfile_s.Get() + strlen(newfile_s.Get()) - 4, ".arx", 4) == NULL) newfile_s = Left(newfile_s.Get(), Len(newfile_s.Get()) - 4);
			if (newfile_s != edit_grideleprof->newparticle.emittername)
			{
				edit_grideleprof->newparticle.emittername = newfile_s;
				if (edit_grideleprof->newparticle.emitterid != -1)
				{
					#ifdef WICKEDENGINE
					gpup_deleteEffect(edit_grideleprof->newparticle.emitterid);
					#endif
					edit_grideleprof->newparticle.emitterid = -1;
				}
				#ifdef WICKEDENGINE
				//PE: Activate instantly.
				if (elementID > 0)
				{
					t.entityelement[elementID].eleprof.newparticle.emittername = edit_grideleprof->newparticle.emittername;
					t.entityelement[elementID].eleprof.newparticle.emitterid = -1;
					entity_updateparticleemitter(elementID);
					edit_grideleprof->newparticle.emitterid = t.entityelement[elementID].eleprof.newparticle.emitterid;
				}
				#endif
			}
		}

		// Sound
		if (t.tflagsound == 1 || t.tflagsoundset == 1 || tflagtext == 1 || tflagimage == 1)
		{
			cstr group_text;
			if (tflagtext == 1 || tflagimage == 1)
			{
				if (tflagtext == 1) group_text = "Text";
				if (tflagimage == 1) group_text = "Image";
			}
			else
			{
				group_text = "Media";
			}

			if (speech_entries > 0)
			{
			}

			//if (ImGui::StyleCollapsingHeader(group_text.Get(), ImGuiTreeNodeFlags_DefaultOpen))
			ImGui::TextCenter(group_text.Get());
			{
				if (g.fpgcgenre == 1)
				{
					if (t.entityprofile[entid].ischaracter > 0)
					{
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Sound0", t.strarr_s[254].Get(), "audiobank\\",readonly);
					}
					else
					{
						if (g.vrqcontrolmode != 0)
						{
							if (t.tflagsound == 1 && t.tflagsoundset != 1)
							{
								//PE: changed from 469 to 467 , should be sound0
								edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
							}
						}
						else
						{
							if (t.tflagsound == 1 && t.tflagsoundset != 1)
							{
								edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly);
							}
						}
						if (t.tflagsoundset == 1)
						{
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
						}
						if (tflagtext == 1)
						{
							edit_grideleprof->soundset_s = imgui_setpropertystring2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Text to Appear", "Enter text to appear in-game",readonly);
						}
						if (tflagimage == 1)
						{
							#ifdef WICKEDENGINE
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "imagebank\\", readonly);
							#else
							edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), "Image File", "Select image to appear in-game", "scriptbank\\images\\imagesinzone\\",readonly);
							#endif
						}
					}

					if (t.tflagnosecond == 0)
					{
						if (t.tflagsound == 1 || t.tflagsoundset == 1)
						{
							//We got some missing translations.
							if (t.strarr_s[468] == "") t.strarr_s[468] = "Sound1";
							if (t.strarr_s[480] == "") t.strarr_s[480] = "Sound2";
							if (t.strarr_s[481] == "") t.strarr_s[481] = "Sound3";
							//if (t.strarr_s[482] == "") t.strarr_s[482] = "Sound4";
							edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
							edit_grideleprof->soundset2_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset2_s.Get(), t.strarr_s[480].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
							edit_grideleprof->soundset3_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset3_s.Get(), t.strarr_s[481].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly);
							ImGui::TextCenter("Sound4");
							ImGui::TextCenter("(repurposed)");
							edit_grideleprof->soundset5_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset5_s.Get(), "Sound5", t.strarr_s[254].Get(), "audiobank\\", readonly);
							edit_grideleprof->soundset6_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset6_s.Get(), "Sound6", t.strarr_s[254].Get(), "audiobank\\", readonly);
						}
					}
				}
				else
				{
					if (t.tflagsoundset == 1)
					{
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[469].Get(), t.strarr_s[255].Get(), "audiobank\\voices\\",readonly);
					}
					else
					{
						edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[253].Get(), "audiobank\\",readonly); ++t.controlindex;
					}
					edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), t.strarr_s[468].Get(), t.strarr_s[254].Get(), "audiobank\\",readonly); ++t.controlindex;
				}
			}
		}

		// Video
		if (t.tflagvideo == 1)
		{
			if (ImGui::StyleCollapsingHeader(t.strarr_s[597].Get(), ImGuiTreeNodeFlags_DefaultOpen)) {

				//edit_grideleprof->soundset_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset_s.Get(), t.strarr_s[467].Get(), t.strarr_s[599].Get(), "audiobank\\",readonly);
				edit_grideleprof->soundset1_s = imgui_setpropertyfile2_v2(t.group, edit_grideleprof->soundset1_s.Get(), "Video Slot", t.strarr_s[601].Get(), "videobank\\",readonly);
			}
		}

		//  Third person settings
		if (t.tflagplayersettings == 1 && t.playercontrol.thirdperson.enabled == 1)
		{
			if (ImGui::StyleCollapsingHeader("Third Person", ImGuiTreeNodeFlags_DefaultOpen)) {

				t.livegroupforthirdperson = t.group;
				t.playercontrol.thirdperson.cameralocked = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.cameralocked), "Camera Locked", "Fixes camera height and angle for third person view", 0,readonly);
				t.playercontrol.thirdperson.cameradistance = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.cameradistance), "Camera Distance", "Sets the distance of the third person camera",readonly));
				t.playercontrol.thirdperson.camerashoulder = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.camerashoulder), "Camera X Offset", "Sets the distance to shift the camera over shoulder",readonly));
				t.playercontrol.thirdperson.cameraheight = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.cameraheight), "Camera Y Offset", "Sets the vertical height of the third person camera. If more than twice the camera distance, camera collision disables",readonly));
				t.playercontrol.thirdperson.camerafocus = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.camerafocus), "Camera Focus", "Sets the camera X angle offset to align focus of the third person camera",readonly));
				t.playercontrol.thirdperson.cameraspeed = atol(imgui_setpropertystring2_v2(t.group, Str(t.playercontrol.thirdperson.cameraspeed), "Camera Speed", "Sets the retraction speed percentage of the third person camera",readonly));
				t.playercontrol.thirdperson.camerafollow = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.camerafollow), "Run Mode", "If set to yes, protagonist uses WASD t.movement mode", 0,readonly);
				t.playercontrol.thirdperson.camerareticle = imgui_setpropertylist2_v2(t.group, t.controlindex, Str(t.playercontrol.thirdperson.camerareticle), "Show Reticle", "Show the third person 'crosshair' reticle Dot ( ", 0,readonly);
			}
		}
		//Advenced open
		ImGui::Indent(-10);
	}
}

int imgui_setpropertylist2_v2(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype,bool readonly)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	int current_selection = atoi(ldata_s.Get());


	int listmax = 0;

	listmax = 0;
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		listmax = fillgloballistwithweapons();
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
	}
	if (listtype == 21)
	{
		listmax = fillgloballistwithcollectables();
	}

	const char* current_item = t.list_s[current_selection].Get();

	std::string uniquiField = ""; //lfields_s.Get()
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	ImGui::PushItemWidth(-10);
	if (listtype == 0)
	{
		//Checkbox.
		bool bTmp = false;
		if (current_selection == 1)
			bTmp = true;
		ImGui::Checkbox(lfields_s.Get(), &bTmp);
		if (bTmp)
			current_selection = 1;
		else
			current_selection = 0;
	}
	else
	{
		ImGui::TextCenter(lfields_s.Get());
		if (ImGui::BeginCombo(uniquiField.c_str(), current_item)) // The second parameter is the label previewed before opening the combo.
		{
			for (int n = 0; n <= listmax; n++)
			{
				bool is_selected = (current_item == t.list_s[n].Get()); // You can store your selection however you want, outside or inside your objects
				if (ImGui::Selectable(t.list_s[n].Get(), is_selected)) {
					current_selection = n;
					current_item = t.list_s[n].Get();
				}
				if (is_selected)
					ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
			}
			ImGui::EndCombo();
		}
	}
	if (ImGui::IsItemHovered())
	{
		if (listtype == 0)
		{
			//When using checkbox, change text.
			std::string newtext = ldesc_s.Get();
			replaceAll(newtext, "Set to YES", "If set");
			replaceAll(newtext, " to YES", "");
			ImGui::SetTooltip("%s", newtext.c_str());
		}
		else
			ImGui::SetTooltip("%s", ldesc_s.Get());
	}

	ImGui::PopItemWidth();
	return current_selection;
}

char* imgui_setpropertylist2c_v2(int group, int controlindex, char* data_s, char* field_s, char* desc_s, int listtype,bool readonly, bool forcharacters, bool bForShooting, bool bForMelee, int iSpecialValue)
{
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;
	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	int current_selection = atoi(ldata_s.Get());
	int listmax = 0;
	bool bIgnoreTitleText = false;
	bool bIncludeSlotNotUsedChoice = false;
	if (listtype == 61)
	{
		listtype = 1;
		bIgnoreTitleText = true;
		bIncludeSlotNotUsedChoice = true;
	}
	if (listtype == 0)
	{
		listmax = 1;
		t.list_s[0] = t.strarr_s[471];
		t.list_s[1] = t.strarr_s[470];
	}
	if (listtype == 1)
	{
		// newer system for MAX weapons - easier to read for users
		listmax = fillgloballistwithweaponsQuick(forcharacters, bForShooting, bForMelee, bIncludeSlotNotUsedChoice);
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1) 
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (bIgnoreTitleText == true)
			{
				if (strlen (thisLabel.Get()) == 0) thisLabel = "No Preference";
			}
			else
			{
				if (strlen (thisLabel.Get()) == 0) thisLabel = "No Weapon";
			}
			thisLabel = gun_names_tonormal(thisLabel.Get());
			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
		for (int n = 0; n <= listmax; n++)
		{
			if (stricmp(ldata_s.Get(), t.list_s[n].Get()) == NULL)
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 2)
	{
		listmax = fillgloballistwithCharAnimSetsQuick(iSpecialValue);
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1)
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (strlen (thisLabel.Get()) == 0) thisLabel = "Default Animation";
			if (strlen (thisLabel.Get()) == 1) thisLabel = "Original Animation";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations.dbo") == NULL) thisLabel = "Adult Male Pistol";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-rifle.dbo") == NULL) thisLabel = "Adult Male Rifle";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-pistol-lowered.dbo") == NULL) thisLabel = "Adult Male Pistol Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-rifle-lowered.dbo") == NULL) thisLabel = "Adult Male Rifle Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-shotgun-lowered.dbo") == NULL) thisLabel = "Adult Male Shotgun Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-melee.dbo") == NULL) thisLabel = "Adult Male Melee";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-axe.dbo") == NULL) thisLabel = "Adult Male Axe";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult male\\default animations-spear.dbo") == NULL) thisLabel = "Adult Male Spear";

			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations.dbo") == NULL) thisLabel = "Adult Female Pistol";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-rifle.dbo") == NULL) thisLabel = "Adult Female Rifle";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-pistol-lowered.dbo") == NULL) thisLabel = "Adult Female Pistol Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-rifle-lowered.dbo") == NULL) thisLabel = "Adult Female Rifle Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-shotgun-lowered.dbo") == NULL) thisLabel = "Adult Female Shotgun Lowered";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-melee.dbo") == NULL) thisLabel = "Adult Female Melee";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-axe.dbo") == NULL) thisLabel = "Adult Female Axe";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\adult female\\default animations-spear.dbo") == NULL) thisLabel = "Adult Female Spear";

			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\zombie male\\default animations.dbo") == NULL) thisLabel = "Zombie Male";
			if (stricmp (thisLabel.Get(), "charactercreatorplus\\parts\\zombie female\\default animations.dbo") == NULL) thisLabel = "Zombie Female";

			if (stricmp(thisLabel.Get(), "charactercreatorplus\\parts\\low poly\\default animations-melee.dbo") == NULL) thisLabel = "Low Poly Melee";
			if (stricmp(thisLabel.Get(), "charactercreatorplus\\parts\\low poly\\default animations-axe.dbo") == NULL) thisLabel = "Low Poly Axe";
			if (stricmp(thisLabel.Get(), "charactercreatorplus\\parts\\low poly\\default animations-spear.dbo") == NULL) thisLabel = "Low Poly Spear";

			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n])
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 3)
	{
		// new system for MAX weapons - interchangable hands
		listmax = fillgloballistwithHands();
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel = ldata_s;
			if (n != -1) thisLabel = t.list_s[n];
			if (strlen (thisLabel.Get()) == 0) thisLabel = "No Preference";
			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n])
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 11)
	{
		listmax = fillgloballistwithbehaviours();
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) 
			{
				current_selection = n;
				break;
			}
		}
	}
	if (listtype == 21)
	{
		listmax = fillgloballistwithcollectables();
		for (int n = 0; n <= listmax; n++)
		{
			if (ldata_s == t.list_s[n]) 
			{
				current_selection = n;
				break;
			}
		}
	}

	const char* current_item = t.list_s[current_selection].Get();

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (bIgnoreTitleText == false)
	{
		ImGui::TextCenter(lfields_s.Get());
		ImGui::PushItemWidth(-10);
	}
	if (ImGui::BeginCombo(uniquiField.c_str(), current_item))
	{
		for (int n = 0; n <= listmax; n++)
		{
			bool is_selected = (current_item == t.list_s[n].Get());
			if (ImGui::Selectable(t.list_s[n].Get(), is_selected))
			{
				current_selection = n;
				current_item = t.list_s[n].Get();
			}
			if (is_selected) ImGui::SetItemDefaultFocus();
		}
		ImGui::EndCombo();
	}
	if (bIgnoreTitleText == false)
	{
		ImGui::PopItemWidth();
	}

	#ifdef WICKEDENGINE
	// newer system for MAX weapons - easier to read for users
	if (listtype == 2)
	{
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1)
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			if (stricmp (thisLabel.Get(), "Default Animation") == NULL) thisLabel = "";
			if (stricmp (thisLabel.Get(), "Original Animation") == NULL) thisLabel = "-";
			if (stricmp (thisLabel.Get(), "Adult Male Pistol") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Rifle") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-rifle.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Pistol Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-pistol-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Rifle Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-rifle-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Shotgun Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-shotgun-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Melee") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-melee.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Axe") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-axe.dbo";
			if (stricmp (thisLabel.Get(), "Adult Male Spear") == NULL) thisLabel = "charactercreatorplus\\parts\\adult male\\default animations-spear.dbo";

			if (stricmp (thisLabel.Get(), "Adult Female Pistol") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Rifle") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-rifle.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Pistol Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-pistol-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Rifle Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-rifle-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Shotgun Lowered") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-shotgun-lowered.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Melee") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-melee.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Axe") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-axe.dbo";
			if (stricmp (thisLabel.Get(), "Adult Female Spear") == NULL) thisLabel = "charactercreatorplus\\parts\\adult female\\default animations-spear.dbo";

			if (stricmp (thisLabel.Get(), "Zombie Male") == NULL) thisLabel = "charactercreatorplus\\parts\\zombie male\\default animations.dbo";
			if (stricmp (thisLabel.Get(), "Zombie Female") == NULL) thisLabel = "charactercreatorplus\\parts\\zombie female\\default animations.dbo";

			if (stricmp(thisLabel.Get(), "Low Poly Melee") == NULL) thisLabel = "charactercreatorplus\\parts\\low poly\\default animations-melee.dbo";
			if (stricmp(thisLabel.Get(), "Low Poly Axe") == NULL) thisLabel = "charactercreatorplus\\parts\\low poly\\default animations-axe.dbo";
			if (stricmp(thisLabel.Get(), "Low Poly Spear") == NULL) thisLabel = "charactercreatorplus\\parts\\low poly\\default animations-spear.dbo";

			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
	}
	else
	{
		for (int n = -1; n <= listmax; n++)
		{
			cstr thisLabel;
			if (n == -1)
				thisLabel = ldata_s;
			else
				thisLabel = t.list_s[n];
			thisLabel = gun_names_tointernal(thisLabel.Get());

			if (n == -1)
				ldata_s = thisLabel;
			else
				t.list_s[n] = thisLabel;
		}
	}
	#else
		// older system for attachments
	#endif
	return t.list_s[current_selection].Get();
}

char* imgui_setpropertyfile2_v2(int group, char* data_s, char* field_s, char* desc_s, char* within_s,bool readonly, char *startsearch)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s, lwithin_s = within_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";
	if (cstr(within_s) == "" || !within_s)  lwithin_s = "";

	std::string uniquiField = "";
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") 
	{
		ImGui::TextCenter(lfields_s.Get());
	}
	strcpy(cTmpInput, ldata_s.Get());

	bool bSoundSet = false;
	if (pestrcasestr(lfields_s.Get(), "soundset") || lfields_s == "Type") 
	{
		bSoundSet = true;
	}
	if (bSoundSet && t.entityprofile[t.gridentity].ischaracter > 0) 
	{
		//Only displayt Male,FeMale selection.
		ImGui::PushItemWidth(-10);
		const char* items[] = { "Male", "Female" };
		int item_current_type_selection = 0; //Default Custom.
		if (pestrcasestr(cTmpInput, "Female")) 
		{
			item_current_type_selection = 1;
		}
		if (ImGui::Combo(uniquiField.c_str(), &item_current_type_selection, items, IM_ARRAYSIZE(items))) 
		{
			strcpy(cTmpInput, items[item_current_type_selection]);
		}
		if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
		ImGui::PopItemWidth();
		return &cTmpInput[0];
	}

	if(!readonly)
		ImGui::PushItemWidth(-10 - (ImGui::GetFontSize()*2.0)); //-6 padding.
	else
		ImGui::PushItemWidth(-10);

	ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT);
	if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImGui::PopItemWidth();

	if (!readonly)
	{
		ImGui::SameLine();

		uniquiField = "...";
		uniquiField = uniquiField + "##";
		uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

		ImGui::PushItemWidth(ImGui::GetFontSize()*2.0);

		bool bAudio = false;
		bool bImage = false;
		bool bVideo = false;
		bool bScript = false;
		bool bParticle = false;
		bool bAnimation = false;
		bool bUseNewSelectionWindow = false;

		#ifdef USENEWMEDIASELECTWINDOWS
		if (pestrcasestr(lwithin_s.Get(), "charactercreatorplus\\animations"))
		{
			bUseNewSelectionWindow = true;
			bAnimation = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "audiobank"))
		{
			bUseNewSelectionWindow = true;
			bAudio = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "\\imagesinzone"))
		{
			bUseNewSelectionWindow = true;
			bImage = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "imagebank"))
		{
			bUseNewSelectionWindow = true;
			bImage = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "videobank"))
		{
			bUseNewSelectionWindow = true;
			bVideo = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "scriptbank"))
		{
			bUseNewSelectionWindow = true;
			bScript = true;
		}
		if (pestrcasestr(lwithin_s.Get(), "particlesbank"))
		{
			bUseNewSelectionWindow = true;
			bParticle = true;
		}
		#endif

		if (bUseNewSelectionWindow)
		{
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)) || iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
			{
				cStr tOldDir = GetDir();
				if (iSelectedLibraryStingReturnID == window->GetID(uniquiField.c_str()))
				{
					char * cFileSelected = sSelectedLibrarySting.Get();
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0) 
					{
						std::string relative = cFileSelected;
						std::string fullpath = tOldDir.Get();

						std::transform(relative.begin(), relative.end(), relative.begin(), [](unsigned char c) { return ::tolower(c); });
						std::transform(fullpath.begin(), fullpath.end(), fullpath.begin(), [](unsigned char c) { return ::tolower(c); });

						fullpath += "\\";
						if (bSoundSet || pestrcasestr(lwithin_s.Get(), "scriptbank")) 
						{
							if (pestrcasestr(cFileSelected, ".lua"))
								fullpath += "scriptbank\\"; //lwithin_s.Get(); PE: This can change in parent mode 2
						}

						if (pestrcasestr(lwithin_s.Get(), "charactercreatorplus"))
						{
							// animations must pass back as DBOs (not FPEs)
							char pReplaceWithDBO[MAX_PATH];
							strcpy(pReplaceWithDBO, relative.c_str());
							pReplaceWithDBO[strlen(pReplaceWithDBO) - 4] = 0;
							strcat(pReplaceWithDBO, ".dbo");
							relative = pReplaceWithDBO;
						}

						replaceAll(relative, fullpath, "");
						strcpy(cTmpInput, relative.c_str());

						if (bSoundSet) 
						{
							char *found = (char *)pestrcasestr(cTmpInput, "audiobank\\voices\\");
							if (found) 
							{
								found += 17;
								strcpy(cTmpInput, found);
							}
							found = (char *)pestrcasestr(cTmpInput, "\\");
							if (found)
								found[0] = 0;
						}
					}
					iSelectedLibraryStingReturnID = -1; //disable.
					sSelectedLibrarySting = "";
				}
				else
				{
					bExternal_Entities_Window = true;
					iDisplayLibraryType = 0;
					iDisplayLibrarySubType = 0;
					if(bAudio)
						iDisplayLibraryType = 1;
					if (bImage)
						iDisplayLibraryType = 2;
					if(bVideo)
						iDisplayLibraryType = 3;
					if(bScript)
						iDisplayLibraryType = 4;
					if (bParticle)
						iDisplayLibraryType = 5;
					if (bAnimation)
					{
						// uses object library system but subtypes to choose animations only
						iDisplayLibraryType = 0;
						iDisplayLibrarySubType = 1;
					}
					
					if (startsearch)
					{
						sStartLibrarySearchString = startsearch;
					}
					iLibraryStingReturnToID = window->GetID(uniquiField.c_str());
					if (iDisplayLibraryType > 0)
					{
						if (strlen(cTmpInput) > 0)
						{
							sMakeDefaultSelecting = cTmpInput;
							bSelectLibraryViewAll = true;
						}
					}
				}
			}
		}
		else
		{
			if (ImGui::StyleButton(uniquiField.c_str(), ImVec2(ImGui::GetFontSize()*1.48, 0)))
			{
				//PE: filedialogs change dir so.
				cStr tOldDir = GetDir();
				char * cFileSelected;
				cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "All\0*.*\0", lwithin_s.Get(), NULL);

				SetDir(tOldDir.Get());

				if (cFileSelected && strlen(cFileSelected) > 0) 
				{
					std::string relative = cFileSelected;
					std::string fullpath = tOldDir.Get();

					std::transform(relative.begin(), relative.end(), relative.begin(), [](unsigned char c) { return ::tolower(c); });
					std::transform(fullpath.begin(), fullpath.end(), fullpath.begin(), [](unsigned char c) { return ::tolower(c); });

					fullpath += "\\";

					if (bSoundSet || pestrcasestr(lwithin_s.Get(), "scriptbank")) 
					{
						if (pestrcasestr(cFileSelected, ".lua"))
							fullpath += "scriptbank\\"; //lwithin_s.Get(); PE: This can change in parent mode 2
					}

					replaceAll(relative, fullpath, "");
					strcpy(cTmpInput, relative.c_str());

					if (bSoundSet) 
					{
						char *found = (char *)pestrcasestr(cTmpInput, "audiobank\\voices\\");
						if (found) 
						{
							found += 17;
							strcpy(cTmpInput, found);
						}
						found = (char *)pestrcasestr(cTmpInput, "\\");
						if (found)
							found[0] = 0;
					}
				}
			}
		}
		ImGui::PopItemWidth();
	}
	return &cTmpInput[0];
}

char * imgui_setpropertystring2_v2(int group, char* data_s, char* field_s, char* desc_s,bool readonly)
{
	char *cRet;
	cstr ldata_s = data_s, ldesc_s = desc_s, lfields_s = field_s;

	if (cstr(data_s) == "" || !data_s)  ldata_s = "";
	if (cstr(desc_s) == "" || !desc_s)  ldesc_s = "";
	if (cstr(field_s) == "" || !field_s)  lfields_s = "";

	std::string uniquiField = ""; //lfields_s.Get();
	uniquiField = uniquiField + "##" + lfields_s.Get();
	uniquiField = uniquiField + std::to_string(grideleprof_uniqui_id++);

	if (lfields_s != "") {
		ImGui::TextCenter(lfields_s.Get());
	}
	ImGui::PushItemWidth(-10);

	strcpy(cTmpInput, ldata_s.Get());
	int inputFlags = 0;
	if (readonly == true)
	{
		inputFlags != ImGuiInputTextFlags_ReadOnly;
		ImGui::Text(&cTmpInput[0]);
		if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	}
	else
	{
		if (ImGui::InputText(uniquiField.c_str(), &cTmpInput[0], MAXTEXTINPUT, inputFlags)) {
			bImGuiGotFocus = true;
		}
		if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	}
	if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

	ImVec2 cpos = ImGui::GetCursorPos();
	ImGui::SetItemAllowOverlap();
	ImGui::SetCursorPos(ImVec2(cpos.x + ImGui::GetContentRegionAvail().x - 33.0f, cpos.y - (ImGui::GetFontSize()*1.5) - 6.0));
	ImGui::ImgBtn(TOOL_PENCIL, ImVec2(16, 16), ImColor(255, 255, 255, 0));
	if (ImGui::IsItemHovered() && ldesc_s != "") ImGui::SetTooltip("%s", ldesc_s.Get());
	if (ImGui::IsItemFocused()) bImGuiGotFocus = true;
	ImGui::SetCursorPos(cpos);

	ImGui::PopItemWidth();

	return &cTmpInput[0];
}

int Get_t_gridentityobj(void)
{
	return t.gridentityobj;
}
int Get_t_gridentity(void)
{
	return t.gridentity;
}

void StartDragDropFromEntityID(int iEntID,int iGroup,int iCustomImage)
{
	if (iEntID < 0) return;
	int masterid = t.entityelement[iEntID].bankindex;
	if (masterid <= 0) return;
	if (masterid > t.entitybank_s.size()) return;
	if (t.entitybank_s[masterid].Len() == 0) return;

	cstr find = t.entitybank_s[masterid];
	cFolderItem *pSearchFolder = &MainEntityList;
	cFolderItem::sFolderFiles * foundfiles = NULL;
	pSearchFolder = pSearchFolder->m_pNext;
	cStr path = "";
	cStr path_remove = pSearchFolder->m_sFolderFullPath.Get();
	std::string sFpeName;
	int ipath_remove_len = path_remove.Len();
	bool bFound = false;
	while (pSearchFolder)
	{
		if (pSearchFolder->iType == 0)
		{
			cStr path = pSearchFolder->m_sFolderFullPath.Get();
			bool bDoubleEntityBank = false;
			char *finde = (char *)pestrcasestr(path.Get(), "\\entitybank"); //Support entitybank inside entitybank.
			if (finde)
			{
				finde += 11;
				finde = (char *)pestrcasestr(finde, "\\entitybank");
				if (finde) bDoubleEntityBank = true;
			}
			if (!bDoubleEntityBank && path.Right(11) == "\\entitybank")
			{
				ipath_remove_len = path.Len();
			}
			else
			{
				if (pSearchFolder->m_pFirstFile) {
					cFolderItem::sFolderFiles * searchfiles = pSearchFolder->m_pFirstFile->m_pNext;
					while (searchfiles) {
						foundfiles = searchfiles;
						path = pSearchFolder->m_sFolderFullPath.Get();
						char *final_name = path.Get();
						final_name += ipath_remove_len;
						if (*final_name == '\\')
							final_name++;

						std::string path_for_filename = final_name;
						sFpeName = path_for_filename.c_str();
						sFpeName = sFpeName + "\\" + foundfiles->m_sName.Get();
						if (stricmp(find.Get(), sFpeName.c_str()) == 0)
							bFound = true;
						if (bFound)
							break;
						searchfiles = searchfiles->m_pNext;
					}
				}
			}
			if (bFound)
				break;
		}
		pSearchFolder = pSearchFolder->m_pNext;
	}

	if (foundfiles)
	{
		//CheckTooltipObjectDelete();
		CloseDownEditorProperties();
		t.inputsys.constructselection = 0;

		foundfiles->m_dropptr = foundfiles;
		if(iGroup >= 0)
			foundfiles->iAnimationFrom = 100000+ iGroup; //Reuse var for selecting a special entity for drag drop.
		else
			foundfiles->iAnimationFrom = iEntID; //Reuse var for selecting a special entity for drag drop.
		foundfiles->m_sFolder = sFpeName.c_str();
		ImGui::SetDragDropPayload("DND_MODEL_DROP_TARGET", foundfiles, sizeof(void *));
		if (iCustomImage > 0)
		{
			float fRatio = (float) ImageHeight(iCustomImage)  / (float) ImageWidth(iCustomImage);
			float imagew = 200.0f;
			float imageh = imagew * fRatio;
			ImGui::ImgBtn(iCustomImage, ImVec2(imagew, imageh), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
		}
		else
		{
			ImGui::ImgBtn(t.entityprofile[masterid].iThumbnailSmall, ImVec2(media_icon_size_leftpanel, media_icon_size_leftpanel), drawCol_back, drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false);
		}
		//ImGui::Text("%s", myfiles->m_sName.Get());
		//ImGui::SetCursorPos(oldCursor);
		pDragDropFile = foundfiles;
		ImGui::EndDragDropSource();
		bReadyToDropEntity = false;
		iDragDropActive = 50;
		bDraggingActive = true;
		bDraggingActiveInitial = true;
		// LB: these can be uninitialised, but we need these filled so the plane can be under the cursor initially
		t.gridentityposx_f = t.inputsys.localx_f;
		t.gridentityposy_f = t.inputsys.localcurrentterrainheight_f;
		t.gridentityposz_f = t.inputsys.localy_f;
	}
}

ImVec4 GetRealSizeToGridEntity(int direction)
{
	//Object size from center, include rotation.
	ImVec4 size = { 0.0f,0.0f,0.0f,0.0f };
	if (t.gridentityobj > 0)
	{
		//PE: Only use pivot on non markers and not on ebe.
		if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
		{
			//Find lowest point in bounding box, and use this to adjust Y
			sObject* pObject = GetObjectData(t.gridentityobj);
			if (pObject)
			{
				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				AABB aabb;
				if (direction == 0)
				{
//					aabb._min.x = pObject->collision.vecMin.x + pObject->collision.vecMax.x;  //offset from pivot.
					aabb._min.x = (pObject->collision.vecMin.x - pObject->collision.vecMax.x) * 0.5;  //offset from center.
					aabb._min.y = pObject->collision.vecMin.y;
					aabb._min.z = 0.0f;
				}
				else if (direction == 1)
				{
					aabb._min.x = 0.0f;
					aabb._min.y = pObject->collision.vecMin.y;
//					aabb._min.z = pObject->collision.vecMin.z + pObject->collision.vecMax.z; //offset from pivot.
					aabb._min.z = (pObject->collision.vecMin.z - pObject->collision.vecMax.z) * 0.5; //offset from center.
				}
				else if (direction == 2)
				{
					aabb._min.x = fabs((pObject->collision.vecMin.x - pObject->collision.vecMax.x) * 0.5);  //offset from center.
					aabb._min.y = pObject->collision.vecMin.y;
					aabb._min.z = 0.0f;
				}
				else if (direction == 3)
				{
					aabb._min.x = 0.0f;
					aabb._min.y = pObject->collision.vecMin.y;
					aabb._min.z = fabs((pObject->collision.vecMin.z - pObject->collision.vecMax.z) * 0.5); //offset from center.
				}

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				
				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);

				size.x = aabb._min.x;
				size.y = aabb._min.y;
				size.z = aabb._min.z;
				size.w = 1.0;
			}
		}

	}
	return(size);
}

ImVec4 GetRealCenterToObject(int obj)
{
	ImVec4 realcenter = { 0.0f,0.0f,0.0f,0.0f };
	if (obj > 0)
	{
		//Find lowest point in bounding box, and use this to adjust Y
		sObject* pObject = GetObjectData(obj);
		if (pObject)
		{

			GGMATRIX matARotation;
			GGVECTOR3 box1;
			GGMATRIX matRotateX, matRotateY, matRotateZ;
			if (pObject->position.bFreeFlightRotation)
			{
				matARotation = pObject->position.matFreeFlightRotate;
			}
			else
			{
				//ZXY
				GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
				GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
				GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
				matARotation = matRotateX * matRotateY * matRotateZ;
			}
			if (pObject->position.bApplyPivot)
			{
				matARotation *= pObject->position.matPivot;
			}

			AABB aabb;
			aabb._min.x = pObject->collision.vecMin.x;
			aabb._min.y = pObject->collision.vecMin.y;
			aabb._min.z = pObject->collision.vecMin.z;
			aabb._max.x = pObject->collision.vecMax.x;
			aabb._max.y = pObject->collision.vecMax.y;
			aabb._max.z = pObject->collision.vecMax.z;

			box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
			box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

			aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
			aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
			aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
			aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
			aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
			aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

			realcenter.x = (aabb._min.x + aabb._max.x)*0.5;
			realcenter.y = (aabb._min.y + aabb._max.y)*0.5;
			realcenter.z = (aabb._min.z + aabb._max.z)*0.5;
			realcenter.w = 1.0;
		}
	}
	return(realcenter);
}

ImVec4 GetRealCenterToGridEntity(void)
{
	ImVec4 realcenter = { 0.0f,0.0f,0.0f,0.0f };
	if (t.gridentityobj > 0)
	{

		//PE: Only use pivot on non markers and not on ebe.
		if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
		{
			//Find lowest point in bounding box, and use this to adjust Y
			sObject* pObject = GetObjectData(t.gridentityobj);
			if (pObject)
			{

				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				AABB aabb;
				aabb._min.x = pObject->collision.vecMin.x;
				aabb._min.y = pObject->collision.vecMin.y;
				aabb._min.z = pObject->collision.vecMin.z;
				aabb._max.x = pObject->collision.vecMax.x;
				aabb._max.y = pObject->collision.vecMax.y;
				aabb._max.z = pObject->collision.vecMax.z;

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
				aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
				aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
				aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

				realcenter.x = (aabb._min.x + aabb._max.x)*0.5;
				realcenter.y = (aabb._min.y + aabb._max.y)*0.5;
				realcenter.z = (aabb._min.z + aabb._max.z)*0.5;
				realcenter.w = 1.0;
			}
		}

	}
	return(realcenter);
}

float GetLowestY(int obj)
{
	if (obj <= 0) return(0.0f);

	if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
	{
		//Find lowest point in bounding box, and use this to adjust Y
		sObject* pObject = GetObjectData(obj);
		if (pObject)
		{

			GGMATRIX matARotation;
			GGVECTOR3 box1;
			GGMATRIX matRotateX, matRotateY, matRotateZ;
			if (pObject->position.bFreeFlightRotation)
			{
				matARotation = pObject->position.matFreeFlightRotate;
			}
			else
			{
				//ZXY
				GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
				GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
				GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
				matARotation = matRotateX * matRotateY * matRotateZ;
			}
			if (pObject->position.bApplyPivot)
			{
				matARotation *= pObject->position.matPivot;
			}

			AABB aabb;
			aabb._min.x = pObject->collision.vecMin.x;
			aabb._min.y = pObject->collision.vecMin.y;
			aabb._min.z = pObject->collision.vecMin.z;
			aabb._max.x = pObject->collision.vecMax.x;
			aabb._max.y = pObject->collision.vecMax.y;
			aabb._max.z = pObject->collision.vecMax.z;

			box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
			box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
			GGVec3TransformCoord(&box1, &box1, &matARotation);
			aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

			aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
			aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
			aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
			aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
			aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
			aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

			float fLowestPoint = aabb._min.y;
			if (aabb._max.y < aabb._min.y)
				fLowestPoint = aabb._max.y;

			return(fLowestPoint);
		}
	}
	return(0.0f);
}

void ApplyPivotToGridEntity(void)
{
	/*LB: messes up smart move system and also introduces sometimes unwanted object shifting, allow user to choose position, do not autoate it (for now)
	int iRealObjectMoveMode = iObjectMoveMode;
	if (iObjectMoveModeDropSystem > 0) iRealObjectMoveMode = 0;
	if (bExtractFixPivot && t.gridentityobj > 0 && iRealObjectMoveMode == 2) // LB: only find surface can use this as Y needs constantly resetting to allow the +=
	{
		//PE: Only use pivot on non markers and not on ebe.
		if (t.entityprofile[t.gridentity].isebe == 0 && t.entityprofile[t.gridentity].ismarker == 0)
		{
			//Find lowest point in bounding box, and use this to adjust Y
			sObject* pObject = GetObjectData(t.gridentityobj);
			if (pObject)
			{
				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				AABB aabb;
				aabb._min.x = pObject->collision.vecMin.x;
				aabb._min.y = pObject->collision.vecMin.y;
				aabb._min.z = pObject->collision.vecMin.z;
				aabb._max.x = pObject->collision.vecMax.x;
				aabb._max.y = pObject->collision.vecMax.y;
				aabb._max.z = pObject->collision.vecMax.z;

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
				aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
				aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
				aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

				float fLowestPoint = aabb._min.y;
				if (aabb._max.y < aabb._min.y)
					fLowestPoint = aabb._max.y;

				if (fLowestPoint < 0)
					t.gridentityposy_f += fabs(fLowestPoint);
			}
		}
	}
	*/
}

bool bUseEditorOutlineSelection(void) { return pref.iEnableEditorOutlineSelection; }
float fGetHighlightThickness(void) { return pref.fHighLightThickness; }
int iGetMouseClickState(void) { return t.inputsys.mclick; }
int iGetgrideditselect(void) { return t.grideditselect; }

//#########################################
//#### Template for new docking window ####
//#########################################

void ProcessTemplateWindow(void)
{
	//Make sure to setup the docking settings search: DockBuilderDockWindow
	//To open window set bTemplate_Window = true;
	//Remember: MAXVERSION should be increased when you add a new window.

	bool bTemplate_Window = false; //This should be moved to the top of code.

	if (refresh_gui_docking == 0 && !bTemplate_Window)
	{
		//Make sure window is setup in docking space.
		ImGui::Begin("Template Window##MustBeUnique", &bTemplate_Window, iGenralWindowsFlags);
		ImGui::End();
	}

	if (!bTemplate_Window)
		return;

	int wflags = ImGuiTreeNodeFlags_DefaultOpen;

	ImGui::Begin("Template Window##MustBeUnique", &bTemplate_Window, iGenralWindowsFlags);

	if (ImGui::StyleCollapsingHeader("Help With Template", wflags)) {

		ImGui::Indent(10);
		ImGui::PushItemWidth(-10);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

		//All you gui stuff goes here.
		ImGui::TextCenter("Heading use TextCenter");

		//Float Slider Template.
		static float fFloatSliderTest = 1000.0f; //1000.0f would be center (50) in this sample.
		if (ImGui::MaxSliderInputFloat("##templatefloatinput", &fFloatSliderTest, 0.0, 2000.0, "All Sliders should use this code."))
		{
		}

		//Add a pencil to a gadget.
		//ImGuiWindow* window = ImGui::GetCurrentWindow(); //PE: Add a pencil to all color gadgets.
		//ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_PENCIL);
		//ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
		//if(lpTexture)
		//	window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));

		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
		ImGui::PopItemWidth();
		ImGui::Indent(-10);
	}


	if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
		//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
		ImGui::Text("");
		ImGui::Text("");
	}

	ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
	if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
	{
		bImGuiGotFocus = true; //Must set bImGuiGotFocus so if you type "w" in a imgui widget , editor dont move forward.
	}
	if (ImGui::IsAnyItemFocused()) {
		bImGuiGotFocus = true;
	}

	ImGui::End();
}

//#####

#ifdef LBBUGTRACKING
void GetDeviceID(LPSTR pKey)
{
	DWORD serial;
	GetVolumeInformationA("C:\\", NULL, 0, &serial, NULL, NULL, NULL, 0);
	unsigned int result[5];
	SHA1 sha;
	sha.Input((unsigned char*)&serial, 4);
	sha.Result(&(result[0]));
	sprintf(pKey, "%08X%08X%08X%08X%08X", result[0], result[1], result[2], result[3], result[4]);
}
void EncDec(uint8_t* pData, uint32_t length)
{
	if (length == 0) return;
	cstr sKey, sKey2;
	char pKey[1024];
	GetDeviceID(pKey);
	strcat(pKey, "N");
	strcat(pKey, "C");
	strcat(pKey, "Y");
	strcat(pKey, "f");
	strcat(pKey, "e");
	strcat(pKey, "3");
	strcat(pKey, "j");
	strcat(pKey, "n");
	strcat(pKey, "b");
	strcat(pKey, "J");
	sKey = pKey;
	uint8_t* pCipher = new uint8_t[SHA256::DIGEST_SIZE];
	uint32_t keyCount = 0;
	uint32_t currLength = 0;
	while (currLength < length)
	{
		sKey2 = sKey;
		char pNum[32];
		_itoa(keyCount, pNum, 10);
		sKey2 += pNum;
		memset(pCipher, 0, SHA256::DIGEST_SIZE);
		SHA256 ctx = SHA256();
		ctx.init();
		ctx.update((uint8_t*)sKey2.Get(), sKey2.Len());
		ctx.final(pCipher);
		for (int i = 0; i < SHA256::DIGEST_SIZE; i++)
		{
			pData[currLength] ^= pCipher[i];
			currLength++;
			if (currLength >= length) break;
		}
		keyCount++;
	}
}
#endif

struct BugReport
{
	//time_t CreateTime;
	char cCreatedAt[32];
	char cTitle[256];
	char cDescription[4096];
	char cReply[4096];
	int iStatus;
};
static std::vector<BugReport *> sBugList;
bool g_bBugTrackerConnected = false;
int g_iUserID = 0;
cstr g_sHashToken = "";

int CLB(ImGuiTextEditCallbackData* data)
{
	float textWidth = ImGui::CalcTextSize(data->Buf).x;
	float controlWidth = *(float*)data->UserData;
	if (textWidth > controlWidth)
	{
		int iCurrPos = data->CursorPos;
		while (data->Buf[iCurrPos] != ' ' && iCurrPos > 0) iCurrPos--;
		if (iCurrPos > 0 && data->Buf[iCurrPos] == ' ' && data->Buf[iCurrPos+1] != '\n') data->InsertChars(iCurrPos+1, "\n");
		data->BufDirty = true;
	}
	return data->BufTextLen;
}

void ProcessBugReporting(void)
{
	static char cBugTitle[256];
	static char cBugDescription[4096];
	static char cBugDescriptionCopy[4096];
	static bool bIncludeScreenShot = true;
	static bool bIncludesystemSpecs = true;
	static int iReportBugProcessing = 0;

	if (refresh_gui_docking == 0 && !bBug_Reporting_Window)
	{
		//Make sure window is setup in docking space.
		ImGui::Begin("Bug Reporting System##BugReportingWindow", &bBug_Reporting_Window, iGenralWindowsFlags);
		ImGui::End();
	}

	static bool bLastBugStatus = false;
	if (bLastBugStatus != bBug_Reporting_Window || bBug_RefreshBugList ==true)
	{
		//Window just open , reset variables.
		strcpy(cBugTitle, "");
		strcpy(cBugDescription, "");
		//bIncludeScreenShot = true; // keep these preferences from the user
		//bIncludesystemSpecs = true;
		bLastBugStatus = bBug_Reporting_Window;
		if (sBugList.size() == 0 || bBug_RefreshBugList==true)
		{
			GetBugReport();
		}
		iReportBugProcessing = 0;
		bBug_RefreshBugList = false;
	}

	if (!bBug_Reporting_Window)
		return;

	int wflags = ImGuiTreeNodeFlags_DefaultOpen;

	if (ImGui::Begin("Bug Reporting System##BugReportingWindow", &bBug_Reporting_Window, iGenralWindowsFlags) == true)
	{
		if (g_bBugTrackerConnected == false)
		{
			if (ImGui::StyleCollapsingHeader("Help With Bugs", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("This Bug Tracker System enables you to submit any bugs you find, creates a record of the bugs you have raised and shows you updates when the bugs you have identified are dealt with.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("Click the button below to link your account at the TheGameCreators with your GitHub account.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Link Your GitHub Account", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://www.thegamecreators.com/github/link", "", "", 0);
				}
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("If you do not have a GitHub account you can register for free by clicking the button below.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Create GitHub Account", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("http://github.com/", "", "", 0);
				}
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("If you do not have an account with TheGameCreators you can register for free by clicking the button below.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Create Account", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://www.thegamecreators.com/", "", "", 0);
				}
			}
		}
		else
		{
			if (ImGui::StyleCollapsingHeader("Help With Bugs", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				ImGui::TextWrapped("If you have found a problem with any functionailty found in the software, you can report it to the development team.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("First, ensure this is not a feature request, which you can submit by clicking this button.");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				if (ImGui::StyleButton("Feature Requests", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://github.com/TheGameCreators/GameGuruRepo/issues/new", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click here to visit our issues board to make a feature request");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::TextWrapped("Also, ensure it is not a general request for help and advice, which you can get by visiting the forum here:");
				if (ImGui::StyleButton("GameGuru Forums", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					ExecuteFile("https://forum.game-guru.com/board/1", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Click here to visit the GameGuru forums");
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}

			if (ImGui::StyleCollapsingHeader("Report A Bug", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				ImGui::TextCenter("Your Bug Title");
				ImGui::InputText("##NameBugReport", &cBugTitle[0], 256);
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Please give your bug a name");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				//Add pencil
				ImGuiWindow* window = ImGui::GetCurrentWindow(); //PE: Add a pencil to all color gadgets.
				ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_PENCIL);
				ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize()*1.5f) - 3.0f };
				if (lpTexture)
					window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));

				ImGui::TextCenter("Your Bug Description");

				float TextHeight = ImGui::GetFontSize()*7.5f;
				float w = ImGui::CalcItemWidth();
				ImGui::InputTextMultiline("##cBugDescription", &cBugDescription[0], 4096, ImVec2(0, TextHeight), ImGuiInputTextFlags_CallbackAlways, CLB, &(w));
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Please enter a detailed step by step description of how to reproduce this bug");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;

				//Add pencil
				window = ImGui::GetCurrentWindow(); //PE: Add a pencil to all color gadgets.
				lpTexture = GetImagePointerView(TOOL_PENCIL);
				vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (TextHeight)-3.0f };
				if (lpTexture)
					window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));

				//Need additional Server Side Code - GitHub will shortly allow attachments it is said
				//ImGui::Checkbox("Include current screenshot",&bIncludeScreenShot);
				//if (ImGui::IsItemHovered()) ImGui::SetTooltip("Tick if you wish to include a screenshot with your bug");

				ImGui::Checkbox("Include my system specs", &bIncludesystemSpecs);
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Tick to include my own system specifications with the bug report");

				if (ImGui::StyleButton("Submit Bug Report", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Start processing bug report.
					iReportBugProcessing = 1;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("When you click submit, your bug will be reported to TGC");

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}
			if (ImGui::StyleCollapsingHeader("Track My Bugs", wflags))
			{
				ImGui::Indent(10);
				ImGui::PushItemWidth(-10);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

				// drop down filter modes
				const char* filtermodes[] = { "Your Outstanding Issues", "Your Completed Issues", "All Issues" };
				static int filter_current_type_selection = 0;
				if (ImGui::Combo("##combostaticIssuesFilter", &filter_current_type_selection, filtermodes, IM_ARRAYSIZE(filtermodes)))
				{
					// set filter mode = filter_current_type_selection
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Use filter dropdown to choose which issues to see");

				float ListBoxHeight = ImGui::GetFontSize()*16.0f;
				float fAvailableX = ImGui::GetContentRegionAvailWidth();

				/*
				if (ImGui::ListBoxHeader("##BugListBox", ImVec2(0, ListBoxHeight)) == true)
				{
					int i = 0;
					for (auto item : sBugList)
					{
						bool bIsSelected = false;
						ImGui::PushID(i);
						if (ImGui::Selectable(item->cTitle, bIsSelected))
						{
							break;
						}
						ImGui::PopID();
						i++;
					}
					ImGui::ListBoxFooter();
				}
				*/
				if (ImGui::ListBoxHeader("##BugListBox", ImVec2(0, ListBoxHeight)) == true)
				{
					ImGui::Columns(3, "buglistcolumns3", false);  //false no border
					ImGui::SetColumnOffset(0, 0.0f);
					ImGui::SetColumnOffset(1, ImGui::GetFontSize()*4.0f);
					ImGui::SetColumnOffset(2, fAvailableX - (20.0f + 18.0f + ImGui::GetCurrentWindow()->ScrollbarSizes.x));
					ImGui::Indent(-2);
					for (auto item : sBugList)
					{
						if (item)
						{
							int iIcon = MEDIA_REFRESH; //Unknown
							if (item->iStatus == 1)
								iIcon = MEDIA_RECORD;
							if (item->iStatus == 2)
								iIcon = MEDIA_RECORDPROCESSING;
							if (item->iStatus == 3)
								iIcon = MEDIA_RECORDING;

							// operate filter
							if (filter_current_type_selection == 0 && item->iStatus == 3) continue;
							if (filter_current_type_selection == 1 && item->iStatus != 3) continue;

							char buffer[80];
							strcpy(buffer, item->cCreatedAt);

							ImGui::Text(buffer);

							ImGui::NextColumn();

							bool bIsSelected = false;
							if (ImGui::Selectable(item->cTitle, bIsSelected))
							{
								// get issue number
								char pThisIssueNumber[6];
								memcpy(pThisIssueNumber, item->cTitle + 1, 6);
								pThisIssueNumber[5] = 0;
								for (int n = 0; n < strlen(pThisIssueNumber); n++)
									if (pThisIssueNumber[n] == ' ') pThisIssueNumber[n] = 0;

								// assemble new URL to exact issue
								char pURLToIssue[1024];
								strcpy(pURLToIssue, "https://github.com/TheGameCreators/GameGuruRepo/issues/");
								strcat(pURLToIssue, pThisIssueNumber);

								// handle selection
								ExecuteFile(pURLToIssue, "", "");
							}
							if (ImGui::IsItemHovered())
							{
								ImGui::BeginTooltip();
								ImGui::Indent(10);
								ImGui::PushItemWidth(-10);
								ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

								ImGui::Text("%s", item->cTitle);
								ImGui::Separator();
								ImGui::TextWrapped(item->cDescription);
								ImGui::Separator();

								ImGui::ImgBtn(iIcon, ImVec2(16, 16), ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false);
								ImGui::SameLine();
								ImGui::Text(" Status: ");
								ImGui::SameLine();
								if (item->iStatus == 1)
									ImGui::Text("The bug has been submitted. ");
								if (item->iStatus == 2)
									ImGui::Text("We have been able to reproduce this. ");
								if (item->iStatus == 3)
									ImGui::Text("The bug has been fixed. ");

								// no need for this
								//ImGui::Separator();
								//ImGui::Text("Reply: %s", item->cReply);

								ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));

								ImGui::PopItemWidth();
								ImGui::Indent(-10);
								ImGui::EndTooltip();
							}

							ImGui::NextColumn();

							ImGui::ImgBtn(iIcon, ImVec2(16, 16), ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false);
							if (ImGui::IsItemHovered())
							{
								LPSTR pTooltip = "";
								if (item->iStatus == 1) pTooltip = "The bug has been submitted.";
								if (item->iStatus == 2)	pTooltip = "We have been able to reproduce this. ";
								if (item->iStatus == 3)	pTooltip = "The bug has been fixed. ";
								ImGui::SetTooltip("%s", pTooltip);
							}

							ImGui::NextColumn();
						}
					}
					ImGui::Columns(1);
					ImGui::Indent(2);
					ImGui::ListBoxFooter();
				}

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3));
				ImGui::PopItemWidth();
				ImGui::Indent(-10);
			}

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0)
			{
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}

			// bug submission process
			if (iReportBugProcessing > 0)
			{
				if (iReportBugProcessing == 1)
				{
					// Validate data before processing
					LPSTR pErrorMsg = "";
					if (strlen(cBugTitle) == 0) pErrorMsg = "Please enter your bug title";
					if (strlen(cBugDescription) == 0) pErrorMsg = "Please enter your bug description";
					if (strlen(pErrorMsg) == 0)
					{
						// remove any /n insertions from cBugDescription
						LPSTR pDst = cBugDescription;
						for (LPSTR pSrc = cBugDescription; pSrc <= cBugDescription + sizeof(cBugDescription); pSrc++)
						{
							if (pSrc > cBugDescription && *(pSrc - 1) == ' ' && *pSrc == '\n')
							{
								// we inserted this to get IMGUI to multi-line wrap! So now remove it
							}
							else
							{
								*pDst = *pSrc;
								pDst++;
							}
						}

						// first make a copy of desc
						strcpy(cBugDescriptionCopy, cBugDescription);

						// if ticked sys specs, add this now
						if (bIncludesystemSpecs == true)
						{
							// if no specs found
							char pSystemSpecs[1024];
							strcpy(pSystemSpecs, "DXDIAG required!");

							// delete any old report
							cstr pDXDiagReport = g.mydocumentsdir_s + "\\GameGuruApps\\GameGuruMAX\\dxdiagreport.txt";
							if (FileExist(pDXDiagReport.Get())) DeleteFileA(pDXDiagReport.Get());

							// copy dxdiag bat to mydocs
							cstr pDXDiagSrc = g.fpscrootdir_s + "\\dxdiagsystemspecs.bat";
							cstr pDXDiagSystemScan = g.mydocumentsdir_s + "\\GameGuruApps\\GameGuruMAX\\dxdiagsystemspecs.bat";
							CopyFileA(pDXDiagSrc.Get(), pDXDiagSystemScan.Get(), FALSE);

							// get system specs from users machine
							LPSTR pOldDir = GetDir();
							SetCurrentDirectoryA(g.mydocumentsdir_s.Get());
							SetCurrentDirectoryA("GameGuruApps");
							SetCurrentDirectoryA("GameGuruMAX");
							int iStatusValue = ExecuteFile("dxdiagsystemspecs.bat", "", "", 1, 1);
							SetDir(pOldDir);

							// load in new report
							if (FileExist(pDXDiagReport.Get()))
							{
								// parse out the lines we are interested in
								strcpy(pSystemSpecs, "");
								std::vector<cstr> dxdiagreport;
								LoadArray(pDXDiagReport.Get(), dxdiagreport);
								for (int line = 0; line < dxdiagreport.size(); line++)
								{
									LPSTR pThisLine = dxdiagreport[line].Get();
									for (int iFields = 0; iFields < 10; iFields++)
									{
										LPSTR pLabel = NULL;
										if (iFields == 0) pLabel = "Operating System: ";
										if (iFields == 1) pLabel = "Language: ";
										if (iFields == 2) pLabel = "System Model: ";
										if (iFields == 3) pLabel = "Processor: ";
										if (iFields == 4) pLabel = "Memory: ";
										if (iFields == 5) pLabel = "Windows Dir: ";
										if (iFields == 6) pLabel = "DirectX Version: ";
										if (iFields == 7) pLabel = "Card name: ";
										if (iFields == 8) pLabel = "Dedicated Memory: ";
										if (iFields == 9) pLabel = "Current Mode: ";
										LPSTR pFound = strstr(pThisLine, pLabel);
										if (pFound)
										{
											// exclude if characters found preceding the label
											bool bFoundChars = false;
											for (LPSTR pPtr = pFound - 1; pPtr > pThisLine; pPtr--)
												if (pPtr >= pThisLine && *pPtr != ' ')
													bFoundChars = true;
											if (bFoundChars == true) continue;

											// get to field data
											pFound += strlen(pLabel);

											// add to system specs
											strcat(pSystemSpecs, pLabel);
											strcat(pSystemSpecs, pFound);
											strcat(pSystemSpecs, "\n");
										}
									}
								}
								dxdiagreport.clear();
							}

							strcat(cBugDescription, "\n");
							strcat(cBugDescription, "\n");
							strcat(cBugDescription, "System Specs:\n");
							strcat(cBugDescription, pSystemSpecs);
						}

						// submit bug report to server
						// Create Issue
						// URL : https://www.thegamecreators.com/api/github/issues/create
						// Method: POST
						// Parameters :
						// title - This is the title of the issue and is required
						// body - This is the body text of the issue and is required, it does not support HTML but does support the special markup that GitHub uses for issues if you want to dead up on that here is the documentation https ://guides.github.com/features/mastering-markdown/ it will allow you to do things like embed images and make text bold so worth adding
						char m_szPostData[1024];
						memset(m_szPostData, 0, sizeof(m_szPostData));
						strcpy(m_szPostData, "title=");
						strcat(m_szPostData, cBugTitle);
						strcat(m_szPostData, "&body=");
						strcat(m_szPostData, cBugDescription);
						strcat(m_szPostData, "&labels[0]=max");
						strcat(m_szPostData, "&labels[1]=bug");
						DWORD dwDataReturnedSize = 0;
						LPSTR pDataReturned = NULL;
						char szAuthHeader[1024];
						sprintf(szAuthHeader, "public-api-auth-token: %d:%s", g_iUserID, g_sHashToken.Get());
						UINT iError = OpenURLForGETPOST("www.thegamecreators.com", &pDataReturned, &dwDataReturnedSize, szAuthHeader, m_szPostData, "POST", "/api/github/issues/create");
						if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
						{
							// to know when the data ends
							LPSTR pEndOfReturnedData = pDataReturned + dwDataReturnedSize;

							// error or success
							char pSuccessMarker[1024];
							strcpy(pSuccessMarker, Chr(34));
							strcat(pSuccessMarker, "success");
							strcat(pSuccessMarker, Chr(34));
							if (strstr(pDataReturned, pSuccessMarker) != NULL)
							{
								// success - all okay
								iReportBugProcessing++;
							}
							else
							{
								// failed to submit
								pErrorMsg = pDataReturned;
							}
						}

						// restore desc as we dont need system spec in local bug list item
						strcpy(cBugDescription, cBugDescriptionCopy);
					}
					// report error if found
					if (strlen(pErrorMsg) > 0)
					{
						MessageBoxA(NULL, pErrorMsg, "Bug Tracker Error", MB_OK);
						iReportBugProcessing = 0;
					}
				}
				if (iReportBugProcessing == 2)
				{
					// Do screenshot here (if supported)
					// next stage
					iReportBugProcessing++;
				}
				if (iReportBugProcessing == 3)
				{
					// Display "Bug has successful been added, Thanks"
					MessageBoxA(NULL, "Bug has successful been added", "Bug Tracking System", MB_OK);

					// just refresh bug list
					bBug_RefreshBugList = true;

					// End processing.
					iReportBugProcessing = 0;
				}
			}
		}

		// ensure IMGUI focus maintained
		ImRect bbwin(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize());
		if (ImGui::IsMouseHoveringRect(bbwin.Min, bbwin.Max))
		{
			bImGuiGotFocus = true;
		}
		if (ImGui::IsAnyItemFocused())
		{
			bImGuiGotFocus = true;
		}

		ImGui::End();
	}
}

LPSTR GetCommentFromIssue( LPSTR pIssueNumber )
{
	// string to return
	LPSTR pCommentToReturn = NULL;

	// get comment from server
	char m_szGETURL[1024];
	strcpy(m_szGETURL, "/api/github/issue/");
	strcat(m_szGETURL, pIssueNumber);
	strcat(m_szGETURL, "/comments?");
	strcat(m_szGETURL, "page=1"); // page number starting with 1
	DWORD dwDataReturnedSize = 0;
	LPSTR pDataReturned = NULL;
	char szAuthHeader[1024];
	sprintf(szAuthHeader, "public-api-auth-token: %d:%s", g_iUserID, g_sHashToken.Get());
	UINT iError = OpenURLForGETPOST("www.thegamecreators.com", &pDataReturned, &dwDataReturnedSize, szAuthHeader, NULL, "GET", m_szGETURL);
	if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
	{
		// to know when the data ends
		LPSTR pEndOfReturnedData = pDataReturned + dwDataReturnedSize;

		// create string to return 
		pCommentToReturn = new char[dwDataReturnedSize+1];
		memset(pCommentToReturn, 0, dwDataReturnedSize);

		// now thin this out to only show comment bodies
		char pSpeechMark[2];
		strcpy(pSpeechMark, Chr(34));
		char pBodyMarker[1024];
		strcpy(pBodyMarker, pSpeechMark);
		strcat(pBodyMarker, "body");
		strcat(pBodyMarker, pSpeechMark);
		strcat(pBodyMarker, ":");
		strcat(pBodyMarker, pSpeechMark);
		LPSTR pBodyPtr = strstr(pDataReturned, pBodyMarker);
		if (pBodyPtr)
		{
			pBodyPtr += strlen(pBodyMarker);
			LPSTR pBodyEndPtr = strstr(pBodyPtr, pSpeechMark);
			if (pBodyEndPtr)
			{
				int iOneCommentSize = pBodyEndPtr - pBodyPtr;
				LPSTR pOneComment = new char[iOneCommentSize + 1];
				memcpy(pOneComment, pBodyPtr, iOneCommentSize);
				pOneComment[iOneCommentSize] = 0;
				strcat(pCommentToReturn, "Comment: ");
				strcat(pCommentToReturn, pOneComment);
				strcat(pCommentToReturn, "\n");
				delete pOneComment;
			}
		}
	}

	// free data returned from GET call
	if (pDataReturned)
	{
		delete pDataReturned;
		pDataReturned = NULL;
	}

	// success, return
	return pCommentToReturn;
}

void GetBugReport(void)
{
	// always assume link is not established (link confirmed below)
	g_bBugTrackerConnected = false;

	// clear old bug list
	if (sBugList.size() > 0)
	{
		//Free old list.
		for (int i = 0; i < sBugList.size(); i++)
			SAFE_DELETE(sBugList[i]);
	}
	sBugList.clear();

	#ifdef LBBUGTRACKING
	// find file containing this users ID and hash
	char pData[260];
	memset(pData, 0, sizeof(pData));
	char defaultWriteFolder[260];
	if ((SHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, &defaultWriteFolder[0])) >= 0)
	{
		cstr hashfilename = defaultWriteFolder;
		hashfilename += "\\AppData\\Local\\AGKApps\\TheGameCreators\\GameGuruMAXUpdater\\";
		hashfilename += "internaldata";
		FILE* hashfile = GG_fopen(hashfilename.Get(), "rb");
		if (hashfile)
		{
			// read contents of internaldata file
			size_t size = fread(&pData, 1, sizeof(pData), hashfile);
			fclose(hashfile);

			// if wrong size, cannot authenticate
			if (size < 74)
			{
				// cannot authenticate
				return;
			}

			// decrypt it
			EncDec((uint8_t*)pData, size);

			cstr sData = (char*)pData;
			cstr sData2 = (char*)(pData + 64); // data without message hash
			cstr sMAC, sUserID;
			sData = sData.Left(64); // extract message hash	
			LPSTR pData2 = sData2.Get();
			LPSTR pColon = strstr(pData2, ":");
			int colon = 0;
			if (pColon)
			{
				colon = pColon - pData2;
			}
			if (colon < 0)
			{
				// could not find the user/hash separator
				return;
			}
			sUserID = sData2.Left(colon-1);
			g_iUserID = sUserID.Val();
			g_sHashToken = sData2.Right(sData2.Len()-colon-1);
		}
	}

	// Get all your bug here via the TGC API (user connects their GitHub account via their TGC account!)
	// populate bug list with items this user created
	char m_szGETURL[1024];
	strcpy(m_szGETURL, "/api/github/issues?");
	strcat(m_szGETURL, "state=open"); // "open", "closed", or "all"
	strcat(m_szGETURL, "&filter=created"); // "assigned", "created" or "all"
	strcat(m_szGETURL, "&page=1"); // page number starting with 1
	DWORD dwDataReturnedSize = 0;
	LPSTR pDataReturned = NULL;
	char szAuthHeader[1024];
	sprintf(szAuthHeader, "public-api-auth-token: %d:%s", g_iUserID, g_sHashToken.Get());
	UINT iError = OpenURLForGETPOST("www.thegamecreators.com", &pDataReturned, &dwDataReturnedSize, szAuthHeader, NULL, "GET", m_szGETURL);
	if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
	{
		// toi know when the data ends
		LPSTR pEndOfReturnedData = pDataReturned + dwDataReturnedSize;

		// ensure we have success, which means full connection and ready to get bug list
		char pFindString[256];
		strcpy(pFindString, Chr(34));
		strcat(pFindString, "status");
		strcat(pFindString, Chr(34));
		strcat(pFindString, ":");
		strcat(pFindString, Chr(34));
		strcat(pFindString, "success");
		strcat(pFindString, Chr(34));
		LPSTR pSuccessPtr = strstr(pDataReturned, pFindString);
		if (pSuccessPtr == NULL)
		{
			// user has likely not registered their Github account with their tgc account
			// main UI will allow user to do this before trying again here
		}
		else
		{
			// link confirmed 
			g_bBugTrackerConnected = true;

			// populate bug list with items this user created
			// find = \"https:\\/\\/api.github.com\\/repos\\/TheGameCreators\\/GameGuruRepo\\/issues\\/
			char pIssueMarker[1024];
			strcpy(pIssueMarker, Chr(34)); // " speech mark
			strcat(pIssueMarker, "https:");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/api.github.com");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/repos");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/TheGameCreators");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/GameGuruRepo");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/issues");
			strcat(pIssueMarker, Chr(92)); // backslash
			strcat(pIssueMarker, "/");
			char pSpeechMark[2];
			strcpy(pSpeechMark, Chr(34)); // " speech mark
			char pCommaMark[2];
			strcpy(pCommaMark, ","); // comma

			// pull out all the bugs from the successful retrieval of the bug list
			LPSTR pIssueBody = pSuccessPtr;
			LPSTR pCurrentPos = pIssueBody;
			bool bHaveIssues = true;
			while (bHaveIssues == true)
			{
				// fields per issue
				char pIssueNumber[32];
				char pIDNumber[32];
				char pNumber[32];
				char pTitle[512];
				char pDesc[10240];
				char pCreatedAt[32];
				char pLabels[512];		

				// look for main issue marker 
				int iDataSize = 0;
				LPSTR pFoundIssue = strstr(pCurrentPos, pIssueMarker);
				if (pFoundIssue)
				{
					// issue number
					pCurrentPos = pFoundIssue + strlen(pIssueMarker);
					LPSTR pIssueNumberEnd = strstr(pCurrentPos, pSpeechMark);
					if (pIssueNumberEnd)
					{
						iDataSize = pIssueNumberEnd - pCurrentPos;
						memcpy(pIssueNumber, pCurrentPos, iDataSize);
						pIssueNumber[iDataSize] = 0;
						pCurrentPos += iDataSize;
					}

					// id
					char pIDMarker[32];
					strcpy(pIDMarker, pSpeechMark);
					strcat(pIDMarker, "id");
					strcat(pIDMarker, pSpeechMark);
					strcat(pIDMarker, ":");
					LPSTR pFoundID = strstr(pCurrentPos, pIDMarker);
					if (pFoundID)
					{
						pCurrentPos = pFoundID + strlen(pIDMarker);
						LPSTR pIDEnd = strstr(pCurrentPos, pCommaMark);
						if (pIDEnd)
						{
							iDataSize = pIDEnd - pCurrentPos;
							memcpy(pIDNumber, pCurrentPos, iDataSize);
							pIDNumber[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// number
					char pNumberMarker[32];
					strcpy(pNumberMarker, pSpeechMark);
					strcat(pNumberMarker, "number");
					strcat(pNumberMarker, pSpeechMark);
					strcat(pNumberMarker, ":");
					LPSTR pFoundNumber = strstr(pCurrentPos, pNumberMarker);
					if (pFoundNumber)
					{
						pCurrentPos = pFoundNumber + strlen(pNumberMarker);
						LPSTR pNumberEnd = strstr(pCurrentPos, pCommaMark);
						if (pNumberEnd)
						{
							iDataSize = pNumberEnd - pCurrentPos;
							memcpy(pNumber, pCurrentPos, iDataSize);
							pNumber[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// title
					char pTitleMarker[32];
					strcpy(pTitleMarker, pSpeechMark);
					strcat(pTitleMarker, "title");
					strcat(pTitleMarker, pSpeechMark);
					strcat(pTitleMarker, ":");
					strcat(pTitleMarker, pSpeechMark);
					LPSTR pFoundTitle = strstr(pCurrentPos, pTitleMarker);
					if (pFoundTitle)
					{
						pCurrentPos = pFoundTitle + strlen(pTitleMarker);
						LPSTR pTitleEnd = strstr(pCurrentPos, pSpeechMark);
						if (pTitleEnd)
						{
							iDataSize = pTitleEnd - pCurrentPos;
							memcpy(pTitle, pCurrentPos, iDataSize);
							pTitle[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// determine what created_at marker looks like so we can stop looking for labels
					char pCreatedMarker[32];
					strcpy(pCreatedMarker, pSpeechMark);
					strcat(pCreatedMarker, "created_at");
					strcat(pCreatedMarker, pSpeechMark);
					strcat(pCreatedMarker, ":");
					strcat(pCreatedMarker, pSpeechMark);

					// labels
					strcpy(pLabels, "");
					LPSTR pLabelMarker = "labels\\/";
					bool bWhileWeHaveLabels = true;
					while (bWhileWeHaveLabels==true)
					{
						LPSTR pFoundLabel = strstr(pCurrentPos, pLabelMarker);
						LPSTR pFoundCreatedAt = strstr(pCurrentPos, pCreatedMarker);
						if (pFoundLabel == NULL || pFoundCreatedAt <= pFoundLabel)
						{
							// no more labels, leave label loop
							bWhileWeHaveLabels = false;
						}
						else
						{
							// add this label
							if (pFoundLabel)
							{
								pCurrentPos = pFoundLabel + strlen(pLabelMarker);
								LPSTR pLabelsEnd = strstr(pCurrentPos, pSpeechMark);
								if (pLabelsEnd)
								{
									char pOneLabel[1024];
									iDataSize = pLabelsEnd - pCurrentPos;
									memcpy(pOneLabel, pCurrentPos, iDataSize);
									pOneLabel[iDataSize] = 0;
									if (strlen(pLabels) > 0) strcat(pLabels, ":");
									strcat(pLabels, pOneLabel);
									pCurrentPos += iDataSize;
								}
							}
						}
					}

					// createdat
					LPSTR pFoundCreated = strstr(pCurrentPos, pCreatedMarker);
					if (pFoundCreated)
					{
						pCurrentPos = pFoundCreated + strlen(pCreatedMarker);
						LPSTR pCreatedEnd = pCurrentPos + 10;//YYYY-MM-DD strstr(pCurrentPos, pSpeechMark);
						if (pCreatedEnd)
						{
							iDataSize = pCreatedEnd - pCurrentPos;
							memcpy(pCreatedAt, pCurrentPos, iDataSize);
							pCreatedAt[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// body is the first comment (main description)
					char pBodyMarker[32];
					strcpy(pBodyMarker, pSpeechMark);
					strcat(pBodyMarker, "body");
					strcat(pBodyMarker, pSpeechMark);
					strcat(pBodyMarker, ":");
					strcat(pBodyMarker, pSpeechMark);
					LPSTR pFoundBodyDesc = strstr(pCurrentPos, pBodyMarker);
					if (pFoundBodyDesc)
					{
						pCurrentPos = pFoundBodyDesc + strlen(pBodyMarker);
						LPSTR pBodyDescEnd = strstr(pCurrentPos, pSpeechMark);
						if (pBodyDescEnd)
						{
							iDataSize = pBodyDescEnd - pCurrentPos;
							if (iDataSize >= 4095) iDataSize = 4095;
							memcpy(pDesc, pCurrentPos, iDataSize);
							pDesc[iDataSize] = 0;
							pCurrentPos += iDataSize;
						}
					}

					// add issue to list if pass the filters
					if (strstr(pLabels, "Max") != NULL && strstr(pLabels, "enhancement") == NULL)
					{
						// prepare bug item
						BugReport * br = new BugReport;
						strcpy(br->cCreatedAt, pCreatedAt + 2); // chop YYYY into YY
						sprintf(br->cTitle,"#%s %s", pIssueNumber, pTitle);
						strcpy(br->cReply, pLabels);

						// main body description
						strcpy(br->cDescription, pDesc);
						for (int n = 0; n < strlen(br->cDescription); n++)
						{
							// replace unwanted stuff from body description
							if (br->cDescription[n + 0] == '\\' && br->cDescription[n + 1] == 'r' && br->cDescription[n + 2] == '\\' && br->cDescription[n + 3] == 'n')
							{
								br->cDescription[n + 0] = '.';
								br->cDescription[n + 1] = ' ';
								br->cDescription[n + 2] = ' ';
								br->cDescription[n + 3] = ' ';
							}
							if (br->cDescription[n + 0] == '\\' && br->cDescription[n + 1] == 'n')
							{
								br->cDescription[n + 0] = ' ';
								br->cDescription[n + 1] = ' ';
							}
							if (strnicmp(br->cDescription + n, "[image](", 8) == NULL)
							{
								// remove image reference
								bool bReplaceWithSpaces = true;
								for (int nn = n; nn < strlen(br->cDescription); nn++)
								{
									if (br->cDescription[n + 0] == ')' && br->cDescription[n + 1] == '\\' && br->cDescription[n + 2] == 'r' && br->cDescription[n + 3] == '\\' && br->cDescription[n + 4] == 'n')
									{
										br->cDescription[nn + 0] = ' ';
										br->cDescription[nn + 1] = ' ';
										br->cDescription[nn + 2] = ' ';
										br->cDescription[nn + 3] = ' ';
										break;
									}
									else
									{
										br->cDescription[nn] = ' ';
									}
								}
							}
							if (strnicmp(br->cDescription + n, "System Specs:", 13) == NULL)
							{
								// remove system specs from end (own PC)
								for (int nn = n; nn < strlen(br->cDescription); nn++)
									br->cDescription[nn] = ' ';
							}
						}
						// now remove all extra spaces to compress body desc to summary sentence
						LPSTR pWritePtr = br->cDescription;
						for (LPSTR pReadPtr = br->cDescription; pReadPtr < br->cDescription+4096; pReadPtr++)
						{
							if (*(pReadPtr + 0) == ' ' && *(pReadPtr + 1) == ' ')
							{
								// ignore extra space
							}
							else
							{
								// keep character
								*pWritePtr = *pReadPtr; 
								pWritePtr++; 
							}
						}
						*pWritePtr = 0;

						// determine status from label
						br->iStatus = 1; //reported
						if (strstr(pLabels, "fixed") != NULL || strstr(pLabels, "Fixed") != NULL)
						{
							if (strstr(pLabels, "confirmation") != NULL)
								br->iStatus = 2; //confirmed
							else
								br->iStatus = 3; //fixed
						}

						// add to bug list
						sBugList.push_back(br);
					}
				}
				else
				{
					// no more issues found
					bHaveIssues = false;
				}
			}
		}
	}
	if (pDataReturned)
	{
		delete pDataReturned;
		pDataReturned = NULL;
	}
	#endif //LBBUGTRACKING
}


ImVec2 Convert3DTo2D(float x, float y, float z)
{
	// take wicked viewproj and convert 3D XYZ to screenspace XY
	XMFLOAT3 thisPos = XMFLOAT3(x, y, z);
	XMVECTOR vecPos = XMLoadFloat3(&thisPos);
	wiCanvas canvas = master.masterrenderer;
	canvas.dpi = 96.0f; //PE: Always use default dpi. 2D coords is not using dpi scaling.
	float screenW = canvas.GetLogicalWidth();
	float screenH = canvas.GetLogicalHeight();
	wiScene::CameraComponent &camera = wiScene::GetCamera();
	XMMATRIX V = camera.GetView();
	XMMATRIX P = camera.GetProjection();
	XMMATRIX W = XMMatrixIdentity();
	XMVECTOR screen2D = XMVector3Project(vecPos, 0, 0, screenW, screenH, 0.0f, 1.0f, P, V, W);
	if (screen2D.m128_f32[2] >= 0.0f )
		return(ImVec2(screen2D.m128_f32[0], screen2D.m128_f32[1]));
	else
		return(ImVec2(-999999,-999999));
}

void GetRubberbandLowHighValues(void)
{
	//PE: Find clipping rect.
	float fLowX = 999999.0, fLowY = 999999.0, fLowZ = 999999.0;
	float fHighX = -999999.0, fHighY = -999999.0, fHighZ = -999999.0;
	for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
	{
		int e = g.entityrubberbandlist[i].e;
		if (e > 0)
		{
			//Think i need the bounding box here.
			AABB aabb;
			sObject* pObject = GetObjectData(t.entityelement[e].obj);
			if (pObject && ObjectExist(t.entityelement[e].obj))
			{
				GGMATRIX matARotation;
				GGVECTOR3 box1;
				GGMATRIX matRotateX, matRotateY, matRotateZ;
				if (pObject->position.bFreeFlightRotation)
				{
					matARotation = pObject->position.matFreeFlightRotate;
				}
				else
				{
					//ZXY
					GGMatrixRotationX(&matRotateX, GGToRadian(pObject->position.vecRotate.x));	// x rotation
					GGMatrixRotationY(&matRotateY, GGToRadian(pObject->position.vecRotate.y));	// y rotation
					GGMatrixRotationZ(&matRotateZ, GGToRadian(pObject->position.vecRotate.z));	// z rotation
					matARotation = matRotateX * matRotateY * matRotateZ;
				}
				if (pObject->position.bApplyPivot)
				{
					matARotation *= pObject->position.matPivot;
				}

				aabb._min.x = pObject->collision.vecMin.x;
				aabb._min.y = pObject->collision.vecMin.y;
				aabb._min.z = pObject->collision.vecMin.z;
				aabb._max.x = pObject->collision.vecMax.x;
				aabb._max.y = pObject->collision.vecMax.y;
				aabb._max.z = pObject->collision.vecMax.z;

				box1.x = aabb._min.x; box1.y = aabb._min.y; box1.z = aabb._min.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._min.x = box1.x; aabb._min.y = box1.y; aabb._min.z = box1.z;
				box1.x = aabb._max.x; box1.y = aabb._max.y; box1.z = aabb._max.z;
				GGVec3TransformCoord(&box1, &box1, &matARotation);
				aabb._max.x = box1.x; aabb._max.y = box1.y; aabb._max.z = box1.z;

				aabb._min.x = (aabb._min.x * pObject->position.vecScale.x);
				aabb._min.y = (aabb._min.y * pObject->position.vecScale.y);
				aabb._min.z = (aabb._min.z * pObject->position.vecScale.z);
				aabb._max.x = (aabb._max.x * pObject->position.vecScale.x);
				aabb._max.y = (aabb._max.y * pObject->position.vecScale.y);
				aabb._max.z = (aabb._max.z * pObject->position.vecScale.z);

				if (t.entityelement[e].x + aabb._min.x < fLowX) fLowX = t.entityelement[e].x + aabb._min.x;
				if (t.entityelement[e].x + aabb._min.x > fHighX) fHighX = t.entityelement[e].x + aabb._min.x;
				if (t.entityelement[e].y + aabb._min.y < fLowY) fLowY = t.entityelement[e].y + aabb._min.y;
				if (t.entityelement[e].y + aabb._min.y > fHighY) fHighY = t.entityelement[e].y + aabb._min.y;
				if (t.entityelement[e].z + aabb._min.z < fLowZ) fLowZ = t.entityelement[e].z + aabb._min.z;
				if (t.entityelement[e].z + aabb._min.z > fHighZ) fHighZ = t.entityelement[e].z + aabb._min.z;
				if (t.entityelement[e].x + aabb._max.x < fLowX) fLowX = t.entityelement[e].x + aabb._max.x;
				if (t.entityelement[e].x + aabb._max.x > fHighX) fHighX = t.entityelement[e].x + aabb._max.x;
				if (t.entityelement[e].y + aabb._max.y < fLowY) fLowY = t.entityelement[e].y + aabb._max.y;
				if (t.entityelement[e].y + aabb._max.y > fHighY) fHighY = t.entityelement[e].y + aabb._max.y;
				if (t.entityelement[e].z + aabb._max.z < fLowZ) fLowZ = t.entityelement[e].z + aabb._max.z;
				if (t.entityelement[e].z + aabb._max.z > fHighZ) fHighZ = t.entityelement[e].z + aabb._max.z;

			}

			if (t.entityelement[e].x < fLowX) fLowX = t.entityelement[e].x;
			if (t.entityelement[e].y < fLowY) fLowY = t.entityelement[e].y;
			if (t.entityelement[e].z < fLowZ) fLowZ = t.entityelement[e].z;
			if (t.entityelement[e].x > fHighX) fHighX = t.entityelement[e].x;
			if (t.entityelement[e].y > fHighY) fHighY = t.entityelement[e].y;
			if (t.entityelement[e].z > fHighZ) fHighZ = t.entityelement[e].z;
		}
	}
	//PE: Convert fLowX to screencords.
	if (fHighX > -999998.0 && fLowX < 999998.0)
	{
		ImVec2 vLowValue = Convert3DTo2D(fLowX, fLowY, fLowZ);
		ImVec2 vHighValue = Convert3DTo2D(fHighX, fHighY, fHighZ);
		if (vLowValue.x < vHighValue.x)
		{
			fLastRubberBandX1 = vLowValue.x;
			fLastRubberBandX2 = vHighValue.x;
		}
		else
		{
			fLastRubberBandX2 = vLowValue.x;
			fLastRubberBandX1 = vHighValue.x;
		}
		if (vLowValue.y < vHighValue.y)
		{
			fLastRubberBandY1 = vLowValue.y;
			fLastRubberBandY2 = vHighValue.y;
		}
		else
		{
			fLastRubberBandY2 = vLowValue.y;
			fLastRubberBandY1 = vHighValue.y;
		}

		//Expand Y.
		fLastRubberBandY1 *= 0.8;
		fLastRubberBandY2 *= 1.2;

		//Adjust to fit better.
		fLastRubberBandX1 -= 40.f;
		fLastRubberBandY1 -= 40.f;
		fLastRubberBandX2 += 40.f;
		fLastRubberBandY2 += 40.f;
	}
}

void DragDrop_DeleteEntityCursor(void)
{
	// prevent deleting them, and instead instruct user to ungroup the objects first
	bool bContinueWithDelete = true; //PE: Changed to true , we should be able to delete normal objects.
	if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
	{
		// do not delete 'key' objects that are part of group
		strcpy(cTriggerMessage, "Cannot delete a parent group. First ungroup objects, then you can delete them all.");
		bTriggerMessage = true;
		bContinueWithDelete = false;
	}
	if (bContinueWithDelete == true)
	{
		//PE: Delete entity cursor.
		//Delete any associated waypoint/trigger zone
		t.waypointindex = t.grideleprof.trigger.waypointzoneindex;
		if (t.waypointindex > 0)
		{
			t.w = t.waypoint[t.waypointindex].start;
			waypoint_delete();
		}
		t.grideleprof.trigger.waypointzoneindex = 0;
		//  delete grid entity object and reset
		t.gridentitydelete = 0;
		if (t.gridentityobj > 0)
		{
			DeleteObject(t.gridentityobj);
			t.gridentityobj = 0;
		}
		t.refreshgrideditcursor = 1;
		t.gridentity = 0;
		t.gridentityposoffground = 0;
		t.gridentityusingsoftauto = 0;
		t.gridentitysurfacesnap = 1 - g.gdisablesurfacesnap;
		#ifdef WICKEDENGINE
		// MAX handles its own positioning system
		t.gridentityautofind = 0;
		#else
		t.gridentityautofind = 1;
		#endif
		t.inputsys.dragoffsetx_f = 0;
		t.inputsys.dragoffsety_f = 0;
		editor_refreshentitycursor();
		t.widget.pickedObject = 0;

		bool bDisableRubberBandMoving = false;
		#ifdef WICKEDENGINE
		if (current_selected_group >= 0 && group_editing_on)
		{
			bDisableRubberBandMoving = true;
		}
		bDraggingActive = false;
		#endif
		if (!bDisableRubberBandMoving)
		{
			// if rubberband selection, delete all in selection
			gridedit_deleteentityrubberbandfrommap();
		}
		// flag also used to restore highlighting behavior
		t.gridentityextractedindex = 0;

		// when place down, ensure waypoint not affected until release mouse button
		t.mclickpressed = 1;
		t.selstage = 1;
	}
}


void DragDrop_CheckTrashcanDrop(ImRect bb)
{
	if (pref.iEnableDragDropEntityMode && !bDraggingActive)
	{
		//Allow Trash drag drop, even when not dragging.
		//Reverse action, so you need to release mouse to delete, to prevent accidental deleting.
		if (t.gridentity != 0 || t.gridentityobj != 0)
		{
			if (ImGui::IsMouseHoveringRect(bb.Min, bb.Max, false))
			{
				if (!ImGui::IsMouseDown(0))
				{
					ImGui::BeginTooltip();
					ImGui::ImgBtn(TOOL_TRASHCAN, ImVec2(48, 48), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors);
					ImGui::EndTooltip();
					bTrashcanIconActive = true;
				}
				else
				{
					DragDrop_DeleteEntityCursor();
				}
			}
		}
	}
	if (pref.iEnableDragDropEntityMode && bDraggingActive)
	{
		if (t.gridentity != 0 || t.gridentityobj != 0)
		{
			if (ImGui::IsMouseHoveringRect(bb.Min, bb.Max, false))
			{
				if (ImGui::IsMouseDown(0))
				{
					//ImGui::SetT   ooltip("%s", "Remove");
					ImGui::BeginTooltip();
					ImGui::ImgBtn(TOOL_TRASHCAN, ImVec2(48, 48), ImVec4(1.0, 1.0, 1.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(0.8, 0.8, 0.8, 0.8), ImVec4(0.8, 0.8, 0.8, 0.8), 0, 0, 0, 0, false, false, false, false,false, bBoostIconColors);
					ImGui::EndTooltip();
					bTrashcanIconActive = true;
				}
				else {
					DragDrop_DeleteEntityCursor();
				}
			}
		}
	}
}

void DragCameraMovement(void)
{
	#ifdef DIRECTIONALCAMERASCROLLING
	// this is a nice method, but probably not ideal for everyone (and you can easily overshoot)
	// so decided to go with the pan method which has more finer controls for camera management
	static int iActivateCount = 0;
	if (pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.xmouse != 500000  && t.grideditselect == 5 && t.gridentity == 0 && t.widget.activeObject == 0 && t.inputsys.keyshift == 0)
	{
		static ImVec2 vStartPos = { 0,0 };
		if (ImGui::IsMouseDown(0))
		{
			if (iActivateCount < 5) //PE: Give priority to object selection.
			{
				iActivateCount++;
				return;
			}
			static float fOldX = 0.0f, fOldY = 0.0f;
			if (!bDragCameraActive)
			{
				vStartPos = ImGui::GetMousePos();
				bDragCameraActive = true;
				fOldX = 0.0f;
			}
			ImVec2 vPos = ImGui::GetMousePos();
			ImVec2 vDiff = (vStartPos - vPos) * 0.60;
			//Draw line.
			{
				ImGuiViewport* mainviewport = ImGui::GetMainViewport();
				if (mainviewport)
				{
					ImDrawList* dl = ImGui::GetForegroundDrawList(mainviewport);
					if (dl)
					{
						dl->AddLine(vStartPos, vPos, ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.8)), 3.0f);
					}
				}
			}

			GGVECTOR3 vCamPos = GetCameraPosition();
			float fMoveSpeed = 8192.0f;
			float fCamDistance = (vCamPos.y*2.0f);
			if (fCamDistance < 50.0f) fCamDistance = 50.0f;

			vDiff = vDiff / fMoveSpeed * fCamDistance;

			float fmove = ImLerp(vDiff.x, fOldX, 0.25f);
			fmove *= g.timeelapsed_f;
			MoveCameraLeft(0, fmove);

			t.cx_f = t.editorfreeflight.c.x_f = GetCameraPosition().x;
			t.editorfreeflight.c.y_f = GetCameraPosition().y;
			t.cy_f = t.editorfreeflight.c.z_f = GetCameraPosition().z;
			fOldX = fmove;

			fmove = ImLerp(vDiff.y, fOldY, 0.25f);
			fmove *= g.timeelapsed_f;
			MoveCameraUp(0, fmove);

			t.cx_f = t.editorfreeflight.c.x_f = GetCameraPosition().x;
			t.editorfreeflight.c.y_f = vCamPos.y;
			t.cy_f = t.editorfreeflight.c.z_f = GetCameraPosition().z;
			fOldY = fmove;


		}
		else
		{
			bDragCameraActive = false;
			iActivateCount = 0;
		}
	}
	else
	{
		iActivateCount = 0;
	}
	#endif
}

void MouseLeftDragXZPanning(void)
{
	#ifdef BUILDINGEDITOR
	if (BuildingEditor::isActive())
		return;
	#endif	
	static int iActivateCount = 0;
	static bool bPanningActive = false;
	if (1)
	{
		static ImVec2 vStartPos = { 0,0 };
		static bool bRestoreMouseAfterXZPan = false;
		bool bOkayToGo = false;
		if (bPanningActive == true) bOkayToGo = true;
		if (t.onedrag == 0 && bPanningActive == false && pref.iDragCameraMovement && t.ebe.on == 0 && t.inputsys.xmouse != 500000 && t.grideditselect == 5 && t.gridentity == 0 && t.widget.activeObject == 0 && t.inputsys.keyshift == 0 && t.inputsys.keycontrol == 0 && bDotObjectDragging==false ) bOkayToGo = true;
		if (ImGui::IsMouseDown(0) && bOkayToGo == true)
		{
			//PE: Give priority to object selection
			if (iActivateCount < 5) 
			{
				iActivateCount++;
				return;
			}

			//PE: Must call it each frame.
			ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);

			// New mouse drag camera system relies on actual ray casts
			// to terrain to get exact XZ coordinates for the drag
			static float fTerrainLastHitX = 0.0f;
			static float fTerrainLastHitZ = 0.0f;
			float fTerrainHitX, fTerrainHitY, fTerrainHitZ;
			if (WickedCall_GetPick(&fTerrainHitX, &fTerrainHitY, &fTerrainHitZ, NULL, NULL, NULL, NULL, GGRENDERLAYERS_NORMAL | GGRENDERLAYERS_TERRAIN) == true)
			{
				if (bPanningActive==false)
				{
					bPanningActive = true;
					bDragCameraActive = true;
					fTerrainLastHitX = fTerrainHitX;
					fTerrainLastHitZ = fTerrainHitZ;
					if (bRestoreMouseAfterXZPan == false && ImGui::GetMouseCursor() == ImGuiMouseCursor_Arrow)
					{
						bRestoreMouseAfterXZPan = true;
						ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);
					}
				}
				float fDifferenceX = fTerrainHitX - fTerrainLastHitX;
				float fDifferenceZ = fTerrainHitZ - fTerrainLastHitZ;
				//LB: prevent moving TOO fast such as grabbing terrain in extreme distance and shifting
				if (fabs(fDifferenceX) + fabs(fDifferenceZ) > 100.0f)
				{
					float fDist = sqrt((fabs(fDifferenceX)*fabs(fDifferenceX)) + (fabs(fDifferenceZ)*fabs(fDifferenceZ)));
					fDifferenceX = (fDifferenceX / fabs(fDist)) * 100.0f;
					fDifferenceZ = (fDifferenceZ / fabs(fDist)) * 100.0f;
				}
				fDifferenceX *= 1.8; //Move a bit faster.
				fDifferenceZ *= 1.8; //Move a bit faster.

				//PE: If we move in-out of water we can get some huge differences.
				if (fabs(fDifferenceX) + fabs(fDifferenceZ) < 6000.0f)
				{
					if (fabs(fDifferenceX) + fabs(fDifferenceZ) != 0.0f)
					{
						bPanningActive = false;
						// LB: also need to close this down or we end up locked in constant drag
						bDragCameraActive = false;
						if (bRestoreMouseAfterXZPan == true)
						{
							bRestoreMouseAfterXZPan = false;
							ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
						}
					}
					t.cx_f = t.editorfreeflight.c.x_f = (t.editorfreeflight.c.x_f - fDifferenceX);
					t.cy_f = t.editorfreeflight.c.z_f = (t.editorfreeflight.c.z_f - fDifferenceZ);
				}
			}
			fTerrainLastHitX = fTerrainHitX;
			fTerrainLastHitZ = fTerrainHitZ;
		}
		else
		{
			if (bPanningActive == true)
			{
				bPanningActive = false;
				bDragCameraActive = false;
				if (bRestoreMouseAfterXZPan == true)
				{
					bRestoreMouseAfterXZPan = false;
					ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
				}
			}
			iActivateCount = 0;
		}
	}
	else
	{
		iActivateCount = 0;
	}
}

void MouseWheelYPanning(void)
{
	static bool bPanningActive = false;
	static ImVec2 vStartPos = { 0,0 };
	static bool bRestoreMouseAfterYPan = false;
	if (ImGui::IsMouseDown(2))
	{
		if (bRestoreMouseAfterYPan ==false && ImGui::GetMouseCursor() == ImGuiMouseCursor_Arrow)
		{
			bRestoreMouseAfterYPan = true;
			ImGui::SetMouseCursor(ImGuiMouseCursor_Pan);
		}

		// New system for Camera Panning (Y) is to pan across the camera lens plane
		// so left/right is left and right for the camera operator, and up/down lifts and lowers the camera operator
	}
	else
	{
		bPanningActive = false;
		if (bRestoreMouseAfterYPan == true)
		{
			bRestoreMouseAfterYPan = false;
			ImGui::SetMouseCursor(ImGuiMouseCursor_Arrow);
		}
	}
}

cStr cLastLibraryList = "";

//PE: TODO - g_LibraryFileList[] should be an array so we can have many on the screen at the same times.
//PE: TODO - get image width height from actual images so we dont lock it to widethumb format only.
//PE: This will be used for many different image selection types, Behavior,Images,Sound? ...
void SortFilesListForLibraryType()
{
	std::vector<sLibraryList> SortFileList;
	SortFileList.clear();
	SortFileList.resize(g_LibraryFileList.size());
	int iSort = 0;
	for (int i = 0; i < 3 ; i++)
	{
		for (int a = 0; a < g_LibraryFileList.size() ; a++)
		{
			if (g_LibraryFileList[a].iType == i)
			{
				SortFileList[iSort++] = g_LibraryFileList[a];
			}
		}
	}
	g_LibraryFileList = SortFileList;
}
void GetFilesListForLibrary(char *path, bool bCreateThumbs, int win, int iThumbWidth, int iThumbHeight, int SortType)
{
	if (!path) return;
	int uniqueId = 16000;

	if (cLastLibraryList != path)
	{
		cLastLibraryList = path;
		//Free any old thumbs.
		for (int n = 0; n < g_LibraryFileList.size(); n++)
		{
			if (g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
			{
				image_setlegacyimageloading(true);
				DeleteImage(g_LibraryFileList[n].iImage);
				image_setlegacyimageloading(false);
				g_LibraryFileList[n].iImage = 0;
			}
		}
		g_LibraryFileList.clear();
		LPSTR pOldDir = GetDir();
		SetDir(path);
		ChecklistForFiles();
		SetDir(pOldDir);
		for (int c = 0; c < ChecklistQuantity(); c++)
		{
			cStr cFile = cStr(ChecklistString(1 + c));
			bool bIsImage = false;
			if (cFile != "." && cFile != "..")
			{
				cstr sTmp = ChecklistString(1 + c);
				if (pestrcasestr(sTmp.Get(), ".png"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".jpg"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".jpeg"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".dds"))
					bIsImage = true;
				if (!bIsImage && pestrcasestr(sTmp.Get(), ".bmp"))
					bIsImage = true;
				if (bIsImage)
				{
					sLibraryList vTmp;
					vTmp.cDescription = "";
					vTmp.cName = cStr(sTmp);
					vTmp.cPath = cStr(path);
					vTmp.cFile = cStr(path) + cFile;
					vTmp.iType = 0;
					vTmp.cProject = "";
					vTmp.bProjectExists = false;

					//Check if we got a description file.
					std::string sDescFile = vTmp.cFile.Get();
					
					replaceAll(sDescFile, ".bmp", "");
					replaceAll(sDescFile, ".dds", "");
					replaceAll(sDescFile, ".jpg", "");
					replaceAll(sDescFile, ".jpeg", "");
					replaceAll(sDescFile, ".png", "");
					sDescFile = sDescFile + ".txt";
					std::ifstream t(sDescFile);
					std::string str((std::istreambuf_iterator<char>(t)),std::istreambuf_iterator<char>());
					if (str.length() > 0)
					{
						if (pestrcasestr(str.c_str(), "(rating:0)"))
						{
							replaceAll(str, "(rating:0)", "");
							vTmp.iType = 0;
						}
						else if (pestrcasestr(str.c_str(), "(rating:1)"))
						{
							replaceAll(str, "(rating:1)", "");
							vTmp.iType = 1;
						}
						else if (pestrcasestr(str.c_str(), "(rating:2)"))
						{
							replaceAll(str, "(rating:2)", "");
							vTmp.iType = 2;
						}

						char *find = (char *) pestrcasestr(str.c_str(), "(project:");
						if (find)
						{
							std::string remove = "(project:";
							find += 9;
							char project[512];
							if (strlen(find) < 500)
							{
								strcpy(project, find);
								char *find2 = (char *)pestrcasestr(project, ")");
								if (find2)
								{
									*find2 = 0;

									remove = remove + project;
									remove = remove + ")";
									replaceAll(str, remove, "");
									vTmp.cProject = project;

									// quick check to see if the folder exists
									char pProjFolderFile[MAX_PATH];					
									strcpy(pProjFolderFile, "projectbank\\");
									strcat(pProjFolderFile, vTmp.cProject.Get());
									strcat(pProjFolderFile, "\\project.dat");
									GG_GetRealPath(pProjFolderFile, false);
									if(FileExist(pProjFolderFile)==1)
										vTmp.bProjectExists = true;
									else
										vTmp.bProjectExists = false;
								}
							}
						}

						//PE: The rest is the pure description.
						vTmp.cDescription = str.c_str();

					}

					g_LibraryFileList.push_back(vTmp);
				}
			}
		}

		if (bCreateThumbs)
		{
			SetDir(pOldDir);
			for (int n = 0; n < g_LibraryFileList.size(); n++)
			{
				//PE: Skip cached thumbs for now.
				CreateBackBufferCacheName(g_LibraryFileList[n].cFile.Get(), iThumbWidth, iThumbHeight);
				g_LibraryFileList[n].iImage = 0;
				GG_SetWritablesToRoot(true);
				if (1==2 && FileExist(BackBufferCacheName.Get()))
				{
					SetMipmapNum(1); //PE: mipmaps not needed.
					image_setlegacyimageloading(true);
					if (FileExist(BackBufferCacheName.Get()))
					{
						LoadImage((char *)BackBufferCacheName.Get(), uniqueId + n);
					}
					if (ImageExist(uniqueId + n))
						g_LibraryFileList[n].iImage = uniqueId + n;
					image_setlegacyimageloading(false);
					SetMipmapNum(-1);
				}
				else
				{
					SetMipmapNum(1); //PE: mipmaps not needed.
					image_setlegacyimageloading(true);
					//Create thumb.
					LoadImageSize((char *)g_LibraryFileList[n].cFile.Get(), uniqueId + n, iThumbWidth, iThumbHeight);
					if (1==2 && ImageExist(uniqueId + n))
					{
						//Image
						//Save thumb.
						SaveImage(BackBufferCacheName.Get(), uniqueId + n);
						DeleteImage(uniqueId + n);
						LoadImage((char *)BackBufferCacheName.Get(), uniqueId + n); //Reload new and delete old.

						// resume thumbbank copy mode
						extern bool g_bThumbBankCopyMode;
						g_bThumbBankCopyMode = true;
					}
					if (ImageExist(uniqueId + n))
						g_LibraryFileList[n].iImage = uniqueId + n;
					image_setlegacyimageloading(false);
					SetMipmapNum(-1);
				}
				GG_SetWritablesToRoot(false);
				BackBufferCacheName = "";
			}
		}
		SetDir(pOldDir);
		if (SortType == 1) SortFilesListForLibraryType();
	}
}

cstr ComboFilesListForLibrary(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension)
{
	cstr sReturnComboName = currentselection;
	cstr sDisplayName = sReturnComboName;
	if (bRemoveExtension)
	{
		char *find = (char *) pestrcasestr(sDisplayName.Get(), ".");
		if (find)
		{
			int iPos = find - sDisplayName.Get();
			if(iPos > 0 && iPos < 1024)
				sDisplayName = Left(sDisplayName.Get(), iPos);
		}
	}
	if (ImGui::BeginCombo("##ComboFilesListForLibrary", sDisplayName.Get(), ImGuiComboFlags_HeightLargest))
	{
		bool is_selected = (sReturnComboName == "None");
		if (ImGui::Selectable("None", is_selected)) {
			sReturnComboName = "None";
		}
		if (is_selected) ImGui::SetItemDefaultFocus();

		bool bUseImage = false;
		float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f) * 0.5;
		if(iFixedWidth > 0)
			fImageWidth = iFixedWidth;
		fImageWidth -= 5.0f;
		float fImageRatio = fImageWidth / 512.0f;
		if(g_LibraryFileList.size() > 0 && g_LibraryFileList[0].iImage > 0 && ImageExist(g_LibraryFileList[0].iImage) )
			bUseImage = true;

		int columns_count = 0;
		for (int n = 0; n < g_LibraryFileList.size(); n++)
		{
			is_selected = (sReturnComboName == g_LibraryFileList[n].cName);

			if (bUseImage && g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
			{
				ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
				if (is_selected)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					ImVec2 padding = { 1.0, 1.0 };
					const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
					window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				}
				if (ImGui::ImgBtn(g_LibraryFileList[n].iImage, iThumbSize, ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false,false))
				{
					sReturnComboName = g_LibraryFileList[n].cName;
					ImGui::CloseCurrentPopup();
				}
				if (columns > 0)
				{
					if (++columns_count < columns)
						ImGui::SameLine();
					else
						columns_count = 0;
				}
				else
				{
					//Default to 2 columns
					if (n % 2 == 0)
						ImGui::SameLine();
				}
			}
			else if (ImGui::Selectable(g_LibraryFileList[n].cName.Get(), is_selected)) {
				sReturnComboName = g_LibraryFileList[n].cName;
			}
			if (is_selected) ImGui::SetItemDefaultFocus();
		}
		ImGui::EndCombo();
	}
	return sReturnComboName;
}

int GetImageIDFilesListForLibrary(cstr & currentselection)
{
	for (int n = 0; n < g_LibraryFileList.size(); n++)
	{
		if (currentselection == g_LibraryFileList[n].cName)
		{
			if (ImageExist(g_LibraryFileList[n].iImage))
				return(g_LibraryFileList[n].iImage);
			return(0);
		}
	}
	return(0);
}

int GetEntryFilesListForLibrary(cstr & currentselection)
{
	for (int n = 0; n < g_LibraryFileList.size(); n++)
	{
		if (currentselection == g_LibraryFileList[n].cName)
		{
			return(n);
		}
	}
	return(-1);
}

cstr ListboxFilesListForLibrary(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension, bool bIncludeNone, char *filter)
{
	cstr sReturnComboName = currentselection;
	if (columns <= 0) columns = 2; //Default to 2.

	bool bUseImage = false;
	float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f - 18.0f ) / columns; //ImGui::GetCurrentWindow()->ScrollbarSizes.x
	if (iFixedWidth > 0)
		fImageWidth = iFixedWidth;
	fImageWidth -= 5.0f;
	fImageWidth -= 6.0f; //Due to now using Columns add spacing.

	float fImageRatio = fImageWidth / 512.0f;
	if (g_LibraryFileList.size() > 0 && g_LibraryFileList[0].iImage > 0 && ImageExist(g_LibraryFileList[0].iImage))
		bUseImage = true;

	float box_height = (((float)288.0*fImageRatio) * 2.0) + 6.0f;
	box_height += ImGui::GetFontSize() * 5.0;

	ImGui::BeginChild("##ListboxFilesListForLibrary", ImVec2(ImGui::GetContentRegionAvail().x - 4.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::Indent(2);
	if(1)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 3));
		bool is_selected = false;

		//if (bIncludeNone)
		//{
		//	is_selected = (sReturnComboName == "None");
		//	if (ImGui::StyleButton("No Backdrop", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, 0)))
		//	{
		//		sReturnComboName = "None";
		//	}
		//	if (is_selected) ImGui::SetItemDefaultFocus();
		//}

		ImGui::Columns(columns, "ListboxFilesListForLibrarycolumns", false);  //false no border

		int columns_count = 0;
		for (int n = 0; n < g_LibraryFileList.size(); n++)
		{
			is_selected = (sReturnComboName == g_LibraryFileList[n].cName);

			cstr sDisplayName = g_LibraryFileList[n].cName;
			if (bRemoveExtension)
			{
				char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
				if (find)
				{
					int iPos = find - sDisplayName.Get();
					if (iPos > 0 && iPos < 1024)
						sDisplayName = Left(sDisplayName.Get(), iPos);
				}
			}
			bool bVisible = true;
			if (filter)
			{
				bVisible = false;
				cstr sfilter = filter;
				char *p = strtok(sfilter.Get(), ",");
				while (p)
				{
					if(p[0] == '*')
						bVisible = true;
					else if (pestrcasestr(g_LibraryFileList[n].cName.Get(), p))
						bVisible = true;
					p = strtok(NULL, ",");
				}
			}
			if (bVisible)
			{
				if (bUseImage && g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
				{
					ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
					if (is_selected)
					{
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
						ImVec2 padding = { 1.0, 1.0 };
						const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
						window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
					}
					if (ImGui::ImgBtn(g_LibraryFileList[n].iImage, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						sReturnComboName = g_LibraryFileList[n].cName;
					}

					ImGui::Text(sDisplayName.Get());

					ImGui::NextColumn();
				}
				else if (ImGui::Selectable(sDisplayName.Get(), is_selected))
				{
					sReturnComboName = g_LibraryFileList[n].cName;
				}
				if (is_selected) ImGui::SetItemDefaultFocus();
			}
		}
		ImGui::Columns(1);
	}
	ImGui::Indent(-2);
	ImGui::EndChild();
	return sReturnComboName;
}


bool bRemoveVideoInNextFrame = false;
int iWelcomeVideoID = -1;
bool bWelcomeVideoMaximized = false;
bool bTriggerEditDemoGame = false;

cstr ListboxFilesListForWelcomeScreen(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension, bool bIncludeNone, char *filter, float fbox_height, bool bDisplayDesc,bool bUseFullScreen)
{
	cstr sReturnComboName = currentselection;
	if (columns <= 0) columns = 2; //Default to 2.
	if (bDisplayDesc) columns++;

	float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f - 18.0f) / columns; //ImGui::GetCurrentWindow()->ScrollbarSizes.x
	if (iFixedWidth > 0)
		fImageWidth = iFixedWidth;
	fImageWidth -= 5.0f;
	fImageWidth -= 6.0f; //Due to now using Columns add spacing.

	float fImageRatio = fImageWidth / 512.0f;

	float box_height = (((float)288.0*fImageRatio) * 5.0) + 10.0f;
	box_height += ImGui::GetFontSize() * 8.0;
	if (fbox_height > 0) box_height = fbox_height;

	//ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 4.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::Indent(2);
	if (1)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 3));
		bool is_selected = false;
		float total_width = ImGui::GetContentRegionAvailWidth();
		ImGui::Columns(columns, "ListboxFilesListForWelcomecolumns", false);  //false no border

		if (bDisplayDesc)
		{
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, total_width * 0.34); //Right 60% size.
			fImageRatio = (ImGui::GetContentRegionAvailWidth()-2.0f) / 512.0f;
		}

		int columns_count = 0;
		for (int n = 0; n < 10; n++) //Display max 12 games.
		{
			int TextureID = WELCOME_FILLERROUNDED;
			cStr sName = "";
			ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };

			if (n < g_LibraryFileList.size())
			{
				if (g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
				{
					TextureID = g_LibraryFileList[n].iImage;
				}
				sName = g_LibraryFileList[n].cName;
				alpha = { 1.0f,1.0f,1.0f,1.0f };
			}


			is_selected = (sReturnComboName == sName);

			cstr sDisplayName = sName;
			if (bRemoveExtension && n < g_LibraryFileList.size())
			{
				char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
				if (find)
				{
					int iPos = find - sDisplayName.Get();
					if (iPos > 0 && iPos < 1024)
						sDisplayName = Left(sDisplayName.Get(), iPos);
				}
			}
			bool bVisible = true;
			if (filter && n < g_LibraryFileList.size())
			{
				bVisible = false;
				cstr sfilter = filter;
				char *p = strtok(sfilter.Get(), ",");
				while (p)
				{
					if (p[0] == '*')
						bVisible = true;
					else if (pestrcasestr(g_LibraryFileList[n].cName.Get(), p))
						bVisible = true;
					p = strtok(NULL, ",");
				}
			}
			if (bVisible)
			{
				ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
				if (is_selected)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					ImVec2 padding = { 1.0, 1.0 };
					const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
					window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				}

				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + iThumbSize);

				if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 200)*alpha, ImColor(255, 255, 255, 200)*alpha, 0, 0, 0, 0, false, false, false))
				{
					if(n < g_LibraryFileList.size())
						sReturnComboName = g_LibraryFileList[n].cName;
				}

				if (ImGui::IsItemHovered())
				{
					if (ImGui::IsMouseDoubleClicked(0))
					{
						if (n < g_LibraryFileList.size())
						{
							sReturnComboName = g_LibraryFileList[n].cName;
							bTriggerEditDemoGame = true;
						}
					}
				}
				static int triggerEndVideo = 0;
				if (n < g_LibraryFileList.size() && ImGui::IsItemHovered() && g_LibraryFileList[n].timer++ > 50)
				{
					if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID))
					{
						float fVideoW = 0;
						float fVideoH = 0;
						float animU = 1.0;
						float animV = 1.0;
						ID3D11ShaderResourceView* lpVideoTexture = NULL;
						lpVideoTexture = GetAnimPointerView(iWelcomeVideoID);
						if (lpVideoTexture != NULL)
						{
							fVideoW = GetAnimWidth(iWelcomeVideoID);
							fVideoH = GetAnimHeight(iWelcomeVideoID);
							SetRenderAnimToImage(iWelcomeVideoID, true);
							animU = GetAnimU(iWelcomeVideoID);
							animV = GetAnimV(iWelcomeVideoID);
							ImVec2 uv0 = ImVec2(0, 0);
							ImVec2 uv1 = ImVec2(animU, animV);
							window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
						}

						float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
						if (fdone > 0.5)
							triggerEndVideo = 1;
						if (triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
						{
							//End loop.
							//PE: Loop dont work, at some point the player breaks and flicker, just restart everyting.
							//void SetVideoPositionPlay(float seconds);
							//SetVideoPositionPlay(0.0);
							//ResumeAnim(iWelcomeVideoID);
							//Try stopping and starting.
							//StopAnimation(iWelcomeVideoID);
							//PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
							//SetRenderAnimToImage(iWelcomeVideoID, true);
							//PlayAnimation(iWelcomeVideoID);
							//SetVideoVolume(100);
							g_LibraryFileList[n].timer = 0;
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
					}
					else
					{
						//Load video.
						std::string sVideoFile = g_LibraryFileList[n].cFile.Get();
						replaceAll(sVideoFile, ".png", ".mp4");
						if (FileExist((LPSTR) sVideoFile.c_str()))
						{
							iWelcomeVideoID = 0;
							for (int i = 1; i <= 32; i++)
							{
								if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
							}

							if (iWelcomeVideoID > 0)
							{
								if (LoadAnimation((LPSTR) sVideoFile.c_str(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
								{
									iWelcomeVideoID = -999;
								}
								if (iWelcomeVideoID > 0)
								{
									PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
									SetRenderAnimToImage(iWelcomeVideoID, true);
									PlayAnimation(iWelcomeVideoID);
									SetVideoVolume(100);
								}
							}
						}
						else
						{
							g_LibraryFileList[n].timer = 0; //Failed.
							triggerEndVideo = 0;
						}
					}
				}
				else
				{
					if (n < g_LibraryFileList.size() && !ImGui::IsItemHovered())
					{
						if (g_LibraryFileList[n].timer > 0 && iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
						g_LibraryFileList[n].timer = 0;
					}
				}
				//zombie cellar demo - level1.mp4
				if (!bDisplayDesc)
					ImGui::Text(sDisplayName.Get());
				if (bDisplayDesc)
				{
					if (n < g_LibraryFileList.size())
					{
						ImGui::SetWindowFontScale(1.4);
						char UniqueString[256];
						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.00f));
						if (g_LibraryFileList[n].iType == 2)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.6f, 0.0f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							sprintf(UniqueString, "Design Complexity: Developer##%d", n);
						}
						else if (g_LibraryFileList[n].iType == 1)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.7f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							sprintf(UniqueString, "Design Complexity: Advanced##%d", n);
						}
						else
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.0f, 0.6f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							sprintf(UniqueString, "Design Complexity: Standard##%d", n);
						}

						if (ImGui::StyleButton(UniqueString, ImVec2(iThumbSize.x, 0.0f)))
						{
							//Select Game
							if (n < g_LibraryFileList.size())
								sReturnComboName = g_LibraryFileList[n].cName;
						}

						ImGui::PopStyleColor(4);

						ImGui::SetWindowFontScale(1.0);
					}
				}

				ImGui::NextColumn();
				if (is_selected) ImGui::SetItemDefaultFocus();

				if (bDisplayDesc)
				{
					if (n < g_LibraryFileList.size())
					{
						//Overlay rating.
						char UniqueString[256];
						sprintf(UniqueString, "##ListboxFilesDescriptionBox%d", n);
						ImGui::BeginChild(UniqueString, ImVec2(ImGui::GetContentRegionAvailWidth() - 2.0f, iThumbSize.y+38.0f), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
						ImGui::SetWindowFontScale(1.8);
						ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
						textcol.w = 1.0;
						ImGui::PushStyleColor(ImGuiCol_Text, textcol);
						ImGui::Text(sDisplayName.Get());
						ImGui::PopStyleColor();
						//ImGui::Separator();
						ImGui::SetWindowFontScale(1.2);
						if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
						ImGui::TextWrapped(g_LibraryFileList[n].cDescription.Get());
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndChild();
					}
					ImGui::NextColumn();
				}
			}
		}
		ImGui::Columns(1);
	}
	ImGui::Indent(-2);
	ImGui::EndChild();
	return sReturnComboName;
}

cstr ListboxFilesListForWelcomeScreen_v2(char *currentselection, int columns, int iFixedWidth, bool bRemoveExtension, bool bIncludeNone, char *filter, float fbox_height, bool bDisplayDesc, bool bUseFullScreen)
{
	cstr sReturnComboName = currentselection;
	if (columns <= 0) columns = 2; //Default to 2.
	if (bDisplayDesc) columns++;

	float fImageWidth = (ImGui::GetContentRegionAvailWidth() - 10.0f - 18.0f) / columns; //ImGui::GetCurrentWindow()->ScrollbarSizes.x
	if (iFixedWidth > 0)
		fImageWidth = iFixedWidth;
	fImageWidth -= 5.0f;
	fImageWidth -= 6.0f; //Due to now using Columns add spacing.

	float fImageRatio = fImageWidth / 512.0f;

	float box_height = (((float)288.0*fImageRatio) * 5.0) + 10.0f;
	box_height += ImGui::GetFontSize() * 8.0;
	if (fbox_height > 0) box_height = fbox_height;

	//ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 4.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::BeginChild("##ListboxFilesListForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
	ImGui::Indent(2);
	if (1)
	{
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 3));
		bool is_selected = false;
		float total_width = ImGui::GetContentRegionAvailWidth();
		ImGui::Columns(columns, "ListboxFilesListForWelcomecolumns", false);  //false no border

		if (bDisplayDesc)
		{
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, total_width * 0.34); //Right 60% size.
			fImageRatio = (ImGui::GetContentRegionAvailWidth() - 2.0f) / 512.0f;
		}

		int columns_count = 0;
		for (int n = 0; n < g_LibraryFileList.size(); n++) // Display max 12 games.
		{
			int TextureID = WELCOME_FILLERROUNDED;
			cStr sName = "";
			ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };

			if (n < g_LibraryFileList.size())
			{
				if (g_LibraryFileList[n].iImage > 0 && ImageExist(g_LibraryFileList[n].iImage))
				{
					TextureID = g_LibraryFileList[n].iImage;
				}
				sName = g_LibraryFileList[n].cName;
				alpha = { 1.0f,1.0f,1.0f,1.0f };
			}


			is_selected = (sReturnComboName == sName);

			cstr sDisplayName = sName;
			if (bRemoveExtension && n < g_LibraryFileList.size())
			{
				char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
				if (find)
				{
					int iPos = find - sDisplayName.Get();
					if (iPos > 0 && iPos < 1024)
						sDisplayName = Left(sDisplayName.Get(), iPos);
				}
			}
			bool bVisible = true;
			if (filter && n < g_LibraryFileList.size())
			{
				bVisible = false;
				cstr sfilter = filter;
				char *p = strtok(sfilter.Get(), ",");
				while (p)
				{
					if (p[0] == '*')
						bVisible = true;
					else if (pestrcasestr(g_LibraryFileList[n].cName.Get(), p))
						bVisible = true;
					p = strtok(NULL, ",");
				}
			}
			if (bVisible)
			{
				ImVec2 iThumbSize = { (float)512.0*fImageRatio, (float)288.0*fImageRatio };
				if (is_selected)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					ImVec2 padding = { 1.0, 1.0 };
					const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
					window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
				}

				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + iThumbSize);
				ImVec2 vTopLeftCorner = ImGui::GetCursorPos();

				if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 200)*alpha, ImColor(255, 255, 255, 200)*alpha, 0, 0, 0, 0, false, false, false))
				{
					if (n < g_LibraryFileList.size())
						sReturnComboName = g_LibraryFileList[n].cName;
				}

				// add not available image over thumb if project not exist
				extern bool g_bFreeTrialVersion;
				if (g_bFreeTrialVersion == true)
				{
					if (g_LibraryFileList[n].bProjectExists == false)
					{
						// place grey layer on thumb to show object not available
						ImVec2 vOldPos = ImGui::GetCursorPos();
						ImGui::SetCursorPos(vTopLeftCorner);
						ImGui::SetItemAllowOverlap();
						ImGui::ImgBtn(FREETRIAL_NOTAVAILABLE, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), ImColor(255, 255, 255, 180), 0, 0, 0, 0, false, false, false, false, true, bBoostIconColors);
						ImGui::SetCursorPos(vOldPos);
					}
				}

				if (ImGui::IsItemHovered())
				{
					if (ImGui::IsMouseDoubleClicked(0))
					{
						if (n < g_LibraryFileList.size())
						{
							sReturnComboName = g_LibraryFileList[n].cName;
							bTriggerEditDemoGame = true;

							if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
								bRemoveVideoInNextFrame = true;
							}
						}
					}
				}
				static int triggerEndVideo = 0;
				if (n < g_LibraryFileList.size() && ImGui::IsItemHovered() && g_LibraryFileList[n].timer++ > 50)
				{
					if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID))
					{
						float fVideoW = 0;
						float fVideoH = 0;
						float animU = 1.0;
						float animV = 1.0;
						ID3D11ShaderResourceView* lpVideoTexture = NULL;
						lpVideoTexture = GetAnimPointerView(iWelcomeVideoID);
						if (lpVideoTexture != NULL)
						{
							fVideoW = GetAnimWidth(iWelcomeVideoID);
							fVideoH = GetAnimHeight(iWelcomeVideoID);
							SetRenderAnimToImage(iWelcomeVideoID, true);
							animU = GetAnimU(iWelcomeVideoID);
							animV = GetAnimV(iWelcomeVideoID);
							ImVec2 uv0 = ImVec2(0, 0);
							ImVec2 uv1 = ImVec2(animU, animV);
							window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
						}

						float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
						if (fdone > 0.5)
							triggerEndVideo = 1;
						if (triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
						{
							//End loop.
							//PE: Loop dont work, at some point the player breaks and flicker, just restart everyting.
							//void SetVideoPositionPlay(float seconds);
							//SetVideoPositionPlay(0.0);
							//ResumeAnim(iWelcomeVideoID);
							//Try stopping and starting.
							//StopAnimation(iWelcomeVideoID);
							//PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
							//SetRenderAnimToImage(iWelcomeVideoID, true);
							//PlayAnimation(iWelcomeVideoID);
							//SetVideoVolume(100);
							g_LibraryFileList[n].timer = 0;
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
					}
					else
					{
						//Load video.
						std::string sVideoFile = g_LibraryFileList[n].cFile.Get();
						replaceAll(sVideoFile, ".png", ".mp4");
						if (FileExist((LPSTR)sVideoFile.c_str()))
						{
							iWelcomeVideoID = 0;
							for (int i = 1; i <= 32; i++)
							{
								if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
							}
							if (iWelcomeVideoID > 0)
							{
								for (int i = 1; i <= 32; i++)
								{
									if (i != iWelcomeVideoID && AnimationExist(i) == 1)
									{ 
										StopAnimation(i);
									}
								}
								if (LoadAnimation((LPSTR)sVideoFile.c_str(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
								{
									iWelcomeVideoID = -999;
								}
								if (iWelcomeVideoID > 0)
								{
									PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
									SetRenderAnimToImage(iWelcomeVideoID, true);
									PlayAnimation(iWelcomeVideoID);
									SetVideoVolume(100);
								}
							}
						}
						else
						{
							g_LibraryFileList[n].timer = 0; //Failed.
							triggerEndVideo = 0;
						}
					}
				}
				else
				{
					if (n < g_LibraryFileList.size() && !ImGui::IsItemHovered())
					{
						if (g_LibraryFileList[n].timer > 0 && iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
							bRemoveVideoInNextFrame = true;
							triggerEndVideo = 0;
						}
						g_LibraryFileList[n].timer = 0;
					}
				}

				if(1)
				{
					if (n < g_LibraryFileList.size())
					{
						ImGui::SetWindowFontScale(1.4);
						char UniqueString[256];
						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.00f));
						if (g_LibraryFileList[n].iType == 2)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.6f, 0.0f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.6f, 0.0f, 0.0f, 1.00f));
							//sprintf(UniqueString, "Design Complexity: Developer##%d", n);
							sprintf(UniqueString, "Design Complexity: Developer");
						}
						else if (g_LibraryFileList[n].iType == 1)
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.7f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.8f, 0.7f, 0.0f, 1.00f));
							//sprintf(UniqueString, "Design Complexity: Advanced##%d", n);
							sprintf(UniqueString, "Design Complexity: Advanced");
						}
						else
						{
							ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.0f, 0.6f, 0.0f, 0.75f));
							ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.0f, 0.6f, 0.0f, 1.00f));
							//sprintf(UniqueString, "Design Complexity: Standard##%d", n);
							sprintf(UniqueString, "Design Complexity: Standard");
						}

						if (ImGui::StyleButton(sDisplayName.Get(), ImVec2(iThumbSize.x, 0.0f)))
						{
							//Select Game
							if (n < g_LibraryFileList.size())
								sReturnComboName = g_LibraryFileList[n].cName;
						}
						if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", UniqueString);

						ImGui::PopStyleColor(4);

						ImGui::SetWindowFontScale(1.0);
					}
				}

				ImGui::NextColumn();
				if (is_selected) ImGui::SetItemDefaultFocus();

				if (bDisplayDesc)
				{
					if (n < g_LibraryFileList.size())
					{
						//Overlay rating.
						char UniqueString[256];
						sprintf(UniqueString, "##ListboxFilesDescriptionBox%d", n);
						ImGui::BeginChild(UniqueString, ImVec2(ImGui::GetContentRegionAvailWidth() - 2.0f, iThumbSize.y + 38.0f), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
						ImGui::SetWindowFontScale(1.8);
						ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
						textcol.w = 1.0;
						ImGui::PushStyleColor(ImGuiCol_Text, textcol);
						ImGui::Text(sDisplayName.Get());
						ImGui::PopStyleColor();
						//ImGui::Separator();
						ImGui::SetWindowFontScale(1.2);
						if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
						ImGui::TextWrapped(g_LibraryFileList[n].cDescription.Get());
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndChild();
					}
					ImGui::NextColumn();
				}
			}
		}
		ImGui::Columns(1);
	}
	ImGui::Indent(-2);
	ImGui::EndChild();
	return sReturnComboName;
}
#ifdef WICKEDENGINE
struct ProjectSortData
{
	std::string writeDate;
	std::string folderName;
	//int imageID;
	//std::string imageName;
};

// Compare two ProjectSortData by date.
bool CompareFileDates(const ProjectSortData& file0, const ProjectSortData& file1)
{
	if (file0.writeDate.compare(file1.writeDate) > 0) return true; // date2 comes before date1 (change required)

	return false; // date1 comes before date2 or they are the same (no change required)
}
// Compare two ProjectSortData by name.
bool CompareFileNames(const ProjectSortData& file0, const ProjectSortData& file1)
{
	cstr a ((char*)file0.folderName.c_str());
	cstr b ((char*)file1.folderName.c_str());

	if (strcmp(a.Lower().Get(), b.Lower().Get()) < 0) return true;

	return false;
}

// Fill in Project Sort Data so it can be sorted by write time later.
void GetProjectSortData (std::vector<ProjectSortData>& output)
{
	LPSTR pOldDir = GetDir();

	char destination[MAX_PATH];
	strcpy(destination, "projectbank\\");
	GG_GetRealPath(destination, 1); // Get actual path to write folder.

	SetDir(destination);
	ChecklistForFiles();
	SetDir(pOldDir);
	for (int c = 1; c <= ChecklistQuantity(); c++)
	{
		if (ChecklistValueA(c) != 0)
		{
			// only folders
			cstr folder = ChecklistString(c);
			if (folder != "." && folder != "..")
			{
				char project[MAX_PATH];
				strcpy(project, destination);
				strcat(project, folder.Get());
				strcat(project, "\\project.dat");

				ProjectSortData data;
				data.folderName = std::string(folder.Get());
				wchar_t filePath[MAX_PATH];
				MultiByteToWideChar(CP_UTF8, 0, &project[0], -1, filePath, MAX_PATH);

				HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
				if (hFile == INVALID_HANDLE_VALUE)
				{
					strcpy(project, destination);
					strcat(project, folder.Get());
					strcat(project, "\\remoteproject.txt");
					if(GG_FileExists(project))
					{
						char pAbsTrueProjectPath[MAX_PATH];
						OpenToRead(1, project);
						strcpy(pAbsTrueProjectPath, ReadString(1));
						CloseFile(1);
						GG_GetRealPath(pAbsTrueProjectPath, 0);
						strcpy(project, pAbsTrueProjectPath);
						strcat(project, folder.Get());
						strcat(project, "\\Files\\projectbank\\");
						strcat(project, folder.Get());
						strcat(project, "\\project.dat");
						MultiByteToWideChar(CP_UTF8, 0, &project[0], -1, filePath, MAX_PATH);
						hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
					}
				}
				if (hFile != INVALID_HANDLE_VALUE)
				{
					// Get the last write time for this file.

					FILETIME ftCreate, ftAccess, ftWrite;
					SYSTEMTIME stUTC, stLocal;

					// Retrieve the file times for the file.
					if (GetFileTime(hFile, &ftCreate, &ftAccess, &ftWrite))
					{
						TCHAR wWriteTime[MAX_PATH];

						// Convert the last-write time to local time.
						FileTimeToSystemTime(&ftWrite, &stUTC);
						SystemTimeToTzSpecificLocalTime(NULL, &stUTC, &stLocal);

						// Build a string showing the date and time.
						StringCchPrintf(wWriteTime, MAX_PATH,
							TEXT("%02d/%02d/%d  %02d:%02d:%02d"),
							stLocal.wMonth, stLocal.wDay, stLocal.wYear,
							stLocal.wHour, stLocal.wMinute, stLocal.wSecond);

						// Convert from wide char.
						char writeTime[MAX_PATH];
						WideCharToMultiByte(CP_UTF8, 0, &wWriteTime[0], MAX_PATH, &writeTime[0], MAX_PATH, NULL, NULL); 
						data.writeDate = std::string(writeTime);
						output.push_back(data);
					}
				}

				CloseHandle(hFile);					
			}
		}
	}
	SetDir(pOldDir);
}

void SortProjects(int iProjectSortMode)
{
	if (projectbank_list.size() == 0)
		return;

	std::vector<ProjectSortData> sortData;
	GetProjectSortData(sortData);
	
	// Perform the sort.
	switch (iProjectSortMode)
	{
	case 0: // Newest
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileDates);
		break;
	}
	case 1: // Oldest
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileDates);
		std::reverse(sortData.begin(), sortData.end());
		break;
	}
	case 2: // A-Z
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileNames);
		break;
	}
	case 3: // Z-A
	{
		std::sort(sortData.begin(), sortData.end(), CompareFileNames);
		std::reverse(sortData.begin(), sortData.end());
		break;
	}
	}

	// Set the new order of project names.
	projectbank_list.clear();
	for (int i = 0; i < sortData.size(); i++)
	{
		projectbank_list.push_back(sortData[i].folderName);
		projectbank_imageid[i] = 0;
	}
}

void GetProjectThumbnails()
{
	projectbank_image.clear();
	projectbank_imageid.resize(projectbank_list.size());
	
	for (int i = 0; i < projectbank_list.size(); i++)
	{
		if (!pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
		{
			char project[MAX_PATH];
			strcpy(project, "projectbank\\");
			strcat(project, projectbank_list[i].c_str());
			strcat(project, "\\remoteproject.txt");
			FILE* projectfile = NULL;
			if (GG_FileExists(project))
			{
				// this project is a remote project
				char pAbsTrueProjectPath[MAX_PATH];
				OpenToRead(1, project);
				strcpy(pAbsTrueProjectPath, ReadString(1));
				CloseFile(1);
				GG_GetRealPath(pAbsTrueProjectPath, 0);
				strcpy(project, pAbsTrueProjectPath);
				strcat(project, projectbank_list[i].c_str());
				strcat(project, "\\Files\\projectbank\\");
			}
			else
			{
				// regular projectbank project
				strcpy(project, "projectbank\\");
			}
			strcat(project, projectbank_list[i].c_str());
			strcat(project, "\\project.dat");
			projectfile = GG_fopen(project, "rb");
			if (projectfile)
			{
				//PE: Need full load now, as we can have Game Settings.
				size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);

				char sig[12] = "Storyboard\0";
				if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
				{
					cstr bestfound = "";
					//Valid Sig - Cleanup old project.
					if (strlen(checkproject.game_thumb) > 0 && FileExist(checkproject.game_thumb))
					{
						bestfound = checkproject.game_thumb;
					}
					else
					{
						for (int i = 0; i < STORYBOARD_MAXNODES; i++) //SMALL_STORYBOARD_MAXNODES
						{
							if (checkproject.Nodes[i].used)
							{
								if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
								{
									//Splash if no level found.
									if (bestfound == "")
									{
										if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\uiv3\\"))
										{
											//custom use.
											bestfound = checkproject.Nodes[i].thumb;
										}
									}
								}
								if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
								{
									if (pestrcasestr(checkproject.Nodes[i].title, "title screen"))
									{
										//Splash if no level found.
										if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\templates\\"))
										{
											//custom use.
											bestfound = checkproject.Nodes[i].thumb;
										}
									}
								}
								//PE: Try finding level that loading.lua is pointing to ?
								if (checkproject.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
								{
									if (strlen(checkproject.Nodes[i].level_name) > 0)
									{
										CreateBackBufferCacheNameEx(checkproject.Nodes[i].level_name, 512, 288, true);
										if (CreateProjectCacheName(checkproject.gamename, BackBufferCacheName.Get()) &&
											FileExist(ProjectCacheName.Get()))
										{
											bestfound = ProjectCacheName.Get();
											break;
										}
										else if (FileExist(BackBufferCacheName.Get()))
										{
											bestfound = BackBufferCacheName.Get();
											break;
										}
									}
								}

							}
						}
					}
					projectbank_image.push_back(bestfound.Get());
				}
				else
				{
					projectbank_image.push_back(""); //Just use CLICK HERE.
				}
				fclose(projectfile);
			}
			else
			{
				//PE: Was missing if not found. https://github.com/TheGameCreators/GameGuruRepo/issues/1722
				projectbank_image.push_back(""); //Just use CLICK HERE.
			}
		}
		else
		{
			projectbank_image.push_back(""); //Backup just use CLICK HERE.
		}
	}
}
#endif

void Welcome_Screen(void)
{
	bool bDisplayAsModal = false; //true;
	bool bStopVideo = false;
	bool bAutoPlayVideo = true;

	static bool bIntroScreenDone = false;
	static bool bResizeWelcome = false;
	static bool bCheckIntroScreenDone = true;

	extern bool bSpecialEditorFromStandalone;
	if (bCheckIntroScreenDone)
	{
		extern bool bSpecialStandalone;
		if (!pref.iDisplayIntroScreen || bSpecialStandalone)
		{
			bIntroScreenDone = true;
		}
		bCheckIntroScreenDone = false;

		void CheckForNewUpdateWicked(void);
		CheckForNewUpdateWicked(); //PE: Check if update process is done, and ask if user like to update.
	}
	if (bRemoveVideoInNextFrame)
	{
		if (iWelcomeVideoID > 0)
		{
			if (AnimationExist(iWelcomeVideoID))
			{
				if (AnimationPlaying(iWelcomeVideoID)) StopAnimation(iWelcomeVideoID);
				DeleteAnimation(iWelcomeVideoID);
				iWelcomeVideoID = 0;
			}
		}
		bRemoveVideoInNextFrame = false;
	}
	extern bool bEnsureIntroVideoIsNotRun;
	if (!bIntroScreenDone && !bSpecialEditorFromStandalone && bEnsureIntroVideoIsNotRun==false)
	{
		ImGuiViewport* viewport = ImGui::GetMainViewport();

		// Window Size control
		ImVec2 WindowSize = ImVec2(54 * ImGui::GetFontSize(), 50 * ImGui::GetFontSize());
		if (viewport->Size.x < 1900)
		{
			//PE: Reduce size on smaller screens.
			WindowSize = ImVec2(42 * ImGui::GetFontSize(), 34 * ImGui::GetFontSize());
		}

		if (refresh_gui_docking == 0)
		{
			// large blank dummy screen
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			// regular window for welcome screen
			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::SetNextWindowSize(WindowSize, ImGuiCond_Always);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bTmp = true;
			ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bTmp, 0);
			ImGui::End();
		}
		else if (bWelcomeScreen_Window)
		{
			//PE: Hide everything in the background (wicked 3D stuff).
			ImGuiWindow* toolbarwindow = ImGui::FindWindowByName("Toolbar");
			ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0);
			if (!bDisplayAsModal && toolbarwindow && toolbarwindow->DrawList)
			{
				toolbarwindow->DrawList->PushClipRect(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(0, 40), true);
				ImGuiWindow* stastuswindow = ImGui::FindWindowByName("Statusbar");
				monitor_col = ImGui::GetStyle().Colors[ImGuiCol_WindowBg] * ImVec4(0.8, 0.8, 0.8, 0.8);
				monitor_col.w = 1.0;
				toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
				if (stastuswindow && stastuswindow->DrawList) stastuswindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
				toolbarwindow->DrawList->PopClipRect();
				monitor_col = ImVec4(0, 0, 0, 1.0);
			}
			else
			{
				if (toolbarwindow) toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
			}
			static int iHideWindowForFrames = 8;
			if (iHideWindowForFrames > 0)
			{
				iHideWindowForFrames--;
				return;
			}
			if (gbWelcomeSystemActive)
			{
				return;
			}

			// welcome screen window
			if (bDisplayAsModal)
			{
				ImGui::OpenPopup("Welcome Screen##WelcomeScreenWindowModal");
			}

			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			// set the window size
			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::SetNextWindowSize(WindowSize, ImGuiCond_Once);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);

			//if (bDisplayAsModal)
			//	ImGui::BeginPopupModal("Welcome Screen##WelcomeScreenWindowModal", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			//else
			ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_None | ImGuiWindowFlags_NoMove  | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);

			ImGui::Indent(10);

			//PE: Now in both modes, so can close welcome and it will load last used project.
			if ( g_iDevToolsOpen >= 2) //PE: Rick - never a back but - !bWelcomeNoBackButton ||
			{
				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6.0f));
				float fFontSize = ImGui::GetFontSize();
				int icon_size = ImGui::GetFontSize()*3.0;
				ImVec2 VIconSize = { (float)icon_size, (float)icon_size };
				if (ImGui::ImgBtn(TOOL_GOBACK, VIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bIntroScreenDone = true;
					bResizeWelcome = true;
					bStopVideo = true;

					//PE: New default to object mode.
					bForceKey = true;
					csForceKey = "o";
				}
				if (ImGui::IsItemHovered() && iSkibFramesBeforeLaunch == 0) ImGui::SetTooltip("%s", "Close");
				ImGui::SetCursorPos(vCurPos);
			}

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6.0f));
			ImGui::Text("");
			ImGui::SetWindowFontScale(2.2);
			ImGui::TextCenter("WELCOME TO GAMEGURU MAX!");
			ImGui::SetWindowFontScale(1.4);
			ImGui::TextCenter("Happy Game Making!");
			ImGui::SetWindowFontScale(1.0);
			ImGui::Text("");
			ImGui::Separator();
			ImGui::Text("");

			//################
			//#### Video. ####
			//################
			ImGui::Indent(10);

			static bool bWelcomeVideoInit = false;
			static int iWelcomeFindFirstFrame = 0;
			static bool bWelcomeResumePossible = false;
			static bool bWelcomeVideoPerccentStart = false;
			static int iWelcomeVideoDelayExecute = 0;

			cstr sWelcomeVideoFile = "tutorialbank\\9901-introduction-video.mp4";

			ImVec4 oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
			{
				bool bInit = false;

				switch (iWelcomeVideoDelayExecute)
				{
				case 1: //Play restart
				{
					iWelcomeVideoDelayExecute = 0;
					StopAnimation(iWelcomeVideoID);
					PlayAnimation(iWelcomeVideoID);
					SetRenderAnimToImage(iWelcomeVideoID, true);
					UpdateAllAnimation();
					Sleep(50); //Sleep so we get a video texture in the next call.
					UpdateAllAnimation();
					SetVideoVolume(100.0);
					bWelcomeResumePossible = false;
					break;
				}
				case 2: //Resume
				{
					iWelcomeVideoDelayExecute = 0;
					ResumeAnim(iWelcomeVideoID);
					break;
				}
				case 3: //Pause
				{
					iWelcomeVideoDelayExecute = 0;
					PauseAnim(iWelcomeVideoID);
					bWelcomeResumePossible = true;
					break;
				}
				default:
					break;
				}

				if (iWelcomeFindFirstFrame > 0)
				{
					SetVideoVolume(0.1);
					if (iWelcomeFindFirstFrame == 2)
					{
						PauseAnim(iWelcomeVideoID);
						bWelcomeResumePossible = false;
					}
					//PE: Set back volume delayed or we hear a small amount of noise.
					if (iWelcomeFindFirstFrame == 1)
					{
						SetVideoVolume(100.0);
					}
					iWelcomeFindFirstFrame--;
				}

				if (iWelcomeVideoID > 0)
				{
					if (!AnimationExist(iWelcomeVideoID))
					{
						bInit = true;
					}
				}

				if (!bWelcomeVideoInit || bInit)
				{
					if (iWelcomeVideoID > 0)
					{
						if (AnimationExist(iWelcomeVideoID))
						{
							if (AnimationPlaying(iWelcomeVideoID))
								StopAnimation(iWelcomeVideoID);

							DeleteAnimation(iWelcomeVideoID);
							iWelcomeVideoID = 0;
						}
					}

					iWelcomeVideoID = 0;
					t.text_s = Lower(Right(sWelcomeVideoFile.Get(), 4));
					if (t.text_s == ".ogv" || t.text_s == ".mp4")
					{
						//PE: Use first available.
						iWelcomeVideoID = 32;
						for (int i = 1; i <= 32; i++)
						{
							if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
						}
						if (LoadAnimation(sWelcomeVideoFile.Get(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
						{
							iWelcomeVideoID = -999;
						}
					}
					if (iWelcomeVideoID > 0)
					{
						if (bAutoPlayVideo)
						{
							bWelcomeVideoPerccentStart = true;
							iWelcomeVideoDelayExecute = 1;
						}
					}
					bWelcomeVideoInit = true;
				}

				float fRatio = 1.0f / ((float)GetDesktopWidth() / (float)GetDesktopHeight());

				float fVideoW = 0;
				float fVideoH = 0;
				float animU = 1.0;
				float animV = 1.0;
				ID3D11ShaderResourceView* lpVideoTexture = NULL;
				if (!(iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID) && AnimationPlaying(iWelcomeVideoID)))
				{
					bool bLogo = true;
					if (bWelcomeResumePossible)
					{
						lpVideoTexture = GetAnimPointerView(iWelcomeVideoID);
						if (lpVideoTexture != NULL)
						{
							fVideoW = GetAnimWidth(iWelcomeVideoID);
							fVideoH = GetAnimHeight(iWelcomeVideoID);
							SetRenderAnimToImage(iWelcomeVideoID, true);
							animU = GetAnimU(iWelcomeVideoID);
							animV = GetAnimV(iWelcomeVideoID);
							bLogo = false;
						}
					}
					if (bLogo)
					{
						lpVideoTexture = GetImagePointerView(WELCOME_VIDEO);
						fVideoW = ImageWidth(WELCOME_VIDEO);
						fVideoH = ImageHeight(WELCOME_VIDEO);
					}
				}
				else
				{
					lpVideoTexture = GetAnimPointerView(iWelcomeVideoID);
					if (lpVideoTexture == NULL)
					{
						lpVideoTexture = GetImagePointerView(WELCOME_VIDEO);
						fVideoW = ImageWidth(WELCOME_VIDEO);
						fVideoH = ImageHeight(WELCOME_VIDEO);
					}
					else
					{
						fVideoW = GetAnimWidth(iWelcomeVideoID);
						fVideoH = GetAnimHeight(iWelcomeVideoID);
						SetRenderAnimToImage(iWelcomeVideoID, true);
						animU = GetAnimU(iWelcomeVideoID);
						animV = GetAnimV(iWelcomeVideoID);
					}
				}
				if (bWelcomeVideoInit && iWelcomeVideoID > 0 && lpVideoTexture)
				{
					fRatio = 1.0f / (fVideoW / fVideoH);
				}

				float videoboxheight = (ImGui::GetContentRegionAvail().x - 20.0) * fRatio;

				oldImGuiCol_ChildWindowBg = ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg];
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = ImVec4(0.1f, 0.1f, 0.1f, 1.0f);
				ImGui::BeginChild("Welcome Video##WelcomeVideo", ImVec2(ImGui::GetContentRegionAvail().x - 20.0, videoboxheight), true, iGenralWindowsFlags);
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + ImGui::GetContentRegionAvail());
				if (lpVideoTexture) {
					ImVec2 uv0 = ImVec2(0, 0);
					ImVec2 uv1 = ImVec2(animU, animV);
					window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
				}

				if (!(iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID) && AnimationPlaying(iWelcomeVideoID)))
				{
					//Display a play button.
					ImVec2 vOldPos = ImGui::GetCursorPos();
					float fPlayButSize = ImGui::GetContentRegionAvail().x * 0.10;
					float fCenterX = (ImGui::GetContentRegionAvail().x*0.5) - (fPlayButSize*0.5);
					float fCenterY = (videoboxheight*0.5) - (fPlayButSize*0.5);
					ImGui::SetCursorPos(ImVec2(fCenterX, fCenterY));
					ImVec4 vColorFade = { 1.0,1.0,1.0,0.5 };
					if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(fPlayButSize, fPlayButSize), ImColor(255, 255, 255, 0), drawCol_normal*vColorFade, drawCol_hover*vColorFade, drawCol_Down*vColorFade, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bWelcomeVideoPerccentStart = true;
						if (bWelcomeResumePossible)
						{
							iWelcomeVideoDelayExecute = 2; //resume
						}
						else
						{
							iWelcomeVideoDelayExecute = 1; //play - restart.
						}
					}
					if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");

					ImGui::SetCursorPos(vOldPos);
				}

				ImGui::EndChild();
				ImGui::GetStyle().Colors[ImGuiCol_ChildWindowBg] = oldImGuiCol_ChildWindowBg;

				if (iWelcomeVideoID > 0)
				{
					if (AnimationExist(iWelcomeVideoID))
					{
						//ImGui::SameLine();
						float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
						if (!bWelcomeVideoPerccentStart) fdone = 0.0f;

						static int triggerEndVideo = 0;
						if (fdone > 0.5)
							triggerEndVideo = 1;
						if (bAutoPlayVideo && triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
						{
							//Auto close and goto welcome screen.
							bIntroScreenDone = true;
							bResizeWelcome = true;
							bStopVideo = true;
						}
						//ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 20, 6), "");
						ImVec2 rstart = ImGui::GetWindowPos() + ImGui::GetCursorPos();
						ImGui::ProgressBar(fdone, ImVec2(ImGui::GetContentRegionAvail().x - 20, 8), "");
						ImVec2 rend = ImGui::GetWindowPos() + ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvail().x - 20.0,0.0);
						if(ImGui::IsMouseClicked(0) && ImGui::IsMouseHoveringRect(rstart, rend))
						{
							float GetVideoDuration();
							void SetVideoPositionPause(float seconds);
							void SetVideoPositionPlay(float seconds);

							ImVec2 mpos = ImGui::GetMousePos() - rstart;
							ImVec2 rwidth = rend - rstart;
							float percent = 100.0 / (rwidth.x / mpos.x);
							float videolength = GetVideoDuration();
							float vpercent = videolength / 100.0f;
							SetVideoPositionPlay( (vpercent * percent) * 0.95 ); //PE: Make it a bit lower as this is thread running so before actual pause there is a little playing.
							ResumeAnim(iWelcomeVideoID);
							bWelcomeResumePossible = false;
							triggerEndVideo = 0;
						}
						#define MEDIAICONSIZE 20

						if (ImGui::ImgBtn(MEDIA_PLAY, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
						{
							bWelcomeVideoPerccentStart = true;
							if (bWelcomeResumePossible)
							{
								iWelcomeVideoDelayExecute = 2; //resume
							}
							else
							{
								iWelcomeVideoDelayExecute = 1; //play - restart.
							}
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play");
						ImGui::SameLine();
						if (ImGui::ImgBtn(MEDIA_PAUSE, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
						{
							iWelcomeVideoDelayExecute = 3; // pause
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Pause");
						ImGui::SameLine();
						if (ImGui::ImgBtn(MEDIA_REFRESH, ImVec2(MEDIAICONSIZE, MEDIAICONSIZE), ImColor(255, 255, 255, 0), drawCol_normal, drawCol_hover, drawCol_Down, -1, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
						{
							bWelcomeVideoPerccentStart = true;
							iWelcomeVideoDelayExecute = 1; //play - restart.
						}
						if (ImGui::windowTabVisible() && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Restart");
					}
				}
			}
			ImGui::Indent(-10);

			ImGui::SetWindowFontScale(1.2);

			bool bTmp = 1 - pref.iDisplayIntroScreen;
			float fTextWidth = ImGui::CalcTextSize("Hide intro video next time").x + 20.0f;
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
			if (ImGui::Checkbox("Hide intro video next time", &bTmp))
			{
				pref.iDisplayIntroScreen = 1 - bTmp;
			}

			//Skip button
			ImGui::SameLine();
			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth() - 180.0), 0.0));
			if (ImGui::StyleButton(" SKIP ", ImVec2(160.0f, 0)))
			{
				bIntroScreenDone = true;
				bResizeWelcome = true;
				bStopVideo = true;
			}

			ImGui::SetWindowFontScale(1.0);

			ImGui::Indent(-10);

			bImGuiGotFocus = true;

			if (bDisplayAsModal)
				ImGui::EndPopup();
			else
				ImGui::End();

			if (!bWelcomeScreen_Window || bStopVideo)
			{
				//PE: Close down everything.
				bWelcomeVideoInit = false;
				bRemoveVideoInNextFrame = true;
			}

		}
		//Intro Video End
	}
	else
	{
		bool bUseFullScreen = true;
		//Welcome Screen Start
		ImVec2 vWindowSize = ImVec2(104 * ImGui::GetFontSize(), 59 * ImGui::GetFontSize());
		float tab_box_height = 630.0f;

		static cstr sCurrentGame = "";
		if (refresh_gui_docking == 0)
		{
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			ImGui::SetNextWindowViewport(viewport->ID);
			ImGui::SetNextWindowSize(vWindowSize, ImGuiCond_Always);
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bTmp = true;
			ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bTmp, 0);
			ImGui::End();
		}
		else if (bWelcomeScreen_Window)
		{
			static std::string current_project_selected = "";
			static int current_project_id = -1;
			static int iCurrentOpenTab = 0;

			static std::string current_tutorial_selected = "";
			static int current_tutorial_id = -1;


			//PE: Hide everything in the background (wicked 3D stuff).
			ImGuiWindow* toolbarwindow = ImGui::FindWindowByName("Toolbar");//ImGui::GetCurrentWindow();
			ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
			if (1)
			{
				if (!bDisplayAsModal && toolbarwindow && toolbarwindow->DrawList)
				{
					toolbarwindow->DrawList->PushClipRect(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(0, 40), true);
					ImGuiWindow* stastuswindow = ImGui::FindWindowByName("Statusbar");//ImGui::GetCurrentWindow();
					//monitor_col = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
					monitor_col = ImGui::GetStyle().Colors[ImGuiCol_WindowBg] * ImVec4(0.8, 0.8, 0.8, 0.8);
					monitor_col.w = 1.0;
					toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					if (stastuswindow && stastuswindow->DrawList) stastuswindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					//monitor_col = ImGui::GetStyle().Colors[ImGuiCol_ModalWindowDimBg]; //ImGuiCol_WindowBg
					//toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					//if (stastuswindow && stastuswindow->DrawList) stastuswindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 40), ImGui::GetColorU32(monitor_col));
					toolbarwindow->DrawList->PopClipRect();
					monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
				}
				else
				{
					if (toolbarwindow) toolbarwindow->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				}
			}
			GetFilesListForLibrary("tutorialbank\\games\\", true, 0, 1024, 576,1); //Get games list and create thumbs.

			if (!bWelcomeScreen_Init)
			{
				if (g_LibraryFileList.size() > 0)
				{
					//sCurrentGame = g_LibraryFileList[0].cName; //First game seleted by default.
					sCurrentGame = "Escape from the Zombie Cellar.png"; //For now default to zombie cellar demo - level1.png
				}
				bWelcomeScreen_Init = true;
				#ifdef WICKEDENGINE
				void CheckForNewUpdateWicked(void);
				CheckForNewUpdateWicked(); //PE: Check if update process is done, and ask if user like to update.
				#endif
			}

			if (bDisplayAsModal)
				ImGui::OpenPopup("Welcome Screen##WelcomeScreenWindow");


			ImGuiViewport* viewport = ImGui::GetMainViewport();

			//PE: Dummy window to disable background clicks.
			if (!bDisplayAsModal)
			{
				ImGui::SetNextWindowViewport(viewport->ID);
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				ImGui::Begin("##DummyWelcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_None | ImGuiWindowFlags_NoBackground  | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoChangeZOrder | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
				ImGui::End();
			}

			ImGui::SetNextWindowViewport(viewport->ID);

			if (bResizeWelcome)
			{
				ImGui::SetNextWindowSize(vWindowSize, ImGuiCond_Always);
			}
			else
			{
				ImGui::SetNextWindowSize(vWindowSize, ImGuiCond_Once);
			}
			if (bDisplayAsModal)
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			else
			{
				if (bResizeWelcome)
					ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				else
					ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			}
			if (bResizeWelcome) bResizeWelcome = false;

			//PE: Test
			if (bUseFullScreen)
			{
				ImGui::SetNextWindowSize(viewport->Size, ImGuiCond_Always);
				ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
				if (viewport->Size.x < 1800.0)
				{
					//PE: Cant use fullscreen font sizes.
					bUseFullScreen = false;
				}
			}

			//if (bDisplayAsModal)
			//	ImGui::BeginPopupModal("Welcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			//else
			ImGui::Begin("Welcome Screen##WelcomeScreenWindow", &bWelcomeScreen_Window, ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_None | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoSavedSettings);
			ImGui::Indent(10);

			// basic menu so user can quit and go to settings
			extern void hub_menubar(void);
			hub_menubar();

			//PE: Playing maximized must be on top.
			ImGuiWindow* welcome_window = ImGui::GetCurrentWindow();
			void CheckWindowsOnTop(ImGuiWindow* storyboard_window);
			CheckWindowsOnTop(welcome_window);

			cstr sDisplayName = sCurrentGame;
			char *find = (char *)pestrcasestr(sDisplayName.Get(), ".");
			if (find)
			{
				int iPos = find - sDisplayName.Get();
				if (iPos > 0 && iPos < 1024)
					sDisplayName = Left(sDisplayName.Get(), iPos);
			}

			bool bTriggerRereadDescription = false;
			if (cLastProjectList != "projectbank\\")
			{
				bTriggerRereadDescription = true;
			}
			GetProjectList("projectbank\\", true); //PE: Moved here before any use of images.

			bool bUseProject = false;
			bool bUseTutorial = false;
			if (iCurrentOpenTab == 1 && current_project_selected != "" && current_project_id >= 0)
			{
				bUseProject = true;
			}
			if (iCurrentOpenTab == 3 && current_tutorial_selected != "" && current_tutorial_id >= 0)
			{
				bUseTutorial = true;
			}

			//PE: Moved this after swap , need to be moved to before next "if (bUseTutorial)" , if we swap around again.
			if (!bUseTutorial)
			{
				if (current_tutorial_id >= 0)
				{
					iStopAndFreeThisVideo = current_tutorial_id;
					cstr title = "";
					std::map<std::string, std::string>::iterator it;
					int iFind = 0;
					for (it = tutorial_description.begin(); it != tutorial_description.end(); ++it)
					{
						if (current_tutorial_id == iFind) break;
						iFind++;
					}
					if (it != tutorial_description.end())
					{
						title = it->first.c_str();
						void SmallTutorialVideoCheckStop(char *tutorial);
						SmallTutorialVideoCheckStop(title.Get());
					}

					current_tutorial_id = -1;
				}
			}

			ID3D11ShaderResourceView* lpTexture = GetImagePointerView(WELCOME_HEADER);
			ImVec2 vHeaderDim = { 1200.0f,150.0f };
			if (iWelcomeHeaderType == 3) vHeaderDim = { 1500.0f,150.0f };
			if (lpTexture)
			{
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				//PE: Right align header, with black background.
				ImVec2 header_pos = ImGui::GetWindowPos() + ImVec2(ImGui::GetWindowSize().x- vHeaderDim.x, 0.0);
				window->DrawList->AddRectFilled(ImGui::GetWindowPos(), ImGui::GetWindowPos()+ImVec2(ImGui::GetWindowSize().x,150.0f), ImGui::GetColorU32(monitor_col));
				if (iWelcomeHeaderType == 2)
				{
					ImVec2 header_pos_left = ImGui::GetWindowPos() + ImVec2(70, 0);
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos_left, header_pos_left + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.9)));
				}
				else if (iWelcomeHeaderType == 3)
				{
					ImVec2 header_pos_center = ImGui::GetWindowPos() + ImVec2((ImGui::GetWindowSize().x*0.5) - (vHeaderDim.x*0.5), 0.0);
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos_center, header_pos_center + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
				}
				else
				{
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos, header_pos + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.9)));
				}
			}

			ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6.0f));

			ImVec2 vCurPos = ImGui::GetCursorPos();

			if (iWelcomeHeaderType == 2)
			{
				ImGui::SetWindowFontScale(2.0);
				ImGui::SetCursorPos(ImVec2(0, (vHeaderDim.y*0.5) - (ImGui::GetFontSize()*0.5)));
				ImGui::TextCenter("GameGuru MAX Hub");
			}
			ImGui::SetWindowFontScale(1.0);
			float fFontSize = ImGui::GetFontSize();
			ImGui::SetWindowFontScale(1.0);

			#ifdef HUBOLDFEEDBACKBOX
			ImRect rect;
			rect.Min = ImVec2(1067,36);
			rect.Max = rect.Min + ImVec2(600, 100);
			if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max))
			{
				char pTip[256];
				sprintf(pTip, "%s : Help us improve with your feedback by clicking here", g.version_s.Get());
				ImGui::SetTooltip("%s", pTip);
				if (ImGui::IsAnyMouseDown() == true)
				{
					ExecuteFile("https://github.com/TheGameCreators/GameGuruRepo/wiki/Help-Us-Improve-with-your-Feedback", "", "", 0);
				}
			}
			#endif

			// Display a button that allows the user to exit the welcome screen window.
			// Store the previous cursor position so that it can be reset (adding the below button at the start of the window causes it to appear faded and i'm not sure why).
			ImVec2 vPrevCursorPos(ImGui::GetCursorPos());
			ImGui::SetCursorPos(ImVec2(12.0f, 10.0f));
			if (g_iDevToolsOpen >= 2) //PE: Rick - never a back but - !bWelcomeNoBackButton ||
			{
				if (ImGui::ImgBtn(TOOL_GOBACK, ImVec2(ImGui::GetFontSize() * 4.0f, ImGui::GetFontSize() * 4.0f), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(180, 180, 180, 180),
					ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false, false, false, false))
				{
					bWelcomeScreen_Window = false;
					if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Exit GameGuru MAX Hub");
			}
			// Reset the cursor position to not interfere with the rest of the menu.
			ImGui::SetCursorPos(vPrevCursorPos);



			ImGui::SetCursorPos(ImVec2(0, vHeaderDim.y));

			float fButWidth = 150.0f;

			float fTotalContentWidth = ImGui::GetContentRegionAvailWidth();

			ImGui::Columns(2, "WelcomeScreencolumns2", false);  //false no border

			//ImGui::SetColumnOffset(0, 0.0f);
			//ImGui::SetColumnOffset(1, fTotalContentWidth * 0.4 ); //Right 60% size.

			//PE: swap.
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, fTotalContentWidth * 0.6); //Right 40% size.


			//#############################
			//######## SWAP Column ########
			//#############################

			ImGui::Text("");
			//ImGui::Text("");

			if (bUseFullScreen || viewport->Size.x < 1800.0)
				tab_box_height = ImGui::GetWindowSize().y - 82.0f - ImGui::GetCursorPosY(); //76.0 , 72.0

			ImGuiWindow* window = ImGui::GetCurrentWindow();
			ImGuiContext& gui = *GImGui;
			ImVec2 TabStartPos = window->DC.CursorPos;

			ImGui::SetWindowFontScale(1.2);
			if (ImGui::BeginTabBar("welcomescreentabbar"))
			{
				int tabflags = 0;

				ImRect rect;
				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" Demo Games ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" Demo Games ", false).x + gui.Style.ItemInnerSpacing.x;

				if (ImGui::BeginTabItem(" Demo Games ", NULL, tabflags))
				{
					iCurrentOpenTab = 0;

					//if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Demo Games you can edit and play");

					if (g_LibraryFileList.size() > 0)
					{

						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 3.0, ImGui::GetCursorPosY() + 6.0));

						//					ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_ENT_FILTER);
						//					if (lpTexture)
						//					{
						//						ImVec2 vImagePos = ImGui::GetCursorPos();
						//						ImGuiWindow* window = ImGui::GetCurrentWindow();
						//						ImVec2 search_icon_pos = ImGui::GetWindowPos() + vImagePos + ImVec2(-5.0, -2.0);
						//						window->DrawList->AddImage((ImTextureID)lpTexture, search_icon_pos, search_icon_pos + ImVec2(20, 20), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
						//						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 22.0, ImGui::GetCursorPosY()));
						//					}
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() - 3.0));

						/* No filter in design.
						static bool bFilterAll = true, bFilterShooter = true;
						cstr filters = "";
						ImGui::Checkbox("All", &bFilterAll);
						ImGui::SameLine();
						ImGui::Checkbox("Shooters", &bFilterShooter);
						if (bFilterAll) filters = "*,";
						if (bFilterShooter) filters = filters + "Shooter,";
						ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3.0));
						*/


						//cstr cRet = ListboxFilesListForWelcomeScreen(sCurrentGame.Get(), 3, -1, true, false, filters.Get(),0,false);
						//cstr cRet = ListboxFilesListForWelcomeScreen(sCurrentGame.Get(), 1, -1, true, false, filters.Get(), tab_box_height,true);
						ImGui::SetWindowFontScale(1.0);
						cstr cRet = ListboxFilesListForWelcomeScreen_v2(sCurrentGame.Get(), 3, -1, true, false, NULL, tab_box_height, false, bUseFullScreen);
						if (cRet != sCurrentGame)
						{
							//Game changed.
							sCurrentGame = cRet;
						}
					}

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}
					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "Demo Games you can edit and play");

				ImGui::SetWindowFontScale(1.2);

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" My Games ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" My Games ", false).x + gui.Style.ItemInnerSpacing.x;

				static bool bCheckForAnyProjectFiles = true;
				int tabflagsMyGames = 0;

				if (bCheckForAnyProjectFiles)
				{
					extern bool bReturnToWelcome;
					if (projectbank_list.size() > 0 && !bReturnToWelcome)
					{
						tabflagsMyGames = ImGuiTabItemFlags_SetSelected;
					}
					bCheckForAnyProjectFiles = false;
				}

				if (ImGui::BeginTabItem(" My Games ", NULL, tabflagsMyGames))
				{
					ImGui::SetWindowFontScale(0.99f);

					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(905.0f, 6.0f));
					ImGui::Text("Sort Projects: ");
					ImGui::SameLine();
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -2.0f));
					
					const char* pProjectSortModes[] = { "Most Recent", "Least Recent", "A-Z", "Z-A" };
					int iProjectSortMode = pref.iProjectSortMode;

					int comboflags = ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
					ImGui::PushItemWidth(110);
					if (ImGui::BeginCombo("##ComboProjectSort", pProjectSortModes[iProjectSortMode], comboflags))
					{
						for (int i = 0; i < 4; i++)
						{
							bool is_selected = (iProjectSortMode == i);
							if (ImGui::Selectable(pProjectSortModes[i], is_selected)) 
							{
								if (i != iProjectSortMode)
								{
									pref.iProjectSortMode = iProjectSortMode = i;
									SortProjects(iProjectSortMode);
									bResetProjectThumbnails = true;
									break;
								}
							}
						}

						ImGui::EndCombo();
					}

					ImGui::Indent(-10);
					ImGui::SetWindowFontScale(1.0f);
					ImGui::PopItemWidth();
					

					//PE: Always have a selection.
					if (current_project_selected == "" && projectbank_list.size() > 0)
					{
						current_project_id = 0;
						current_project_selected = projectbank_list[0];
					}

					iCurrentOpenTab = 1;
					//My Games.
					bool bTriggerLoad = false;

					ImGui::SetWindowFontScale(1.0);
					ImGui::BeginChild("##MyGamesProjectsForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(2);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
					float total_width = ImGui::GetContentRegionAvailWidth();
					ImGui::Columns(3, "MyGamesProjectsForWelcomecolumns", false);  //false no border

					float colwidth = ImGui::GetContentRegionAvailWidth(); //padding.
					float fRatio = colwidth / 512.0f;
					ImVec2 iThumbSize = { (float)512.0*fRatio, (float)288.0*fRatio };
					int iCount = projectbank_list.size() + 1;
					if (iCount < 9) iCount = 9; //PE: Always display min. 9 empty slots.
					for (int i = 0; i < iCount; i++)
					{
						if (i >= projectbank_list.size())
						{
							if (i == projectbank_list.size())
							{
								ImVec2 cursorPos = ImGui::GetCursorPos();
								int iTextureID = WELCOME_FILLERROUNDED;
								ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };
								if(ImGui::ImgBtn(iTextureID, ImVec2(iThumbSize.x, iThumbSize.y + 36.0), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 255)*alpha,
									ImColor(255, 255, 255, 255)*alpha, 0, 0, 0, 0, false, false, false, false, true))
								{
									// The first available empty slot should also serve as a Create new game project button.
									strcpy(pref.cLastUsedStoryboardProject, "");
									bStoryboardInitNodes = false; //Just init again.
									bStoryboardFirstRunSetInitPos = false;
									process_storeboard(true); //Init a new project.
									bTriggerSaveAsAfterNewLevel = true;
									bTriggerSaveAs = true;
									strcpy(SaveProjectAsName, "");
									strcpy(SaveProjectAsError, "");
								}
								ImVec2 buttonSize(iThumbSize.x / 4.f, iThumbSize.y / 4.f + 36.0f);
								ImGui::SetCursorPos(cursorPos + ImVec2(iThumbSize.x / 2.f - 3.35f, iThumbSize.y / 2.f + 18.f - 3.35f) - buttonSize / 2);
								if (ImGui::ImgBtn(KEY_SEPARATOR, buttonSize, ImColor(255.0f, 255.0f, 255.0f, 0.0f), ImColor(220, 220, 220, 220),
									ImColor(220, 220, 220, 180), ImColor(220, 220, 220, 150), 0, 0, 0, 0, false, false, false, false, true))
								{

								}
								if (ImGui::IsItemHovered())ImGui::SetTooltip("Create a new game project");
							}
							else
							{
								//PE: Filler.
								int iTextureID = WELCOME_FILLERROUNDED;
								ImVec4 alpha = { 1.0f,1.0f,1.0f,0.15f };
								if (ImGui::ImgBtn(iTextureID, ImVec2(iThumbSize.x, iThumbSize.y + 36.0), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255)*alpha, ImColor(255, 255, 255, 200)*alpha, ImColor(255, 255, 255, 200)*alpha, 0, 0, 0, 0, false, false, false, false, true))
								{
									//
								}
							}

							
							ImGui::NextColumn();
						}
						else
						{
							if (!ImageExist(projectbank_imageid[i]) || bResetProjectThumbnails) //STORYBOARD_THUMBS + 800 + i))
							{
								if (bResetProjectThumbnails)
								{
									bResetProjectThumbnails = false;

									// After sorting, the thumbnails can be out of order but not safe to delete them before here.
									for (int i = 0; i < projectbank_imageid.size(); i++)
									{
										if (ImageExist(STORYBOARD_THUMBS + 800 + i)) DeleteImage(STORYBOARD_THUMBS + 800 + i);
									}
									GetProjectThumbnails();
								}

								if (projectbank_imageid[i] != BOX_CLICK_HERE)
								{
									if (ImageExist(STORYBOARD_THUMBS + 800 + i)) DeleteImage(STORYBOARD_THUMBS + 800 + i);
								}
								if (projectbank_image[i] == "")
								{
									//Click Here.
									projectbank_imageid[i] = BOX_CLICK_HERE;
								}
								else
								{
									//PE: Load in thumb.
									image_setlegacyimageloading(true);
									LoadImageSize((char *)projectbank_image[i].c_str(), STORYBOARD_THUMBS + 800 + i, 512, 288);
									image_setlegacyimageloading(false);
									if (!ImageExist(STORYBOARD_THUMBS + 800 + i))
									{
										//Fail click here.
										projectbank_imageid[i] = BOX_CLICK_HERE;
									}
									else
									{
										projectbank_imageid[i] = STORYBOARD_THUMBS + 800 + i;
									}
								}
							}

							if (!pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
							{
								ImGui::PushID(564231 + i);
								int TextureID = BOX_CLICK_HERE;
								if (ImageExist(projectbank_imageid[i])) TextureID = projectbank_imageid[i];

								if (current_project_selected == projectbank_list[i])
								{
									//PE: Highlight by name.
									current_project_id = i; //PE: If adding new project, make sure current_project_id match name.
									if (1)
									{
										ImGuiWindow* window = ImGui::GetCurrentWindow();
										ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
										ImVec2 padding = { 1.0, 1.0 };
										const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
										window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}

								}
								if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
								{
									current_project_selected = projectbank_list[i];
									current_project_id = i;
								}
								ImGui::PopID();

								if (ImGui::IsItemHovered())
								{
									if (ImGui::IsMouseDoubleClicked(0))
									{
										current_project_selected = projectbank_list[i];
										current_project_id = i;
										bTriggerLoad = true;
									}
								}
								ImGui::SetWindowFontScale(1.4);
								if (ImGui::StyleButton(projectbank_list[i].c_str(), ImVec2(colwidth, 0.0f)))
								{
									current_project_selected = projectbank_list[i];
									current_project_id = i;
									//bTriggerLoad = true;
								}
								//PE: Need pencil for edit.
								ImGui::SameLine();
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(-35.0, 3.0));
								ImGui::SetItemAllowOverlap();
								ImGui::PushID(464231 + i);
								if (ImGui::ImgBtn(TOOL_PENCIL, ImVec2(22, 22), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
								{
									current_project_selected = projectbank_list[i];
									current_project_id = i;
									bTriggerLoad = true;
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Edit The Game Project");
								ImGui::PopID();

								ImGui::SetWindowFontScale(1.0);
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
								ImGui::NextColumn();

							}
						}
					}

					// Sort the projects initially.
					if (bSortProjects)
					{
						bSortProjects = false;
						SortProjects(iProjectSortMode);
						bResetProjectThumbnails = true;
					}

					//PE: No trigger load here, moved to other column.
					if (bTriggerLoad)
					{
						//Load and start storyboard.
						TriggerLoadGameProject = current_project_selected.c_str();
						bWelcomeScreen_Window = false;
						bStoryboardWindow = true;
						if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
					}

					ImGui::Columns(1);
					ImGui::Indent(-2);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndChild();

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}
					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "My Games");


				if (1) //Disable all other tabs.
				{
					ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
				}

				ImGui::SetWindowFontScale(1.2);

				ImGui::PopItemFlag(); //PE: Enable this tab.

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" Tutorials ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" Tutorials ", false).x + gui.Style.ItemInnerSpacing.x;
				if (ImGui::BeginTabItem(" Tutorials ", NULL, tabflags))
				{
					char* tutorial_order[] = { "9901-introduction-video.mp4", "0101-getting-started.mp4", "0701-game-storyboard.mp4", "0501-terrain-generator.mp4", "0502-terrain-height-maps.mp4", "0201-level-editor.mp4", "0202-particle-editor.mp4", "0203-animation-library.mp4", "0301-object-library.mp4" , "0801-character-creator.mp4" ,"0601-terrain-editing.mp4", "0401-objects-grouping.mp4", "0901-behaviour-ai.mp4", "0902-behaviour-demos-1.mp4",  "0903-behaviour-demos-2.mp4" };

					iCurrentOpenTab = 3;

					ImGui::SetWindowFontScale(1.0);
					ImGui::BeginChild("##MyGamesTutorialsForWelcome", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(2);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
					float total_width = ImGui::GetContentRegionAvailWidth();
					ImGui::Columns(3, "MyGamesTutorialsForWelcomecolumns", false);  //false no border

					float colwidth = ImGui::GetContentRegionAvailWidth(); //padding.
					float fRatio = colwidth / 512.0f;
					ImVec2 iThumbSize = { (float)512.0*fRatio, (float)288.0*fRatio };
					int old_current_tutorial_id = current_tutorial_id;
					for (int i = 0; i < ARRAYSIZE(tutorial_order); i++)
					{
						int iTutorialID = -1;
						cstr cTitle = "";

						//PE: Find next tutorial.
						if (tutorial_videos.size() > 0)
						{
							int il = 0;
							for (std::map<std::string, std::string>::iterator it = tutorial_videos.begin(); it != tutorial_videos.end(); ++it)
							{
								if (it->first.length() > 0)
								{
									if (strstr(it->second.c_str(), tutorial_order[i]) != 0)
									{
										cTitle = it->first.c_str();
										cSmallVideoPath = it->second.c_str();
										iTutorialID = il;
										break;
									}
								}
								il++;
							}
						}

						if (iTutorialID >= 0)
						{
							//PE: Always have a selection.
							if (current_tutorial_selected == "")
							{
								current_tutorial_id = iTutorialID;
								current_tutorial_selected = tutorial_order[i];
							}

							SmallTutorialThumbLoad(iTutorialID);

							if (ImageExist(iSmallVideoThumbnail[iTutorialID]))
							{
								ImGui::PushID(565231 + i);
								int TextureID = iSmallVideoThumbnail[iTutorialID];

								if (current_tutorial_selected == tutorial_order[i])
								{
									//PE: Highlight by name.
									current_tutorial_id = iTutorialID;
									if (1)
									{
										ImGuiWindow* window = ImGui::GetCurrentWindow();
										ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
										ImVec2 padding = { 1.0, 1.0 };
										const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + iThumbSize);
										window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
									}

								}
								if (ImGui::ImgBtn(TextureID, iThumbSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
								{
									current_tutorial_selected = tutorial_order[i];
									current_tutorial_id = iTutorialID;
									if (old_current_tutorial_id >= 0)
									{
										iStopAndFreeThisVideo = old_current_tutorial_id;
									}

								}
								ImGui::PopID();

								ImGui::SetWindowFontScale(1.4);

								char *find = strstr(cTitle.Get(), "-");
								if (find) find++;
								if (find && find[0] == ' ') find++;
								else find = cTitle.Get();

								if (ImGui::StyleButton(find, ImVec2(colwidth, 0.0f)))
								{
									if (old_current_tutorial_id >= 0)
									{
										iStopAndFreeThisVideo = old_current_tutorial_id;
									}

									current_tutorial_selected = tutorial_order[i];
									current_tutorial_id = iTutorialID;
								}

								ImGui::SetWindowFontScale(1.0);
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
								ImGui::NextColumn();

							}
						}
					}

					ImGui::Columns(1);
					ImGui::Indent(-2);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) 
					{
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndChild();

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) 
					{
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}
					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "Tutorials");

				ImGui::SetWindowFontScale(1.2);

				// TRUSTED UDER ACCOUNT ID
				bool bOnlyTrustedSteamUsersForNow = false;
				#ifndef GGMAXEDU
				uint64 uAccountID = 0;
				if (SteamUGC())
				{
					// some concerns raised in the community of TGCs association with potential piracy - one bad apple and all that - sorry everyone!
					uAccountID = SteamUser()->GetSteamID().GetAccountID();
					if (uAccountID == 58134713 || uAccountID == 6704278)
					{
						// basically just means Steve :)
						bOnlyTrustedSteamUsersForNow = true;
					}
				}
				#endif

				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" User Guide ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" User Guide ", false).x + gui.Style.ItemInnerSpacing.x;
				if (ImGui::BeginTabItem(" User Guide ", NULL, tabflags))
				{
					iCurrentOpenTab = 4;
					ImGui::Text("");
					ImGui::SetWindowFontScale(2.0);
					ImGui::TextCenter("GameGuru MAX User Guide");
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
					ImGui::Text("");
					float descwidth = ImGui::GetContentRegionAvail().x * 0.6f;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5)- (descwidth*0.5), 0));

					float oldChildBorderSize = gui.Style.ChildBorderSize;
					gui.Style.ChildBorderSize = 10.0;
					ImVec2 oldFramePadding = gui.Style.FramePadding;
					gui.Style.FramePadding = ImVec2(10.0,10.0);
					float guide_height = tab_box_height - 380.0;
					if (guide_height < 375.0) guide_height = 375.0;
					ImGui::BeginChild("##MyUserGuideForWelcome", ImVec2(descwidth - 5.0, guide_height), true, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(10);
					ImGui::Text("");
					ImGui::SetWindowFontScale(2.0);
					ImGui::TextWrapped("The GameGuru MAX user guide is a comprehensive guide to the software.");
					ImGui::Text("");
					ImGui::TextWrapped("Provided as a simple PDF file, you can easily find the advice and help you are looking for.");
					ImGui::Text("");
					ImGui::TextWrapped("We hope this user guide offers the best advice to new and experienced game developers.");
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
					ImGui::Indent(-10);
					ImGui::EndChild();

					gui.Style.ChildBorderSize = oldChildBorderSize;
					gui.Style.FramePadding = oldFramePadding;
					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max))
				{
					#ifndef GGMAXEDU
					if (uAccountID > 0)
					{
						char pExtraUserGuideTip[256];
						sprintf(pExtraUserGuideTip, "User Guide (ID:%d)", uAccountID);
						ImGui::SetTooltip("%s", pExtraUserGuideTip);
					}
					else
					#endif
					{
						ImGui::SetTooltip("%s", "User Guide");
					}
				}

				ImGui::SetWindowFontScale(1.2);

				#ifndef GGMAXEDU
				//
				// Live Streams & Social
				//
				rect.Min = TabStartPos;
				rect.Max = rect.Min + ImGui::TabItemCalcSize(" Live Streams & Social ", false);
				TabStartPos.x += ImGui::TabItemCalcSize(" Live Streams & Social ", false).x + gui.Style.ItemInnerSpacing.x;
				if (ImGui::BeginTabItem(" Live Streams & Social ", NULL, tabflags))
				{
					ImGui::Text("");
					ImGui::SetWindowFontScale(2.0);
					ImGui::TextCenter("GameGuru MAX Socials");
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
					ImGui::Text("");

					//const char* items_social_header[] = { "OFFICIAL FORUMS","TWITTER", "INSTAGRAM", "TIKTOK" , "FACEBOOK","DISCORD" };
					//const char* items_social_header[] = { "OFFICIAL FORUMS", "TIKTOK" , "FACEBOOK", "DISCORD" };
					const char* items_social_header[] = { "OFFICIAL FORUMS", "FACEBOOK", "DISCORD" };
					const char* items_social_desc[] = {
						"The online forums are a great place to learn and ask questions",
						//"Keep up to date with announcements by following our official Twitter account",
						//"Follow us on Instagram to see new images and news",
						//"Watch vidoes and updates on our official TikTok channel" ,
						"Follow us at our official GameGuru MAX Facebook page",
						"Join the conversation with other users of GameGuru MAX on Discord" };
					const char* items_social_link[] = {
						"https://bit.ly/MAXForum",
						//"https://bit.ly/MAXTwitter",
						//"https://bit.ly/MAXInstagram",
						//"https://bit.ly/MAXTikTok" ,
						"https://bit.ly/MAXMeta",
						"https://bit.ly/MAX_Discord" };
					//const int items_social_thumb[] = { HUB_FORUM,HUB_TWITTER, HUB_INSTAGRAM, HUB_TIKTOK,HUB_FACEBOOK,HUB_DISCORD };
					//const int items_social_thumb[] = { HUB_FORUM, HUB_TIKTOK, HUB_FACEBOOK, HUB_DISCORD };
					const int items_social_thumb[] = { HUB_FORUM, HUB_FACEBOOK, HUB_DISCORD };

					iCurrentOpenTab = 5;

					ImGui::SetWindowFontScale(1.0);
					//ImVec2 vWidthOfSocialsArea = ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height);
					//ImVec2 vWidthOfSocialsArea = ImVec2((ImGui::GetContentRegionAvail().x*0.66f) - 2.0, tab_box_height);
					ImVec2 vWidthOfSocialsArea = ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height);
					//float fIntendAmount = (ImGui::GetContentRegionAvail().x*0.33f) / 2.0f;
					float fIntendAmount = 0.0f;
					ImGui::Indent(fIntendAmount);
					ImGui::BeginChild("##MySocialsForWelcome", vWidthOfSocialsArea, false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
					ImGui::Indent(2);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
					float total_width = ImGui::GetContentRegionAvailWidth();
					//ImGui::Columns(3, "MySocialsForWelcomecolumns", false);  //false no border
					//ImGui::Columns(2, "MySocialsForWelcomecolumns", false);  //false no border
					ImGui::Columns(3, "MySocialsForWelcomecolumns", false);  //false no border

					float colwidth = ImGui::GetContentRegionAvailWidth(); //padding.
					float fRatio = colwidth / 512.0f;
					ImVec2 iThumbSize = { (float)512.0*fRatio, (float)288.0*fRatio };
					
					char child[MAX_PATH];
					for (int i = 0; i < IM_ARRAYSIZE(items_social_thumb); i++)
					{
						sprintf(child, "##JustaSocialFrame%d", i);
						ImGui::BeginChild(child, ImVec2(iThumbSize.x-8.0, iThumbSize.x - 60.0), true, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);

						ImGui::SetWindowFontScale(1.6);
						ImGui::TextCenter(items_social_header[i]);
						ImGui::SetWindowFontScale(1.0);

						int TextureID = items_social_thumb[i];
						if (!ImageExist(TextureID))
						{
							TextureID = BOX_CLICK_HERE;
						}

						ImGui::PushID(554231 + i);
						float wthumb = iThumbSize.x - 120.0;
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5)-(wthumb*0.5)-3.0, 0.0f));
						if (ImGui::ImgBtn(TextureID, ImVec2(wthumb, wthumb), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false, false, true))
						{
							ExecuteFile( (LPSTR) items_social_link[i], "", "", 0);
						}
						ImGui::PopID();

						ImGui::EndChild();

						ImGui::SetWindowFontScale(1.2);
						ImGui::TextWrapped(items_social_desc[i]);
						ImGui::SetWindowFontScale(1.0);

						ImGui::SetWindowFontScale(1.0);
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
						ImGui::NextColumn();
					}

					ImGui::Columns(1);
					ImGui::Indent(-2);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}

					ImGui::EndChild();
					ImGui::Indent(-fIntendAmount);

					if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
						//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
						ImGui::Text("");
						ImGui::Text("");
						ImGui::Text("");
					}


					ImGui::EndTabItem();
				}
				if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "Live Streams & Social");

				//
				// Workshop Uploader and Workshop Viewer
				//
				if (g_bWorkshopAvailable == true && bOnlyTrustedSteamUsersForNow == true)
				{
					// For Workshop Uploader Trusted Users
					rect.Min = TabStartPos;
					rect.Max = rect.Min + ImGui::TabItemCalcSize(" Workshop Uploader ", false);
					TabStartPos.x += ImGui::TabItemCalcSize(" Workshop Uploader ", false).x + gui.Style.ItemInnerSpacing.x;
					if (ImGui::BeginTabItem(" Workshop Uploader ", NULL, tabflags))
					{
						iCurrentOpenTab = 6;
						ImGui::Text("");
						ImGui::SetWindowFontScale(2.0);
						ImGui::TextCenter("Your Uploaded Workshop Items");
						ImGui::SetWindowFontScale(1.0);
						ImGui::Text("");
						ImGui::Text("");

						if (SteamUGC())
						{
							if (g_bStillDownloadingThings == false)
							{
								// show list of existing workshop items as buttons
								ImGui::SetWindowFontScale(1.0);
								ImGui::BeginChild("##MyOwnWorkshopItems", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height - 250.0f), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
								float half_total_width = ImGui::GetContentRegionAvailWidth() / 2.0f;
								ImGui::Indent(half_total_width / 2.0f);
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
								for (int i = 0; i < g_workshopItemsList.size(); i++)
								{
									if (_atoi64(g_workshopItemsList[i].sSteamUserAccountID.Get()) == SteamUser()->GetSteamID().GetAccountID())
									{
										char pWorkshipItemName[MAX_PATH];
										sprintf(pWorkshipItemName, g_workshopItemsList[i].sName.Get());
										if (ImGui::StyleButton(pWorkshipItemName, ImVec2(half_total_width, 0)))
										{
											// select existing workshop item to edit
											g_currentWorkshopItem = g_workshopItemsList[i];
											g_iCurrentMediaTypeForWorkshopItem = workshop_getvaluefromtype(g_currentWorkshopItem.sMediaType.Get());
											g_iSelectedExistingWorkshopItem = i;
											extern int g_iIconImageInProperties;
											g_iIconImageInProperties = 0;
										}
										if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to edit this workshop item and submit an update");
									}
								}

								// show "add new item" button to start creating a new one
								if (ImGui::StyleButton("Add New Item", ImVec2(half_total_width, 0)))
								{
									// select new workshop item to create
									g_iSelectedExistingWorkshopItem = -1;
									workshop_new_item();
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to start a new workshop item submission of your own creation");

								// end of main Workshop tab page
								ImGui::Indent(-half_total_width / 2.0f);
								ImGui::EndChild();

								// Instructions for Workshop Item
								ImGui::SetWindowFontScale(1.25);
								ImGui::Text("");
								ImGui::TextCenter("From here you can add and edit your own workshop items for submission to the Steam Workshop Community");
								ImGui::TextCenter("in the form of game ready assets for the Asset Libraries and can only add and edit items when you");
								ImGui::TextCenter("are logged into your Steam client account and you agree to the workshop terms of service.");
								ImGui::Indent(half_total_width / 2.0f);
								ImGui::Text("");
								if (ImGui::StyleButton("Steam Workshop Terms Of Service", ImVec2(half_total_width, 0)))
								{
									ExecuteFile("https://steamcommunity.com/sharedfiles/workshoplegalagreement", "", "", false);
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Go to the Steam Workshop Terms of Service page");
								ImGui::Indent(-half_total_width / 2.0f);
							}
							else
							{
								ImGui::Text("");
								ImGui::SetWindowFontScale(1.25);
								ImGui::TextCenter("Steam Client is currently downloading workshop items...");
								ImGui::Text("");
							}
						}
						else
						{
							ImGui::Text("");
							ImGui::SetWindowFontScale(1.25);
							ImGui::TextCenter("You must log into your Steam Client Account in order to submit Workshop items");
							ImGui::Text("");
						}
						ImGui::EndTabItem();
					}
					if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "The Workshop Item uploader enables game assets to be submitted to the Steam Workshop Community");
				}
				if (g_bWorkshopAvailable == true)
				{
					// For Workshop Viewer
					rect.Min = TabStartPos;
					rect.Max = rect.Min + ImGui::TabItemCalcSize(" Workshop ", false);
					TabStartPos.x += ImGui::TabItemCalcSize(" Workshop ", false).x + gui.Style.ItemInnerSpacing.x;
					if (ImGui::BeginTabItem(" Workshop ", NULL, tabflags))
					{
						iCurrentOpenTab = 7;
						ImGui::Text("");
						ImGui::SetWindowFontScale(2.0);
						ImGui::TextCenter("Your Workshop Items");
						ImGui::SetWindowFontScale(1.0);
						ImGui::Text("");
						ImGui::Text("");
						if (SteamUGC())
						{
							extern bool g_bUpdateWorkshopDownloads;
							if (g_bStillDownloadingThingsWithDelay == true)
							{
								extern std::vector<cstr> g_sStillDownloadingLog;
								extern int g_iStillDownloadingLogCount;
								if (Timer() > g_iStillDownloadingThingsWithDelayTimer + 1000 && g_sStillDownloadingLog.size() == 0 )
								{
									g_bStillDownloadingThingsWithDelay = false;
									g_iStillDownloadingLogCount = 0;
								}
							}
							if (g_bStillDownloadingThingsWithDelay == false && g_bUpdateWorkshopDownloads == false && g_bUpdateWorkshopItemList == false )
							{
								// show list of existing workshop items as buttons
								ImGui::SetWindowFontScale(1.0);
								ImGui::BeginChild("##MyOwnWorkshopLineItems", ImVec2(ImGui::GetContentRegionAvail().x - 2.0, tab_box_height - 250.0f), false, iGenralWindowsFlags | ImGuiWindowFlags_NoSavedSettings);
								float half_total_width = ImGui::GetContentRegionAvailWidth() / 2.0f;
								ImGui::Indent(half_total_width / 2.0f);
								ImVec2 alignment = ImGui::GetCursorPos();
								ImGui::Text("Title");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImVec2(alignment.x, ImGui::GetCursorPos().y) + ImVec2(400, 0));
								ImGui::Text("Files");
								ImGui::SameLine();
								ImGui::SetCursorPos(ImVec2(alignment.x, ImGui::GetCursorPos().y) + ImVec2(490, 0));
								ImGui::Text("Date");
								ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 6));
								for (int i = 0; i < g_workshopItemsList.size(); i++)
								{
									char p64BitNumber[_MAX_U64TOSTR_BASE10_COUNT];
									_ui64toa(g_workshopItemsList[i].nPublishedFileId, p64BitNumber, 10);
									char pWorkshipItemLine[MAX_PATH];
									sprintf(pWorkshipItemLine, "%s : %s", p64BitNumber, g_workshopItemsList[i].sName.Get());
									ImGui::Text(pWorkshipItemLine);
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(alignment.x,ImGui::GetCursorPos().y) + ImVec2(400,0));
									ImGui::Text(cstr(g_workshopItemsList[i].iNumberOfFilesInWorkshopItem).Get());
									ImGui::SameLine();
									ImGui::SetCursorPos(ImVec2(alignment.x, ImGui::GetCursorPos().y) + ImVec2(490, 0));
									ImGui::Text(cstr(g_workshopItemsList[i].sLatestDateOfItem).Get());
								}

								// show "add new item" button to start creating a new one
								ImGui::Text("");
								extern bool g_bRequireRestartAfterUnsubByForce;
								if (g_bRequireRestartAfterUnsubByForce==false)
								{
									if (ImGui::StyleButton("Update Workshop Items", ImVec2(half_total_width, 0)))
									{
										// delete local files copy so can get new items from Steam
										extern bool g_bUpdateWorkshopDownloadsAlwaysPerformOnce;
										g_bUpdateWorkshopDownloadsAlwaysPerformOnce = true;
										g_bStillDownloadingThings = true;
										g_bStillDownloadingThingsWithDelay = true;
										g_iStillDownloadingThingsWithDelayTimer = Timer();
										g_bUpdateWorkshopItemList = true;
										g_iUnsubscribeByForce = 1;
										g_bRequireRestartAfterUnsubByForce = true;
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Click to refresh all trusted workshop items (NOTE: Allow the system some time to auto-update after using this button)");
								}
								else
								{
									if (g_iUnsubscribeByForce > 0)
									{
										ImGui::TextCenter("PERFORMING FULL REFRESH OF TRUSTED WORKSHOP ITEMS");
									}
									else
									{
										ImGui::TextCenter("RELAUNCH GAMEGURU MAX TO START WORKSHOP ITEMS REFRESH");
									}
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Unsubscribing and resubscribing allows for a complete workshop items refresh");
								}

								// end of main Workshop tab page
								ImGui::Indent(-half_total_width / 2.0f);
								ImGui::EndChild();

								// Instructions for Workshop Item
								ImGui::SetWindowFontScale(1.25);
								ImGui::Text("");
								ImGui::TextCenter("From here you can view all the workshop items you are subscribed to in the Steam Workshop Community");
								ImGui::TextCenter("in the form of game ready assets for the Asset Libraries and can only view and receive updates for");
								ImGui::TextCenter("these when you are logged into your Steam client account.");
							}
							else
							{
								ImGui::Text("");
								ImGui::SetWindowFontScale(1.25);
								extern std::vector<cstr> g_sStillDownloadingLog;
								extern std::vector<cstr> g_sStillDownloadingLogTitle;
								if (g_sStillDownloadingLog.size() > 0)
								{
									ImGui::TextCenter("...currently downloading workshop items...");
									ImGui::Text("");
									static int iPauseOnEachInMS = 10;
									extern int g_iStillDownloadingLogCount;
									if (g_sStillDownloadingLog.size() > g_iStillDownloadingLogCount)
									{
										g_iStillDownloadingLogCount = g_sStillDownloadingLog.size();
										if (g_iStillDownloadingLogCount > 100)
											iPauseOnEachInMS = 10;
										else
										{
											if (g_iStillDownloadingLogCount > 10)
												iPauseOnEachInMS = 100;
											else
												iPauseOnEachInMS = 500;
										}
									}
									int iLastOne = g_sStillDownloadingLog.size() - 1;
									float fProgress = ((float)g_iStillDownloadingLogCount - (float)g_sStillDownloadingLog.size()) / (float)g_iStillDownloadingLogCount;
									if (fProgress > 1.0f) fProgress = 1.0f;
									int iTotalWidthOfArea = ImGui::GetContentRegionAvail().x;
									ImGui::Indent((iTotalWidthOfArea - 500) / 2.0f);
									ImGui::TextCenter(g_sStillDownloadingLogTitle[iLastOne].Get());
									ImGui::ProgressBar(fProgress, ImVec2(500, 26), g_sStillDownloadingLog[iLastOne].Get());
									ImGui::Indent(-((iTotalWidthOfArea - 500) / 2.0f));
									if (g_bStillDownloadingThingsWithDelay == true)
									{
										if (Timer() > g_iStillDownloadingThingsWithDelayTimer + iPauseOnEachInMS)
										{
											g_iStillDownloadingThingsWithDelayTimer = Timer();
											g_sStillDownloadingLog.pop_back();
											g_sStillDownloadingLogTitle.pop_back();
										}
									}
								}
								else
								{
									ImGui::TextCenter("...currently checking workshop items...");
									ImGui::Text("");
								}
								ImGui::Text("");
							}
						}
						else
						{
							ImGui::Text("");
							ImGui::SetWindowFontScale(1.25);
							ImGui::TextCenter("You must log into your Steam Client Account in order to view your Workshop items");
							ImGui::Text("");
						}							
						ImGui::EndTabItem();
					}
					if (ImGui::IsMouseHoveringRect(rect.Min, rect.Max)) ImGui::SetTooltip("%s", "The Workshop Area shows all the workshop items you are manually and automatically subscribed to");
				}
				#endif

				// end of all tabs
				ImGui::EndTabBar();
			}
			ImGui::SetWindowFontScale(1.0);

			//#############################
			//######## SWAP Column ########
			//#############################

			ImGui::NextColumn();
			ImGui::Text("");

			float fContentWidth = ImGui::GetContentRegionAvailWidth() - 10.0f;
			//static float WelcomeFrameHeight = ImGui::GetWindowSize().y - 82.0f - ImGui::GetCursorPosY(); //76.0 , 72.0
			float WelcomeFrameHeight = ImGui::GetWindowSize().y - 82.0f - ImGui::GetCursorPosY(); //76.0 , 72.0
			ImGui::BeginChild("##JustaFrameWelcome", ImVec2(fContentWidth+4.0, WelcomeFrameHeight), true, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
			ImGui::Indent(2);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetCursorPosY() + 3.0));

			float fRatio = 288.0f / 512.0f;
			float right_margin = 9.0;
			ImVec2 vPreviewSize = { (fContentWidth - right_margin) , (fContentWidth - right_margin) * fRatio };
			float fImageWidth = 460;
			float fImageHeight = 215;
			
			if (iCurrentOpenTab == 4)
			{
				int iTextureID = HUB_USERGUIDE;
				if (!ImageExist(iTextureID)) iTextureID = WELCOME_FILLERROUNDED;

				ImGui::SetWindowFontScale(1.0);
				if (iTextureID > 0)
				{
					if (ImGui::ImgBtn(iTextureID, ImVec2(vPreviewSize.x, vPreviewSize.x + 17.0f), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						//ExecuteFile("https://gameguru-max.document360.io/docs/test-topic", "", "", 0);
						//ExecuteFile("https://bit.ly/MAXUserGuide", "", "", 0);
						// User guide has been moved to offline only
						ExecuteFile("..\\Guides\\User Manual\\GameGuru MAX - User Guide.pdf", "", "", 0);
					}
				}
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.2);

			}
			else if (iCurrentOpenTab == 5)
			{
				float image_size_sub_x = 310.0;
				if (vPreviewSize.x - image_size_sub_x < 250.0) image_size_sub_x += vPreviewSize.x - image_size_sub_x- 250.0;
				int iTextureID = HUB_WEBSITE;
				if (!ImageExist(iTextureID)) iTextureID = WELCOME_FILLERROUNDED;
				float ratio = 394.0 / 700.0;
				ImGui::SetWindowFontScale(1.0);
				if (iTextureID > 0)
				{
					ImGui::SetWindowFontScale(1.4);
					ImGui::TextCenter("Official Website");
					ImGui::SetWindowFontScale(1.0);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x*0.5, 0.0));
					if (ImGui::ImgBtn(iTextureID, ImVec2(vPreviewSize.x - image_size_sub_x, (vPreviewSize.x- image_size_sub_x) * ratio), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						ExecuteFile("https://bit.ly/MAXWebsite", "", "", 0);
					}
					ImGui::SetWindowFontScale(1.4);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x*0.5, 0.0));
					if (ImGui::StyleButton("Click Here to Visit The Website", ImVec2(vPreviewSize.x - image_size_sub_x, 0)))
					{
						/*ExecuteFile("https://www.game-guru.com/max", "", "", 0);*/
						ExecuteFile("https://bit.ly/MAXWebsite", "", "", 0);
					}
					ImGui::SetWindowFontScale(1.0);
					ImGui::Text("");
				}

				iTextureID = HUB_LIVEBROADCAST;
				if (!ImageExist(iTextureID)) iTextureID = WELCOME_FILLERROUNDED;

				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Live Stream");
				ImGui::SetWindowFontScale(1.0);
				if (iTextureID > 0)
				{
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x*0.5, 0.0));
					if (ImGui::ImgBtn(iTextureID, ImVec2(vPreviewSize.x - image_size_sub_x, (vPreviewSize.x - image_size_sub_x) * ratio), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						ExecuteFile("https://bit.ly/MAXYouTubeChannel", "", "", 0);
					}
				}
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);

				cstr desc = "Join us live and ask your burning questions!";
				{
					ImGui::Indent(2);
					ImVec2 cp = ImGui::GetCursorPos();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
					ImGui::BeginChild("##JustaFrameForLiveBroadcastDescription", ImVec2(fContentWidth-8.0, WelcomeFrameHeight - cp.y - 4.0), false, ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
					ImGui::TextCenter(desc.Get());
					ImGui::Text("");
					ImGui::PopStyleVar(2);
					ImGui::EndChild();
					ImGui::Indent(-2);
				}
				ImGui::SetWindowFontScale(1.2);
			}
			#ifndef GGMAXEDU
			else if (iCurrentOpenTab == 6)
			{
				float image_size_sub_x = 350;
				if (vPreviewSize.x - image_size_sub_x < 250.0) image_size_sub_x += vPreviewSize.x - image_size_sub_x - 250.0;
				float ratio = 1.0f;
				ImGui::SetWindowFontScale(1.0);
				if (1)
				{
					// title
					ImGui::SetWindowFontScale(1.4);
					ImGui::TextCenter("Workshop Item Uploader");
					ImGui::Text("");
					float element_overall_width = vPreviewSize.x - image_size_sub_x;

					// image
					ImGui::SetWindowFontScale(1.0);
					ImGui::TextCenter("Workshop Item Image");
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x * 0.5, 0.0));
					int iTextureID = HUB_WORKSHOPITEM;
					extern int g_iIconImageInProperties;
					if (g_iIconImageInProperties == 0)
					{
						g_iIconImageInProperties = g.iconimagebankoffset;
						if (GetImageExistEx(g_iIconImageInProperties) == 1) DeleteImage(g_iIconImageInProperties);
						if (FileExist(g_currentWorkshopItem.sImage.Get()) == 1)
						{
							// actual icon image
							image_setlegacyimageloading(true);
							LoadImage(g_currentWorkshopItem.sImage.Get(), g_iIconImageInProperties);
							image_setlegacyimageloading(false);
						}
						else
						{
							// specified image not found, use placeholder
							g_iIconImageInProperties = HUB_WORKSHOPITEM;
							g_currentWorkshopItem.sImage = "";
						}
					}
					else
					{
						// check if preview image is changed externally
						if (g_currentWorkshopItem.sImage.Len() == 0 && g_iIconImageInProperties != HUB_WORKSHOPITEM)
						{
							g_iIconImageInProperties = HUB_WORKSHOPITEM;
						}

						// use default or specified preview image
						iTextureID = g_iIconImageInProperties;
					}
					if (ImGui::ImgBtn(iTextureID, ImVec2(element_overall_width, element_overall_width * ratio), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						// clicking image itself does nothing (we can absorb button functionality below if we need more item details space)
					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x * 0.5, 0.0));
					ImGui::SetWindowFontScale(1.4);
					cstr UniqueWorkshopItemPreviewImage = "##UniqueWorkshopItemPreviewImage";
					if (iSelectedLibraryStingReturnID == window->GetID(UniqueWorkshopItemPreviewImage.Get()))
					{
						g_currentWorkshopItem.sImage = sSelectedLibrarySting;
						sSelectedLibrarySting = "";
						iSelectedLibraryStingReturnID = -1;
						g_iIconImageInProperties = 0; // force a reload
					}
					if (ImGui::StyleButton("Change Workshop Item Image", ImVec2(element_overall_width, 0)))
					{
						// open file requester to specify non-default workshop item preview image
						sStartLibrarySearchString = "Image";
						bExternal_Entities_Window = true;
						iDisplayLibraryType = 2; //Image
						iLibraryStingReturnToID = window->GetID(UniqueWorkshopItemPreviewImage.Get());
					}
					static char pEntry[MAX_PATH] = "\0";

					// Name
					ImGui::SetWindowFontScale(1.0);
					ImGui::TextCenter("Workshop Item Name");
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x * 0.5, 0.0));
					ImGui::PushItemWidth(element_overall_width);
					strcpy(pEntry, g_currentWorkshopItem.sName.Get());
					if (ImGui::InputText("##WorkshopItemName", pEntry, MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						g_currentWorkshopItem.sName = pEntry;
					}
					ImGui::PopItemWidth();

					// Description
					ImGui::SetWindowFontScale(1.0);
					ImGui::TextCenter("Workshop Item Description");
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x * 0.5, 0.0));
					ImGui::PushItemWidth(element_overall_width);
					strcpy(pEntry, g_currentWorkshopItem.sDesc.Get());
					if (ImGui::InputText("##WorkshopItemDesc", pEntry, MAX_PATH, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						g_currentWorkshopItem.sDesc = pEntry;
					}
					ImGui::PopItemWidth();

					// Disable type and folder for when item is only being updated
					bool bDisableTypeAndFolder = false;
					if (g_iSelectedExistingWorkshopItem != -1)
					{
						ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7, 0.7, 0.7, 1));
						bDisableTypeAndFolder = true;
					}

					// Media for Item
					ImGui::SetWindowFontScale(1.0);
					ImGui::TextCenter("Workshop Item Media Folder");
					extern int g_iCurrentMediaTypeForWorkshopItem;
					int iRememberOldSetting = g_iCurrentMediaTypeForWorkshopItem;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x * 0.5, 0.0));
					ImGui::RadioButton("Audio", &g_iCurrentMediaTypeForWorkshopItem, 1); ImGui::SameLine();
					ImGui::RadioButton("Objects", &g_iCurrentMediaTypeForWorkshopItem, 2); ImGui::SameLine();
					ImGui::RadioButton("Images", &g_iCurrentMediaTypeForWorkshopItem, 3); ImGui::SameLine();
					ImGui::RadioButton("Particles", &g_iCurrentMediaTypeForWorkshopItem, 4); ImGui::SameLine();
					ImGui::RadioButton("Scripts", &g_iCurrentMediaTypeForWorkshopItem, 5); ImGui::SameLine();
					ImGui::RadioButton("Root", &g_iCurrentMediaTypeForWorkshopItem, 6);
					if (bDisableTypeAndFolder == true) g_iCurrentMediaTypeForWorkshopItem = iRememberOldSetting;
					g_currentWorkshopItem.sMediaType = workshop_getmediatypepath(g_iCurrentMediaTypeForWorkshopItem);

					// Media Sub Folder for Item
					ImGui::PushItemWidth(element_overall_width);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(image_size_sub_x * 0.5, 0.0));
					strcpy(pEntry, g_currentWorkshopItem.sMediaFolder.Get());
					int flagforfolder = ImGuiInputTextFlags_EnterReturnsTrue;
					if (bDisableTypeAndFolder == true) flagforfolder |= ImGuiInputTextFlags_ReadOnly;
					if (ImGui::InputText("##WorkshopItemMediaFolder", pEntry, MAX_PATH, flagforfolder))
					{
						g_currentWorkshopItem.sMediaFolder = pEntry;
					}
					if (bDisableTypeAndFolder == true)
					{
						// restore any disabled gadgets
						ImGui::PopStyleColor();
						ImGui::PopStyleVar();
					}
					if (ImGui::IsItemHovered())
					{
						if(bDisableTypeAndFolder==true)
							ImGui::SetTooltip("You can only set the media type and folder when creating a new workshop item");
						else
							ImGui::SetTooltip("First create your media folder in the community folder indicated below, then enter that media folder name here");
					}
					ImGui::PopItemWidth();

					// Show user where their community folder is located
					static char pWorkshopItemMedia[256];
					sprintf(pWorkshopItemMedia, "");
					uint32 uAccountID = 0;
					if (SteamUser())
					{
						uAccountID = SteamUser()->GetSteamID().GetAccountID();
						LPSTR pMediaTypePath = workshop_getmediatypepath(g_iCurrentMediaTypeForWorkshopItem);
						if (stricmp(pMediaTypePath, "root") == NULL)
							sprintf(pWorkshopItemMedia, "Your Root Folder: 'GameGuruMAX\\%s'", g_currentWorkshopItem.sMediaFolder.Get());
						else
							sprintf(pWorkshopItemMedia, "Your Community Folder: '%s\\Community\\%d\\'", pMediaTypePath, uAccountID);
					}
					ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(255, 255, 128, 128));
					ImGui::TextCenter(pWorkshopItemMedia, MAX_PATH, ImGuiInputTextFlags_None);
					ImGui::PopStyleColor(ImGuiCol_Text);
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("When a user views your folder, they will see your Steam Name and not your Steam ID in the UI");

					// progress and user prompt
					extern void workshop_update(bool);
					workshop_update(true);
					ImGui::SetWindowFontScale(1.25);
					ImGui::Text("");
					ImGui::TextCenter(g_WorkshopUserPrompt.Get());
					ImGui::Text("");
				}
				ImGui::SetWindowFontScale(1.2);
			}
			else if (iCurrentOpenTab == 7)
			{
				// ensure steam callbacks are handled
				extern void workshop_update(bool);
				workshop_update(true);
			}
			#endif
			else if (bUseTutorial)
			{
				cstr title = "";
				cstr description = "Testing description.";

				std::map<std::string, std::string>::iterator it;
				int iFind = 0;
				for (it = tutorial_description.begin(); it != tutorial_description.end(); ++it)
				{
					if (current_tutorial_id == iFind) break;
					iFind++;
				}
				if (it != tutorial_description.end()) {
					title = it->first.c_str();
					description = it->second.c_str();
				}
				//ImGui::Indent(10);
				//SmallTutorialVideo(cShowTutorial.Get(), my_combo_itemsp, my_combo_items, iVideoSection);
				SmallTutorialVideo(title.Get(), NULL, 0, SECTION_MAX_HUB);

				//ImGui::Indent(-10);
				if (bLastSmallVideoPlayerMaximized)
				{
					int iTextureID = iSmallVideoThumbnail[current_tutorial_id];
					if (iTextureID > 0)
					{
						if (ImGui::ImgBtn(iTextureID, vPreviewSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
						{
							//Click ?
						}
					}
				}
				ImGui::SetWindowFontScale(1.8);

				char *find = strstr(title.Get(), "-");
				if (find) find++;
				if (find && find[0] == ' ') find++;
				else find = title.Get();

				if (pref.current_style == 25)
				{
					//PE: Only blue style have different color, dont match on other styles.
					ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
					textcol.w = 1.0;
					ImGui::PushStyleColor(ImGuiCol_Text, textcol);
					ImGui::Text(find);
					ImGui::PopStyleColor();
				}
				else
				{
					ImGui::Text(find);
				}
				ImGui::SetWindowFontScale(1.2);

				if (description.Len() > 0)
				{
					if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
					ImGui::Indent(-2);
					ImVec2 cp = ImGui::GetCursorPos();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
					ImGui::BeginChild("##JustaFrameForTutorialDescription", ImVec2(fContentWidth, WelcomeFrameHeight - cp.y - 4.0), false, ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
					ImGui::TextWrapped(description.Get());
					ImGui::PopStyleVar(2);
					ImGui::EndChild();
					ImGui::Indent(2);
					ImGui::SetWindowFontScale(1.2);
				}
				else
				{
					//ImGui::TextWrapped("Description:");
				}

			}
			else if (bUseProject)
			{
				//lpTexture
				//sDisplayName
				int iTextureID = BOX_CLICK_HERE;
				if (ImageExist(projectbank_imageid[current_project_id])) iTextureID = projectbank_imageid[current_project_id];

				if (iTextureID > 0)
				{
					if (current_project_selected.length() > 0)
					{
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
						ImVec2 padding = { 1.0, 1.0 };
						const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + vPreviewSize);
						window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
					}

					if (ImGui::ImgBtn(iTextureID, vPreviewSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
					{
						//Click ?
					}
				}
				ImGui::SetWindowFontScale(1.4);
				float fButWidth = fContentWidth * 0.25 - right_margin;
				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5, 12));
				if (ImGui::StyleButton("Play Game", ImVec2(fButWidth, 0)))
				{
					//PE: Play - Load and start storyboard, also start play process.
					TriggerLoadGameProject = current_project_selected.c_str();
					bWelcomeScreen_Window = false;
					bStoryboardWindow = true;
					iStoryboardExecuteKey = ' ';
					if (current_tutorial_id >= 0)
					{
						iStopAndFreeThisVideo = current_tutorial_id;
					}

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Play The Game");
				ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5 + fButWidth + fButWidth, 12));
				if (ImGui::StyleButton("Edit Game", ImVec2(fButWidth, 0)))
				{
					//PE: Edit - Load and start storyboard.
					TriggerLoadGameProject = current_project_selected.c_str();
					bWelcomeScreen_Window = false;
					bStoryboardWindow = true;
					if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Edit The Game");
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));

				ImGui::SetWindowFontScale(1.8);
				if (pref.current_style == 25)
				{
					//PE: Only blue style have different color, dont match on other styles.
					ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
					textcol.w = 1.0;
					ImGui::PushStyleColor(ImGuiCol_Text, textcol);
					ImGui::Text(current_project_selected.c_str());
					ImGui::PopStyleColor();
				}
				else
				{
					ImGui::Text(current_project_selected.c_str());
				}
				ImGui::SetWindowFontScale(1.2);

				//PE: Need a tmp read of storyboard to get the correct desc...
				static std::string last_current_project_selected = "##";
				static std::string game_description = "";
				static std::string game_developer_description = "";
				if (current_project_selected != last_current_project_selected || bTriggerRereadDescription)
				{
					game_description = "";
					game_developer_description = "";
					if (load_checkproject_storyboard( (char *) current_project_selected.c_str() ))
					{
						game_description = checkproject.game_description;
						game_developer_description = checkproject.game_developer_desc;
					}
					last_current_project_selected = current_project_selected;
					bTriggerRereadDescription = false;
				}
				if (game_description.length() > 0)
				{
					if(bUseFullScreen) ImGui::SetWindowFontScale(1.2);
					ImGui::Indent(-2);
					ImVec2 cp = ImGui::GetCursorPos();
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.f, 0.f));
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
					ImGui::BeginChild("##JustaFrameForDescription", ImVec2(fContentWidth, WelcomeFrameHeight-cp.y-4.0), false, ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
					ImGui::TextWrapped(game_description.c_str());

					if (game_developer_description.length() > 0)
					{
						ImGui::SetWindowFontScale(1.5);
						ImGui::Text("");
						if (pref.current_style == 25)
						{
							ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
							textcol.w = 1.0;
							ImGui::PushStyleColor(ImGuiCol_Text, textcol);
							ImGui::Text("Game Developer");
							ImGui::PopStyleColor();
						}
						else
						{
							ImGui::Text("Game Developer");
						}
						ImGui::SetWindowFontScale(1.2);
						ImGui::Text(game_developer_description.c_str());
					}

					ImGui::PopStyleVar(2);
					ImGui::EndChild();
					ImGui::Indent(2);
					ImGui::SetWindowFontScale(1.2);
				}
			}
			else
			{
				int iFileListEntry = GetEntryFilesListForLibrary(sCurrentGame);
				if (g_LibraryFileList.size() > 0)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + vPreviewSize);

					int iTextureID = GetImageIDFilesListForLibrary(sCurrentGame);
					if (iTextureID > 0)
					{
						if (current_project_selected.length() > 0)
						{
							ImGuiWindow* window = ImGui::GetCurrentWindow();
							ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
							ImVec2 padding = { 1.0, 1.0 };
							const ImRect image_bb((window->DC.CursorPos - padding), window->DC.CursorPos + padding + vPreviewSize);
							window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
						}

						if (ImGui::ImgBtn(iTextureID, vPreviewSize, ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 200), 0, 0, 0, 0, false, false, false))
						{
							//Click ?
						}
					}
					//#### VIDEO START ####
					static int triggerEndVideo = 0;
					static int iVideoTriggerTimer = 0;
					int n = iFileListEntry;

					if (n < g_LibraryFileList.size() && ImGui::IsItemHovered() && iVideoTriggerTimer++ > 30)
					{
						if (iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID))
						{
							float fVideoW = 0;
							float fVideoH = 0;
							float animU = 1.0;
							float animV = 1.0;
							ID3D11ShaderResourceView* lpVideoTexture = NULL;
							lpVideoTexture = GetAnimPointerView(iWelcomeVideoID);
							if (lpVideoTexture != NULL)
							{
								fVideoW = GetAnimWidth(iWelcomeVideoID);
								fVideoH = GetAnimHeight(iWelcomeVideoID);
								SetRenderAnimToImage(iWelcomeVideoID, true);
								animU = GetAnimU(iWelcomeVideoID);
								animV = GetAnimV(iWelcomeVideoID);
								ImVec2 uv0 = ImVec2(0, 0);
								ImVec2 uv1 = ImVec2(animU, animV);
								window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
							}

							float fdone = GetAnimPercentDone(iWelcomeVideoID) / 100.0f;
							if (fdone > 0.5)
								triggerEndVideo = 1;
							if (triggerEndVideo > 0 && (fdone == 0.0f || fdone >= 1.0f))
							{
								iVideoTriggerTimer = 0;
								bRemoveVideoInNextFrame = true;
								triggerEndVideo = 0;
							}
						}
						else
						{
							//Load video.
							std::string sVideoFile = g_LibraryFileList[n].cFile.Get();
							replaceAll(sVideoFile, ".png", ".mp4");
							if (FileExist((LPSTR)sVideoFile.c_str()))
							{
								iWelcomeVideoID = 0;
								for (int i = 1; i <= 32; i++)
								{
									if (AnimationExist(i) == 0) { iWelcomeVideoID = i; break; }
								}

								if (iWelcomeVideoID > 0)
								{
									if (LoadAnimation((LPSTR)sVideoFile.c_str(), iWelcomeVideoID, g.videoprecacheframes, g.videodelayedload, 1) == false)
									{
										iWelcomeVideoID = -999;
									}
									if (iWelcomeVideoID > 0)
									{
										PlaceAnimation(iWelcomeVideoID, -1, -1, -1, -1);
										SetRenderAnimToImage(iWelcomeVideoID, true);
										PlayAnimation(iWelcomeVideoID);
										SetVideoVolume(100);
									}
								}
							}
							else
							{
								iVideoTriggerTimer = 0; //Failed.
								triggerEndVideo = 0;
							}
						}
					}
					else
					{
						if (n < g_LibraryFileList.size() && !ImGui::IsItemHovered())
						{
							if (iVideoTriggerTimer > 0 && iWelcomeVideoID > 0 && AnimationExist(iWelcomeVideoID)) {
								bRemoveVideoInNextFrame = true;
								triggerEndVideo = 0;
							}
							iVideoTriggerTimer = 0;
						}
					}
					//#### VIDEO END ####

					// Project Exists if can get dev description
					extern bool g_bFreeTrialVersion;
					bool bProjectExistsAndValidToUse = false;
					static std::string sDevDescription = "";
					if (iFileListEntry >= 0) 
						if (g_LibraryFileList[iFileListEntry].bProjectExists==true) 
							bProjectExistsAndValidToUse = true;

					// Play and Edit Buttons
					ImGui::SetWindowFontScale(1.4);
					float fButWidth = fContentWidth * 0.25 - right_margin;
					ImVec2 vCurPos = ImGui::GetCursorPos();
					ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5, 12));
					ImVec4 vTextColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
					LPSTR pPlayTextTip = "Play The Game";
					LPSTR pEditTextTip = "Edit The Game";
					if (bProjectExistsAndValidToUse == false)
					{
						if (g_bFreeTrialVersion == true)
						{
							vTextColor = ImVec4(0.9f, 0.9f, 0.9f, 0.5f);
							pPlayTextTip = "Upgrade to the full version to play this demo game";
							pEditTextTip = "Upgrade to the full version to edit this demo game";
						}
					}
					ImGui::PushStyleColor(ImGuiCol_Text, vTextColor);
					if (ImGui::StyleButton("Play Game", ImVec2(fButWidth, 0)))
					{
						if (bProjectExistsAndValidToUse == true)
						{
							bool bUseProjectName = false;
							if (iFileListEntry >= 0)
							{
								if (g_LibraryFileList[iFileListEntry].cProject.Len() > 0)
								{
									if (load_checkproject_storyboard((char *)g_LibraryFileList[iFileListEntry].cProject.Get()))
									{
										//Success use this project name.
										bUseProjectName = true;
									}
								}
							}
							if (bUseProjectName)
							{
								//PE: Launch real standalone, that will return to storyboard when done.
								extern bool g_bCascadeQuitFlag;
								g_bCascadeQuitFlag = true;
								PostQuitMessage(0);
								SetCurrentDirectoryA("..\\");
								char par[MAX_PATH];
								sprintf(par, "project=2%s", g_LibraryFileList[iFileListEntry].cProject.Get());
								ExecuteFile("GameGuruMAX.exe", par, "", 0);
								Sleep(500);
								ExitProcess(0);
							}
							else
							{
								cstr filetoload = cstr("mapbank\\") + sDisplayName + cstr(".fpm");
								strcpy(cDirectOpen, filetoload.Get());
								iLaunchAfterSync = 7; //Direct load.
								iSkibFramesBeforeLaunch = 5;
								bLaunchTestGameAfterLoad = true;
								bWelcomeScreen_Window = false;
								if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
							}
						}
						else
						{
							if (g_bFreeTrialVersion == true)
							{
								extern bool bFreeTrial_Window;
								bFreeTrial_Window = true;
							}
						}
					}
					ImGui::PopStyleColor();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pPlayTextTip);
					ImGui::PushStyleColor(ImGuiCol_Text, vTextColor);
					ImGui::SetCursorPos(vCurPos + ImVec2(fButWidth*0.5 + fButWidth + fButWidth, 12));
					if (ImGui::StyleButton("Edit Game", ImVec2(fButWidth, 0)) || bTriggerEditDemoGame)
					{
						if (bProjectExistsAndValidToUse == true)
						{
							bool bUseProjectName = false;
							if (iFileListEntry >= 0)
							{
								if (g_LibraryFileList[iFileListEntry].cProject.Len() > 0)
								{
									if (load_checkproject_storyboard((char *)g_LibraryFileList[iFileListEntry].cProject.Get()))
									{
										//Success use this project name.
										bUseProjectName = true;
									}
								}
							}
							if (bUseProjectName)
							{
								//PE: Edit - Load and start storyboard.
								TriggerLoadGameProject = g_LibraryFileList[iFileListEntry].cProject.Get();
								bWelcomeScreen_Window = false;
								bStoryboardWindow = true;
								if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
							}
							else
							{
								cstr filetoload = cstr("mapbank\\") + sDisplayName + cstr(".fpm");
								strcpy(cDirectOpen, filetoload.Get());
								iLaunchAfterSync = 7; //Direct load.
								iSkibFramesBeforeLaunch = 5;
								bWelcomeScreen_Window = false;
								if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
							}
						}
						else
						{
							if (g_bFreeTrialVersion == true && bTriggerEditDemoGame == false)
							{
								extern bool bFreeTrial_Window;
								bFreeTrial_Window = true;
							}
						}
						bTriggerEditDemoGame = false;
					}
					ImGui::PopStyleColor();
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pEditTextTip);

					// Project Descriptions and Text
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, 8));
					ImGui::SetWindowFontScale(1.8);
					ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
					textcol.w = 1.0;
					ImGui::PushStyleColor(ImGuiCol_Text, textcol);
					ImGui::Text(sDisplayName.Get());
					ImGui::PopStyleColor();

					ImGui::SetWindowFontScale(1.2);
					if (iFileListEntry >= 0)
					{
						if (g_LibraryFileList[iFileListEntry].cDescription.Len() > 0)
						{
							if (bUseFullScreen) ImGui::SetWindowFontScale(1.5);
							ImGui::TextWrapped(g_LibraryFileList[iFileListEntry].cDescription.Get());
							ImGui::SetWindowFontScale(1.2);
							static cstr sPrevGame = "";
							if (strcmp(sPrevGame.Get(), sCurrentGame.Get()) != 0)
							{
								sDevDescription = "";
								sPrevGame = sCurrentGame;
								if (sCurrentGame.Len() > 0)
								{
									// Extract the game developer description from the project.dat file.
									char projectname[MAX_PATH];
									strcpy(projectname, sCurrentGame.Get());
									projectname[strlen(projectname) - 4] = 0;
									char project[MAX_PATH];
									strcpy(project, "projectbank\\");
									strcat(project, projectname);
									strcat(project, "\\project.dat");
							
									FILE* projectfile = GG_fopen(project, "rb");
									if (projectfile)
									{
										tempProjectData.game_developer_desc[0] = 0;
										size_t size = fread(&tempProjectData, 1, sizeof(tempProjectData), projectfile);
										//Valid pref:
										fclose(projectfile);
										if(strlen(tempProjectData.game_developer_desc) > 0)
											sDevDescription = tempProjectData.game_developer_desc;

										// Text wrapping is saved into the project data, so unwrap it so it can be wrapped by ImGui at larger font sizes.
										for (int i = 0; i < sDevDescription.length(); i++)
										{
											if (sDevDescription[i] == '\n')
											{
												sDevDescription[i] = ' ';
											}
										}
									}
								}
							}
							if (sDevDescription.length() > 0)
							{
								ImGui::Spacing();
								ImGui::SetWindowFontScale(1.8);
								if (pref.current_style == 25)
								{
									ImVec4 textcol = ImGui::GetStyleColorVec4(ImGuiCol_Button);
									textcol.w = 1.0;
									ImGui::PushStyleColor(ImGuiCol_Text, textcol);
									ImGui::Text("Game Developer");
									ImGui::PopStyleColor();
								}
								else
								{
									ImGui::Text("Game Developer");
								}
								ImGui::SetWindowFontScale(1.5f);
								ImGui::TextWrapped(sDevDescription.c_str());
								ImGui::SetWindowFontScale(1.2);
							}
						}
						ImGui::PushStyleColor(ImGuiCol_Text, textcol);
						ImGui::PopStyleColor();
					}
				}
			}

			vPreviewSize = { fContentWidth , fContentWidth * fRatio };


			ImGui::Text("");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), ImGui::GetWindowSize().y - 72.0f));

			ImGui::Indent(-2);
			ImGui::EndChild();

			ImGui::SetWindowFontScale(2.0); //1.4

			if (iCurrentOpenTab == 4)
			{
				if (ImGui::StyleButton("View the User Guide", ImVec2(vPreviewSize.x + 4.0, fFontSize*2.6))) //*2.0
				{
					// User guide has been moved to offline only
					ExecuteFile("..\\Guides\\User Manual\\GameGuru MAX - User Guide.pdf", "", "", 0);
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "View the GameGuru MAX User Guide"); //Weekly Live Stream
			}
			else if (iCurrentOpenTab == 5)
			{
				if (ImGui::StyleButton("Click here to view the GameGuru MAX YouTube Channel", ImVec2(vPreviewSize.x + 4.0, fFontSize*2.6))) //*2.0
				{
					ExecuteFile("https://bit.ly/MAXYouTubeChannel", "", "", 0);
				}
			}
			#ifndef GGMAXEDU
			else if (iCurrentOpenTab == 6)
			{
				char pCheckFinalDestFolderExists[MAX_PATH];
				strcpy(pCheckFinalDestFolderExists, "");
				uint32 uAccountID = 0;
				if (SteamUser())
				{
					uAccountID = SteamUser()->GetSteamID().GetAccountID();
					LPSTR pMediaTypePath = workshop_getmediatypepath(g_iCurrentMediaTypeForWorkshopItem);
					sprintf(pCheckFinalDestFolderExists, "%s\\Community\\%d\\'", pMediaTypePath, uAccountID);
					GG_GetRealPath(pCheckFinalDestFolderExists, 1);
					LPSTR pTitleOfWorkshopButton = "Submit New Item To Workshop";
					if (g_iSelectedExistingWorkshopItem != -1) pTitleOfWorkshopButton = "Update Your Workshop Item";
					if (ImGui::StyleButton(pTitleOfWorkshopButton, ImVec2(vPreviewSize.x + 4.0, fFontSize * 2.6)))
					{
						// submit workshop item
						if (workshop_submit_item_check() == true)
						{
							// perform actual submission of current workshop item
							workshop_submit_item_now();
						}
					}
				}
			}
			#endif
			else
			{
				//Changed to project based.
				if (ImGui::StyleButton("Create a New Game Project", ImVec2(vPreviewSize.x+4.0, fFontSize*2.6))) //*2.0
				{
					strcpy(pref.cLastUsedStoryboardProject, "");
					bStoryboardInitNodes = false; //Just init again.
					bStoryboardFirstRunSetInitPos = false;
					process_storeboard(true); //Init a new project.
					bTriggerSaveAsAfterNewLevel = true;
					bTriggerSaveAs = true;
					strcpy(SaveProjectAsName, "");
					strcpy(SaveProjectAsError, "");
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Create a new game project");

				if (bTriggerSaveAs)
				{
					ImGui::SetWindowFontScale(1.0);
					int iCreateRet = save_create_storyboard_project();
					if (iCreateRet == 1)
					{
						//PE: New project created.
						bWelcomeScreen_Window = false;
						bStoryboardWindow = true;
						if (current_tutorial_id >= 0) iStopAndFreeThisVideo = current_tutorial_id;
					}
					if (iCreateRet == 2)
					{
						bTriggerSaveAsAfterNewLevel = false;
						bTriggerSaveAs = false;
					}
					ImGui::SetWindowFontScale(2.0); //1.4
				}

			}

			ImGui::SetWindowFontScale(1.0);

			//###########################################################
			//#### SWAP TOOL_GOBACK was here "Exit GameGuru MAX Hub" ####
			//###########################################################
			if (projectbank_list.size() > 0)
			{
				bool bTmp = 1 - pref.iDisplayWelcomeScreen;
				float fTextWidth = ImGui::CalcTextSize("Tick to skip GameGuru MAX Hub and continue editing the last game project").x + 20.0f;
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvailWidth() - 10.0) * 0.5) - (fTextWidth * 0.5), 0));
				if (ImGui::Checkbox("Tick to skip GameGuru MAX Hub and continue editing the last game project", &bTmp))
				{
					pref.iDisplayWelcomeScreen = 1 - bTmp;
				}
			}

			ImGui::SetWindowFontScale(1.0);
			ImGui::Columns(1);

			ImGui::Indent(-10);

			bImGuiGotFocus = true;

			if (bDisplayAsModal)
				ImGui::EndPopup();
			else
				ImGui::End();
		}
	}

}

void About_Screen(void)
{
	ImGuiWindowFlags ex_window_flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
	if (refresh_gui_docking == 0)
	{
		if (iAboutLogoType == 2)
			ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 39 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		else
			ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 30 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		bool bAlwaysTrue = true;
		ImGui::Begin("##About##AboutWindow", &bAlwaysTrue, ex_window_flags);
		ImGui::End();
	}
	else if (bAbout_Window)
	{
		if (bAbout_Window_First_Run)
		{
			if (iAboutLogoType == 2)
				ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 39 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
			else
				ImGui::SetNextWindowSize(ImVec2(52 * ImGui::GetFontSize(), 30 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bAbout_Window_First_Run = false;
		}

		ImGui::Begin("##About##AboutWindow", &bAbout_Window, ex_window_flags);

		ImGui::Text("");

		float fRegionWidth = ImGui::GetWindowContentRegionWidth();
		float img_w = ImageWidth(ABOUT_LOGO);
		float img_h = ImageHeight(ABOUT_LOGO);

		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (img_w*0.5), 0.0f));

		ImGui::ImgBtn(ABOUT_LOGO, ImVec2(img_w, img_h), ImVec4(0.0, 0.0, 0.0, 0.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), ImVec4(1.0, 1.0, 1.0, 1.0), 0, 0, 0, 0, false);

		ImGui::TextCenter("");
		char pBuildText[1024];
		sprintf(pBuildText, "Version: %s", g.version_s.Get());
		ImGui::TextCenter(pBuildText);
		ImGui::TextCenter("");

		ImGui::SetWindowFontScale(1.25);
		ImGui::TextCenter("(c) Copyright 2020-2023 The Game Creators Ltd. All Rights Reserved");
		ImGui::SetWindowFontScale(1.0);
		ImGui::TextCenter("GameGuru MAX, TheGameCreators, and their respective logos are trademarks or registred trademarks of The Game Creators Ltd.");
		
		ImGui::Text("");
		ImGui::Text("");
		ImVec2 cp = ImGui::GetCursorPos() + ImVec2(fRegionWidth*0.5 , 0.0f);
		ImGui::SetCursorPos(cp + ImVec2(-200.0f, 0.0f));
		if (ImGui::StyleButton("View Credits", ImVec2(100.0f, 0.0f))) 
		{
			bCredits_Window = true;
			bAbout_Window = false;
			bCredits_Window_First_Run = true;
		}
		ImGui::SameLine();
		ImGui::SetCursorPos(cp + ImVec2(100.0f, 0.0f));
		if (ImGui::StyleButton("OK", ImVec2(100.0f, 0.0f))) 
		{
			bAbout_Window = false;
		}
		ImGui::Text("");

		bImGuiGotFocus = true;

		cstr title = "About";
		float fTextSize = ImGui::CalcTextSize(title.Get()).x;
		float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
		ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		ImGui::End();

		//Render title bar after End. end fill titlebar.
		ImGuiContext& g = *GImGui;
		window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());

	}

	//Credits window.
	if (refresh_gui_docking == 0)
	{
		ImGui::SetNextWindowSize(ImVec2(32 * ImGui::GetFontSize(), 52 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		bool bAlwaysTrue = true;
		ImGui::Begin("##Credits##AboutWindow", &bAlwaysTrue, ex_window_flags);
		ImGui::End();
	}
	else if (bCredits_Window)
	{

		if (bCredits_Window_First_Run)
		{
			ImGui::SetNextWindowSize(ImVec2(32 * ImGui::GetFontSize(), 52 * ImGui::GetFontSize()), ImGuiCond_Always); //ImGuiCond_FirstUseEver
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bCredits_Window_First_Run = false;
		}

		ImGui::Begin("##Credits##AboutWindow", &bCredits_Window, ex_window_flags);

		ImGui::Text("");
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 8.0f));

		float fRegionWidth = ImGui::GetWindowContentRegionWidth();

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Programming Team");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Lee Bamber & Zak Judges");
		ImGui::TextCenter("Preben Eriksen & Paul Johnston");
		ImGui::TextCenter("Maciej Dowbor & Mike Johnson");
		ImGui::Text("");

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Community Contributors");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Synchromesh & Dave Hawkins for Support");
		ImGui::TextCenter("Necrym59 for Behaviors and Design");
		ImGui::TextCenter("Tom from Blood Moon Interactive for User Manual");
		ImGui::TextCenter("GraphiX for Art Support");
		ImGui::Text("");

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Art & Media Team");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Mark Blosser & Peter Jovanovic");
		ImGui::TextCenter("Martin Oliver & Glynn Taylor");
		ImGui::TextCenter("Ugur Gokus & Ispas Gabriela Cristina");
		ImGui::TextCenter("Volkov Studio");
		ImGui::Text("");

		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Design Team");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Lee Bamber & Richard Vanner");
		ImGui::TextCenter("Meash Meakin & Stuart Scott");

		ImGui::Text("");
		ImGui::SetWindowFontScale(1.5);
		ImGui::TextCenter("Wicked Engine");
		ImGui::SetWindowFontScale(1.0);
		ImGui::Text("");
		ImGui::TextCenter("Janos Turanszki");
		ImGui::TextCenter("www.wickedengine.net");

		ImGui::Text("");
		ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((fRegionWidth*0.5) - (100.0f*0.5), 0.0f));
		if (ImGui::StyleButton("OK", ImVec2(100.0f, 0.0f))) {
			bCredits_Window = false;
			bAbout_Window = false;
		}

		bImGuiGotFocus = true;

		cstr title = "GameGuru MAX Credits";
		float fTextSize = ImGui::CalcTextSize(title.Get()).x;
		float xcenter = (ImGui::GetWindowSize().x*0.5) - (fTextSize*0.5);
		ImVec2 titlebar_pos = ImGui::GetWindowPos() + ImVec2(xcenter, 4);
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		ImGui::End();

		//Render title bar after End. end fill titlebar.
		ImGuiContext& g = *GImGui;
		window->DrawList->AddText(g.Font, g.FontSize, titlebar_pos, ImGui::GetColorU32(ImGuiCol_Text), title.Get());

	}

}

#endif //WICKED

#endif //VRTECH

void FixEulerZInverted(float &ax, float &ay, float &az)
{
	if (ax < 0.0f) ax += 360.0f;
	if (ay < 0.0f) ay += 360.0f;
	if (az < 0.0f) az += 360.0f;
	if (ax > 360.0f) ax -= 360.0f;
	if (ay > 360.0f) ay -= 360.0f;
	if (az > 360.0f) az -= 360.0f;
	bool bZFlipped = false, bXFlipped = false, bXDeadPos = false , bZDeadPos = false;
	if (az >= 179.5f && az <= 180.5f) bZFlipped = true; // 180
	if (ax >= 179.5f && ax <= 180.5f) bXFlipped = true; // 180
	if (ax >= 89.5f && ax <= 90.5f) bXDeadPos = true; // 90
	if (az >= 299.5f && az <= 300.5f) bZDeadPos = true; // 300 Got a 299.7 , so lowered to 299.5.
	if (bZFlipped && bXFlipped)
	{
		//PE: When both z and x flipped it count backward, so 180-ay = real Y without x,z.
		ax = 0.0f;
		az = 0.0f;
		ay = (180.0 - ay);
	}
	else if (!bXDeadPos && bZFlipped)
	{
		ax -= 180.0f;
		ay = (180.0 - ay);
		az = 0.0f;
	}
	else if (bXDeadPos && bZDeadPos)
	{
		//Y dont change. z is just moved to x
		ax = az + 90;
		az = 0.0f;
	}
	if (ax < 0.0f) ax += 360.0f;
	if (ay < 0.0f) ay += 360.0f;
	if (az < 0.0f) az += 360.0f;
	if (ax > 360.0f) ax -= 360.0f;
	if (ay > 360.0f) ay -= 360.0f;
	if (az > 360.0f) az -= 360.0f;
	return;
}

void SetStartPositionsForRubberBand(int iActiveObj)
{
	// for multiple objects
	if (g.entityrubberbandlist.size() > 0)
	{
		// for each object in the selection
		for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			int tobj = t.entityelement[e].obj;
			if (tobj > 0)
			{
				if (ObjectExist(tobj) == 1)
				{
					// store starting position and orientation of objects
					g.entityrubberbandlist[i].x = ObjectPositionX(tobj) - ObjectPositionX(iActiveObj);
					g.entityrubberbandlist[i].y = ObjectPositionY(tobj) - ObjectPositionY(iActiveObj);
					g.entityrubberbandlist[i].z = ObjectPositionZ(tobj) - ObjectPositionZ(iActiveObj);
					if (t.entityelement[e].quatmode == 1)
					{
						g.entityrubberbandlist[i].quatAngle = GGQUATERNION(t.entityelement[e].quatx, t.entityelement[e].quaty, t.entityelement[e].quatz, t.entityelement[e].quatw);
					}
					else
					{
						GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
						GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(ObjectAngleX(tobj)));
						GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(ObjectAngleY(tobj)));
						GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(ObjectAngleZ(tobj)));
						g.entityrubberbandlist[i].quatAngle = QuatAroundX * QuatAroundY * QuatAroundZ;
					}
				}
			}
		}
	}
}

void RotateAndMoveRubberBand(int iActiveObj, float fMovedActiveObjectX, float fMovedActiveObjectY, float fMovedActiveObjectZ, GGQUATERNION quatRotationEvent )//float fMovedActiveObjectRX, float fMovedActiveObjectRY, float fMovedActiveObjectRZ)
{
	// for multiple objects
	if (g.entityrubberbandlist.size() > 0)
	{
		// for each object in the selection
		for (int i = 0; i < (int)g.entityrubberbandlist.size(); i++)
		{
			int e = g.entityrubberbandlist[i].e;
			int tobj = t.entityelement[e].obj;
			if (tobj > 0 && t.entityelement[e].editorlock == 0)
			{
				if (ObjectExist(tobj) == 1)
				{
					if (tobj != iActiveObj)
					{
						// this object rotyation quat
						GGQUATERNION quatThisOrientation = g.entityrubberbandlist[i].quatAngle;

						// apply the rotation event to the object angle
						GGQUATERNION quatNewOrientation;
						GGQuaternionMultiply(&quatNewOrientation, &quatThisOrientation, &quatRotationEvent);

						// rotate this object with final quat and get new entity rotation eulers
						RotateObjectQuat(tobj, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);
						
						// final angles
						t.entityelement[e].rx = WrapValue(ObjectAngleX(tobj));
						t.entityelement[e].ry = WrapValue(ObjectAngleY(tobj));
						t.entityelement[e].rz = WrapValue(ObjectAngleZ(tobj));

						// and store the quat
						entity_updatequat(e, quatNewOrientation.x, quatNewOrientation.y, quatNewOrientation.z, quatNewOrientation.w);

						// apply the rotation event to the position
						GGVECTOR3 positionalOffset;
						positionalOffset.x = g.entityrubberbandlist[i].x;
						positionalOffset.y = g.entityrubberbandlist[i].y;
						positionalOffset.z = g.entityrubberbandlist[i].z;
						GGMATRIX matRotatePositions;
						GGMatrixRotationQuaternion(&matRotatePositions, &quatRotationEvent);
						GGVec3TransformCoord(&positionalOffset, &positionalOffset, &matRotatePositions);

						// if object was static, flag that static object moved
						if (t.entityelement[e].staticflag == 1) g.projectmodifiedstatic = 1;

						// put new adjusted positions back
						t.entityelement[e].x = ObjectPositionX(iActiveObj) + positionalOffset.x;
						t.entityelement[e].y = ObjectPositionY(iActiveObj) + positionalOffset.y;
						t.entityelement[e].z = ObjectPositionZ(iActiveObj) + positionalOffset.z;

						// update entity to new offset position if any movement
						t.entityelement[e].x = t.entityelement[e].x + fMovedActiveObjectX;
						t.entityelement[e].y = t.entityelement[e].y + fMovedActiveObjectY;
						t.entityelement[e].z = t.entityelement[e].z + fMovedActiveObjectZ;

						// finally update latest object position
						PositionObject(tobj, t.entityelement[e].x, t.entityelement[e].y, t.entityelement[e].z);

						// update light data for spot
						if (t.entityelement[e].eleprof.usespotlighting)	lighting_refresh();

						// move zones and lights if in group
						widget_movezonesandlights(e);
					}
				}
			}
		}
	}
}

#ifdef WICKEDENGINE
void SetLightShaftState(bool bState)
{
	if (master_renderer) master_renderer->setLightShaftsEnabled(bState);
}
bool GetLightShaftState(void)
{
	if (master_renderer) return master_renderer->getLightShaftsEnabled();
	return false;
}

bool GetLensFlareState()
{
	if (master_renderer) return master_renderer->getLensFlareEnabled();
	return false;
}
void SetLensFlareState(bool bState)
{
	if (master_renderer) master_renderer->setLensFlareEnabled(bState);
}

void editor_toggle_element_vis(bool bIsVisible)
{
	if (t.game.gameisexe == 1) return; //PE: This trigger a 7018 error in standalone. from DrawLogicNodes();

	// hide all markers from view: win zones, player start, image zones etc.
	for (t.e = 1; t.e <= g.entityelementlist; t.e++)
	{
		t.entid = t.entityelement[t.e].bankindex;
		t.obj = t.entityelement[t.e].obj;
		if (t.obj > 0)
		{
			if (ObjectExist(t.obj) == 1)
			{
				if (t.entityprofile[t.entid].ismarker)
				{
					if (bIsVisible)
					{
						ShowObject(t.obj);
					}
					else
					{
						HideObject(t.obj);
					}
				}
			}
		}
	}

	// hide show waypoints
	if (bIsVisible)
	{
		for (t.waypointindex = 1; t.waypointindex <= g.waypointmax; t.waypointindex++)
		{
			t.obj = g.editorwaypointoffset + t.waypointindex;
			if (ObjectExist(t.obj) == 1)
			{
				ShowObject(t.obj);
				t.waypoint[t.waypointindex].active = 1;
			}
		}
	}
	else
	{
		for (t.waypointindex = 1; t.waypointindex <= g.waypointmax; t.waypointindex++)
		{
			t.obj = g.editorwaypointoffset + t.waypointindex;
			if (ObjectExist(t.obj) == 1)
			{
				HideObject(t.obj);
			}
		}

		if (ObjectExist(g.editorwaypointoffset + 0) == 1) 
		{
			HideObject(g.editorwaypointoffset + 0);
		}
	}

	// hide show relational lines
	extern bool g_bDotsAreVisible;
	if (t.showeditorelements)
	{
		if (g_bDotsAreVisible==false)
		{
			DrawLogicNodes(true);
			g_bDotsAreVisible = true;
		}
	}
	else
	{
		if (g_bDotsAreVisible==true)
		{
			DrawLogicNodes(false);
			g_bDotsAreVisible = false;
		}
	}

	//  Deactivate widget if still in effect
	if (!bIsVisible)
	{
		widget_switchoff();

		//  Deactivate floating selection of entity
		if (t.grideditselect != 5 && t.grideditselect != 4)
		{
			if (t.grideditselect != 5) HideObject(t.editor.objectstartindex + 5);
			t.gridentity = 0; t.gridentityposoffground = 0;
			t.gridentityusingsoftauto = 0;
			t.gridentitysurfacesnap = 1 - g.gdisablesurfacesnap;
			#ifdef WICKEDENGINE
			// MAX handles its own positioning system
			t.gridentityautofind = 0;
			#else
			t.gridentityautofind = 1;
			#endif
			t.inputsys.dragoffsetx_f = 0;
			t.inputsys.dragoffsety_f = 0;
		}
	}
	//  Update entity cursor? (delete many of these as it WAS old shroud updater!)
	t.refreshgrideditcursor = 1;

	//  Update clipboard items based on mode
	//editor_cutcopyclearstate();

	//  Waypoint visibility
	if (t.grideditselect != t.lastgrideditselect)
	{
		t.lastgrideditselect = t.grideditselect;
		if (t.grideditselect == 6)
		{
			waypoint_showallpaths();
		}
		else
		{
			if (t.inputsys.dowaypointview == 0)
			{
				waypoint_showallpaths();
			}
			else
			{
				waypoint_hideallpaths();
			}
		}
	}

	// clear any gridentity light if gridentity no longer used
	if (t.gridentity == 0)
	{
		if (t.gridentitywickedlightindex > 0)
		{
			WickedCall_DeleteLight(t.gridentitywickedlightindex);
			t.gridentitywickedlightindex = 0;
		}
	}
}

bool DoTreeNodeEntity(int masterid,bool bMoveCameraToObjectPosition)
{
	for (int i = 1; i < t.entityelement.size(); i++)
	{
		bool bValid = true;
		if (t.entityelement[i].iIsSmarkobjectDummyObj == 1) bValid = false;
		if (bValid)
		{
			if (masterid > 0 && t.entityelement[i].bankindex == masterid || (t.widget.pickedEntityIndex == i && t.gridentity == masterid))
			{
				char cName[512];
				strcpy(cName, t.entityprofileheader[masterid].desc_s.Get());
				if(t.entityelement[i].eleprof.name_s.Len()  > 0 )
					strcpy(cName, t.entityelement[i].eleprof.name_s.Get());

				ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow; //Got sub selections.

				node_flags = ImGuiTreeNodeFlags_Leaf; //No sub selections.

				bool bSelected = false;
				//Find selection here.
				if (bSelected)
					node_flags |= ImGuiTreeNodeFlags_Selected;
				else
					node_flags &= ~ImGuiTreeNodeFlags_Selected;

				ImGui::PushItemWidth(-20.0); //PE: Room for a icon.


				std::string treename = "#" + std::to_string(i);
				if (t.widget.pickedEntityIndex == i && t.gridentity == masterid)
					treename = treename + " (Cursor) " + cName;
				else
					treename = treename + " " + cName;

				bool bAutoGenObject = false;
				if (t.entityelement[i].x == -99999 && t.entityelement[i].y == -99999 && t.entityelement[i].z == -99999)
				{
					treename = treename + " (Auto-Gen) ";
					bAutoGenObject = true;
				}

				bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)(i + 90000), node_flags, treename.c_str());
				ImGui::PopItemWidth();

				//PE: Select on mouse release.
				if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
				{
					//PE: Find object in scene. and move camera. and select to cursor.
					if (t.entityelement[i].obj > 0)
					{
						t.widget.pickedEntityIndex = i;
						t.widget.pickedObject = t.entityelement[t.widget.pickedEntityIndex].obj;
						g.entityrubberbandlist.clear();

						bEditorInFreeFlightMode = true; //PE: Must be in freeflight mode.
						t.editorfreeflight.mode = 1;

						int group = isEntityInGroupList(t.widget.pickedEntityIndex);
						if (group >= 0)
						{
							//PE: Add all groups with entity to rubberband.
							CheckGroupListForRubberbandSelections(t.widget.pickedEntityIndex);
						}

						if (bMoveCameraToObjectPosition == true && bAutoGenObject == false)
						{
							float zoom = ObjectSize(t.entityelement[i].obj, 1) * 2.0;
							if (zoom < 30.0f) zoom = 30.0f;
							float realcamy = ObjectSizeY(t.entityelement[i].obj, 1) * 0.75;
							float camy = realcamy;
							if (camy < 30.0f) camy = 30.0f;

							if (t.entityprofile[masterid].ismarker > 0)
							{
								zoom = 100.0;
								camy = 50.0;
							}

							//PE: Move camera keep camera Y.
							PositionCamera(t.entityelement[i].x, t.entityelement[i].y, t.entityelement[i].z);
							PointCamera(t.entityelement[i].x, t.entityelement[i].y, t.entityelement[i].z);
							MoveCamera(0, -zoom);
							PositionCamera(CameraPositionX(0), t.entityelement[i].y + camy, CameraPositionZ(0));
							PointCamera(t.entityelement[i].x, t.entityelement[i].y + (realcamy * 0.5), t.entityelement[i].z);
							t.editorfreeflight.c.x_f = CameraPositionX();
							t.editorfreeflight.c.y_f = CameraPositionY();
							t.editorfreeflight.c.z_f = CameraPositionZ();
							t.editorfreeflight.c.angx_f = CameraAngleX();
							t.editorfreeflight.c.angy_f = CameraAngleY();
							t.cx_f = t.editorfreeflight.c.x_f;
							t.cy_f = t.editorfreeflight.c.z_f;
						}
					}
				}

				if (TreeNodeOpen) 
				{
					ImGui::TreePop();
				}
			}
		}
	}
	return(0);
}

bool DoTreeNodeGroup(int groupindex, bool bMoveCameraToObjectPosition)
{
	for (int i = 1; i < t.entityelement.size(); i++)
	{
		bool bValid = true;
		if (t.entityelement[i].iIsSmarkobjectDummyObj == 1) bValid = false;
		if (bValid)
		{
			if ( groupindex > 0 )
			{
				int iGroupID = isEntityInGroupList(i);
				if (groupindex == iGroupID)
				{
					char cName[512];
					int masterid = t.entityelement[i].bankindex;
					strcpy(cName, t.entityprofileheader[masterid].desc_s.Get());
					if (t.entityelement[i].eleprof.name_s.Len() > 0)
						strcpy(cName, t.entityelement[i].eleprof.name_s.Get());

					ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_OpenOnArrow;
					node_flags = ImGuiTreeNodeFlags_Leaf;

					//Find selection here.
					bool bSelected = false;
					if (bSelected)
						node_flags |= ImGuiTreeNodeFlags_Selected;
					else
						node_flags &= ~ImGuiTreeNodeFlags_Selected;

					ImGui::PushItemWidth(-20.0);

					std::string treename = "#" + std::to_string(i);
					if (t.widget.pickedEntityIndex == i && t.gridentity == masterid)
						treename = treename + " (Cursor) " + cName;
					else
						treename = treename + " " + cName;

					bool TreeNodeOpen = ImGui::TreeNodeEx((void*)(intptr_t)(i + 90000), node_flags, treename.c_str());
					ImGui::PopItemWidth();

					if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(0))
					{
						//PE: Find object in scene. and move camera. and select to cursor.
						if (t.entityelement[i].obj > 0)
						{
							t.widget.pickedEntityIndex = i;
							t.widget.pickedObject = t.entityelement[t.widget.pickedEntityIndex].obj;
							g.entityrubberbandlist.clear();
							bEditorInFreeFlightMode = true;
							t.editorfreeflight.mode = 1;
							int group = isEntityInGroupList(t.widget.pickedEntityIndex);
							if (group >= 0)
							{
								//PE: Add all groups with entity to rubberband.
								CheckGroupListForRubberbandSelections(t.widget.pickedEntityIndex);
							}
							if (bMoveCameraToObjectPosition == true)
							{
								//float zoom = 500;
								//float zoom = ObjectSize(t.entityelement[i].obj, 1) * 2.0;
								//if (zoom < 30.0f) zoom = 30.0f;
								//float realcamy = ObjectSizeY(t.entityelement[i].obj, 1) * 0.75;
								//float camy = realcamy;
								//if (camy < 30.0f) camy = 30.0f;
								//if (t.entityprofile[masterid].ismarker > 0)
								//{
								//	zoom = 100.0;
								//	camy = 50.0;
								//}
								PositionCamera(t.entityelement[i].x, t.entityelement[i].y+500, t.entityelement[i].z-500);
								PointCamera(t.entityelement[i].x, t.entityelement[i].y, t.entityelement[i].z);
								//MoveCamera(0, -zoom);
								//PositionCamera(CameraPositionX(0), t.entityelement[i].y + camy, CameraPositionZ(0));
								//PointCamera(t.entityelement[i].x, t.entityelement[i].y + (realcamy * 0.5), t.entityelement[i].z);
								t.editorfreeflight.c.x_f = CameraPositionX();
								t.editorfreeflight.c.y_f = CameraPositionY();
								t.editorfreeflight.c.z_f = CameraPositionZ();
								t.editorfreeflight.c.angx_f = CameraAngleX();
								t.editorfreeflight.c.angy_f = CameraAngleY();
								t.cx_f = t.editorfreeflight.c.x_f;
								t.cy_f = t.editorfreeflight.c.z_f;
							}
						}
					}
					if (TreeNodeOpen)
					{
						ImGui::TreePop();
					}
				}
			}
		}
	}
	return(0);
}

void SetupDecalObject(int obj, int elementID)
{
	//SetAlphaMappingOn(obj, 100.0);
	SetObjectTransparency(obj, 6);
	SetObjectLight(obj, 0);
	sObject* pObject = g_ObjectList[obj];
	if (pObject)
	{
		//PE: SetObjectCull(t.tobj, 1); Dont work.
		//PE: iCullMode need to be zero in wicked ?
		for (int iMesh = 0; iMesh < pObject->iMeshCount; iMesh++)
		{
			if (pObject->ppMeshList[iMesh]) pObject->ppMeshList[iMesh]->iCullMode = 0;
		}
		WickedCall_SetObjectCullmode(pObject);
		WickedCall_SetObjectCastShadows(pObject, false); //PE: No shadows on particles for now.

		if(!t.entityelement[elementID].eleprof.bCustomWickedMaterialActive) // ZJ: Only reset this if not using custom materials for this decal.
		{
			//PE: Use unlit shader.
			for (int iMesh = 0; iMesh < pObject->iMeshCount; iMesh++)
			{
				sMesh* pMesh = pObject->ppMeshList[iMesh];
				if (pMesh)
				{
					pMesh->mMaterial.Diffuse.r = 1.5;
					pMesh->mMaterial.Diffuse.g = 1.5;
					pMesh->mMaterial.Diffuse.b = 1.5;
					pMesh->mMaterial.Diffuse.a = 1.0;

					pMesh->mMaterial.Diffuse.a = 1.0;
					pMesh->mMaterial.Emissive.r = 1.0;
					pMesh->mMaterial.Emissive.g = 1.0;
					pMesh->mMaterial.Emissive.b = 1.0;
					pMesh->mMaterial.Emissive.a = 1.0;

					wiScene::MeshComponent* mesh = wiScene::GetScene().meshes.GetComponent(pMesh->wickedmeshindex);
					if (mesh)
					{
						uint64_t materialEntity = mesh->subsets[0].materialID;
						wiScene::MaterialComponent* pObjectMaterial = wiScene::GetScene().materials.GetComponent(materialEntity);
						if (pObjectMaterial)
						{
							pObjectMaterial->SetReflectance(0.0f);
							pObjectMaterial->shaderType = wiScene::MaterialComponent::SHADERTYPE_UNLIT; //PE: Yes 1:1 mapping and no light,env...
							pObjectMaterial->SetDirty(true);
						}
					}
					WickedCall_SetMeshMaterial(pMesh,true);
					if (elementID > 0)
					{
						WickedCall_SetMeshAlpha(pMesh, t.entityelement[elementID].fDecalOpacity * 100.0);
					}
				}
			}
		}
	}
}

// Sets the contents of a file in local app data with the path to the writable area.
// Used by the Updater to backup the writable area.
void SetUpdaterWritePathFile(char* sContents)
{
	cstr sUpdaterWritePath = defaultWriteFolder;
	sUpdaterWritePath += "writepath.ini";
	if (FileOpen(1)) CloseFile(1);
	if (FileExist(sUpdaterWritePath.Get())) DeleteAFile(sUpdaterWritePath.Get());
	OpenToWrite(1, sUpdaterWritePath.Get());
	WriteString(1, sContents);
	CloseFile(1);
}

void loadMarketplaceData(int* ggMaxDlc, cstr* ggMaxLink, int* sketchfabDlc, cstr* sketchfabLink, int* shockwaveDlc, cstr* shockwaveLink, int* communityDlc, cstr* communityLink, int* gcStoreDlc, cstr* gcStoreImageURL, cstr* gcStoreLink)
{
	#ifdef WICKEDENGINE
	std::ifstream fileRead;
	nlohmann::json jsonFile;
	int numOfPromoItems = 8;

	fileRead.open("editors\\marketplace\\MarketplaceData.json");
	if (fileRead.is_open())
	{
		fileRead >> jsonFile;
		numOfPromoItems = jsonFile["numberOfPromotionalItems"];
		std::string mainDir = jsonFile["mainMarketplaceDirectory"];
		std::string imageName = "";
		std::string link = "";
		std::string fullImageDir = "";

		//Have to convert strings to chars for LoadImage() to take it in
		char converter[254];

		for (int i = 0; i < numOfPromoItems; i++)
		{
			//GG MAX DLC
			//Thumb
			ggMaxDlc[i] = MARKETPLACE_ICONS + i;
			imageName = jsonFile["ggMaxDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, ggMaxDlc[i]);

			//Link
			//if (g_bUpdateAppAvailable==true) 
			//{ 
			//	link = jsonFile["ggMaxDLC"][i]["tgcLink"]; 
			//}
			//else 
			{ 
				link = jsonFile["ggMaxDLC"][i]["steamLink"]; 
			}
			strcpy(converter, link.c_str());
			ggMaxLink[i] = converter;

			//Sketchfab DLC
			//Thumb
			sketchfabDlc[i] = MARKETPLACE_ICONS + i + numOfPromoItems;
			imageName = jsonFile["sketchfabDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, sketchfabDlc[i]);

			//Link
			link = jsonFile["sketchfabDLC"][i]["websiteLink"];
			strcpy(converter, link.c_str());
			sketchfabLink[i] = converter;

			//Shockwave DLC
			//Thumb
			shockwaveDlc[i] = MARKETPLACE_ICONS + i + (numOfPromoItems * 2);
			imageName = jsonFile["shockwaveDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, shockwaveDlc[i]);

			//Link
			link = jsonFile["shockwaveDLC"][i]["websiteLink"];
			strcpy(converter, link.c_str());
			shockwaveLink[i] = converter;

			//Community DLC
			//Thumb
			communityDlc[i] = MARKETPLACE_ICONS + i + (numOfPromoItems * 3);
			imageName = jsonFile["communityDLC"][i]["imageName"];
			fullImageDir = mainDir + imageName;
			strcpy(converter, fullImageDir.c_str());
			LoadImage(converter, communityDlc[i]);

			//Link
			link = jsonFile["communityDLC"][i]["websiteLink"];
			strcpy(converter, link.c_str());
			communityLink[i] = converter;

			//Game Creator Store DLC
			gcStoreDlc[i] = MARKETPLACE_ICONS + i + (numOfPromoItems * 4);
		}
	}
	fileRead.close();

	// additional system can replace the fixed 'Game Creator Store DLC' if a live connection can be had
	bool bUpdateGameCreatorStoreLive = true;
	if (bUpdateGameCreatorStoreLive)
	{
		// needed data reserve
		char pDataReturned[132000];
		char pDatatmp[132000];
		char cUrl[10240];

		// list we need
		std::vector<cstr> ItemName;
		std::vector<cstr> ItemURL;
		std::vector<cstr> ItemImage;

		// call API to get featured items in list
		memset(pDataReturned, 0, sizeof(pDataReturned));
		memset(pDatatmp, 0, sizeof(pDatatmp));
		DWORD dwDataReturnedSize = 0;
		sprintf(cUrl, "/api/max/featured/products");

		// access features list from store server
		UINT iError = StoreOpenURLForDataOrFile(NULL, pDataReturned, &dwDataReturnedSize, "", "GET", cUrl, NULL);
		if (iError <= 0 && *pDataReturned != 0 && strchr(pDataReturned, '{') != 0)
		{
			char* pChop = NULL;
			if ((pChop = (char *)pestrcasestr(pDataReturned, "{\"status\":\"success\"")) != NULL)
			{
				// data we need from each entry
				char pItemName[1024];
				char pStoreURL[1024];
				char pThumbURL[10240];

				// go through all items until no more names
				while (ItemName.size() < 8)
				{
					int iResultCount = 0;
					char pSearchForToken[256];
					strcpy(pSearchForToken, "\"name\"\0");
					if (pChop)
					{
						pChop = strstr(pChop, pSearchForToken);
						if (pChop)
						{
							pChop += strlen(pSearchForToken) + 2;
							strcpy(pDatatmp, pChop);
							char* pFindEnd = strstr(pDatatmp, "\"\0");
							if (pFindEnd)
							{
								pDatatmp[pFindEnd - pDatatmp] = 0;
								if (strlen(pDatatmp) < 256)
								{
									strcpy(pItemName, pDatatmp);
									iResultCount++;
								}
								pChop = pFindEnd + 1;
							}
							strcpy(pSearchForToken, "\"thumbnail_url\"\0");
							pChop = strstr(pChop, pSearchForToken);
							if (pChop)
							{
								pChop += strlen(pSearchForToken) + 2;
								strcpy(pDatatmp, pChop);
								char* pFindEnd = strstr(pDatatmp, "\"\0");
								pDatatmp[pFindEnd - pDatatmp] = 0;
								if (strlen(pDatatmp) < 10240)
								{
									strcpy(pThumbURL, pDatatmp);
									iResultCount++;
								}
								pChop = pFindEnd + 1;
							}
							if (pChop)
							{
								strcpy(pSearchForToken, "\"store_url\"\0");
								pChop = strstr(pChop, pSearchForToken);
								if (pChop)
								{
									pChop += strlen(pSearchForToken) + 2;
									strcpy(pDatatmp, pChop);
									char* pFindEnd = strstr(pDatatmp, "\"\0");
									pDatatmp[pFindEnd - pDatatmp] = 0;
									if (strlen(pDatatmp) < 256)
									{
										strcpy(pStoreURL, pDatatmp);
										iResultCount++;
									}
									pChop = pFindEnd + 1;
								}
							}
							if (iResultCount == 3)
							{
								// add results if valid
								ItemName.push_back(pItemName);
								ItemURL.push_back(pStoreURL);
								ItemImage.push_back(pThumbURL);
							}
						}
						else
						{
							// no more item names, leave now
							break;
						}
					}
					else
					{
						// less than eight
						break;
					}
				}
			}
		}

		// go through ItemImage list and fill gcStoreImageURL
		int iMaximumOfEight = ItemImage.size();
		if (iMaximumOfEight > 8) iMaximumOfEight = 8;
		for (int i = 0; i < iMaximumOfEight; i++)
		{
			// ItemName not carried back
			gcStoreLink[i] = ItemURL[i] + "?r=tgc";
			gcStoreImageURL[i] = ItemImage[i];
		}
	}

	#endif // WICKEDENGINE
}

#endif //Wickedengine

#ifdef WICKEDENGINE
int current_icon_set = -1;
bool bTriggerIconSetChange = false;

void SetIconSet(bool bInstant)
{
	//PE: This need to be done as the first, or we could change a image that is already on screen (crash).
	bTriggerIconSetChange = true;
	if (bInstant) SetIconSetCheck(bInstant);
}
void SetIconSetCheck(bool bInstant)
{
	if (bInstant == false && !bTriggerIconSetChange) return;
	
	bTriggerIconSetChange = false;

	//PE: These should be change when changing style.
	if (current_icon_set != pref.current_style)
	{
		SetMipmapNum(1); //PE: mipmaps not needed.
		image_setlegacyimageloading(true);
		if (pref.current_style == 25 || pref.current_style == 3)
		{
			LoadImage("editors\\uiv3\\entity_particle.png", ENTITY_PARTICLE);
			LoadImage("editors\\uiv3\\entity_light.png", ENTITY_LIGHT);
			LoadImage("editors\\uiv3\\entity_probe.png", ENTITY_PROBE);
			LoadImage("editors\\uiv3\\entity_win.png", ENTITY_WIN);
			LoadImage("editors\\uiv3\\entity_image.png", ENTITY_IMAGE);
			LoadImage("editors\\uiv3\\entity_music.png", ENTITY_MUSIC);
			LoadImage("editors\\uiv3\\entity_sound.png", ENTITY_SOUND);
			LoadImage("editors\\uiv3\\entity_text.png", ENTITY_TEXT);
			LoadImage("editors\\uiv3\\entity_video.png", ENTITY_VIDEO);
			LoadImage("editors\\uiv3\\entity_start.png", ENTITY_START);
			LoadImage("editors\\uiv3\\entity_checkpoint.png", ENTITY_CHECKPOINT); //
			LoadImage("editors\\uiv3\\shooter_flag.png", ENTITY_FLAG); //
			LoadImage("editors\\uiv3\\shooter_guns.png", ENTITY_GUNS); // Not used anymore?
			LoadImage("editors\\uiv3\\shooter_ammo.png", ENTITY_AMMO); // Not used anymore?
			LoadImage("editors\\uiv3\\shooter_enemies.png", ENTITY_ENEMIES); // Not used anymore?
			LoadImage("editors\\uiv3\\shooter_allies.png", ENTITY_ALLIES); // Not used anymore?
			LoadImage("editors\\uiv3\\entity_triggerzone.png", ENTITY_TRIGGERZONE);


			LoadImage("editors\\uiv3\\ccp-hat.png", CCP_HAT);
			LoadImage("editors\\uiv3\\ccp-feet.png", CCP_FEET);
			LoadImage("editors\\uiv3\\ccp-legs.png", CCP_LEGS);
			LoadImage("editors\\uiv3\\ccp-body.png", CCP_BODY);
			LoadImage("editors\\uiv3\\ccp-glasses.png", CCP_GLASSES);
			LoadImage("editors\\uiv3\\ccp-beard.png", CCP_BEARD);
			LoadImage("editors\\uiv3\\ccp-hair.png", CCP_HAIR);
			LoadImage("editors\\uiv3\\ccp-head.png", CCP_HEAD);
			LoadImage("editors\\uiv3\\ccp-tattoo.png", CCP_TATTOO);

			LoadImage("editors\\uiv3\\filetype-script.png", FILETYPE_SCRIPT);

		}
		else
		{
			LoadImage("editors\\uiv3\\entity_particle2.png", ENTITY_PARTICLE);
			LoadImage("editors\\uiv3\\entity_light2.png", ENTITY_LIGHT);
			LoadImage("editors\\uiv3\\entity_probe2.png", ENTITY_PROBE);
			LoadImage("editors\\uiv3\\entity_win2.png", ENTITY_WIN);
			LoadImage("editors\\uiv3\\entity_image2.png", ENTITY_IMAGE);
			LoadImage("editors\\uiv3\\entity_music2.png", ENTITY_MUSIC);
			LoadImage("editors\\uiv3\\entity_sound2.png", ENTITY_SOUND);
			LoadImage("editors\\uiv3\\entity_text2.png", ENTITY_TEXT);
			LoadImage("editors\\uiv3\\entity_video2.png", ENTITY_VIDEO);
			LoadImage("editors\\uiv3\\entity_start2.png", ENTITY_START);
			LoadImage("editors\\uiv3\\entity_checkpoint2.png", ENTITY_CHECKPOINT); //
			LoadImage("editors\\uiv3\\shooter_flag2.png", ENTITY_FLAG); //
			LoadImage("editors\\uiv3\\shooter_guns2.png", ENTITY_GUNS);
			LoadImage("editors\\uiv3\\shooter_ammo2.png", ENTITY_AMMO);
			LoadImage("editors\\uiv3\\shooter_enemies2.png", ENTITY_ENEMIES);
			LoadImage("editors\\uiv3\\shooter_allies2.png", ENTITY_ALLIES);
			LoadImage("editors\\uiv3\\entity_triggerzone2.png", ENTITY_TRIGGERZONE);

			LoadImage("editors\\uiv3\\ccp-hat2.png", CCP_HAT);
			LoadImage("editors\\uiv3\\ccp-feet2.png", CCP_FEET);
			LoadImage("editors\\uiv3\\ccp-legs2.png", CCP_LEGS);
			LoadImage("editors\\uiv3\\ccp-body2.png", CCP_BODY);
			LoadImage("editors\\uiv3\\ccp-glasses2.png", CCP_GLASSES);
			LoadImage("editors\\uiv3\\ccp-beard2.png", CCP_BEARD);
			LoadImage("editors\\uiv3\\ccp-hair2.png", CCP_HAIR);
			LoadImage("editors\\uiv3\\ccp-head2.png", CCP_HEAD);
			LoadImage("editors\\uiv3\\ccp-tattoo2.png", CCP_TATTOO);

			LoadImage("editors\\uiv3\\filetype-script2.png", FILETYPE_SCRIPT);

		}
		current_icon_set = pref.current_style;
		image_setlegacyimageloading(false);
		SetMipmapNum(-1);
	}
	//----
}

int get_gameisexe(void)
{
	return(t.game.gameisexe);
}

int get_hidehudstate()
{
	return g.tabmodehidehuds;
}

#ifdef STORYBOARD

#define STORYBOARD_INCLUDE_LOADGAME //PE: Not ready yet, also missing "in between game menu" graphics/music setup ...

#define STORYBOARD_SAVE_MESSAGE "Do you wish to save your game project first ?"
#define STORYBOARD_YSTART 30

//PE: Undo redo will be hole structure copy.
//#define STORYBOARD_UNDO_MAX 10
//StoryboardStruct Storyboard_Undo[STORYBOARD_UNDO_MAX];
//int iStoryboardUndoIndex = 0;

//PE: Not needed in save struct.
int StoryboardiActiveLinksId[STORYBOARD_MAXNODES];
int StoryboardiActiveLinksIdFrom[STORYBOARD_MAXNODES];
int iLoadGameNodeID = 3;
int iTitleScreenNodeID = 1;
int iGamePausedNodeID = 8;
int iSaveGameNodeID = 9;
int iGraphicsNodeID = 10;
int iSoundsNodeID = 11;

int iControlNodeID = 12;

int iLoadingScreenNodeID = 2;
int iAboutScreenNodeID = 4;
int iGameWonScreenNodeID = 5;
int iGameLostScreenNodeID = 6;
int iHUDScreenNodeID = 13;

int get_output_linkindex(int node, int index)
{
	if (node < 0 || node > STORYBOARD_MAXNODES) return index;
	int i = node;
	int outlinknum = 0;
	if (i == iGamePausedNodeID) return index;
	if (i == iGraphicsNodeID) return index;
	if (i == iSoundsNodeID) return index;
	if (i == iControlNodeID) return index;
	if (i == iSaveGameNodeID) return index;
	if (i == iLoadGameNodeID) return index;
	if (i == iLoadingScreenNodeID) return index; //PE: Special got no button for linking to output.

	if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH) return index;
	if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD) return index;

	for (int ll = 0; ll < STORYBOARD_MAXWIDGETS; ll++)
	{
		if (ll == index)
			return outlinknum;
		if (Storyboard.Nodes[i].widget_used[ll])
		{
			if (Storyboard.Nodes[node].widget_type[ll] == STORYBOARD_WIDGET_BUTTON)
			{
				if (Storyboard.Nodes[node].widget_action[ll] == STORYBOARD_ACTIONS_STARTGAME || Storyboard.Nodes[node].widget_action[ll] == STORYBOARD_ACTIONS_GOTOLEVEL)
				{
					outlinknum++;
				}
				else if (Storyboard.Nodes[node].widget_action[ll] == STORYBOARD_ACTIONS_GOTOSCREEN)
				{
					outlinknum++;
				}
			}
		}
	}

	return(index);
}

void setup_output_links(int node)
{

	//int iTitleScreenNodeID = 1;
	//int iAboutScreenNodeID = 4;
	//int iGameWonScreenNodeID = 5;
	//int iGameLostScreenNodeID = 6;

	if (node < 0 || node > STORYBOARD_MAXNODES) return;
	int i = node;
	int outlinknum = 0;
	char chr[MAX_PATH];
	if (i == iGamePausedNodeID) return;
	if (i == iGraphicsNodeID) return;
	if (i == iSoundsNodeID) return;
	if (i == iControlNodeID) return;
	if (i == iSaveGameNodeID) return;
	if (i == iLoadGameNodeID) return;
	if (i == iLoadingScreenNodeID) return; //PE: Special got no button for linking to output.

	if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH) return;
	if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD) return;


	//PE: reset outlinks.
	for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
	{
		strcpy(Storyboard.Nodes[i].output_action[l], "");
		strcpy(Storyboard.Nodes[i].output_title[l], "");
		Storyboard.Nodes[i].output_can_link_to_type[l] = 0;
	}

	for (int ll = 0; ll < STORYBOARD_MAXWIDGETS; ll++)
	{
		if (Storyboard.Nodes[node].widget_used[ll])
		{
			if (Storyboard.Nodes[node].widget_type[ll] == STORYBOARD_WIDGET_BUTTON)
			{
				if (Storyboard.Nodes[node].widget_action[ll] == STORYBOARD_ACTIONS_STARTGAME || Storyboard.Nodes[node].widget_action[ll] == STORYBOARD_ACTIONS_GOTOLEVEL)
				{
					strcpy(chr, Storyboard.Nodes[node].widget_label[ll]);
					strcat(chr, " -> Connect to Level");
					strcpy(Storyboard.Nodes[node].output_title[outlinknum], chr);
					strcpy(Storyboard.Nodes[node].output_action[outlinknum], "loadlevel"); //Not defined this yet.
					Storyboard.Nodes[node].output_can_link_to_type[outlinknum] = STORYBOARD_TYPE_LEVEL;
					outlinknum++;
				}
				else if (Storyboard.Nodes[node].widget_action[ll] == STORYBOARD_ACTIONS_GOTOSCREEN)
				{
					strcpy(chr, Storyboard.Nodes[node].widget_label[ll]);
					strcat(chr, " ->  Connect to Scene ");
					strcpy(Storyboard.Nodes[node].output_title[outlinknum], chr);
					strcpy(Storyboard.Nodes[node].output_action[outlinknum], "loadscene"); //Not defined this yet.
					Storyboard.Nodes[node].output_can_link_to_type[outlinknum] = STORYBOARD_TYPE_SCREEN;
					outlinknum++;
				}
			}
			if (pestrcasestr(Storyboard.Nodes[node].lua_name, "loading"))
			{
				strcpy(Storyboard.Nodes[node].output_title[0], " LOAD LEVEL -> Connect to Level ");
				strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
				Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_LEVEL;
				outlinknum++;
			}
		}
	}
}

void reset_single_node_interscreen(int node)
{
	// this is called by restore to reset all 'screen elements' without affecting wider relationships (i.e. connections to nodes)
	int i = node;

	//Screen
	strcpy(Storyboard.Nodes[i].screen_title, "");
	strcpy(Storyboard.Nodes[i].screen_music, "");
	Storyboard.Nodes[i].screen_grid_size = 0;
	strcpy(Storyboard.Nodes[i].screen_backdrop, "");
	Storyboard.Nodes[i].screen_back_color = ImVec4(0.0, 0.0, 0.0, 1.0);
	Storyboard.Nodes[i].screen_backdrop_placement = 2; // center,stretch,zoom. PE: Default to zoom.
	strcpy(Storyboard.Nodes[i].screen_thumb, "");
	for (int ll = 0; ll < 10; ll++)
		Storyboard.Nodes[i].screen_backdrop_ratio_placement[ll] = 0; // 0=1920x1080 center,stretch,zoom. 1=1366x768 center,stretch,zoom ...

	//Editor.
	for (int ll = 0; ll < STORYBOARD_MAXWIDGETS; ll++)
	{
		Storyboard.Nodes[i].widget_used[ll] = 0;
		strcpy(Storyboard.Nodes[i].widget_label[ll], "");
		Storyboard.Nodes[i].widget_size[ll] = ImVec2(1.0, 1.0); // size zoom.
		Storyboard.Nodes[i].widget_pos[ll] = ImVec2(0, 0);
		strcpy(Storyboard.Nodes[i].widget_normal_thumb[ll], "");
		strcpy(Storyboard.Nodes[i].widget_highlight_thumb[ll], "");
		strcpy(Storyboard.Nodes[i].widget_selected_thumb[ll], ""); //only for state change button, checkbox ...
		strcpy(Storyboard.Nodes[i].widget_click_sound[ll], "");
		Storyboard.Nodes[i].widget_action[ll] = 0; // 0=none ...
		strcpy(Storyboard.Nodes[i].widget_font[ll], "Default Font");
		Storyboard.Nodes[i].widget_font_color[ll] = ImVec4(1.0, 1.0, 1.0, 1.0);
		Storyboard.Nodes[i].widget_font_size[ll] = 1.0;
		Storyboard.Nodes[i].widget_type[ll] = 0; // 0=none,but,text,image,video...
		Storyboard.Nodes[i].widget_layer[ll] = 0;
		Storyboard.Nodes[i].widget_initial_value[ll] = 0;
		strcpy(Storyboard.Nodes[i].widget_name[ll], "");
		Storyboard.Nodes[i].widget_read_only[ll] = 0; //off,level,screen.
		Storyboard.NodeSliderValues[i][ll] = 0.0;
	}

	// used by GRAPHICS SETTINGS (1,2,3)
	Storyboard.NodeRadioButtonSelected[i] = -1;
}

void reset_single_node(int node)
{
	int i = node;
	//PE: Dont touch id's they are reused.
	Storyboard.Nodes[i].used = false;
	Storyboard.Nodes[i].type = 0;
	if (ImageExist(Storyboard.Nodes[i].thumb_id)) DeleteImage(Storyboard.Nodes[i].thumb_id);
	Storyboard.Nodes[i].restore_position = ImVec2(0, 0);
	Storyboard.Nodes[i].iEditEnable = true;
	strcpy(Storyboard.Nodes[i].title, "");
	strcpy(Storyboard.Nodes[i].levelnumber, "");
	strcpy(Storyboard.Nodes[i].thumb, "");
	strcpy(Storyboard.Nodes[i].lua_name, "");
	strcpy(Storyboard.Nodes[i].level_name, "");

	//Each filler have its own, so can count it down later.
	Storyboard.Nodes[i].screen_backdrop_transparent = false;
	
	for (int l = 0; l < 19; l++) Storyboard.Nodes[i].iFiller20[l] = 0;
	for (int l = 0; l < 20; l++) Storyboard.Nodes[i].fFiller20[l] = 0.0;
	for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
	{
		for (int ll = 0; ll < 20; ll++) Storyboard.Nodes[i].iFillerMaxOutputs20[ll][l] = 0.0;
		for (int ll = 0; ll < 20; ll++) strcpy(Storyboard.Nodes[i].FillerCharMaxOutput20[ll][l],"");
		strcpy(Storyboard.Nodes[i].output_action[l], "");
		strcpy(Storyboard.Nodes[i].output_title[l], "");
		Storyboard.Nodes[i].output_linkto[l] = 0;
		Storyboard.Nodes[i].output_can_link_to_type[l] = 0;
		strcpy(Storyboard.Nodes[i].input_title[l], "");
		strcpy(Storyboard.Nodes[i].input_action[l], "");
	}

	//Screen and Editor
	reset_single_node_interscreen(i);
}

void storeboard_fix_uniqueids( void )
{
	int iUniqueId = STORYBOARD_THUMBS;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		int node = i;

		for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
		{
			//PE: input_id,output_id ID's broken in checkproject.
			if (Storyboard.Nodes[node].input_id[l] != iUniqueId + 1000 + (1000 * l) ||
				Storyboard.Nodes[node].output_id[l] != iUniqueId + 1000 + (1000 * l) + 500)
			{
				//PE: Something wrong reset.
				bool bInputChanged = false;
				if (Storyboard.Nodes[node].input_id[l] != iUniqueId + 1000 + (1000 * l)) bInputChanged = true;
				int oldinput = Storyboard.Nodes[node].input_id[l];
				Storyboard.Nodes[node].input_id[l] = iUniqueId + 1000 + (1000 * l);
				Storyboard.Nodes[node].output_id[l] = iUniqueId + 1000 + (1000 * l) + 500;

				if (bInputChanged)
				{
					//PE: As the unique ids has changed we need to remove all linking to us, need to be done so corrupt projects can be fixed by reconnecting again.
					for (int ii = 0; ii < STORYBOARD_MAXNODES; ii++)
					{
						for (int a = 0; a < STORYBOARD_MAXOUTPUTS; a++)
						{
							//PE: Check all output_linkto and remove link.
							if (Storyboard.Nodes[ii].output_linkto[a] == oldinput)
								Storyboard.Nodes[ii].output_linkto[a] = 0;
						}
					}
				}
			}
		}
		if (pestrcasestr(Storyboard.Nodes[node].title, "Level "))
		{
			if (Storyboard.Nodes[node].type != STORYBOARD_TYPE_LEVEL)
				Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
		}
		if (pestrcasestr(Storyboard.Nodes[node].lua_name, "loading"))
		{
			if (Storyboard.Nodes[node].type != STORYBOARD_TYPE_LEVEL)
				Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
		}

		iUniqueId++;
	}
}

void storeboard_init_nodes(float area_width, float node_width, float node_height)
{
	if (bStoryboardInitNodes) return;
	bStoryboardInitNodes = true;
	iLoadGameNodeID = 3;
	iTitleScreenNodeID = 1;
	iGamePausedNodeID = 8;
	iSaveGameNodeID = 9;
	iGraphicsNodeID = 10;
	iSoundsNodeID = 11;
	iHUDScreenNodeID = 13;
	int iUniqueIds = STORYBOARD_THUMBS;
	strcpy(Storyboard.gamename,""); //Start with no name,
	Storyboard.iStoryboardVersion = STORYBOARDVERSION;
	Storyboard.iChanged = false;
	Storyboard.vEditorPanning = ImVec2(0.0f, 0.0f);
	strcpy(Storyboard.game_icon, "");
	strcpy(Storyboard.game_thumb, "");
	strcpy(Storyboard.game_description, "Game Description");
	strcpy(Storyboard.game_world_edge_text, "You cannot leave the area of play");
	strcpy(Storyboard.game_developer_desc, "");
	Storyboard.project_readonly = 0;

	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		reset_single_node(i);

		StoryboardiActiveLinksId[i] = 0;
		StoryboardiActiveLinksIdFrom[i] = 0;

		//PE: Setup Id's
		Storyboard.Nodes[i].id = iUniqueIds;
		Storyboard.Nodes[i].thumb_id = iUniqueIds;

		for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
		{
			Storyboard.Nodes[i].input_id[l] = iUniqueIds + 1000 + (1000 * l);
			Storyboard.Nodes[i].output_id[l] = iUniqueIds + 1000 + (1000 * l) + 500;
		}

		for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
		{
			Storyboard.Nodes[i].widget_normal_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 600;
			Storyboard.Nodes[i].widget_highlight_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 700;
			Storyboard.Nodes[i].widget_selected_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 800;
		}
		Storyboard.Nodes[i].screen_backdrop_id = iUniqueIds + 500;

		iUniqueIds++;
	}
	
	Storyboard.game_thumb_id = STORYBOARD_THUMBS + 420;
	Storyboard.game_icon_id = STORYBOARD_THUMBS + 421;

	// All default screens
	int node = 0;
	constexpr int allWidgets = ALLOW_BUTTON | ALLOW_TEXT | ALLOW_IMAGE | ALLOW_RADIOTYPE | ALLOW_SLIDER | ALLOW_TICKBOX | ALLOW_VIDEO | ALLOW_PROGRESS | ALLOW_TEXTAREA;

	//
	// 0 : Default splash screen.
	//
	storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;
	
	//
	// 1 : Default title screen
	//
	iTitleScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 2 : iLoadingScreenNodeID
	//
	iLoadingScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 3 : iLoadGameNodeID
	//
	iLoadGameNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 4 : Default About screen.
	//
	iAboutScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 5 : Default Game Won screen.
	//
	iGameWonScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 6 : Default Game Over screen.
	//
	iGameLostScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 7 : Default Level1 screen.
	//
	int iLevelOne = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	Storyboard.Nodes[node].output_linkto[0] = Storyboard.Nodes[5].input_id[0];
	Storyboard.Nodes[node].output_linkto[1] = Storyboard.Nodes[6].input_id[0];
	Storyboard.Nodes[node].output_linkto[2] = 0;
	node++;

	//
	// 8 : iGamePausedNodeID
	//
	iGamePausedNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 9 : iSaveGameNodeID
	//
	iSaveGameNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 10 : iGraphicsNodeID
	//
	iGraphicsNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 11 : iSoundsNodeID
	//
	iSoundsNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 12 : iControlNodeID
	//
	iControlNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	//
	// 13 : In-game HUD screen
	//
	iHUDScreenNodeID = storyboard_add_missing_nodex(node, area_width, node_width, node_height, true);
	node++;

	// Create node links now we know screen IDs
	Storyboard.Nodes[0].output_linkto[0] = Storyboard.Nodes[iTitleScreenNodeID].input_id[0];
	Storyboard.Nodes[iTitleScreenNodeID].output_linkto[0] = Storyboard.Nodes[iLoadingScreenNodeID].input_id[0];
	Storyboard.Nodes[iTitleScreenNodeID].output_linkto[1] = Storyboard.Nodes[iLoadGameNodeID].input_id[0];
	Storyboard.Nodes[iTitleScreenNodeID].output_linkto[2] = Storyboard.Nodes[iAboutScreenNodeID].input_id[0];
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[0] = Storyboard.Nodes[iLoadGameNodeID].input_id[0];
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[1] = Storyboard.Nodes[iSaveGameNodeID].input_id[0];
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[2] = Storyboard.Nodes[iGraphicsNodeID].input_id[0];
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[3] = Storyboard.Nodes[iSoundsNodeID].input_id[0];
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[4] = 0;
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[5] = 0;
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[6] = 0;
	Storyboard.Nodes[iGamePausedNodeID].output_linkto[7] = Storyboard.Nodes[iControlNodeID].input_id[0];
	Storyboard.Nodes[iLoadingScreenNodeID].output_linkto[0] = Storyboard.Nodes[iLevelOne].input_id[0];

	//Make sure we have the needed folders
	char destination[MAX_PATH];
	strcpy(destination, "projectbank\\");
	GG_GetRealPath(destination, 1);
	MakeDirectory(destination);
}

int storyboard_add_missing_nodex(int node,float area_width, float node_width, float node_height, bool bForce, bool bRestoring)
{
	// LB latest
	int orgnode = node;
	constexpr int allWidgets = ALLOW_BUTTON | ALLOW_TEXT | ALLOW_IMAGE | ALLOW_RADIOTYPE | ALLOW_SLIDER | ALLOW_TICKBOX | ALLOW_VIDEO | ALLOW_PROGRESS | ALLOW_TEXTAREA;
	constexpr int defaultWidgets = ALLOW_TEXT | ALLOW_IMAGE | ALLOW_VIDEO | ALLOW_BUTTON;
	bool bUpdateStoryboardToV2 = false;

	//General.
	if( strlen(Storyboard.Nodes[0].thumb) > 0 && pestrcasestr(Storyboard.Nodes[0].thumb,"loadingsplash.jpg"))
		strcpy(Storyboard.Nodes[0].thumb, "editors\\uiv3\\loadingsplash.jpg");

	if(orgnode == 0)
	{
		Storyboard.Nodes[node].used = true;
		Storyboard.Nodes[node].type = STORYBOARD_TYPE_SPLASH;
		Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5) - ((node_width + NODE_WIDTH_PADDING) * 4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * node);
		Storyboard.Nodes[node].iEditEnable = true;
		strcpy(Storyboard.Nodes[node].title, "Splash Screen");
		strcpy(Storyboard.Nodes[node].thumb, "editors\\uiv3\\loadingsplash.jpg");
		strcpy(Storyboard.Nodes[node].lua_name, ""); //No script.
		strcpy(Storyboard.Nodes[node].output_title[0], " Connect to Scene ");
		strcpy(Storyboard.Nodes[node].output_action[0], "loadscene"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
	}

	if (orgnode == 1)
	{
		Storyboard.Nodes[node].used = true;
		Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
		Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5) - ((node_width + NODE_WIDTH_PADDING) * 2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
		Storyboard.Nodes[node].iEditEnable = true;
		strcpy(Storyboard.Nodes[node].title, "Title Screen");
		strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_title.lua.png");
		strcpy(Storyboard.Nodes[node].lua_name, "title.lua");
		strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\title.png");
		Storyboard.Nodes[node].widgets_available = allWidgets;
		strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
		strcpy(Storyboard.Nodes[node].output_title[0], " START GAME -> Connect to Level ");
		strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
		strcpy(Storyboard.Nodes[node].output_title[1], " LOAD GAME -> Connect to Scene ");
		strcpy(Storyboard.Nodes[node].output_action[1], "loadscene"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
		strcpy(Storyboard.Nodes[node].output_title[2], " ABOUT -> Connect to Scene ");
		strcpy(Storyboard.Nodes[node].output_action[2], "loadscene"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_SCREEN;
		int button = 0;
		strcpy(Storyboard.Nodes[node].widget_label[button], "START");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 10.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_STARTGAME;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "start"); //Also add "-hover.png" ...
		button++;
		strcpy(Storyboard.Nodes[node].widget_label[button], "LOAD GAME");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 20.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "load-game"); //Also add "-hover.png" ...
		button++;
		strcpy(Storyboard.Nodes[node].widget_label[button], "ABOUT");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 30.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "about"); //Also add "-hover.png" ...
		button++;
		strcpy(Storyboard.Nodes[node].widget_label[button], "QUIT GAME");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0 + 40.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_EXITGAME;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "quit-game"); //Also add "-hover.png" ...
	}

	if (orgnode == 4)
	{
		Storyboard.Nodes[node].used = true;
		Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
		Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
		Storyboard.Nodes[node].iEditEnable = true;
		strcpy(Storyboard.Nodes[node].title, "About Screen");
		strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_about.lua.png");
		strcpy(Storyboard.Nodes[node].lua_name, "about.lua");
		strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\about.png");
		Storyboard.Nodes[node].widgets_available = allWidgets;
		strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
		int button = 0;
		strcpy(Storyboard.Nodes[node].widget_label[button], "ABOUT GAME");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_name[button], "about-title"); //Also add "-hover.png" ...
		button = 1;
		strcpy(Storyboard.Nodes[node].widget_label[button], "");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_name[button], "about-textarea"); //Also add "-hover.png" ...
		button = 2;
		strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "back"); //NOTE: DUP (back) - Also add "-hover.png" ...
	}

	if (orgnode == 5)
	{
		Storyboard.Nodes[node].used = true;
		Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
		Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5) + ((node_width + NODE_WIDTH_PADDING) * 4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
		Storyboard.Nodes[node].iEditEnable = true;
		strcpy(Storyboard.Nodes[node].title, "Game Won Screen");
		strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_win.lua.png");
		strcpy(Storyboard.Nodes[node].lua_name, "win.lua");
		strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\end.png");
		Storyboard.Nodes[node].widgets_available = allWidgets;
		strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
		int button = 0;
		strcpy(Storyboard.Nodes[node].widget_label[button], "CONTINUE");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_CONTINUE;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "continue"); //NOTE: DUP (continue) - Also add "-hover.png" ...
		button = 1;
		strcpy(Storyboard.Nodes[node].widget_label[button], "GAME COMPLETE");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_name[button], "gamecomplete"); //Also add "-hover.png" ...
	}

	if (orgnode == 6)
	{
		Storyboard.Nodes[node].used = true;
		Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
		Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5) + ((node_width + NODE_WIDTH_PADDING) * 4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
		Storyboard.Nodes[node].iEditEnable = true;
		strcpy(Storyboard.Nodes[node].title, "Game Over Screen");
		strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_lose.lua.png");
		strcpy(Storyboard.Nodes[node].lua_name, "lose.lua");
		strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\lost.png");
		Storyboard.Nodes[node].widgets_available = allWidgets;
		strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
		int button = 0;
		strcpy(Storyboard.Nodes[node].widget_label[button], "CONTINUE");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_CONTINUE;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
		strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
		strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
		strcpy(Storyboard.Nodes[node].widget_name[button], "continue"); //NOTE: DUP (continue) - Also add "-hover.png" ...
		button = 1;
		strcpy(Storyboard.Nodes[node].widget_label[button], "GAME OVER");
		Storyboard.Nodes[node].widget_used[button] = 1;
		Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
		Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
		Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
		Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
		Storyboard.Nodes[node].widget_layer[button] = 0;
		Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
		strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
		strcpy(Storyboard.Nodes[node].widget_name[button], "gameover"); //Also add "-hover.png" ...
	}

	if (orgnode == 7 && bRestoring == false)
	{
		Storyboard.Nodes[node].used = true;
		Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
		Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5) + ((node_width + NODE_WIDTH_PADDING) * 2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
		Storyboard.Nodes[node].iEditEnable = true;
		strcpy(Storyboard.Nodes[node].title, "Level 1");
		strcpy(Storyboard.Nodes[node].levelnumber, "Level 1");
		strcpy(Storyboard.Nodes[node].thumb, "");
		strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
		strcpy(Storyboard.Nodes[node].output_title[0], " WIN LEVEL -> Connect to Scene ");
		strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
		Storyboard.Nodes[node].output_linkto[0] = Storyboard.Nodes[5].input_id[0];
		strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
		strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
		Storyboard.Nodes[node].output_linkto[1] = Storyboard.Nodes[6].input_id[0];
		strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
		strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
		Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
		Storyboard.Nodes[node].output_linkto[2] = 0;
	}

	if (orgnode == 8)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "gamemenu.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		//Change old node label.
		if (stricmp(Storyboard.Nodes[node].widget_label[5], "SOUND LEVELS") == 0)
		{
			strcpy(Storyboard.Nodes[node].widget_label[5], "SOUND SETTINGS");
		}

		//8 Default GAME PAUSED
		if( bValid && (Storyboard.Nodes[node].used == false || bForce) )
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if (bRestoring==false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*4.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Game Paused");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_gamemenu.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "gamemenu.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, ""); //No backdrop transparent.
			Storyboard.Nodes[node].screen_backdrop_transparent = true;
			Storyboard.Nodes[node].widgets_available = allWidgets;
			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "GAME PAUSED");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "about-title"); //Also add "-hover.png" ...
			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "MAIN MENU");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_LEAVEGAME; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "main-menu"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], "title"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_TYPE_SCREEN;
			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOAD GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "load-game"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[0], " LOAD GAME -> Connect to Scene ");
			strcpy(Storyboard.Nodes[node].output_action[0], "loadscene"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SAVE GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 40.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "save-game"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[1], " SAVE GAME -> Connect to Scene ");
			strcpy(Storyboard.Nodes[node].output_action[1], "savescene"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "GRAPHICS SETTINGS");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 50.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "graphics-settings"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[2], " GRAPHICS SETTINGS -> Connect to Scene ");
			strcpy(Storyboard.Nodes[node].output_action[2], "graphicsscene"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_SCREEN;
			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SOUND SETTINGS"); //SOUND LEVELS
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 60.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //	//LeaveGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "sound-levels"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[3], " SOUND SETTINGS -> Connect to Scene ");
			strcpy(Storyboard.Nodes[node].output_action[3], "soundsscene"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[3] = STORYBOARD_TYPE_SCREEN;
			button = 6;
			strcpy(Storyboard.Nodes[node].widget_label[button], "RESUME GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_RESUMEGAME; //ResumeGame
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "resume-game"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[button], ""); //Empty no output pin.
			strcpy(Storyboard.Nodes[node].output_action[button], ""); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[button] = STORYBOARD_ACTIONS_RESUMEGAME;
			button = 7;
			strcpy(Storyboard.Nodes[node].widget_label[button], "CONTROLS"); //SOUND LEVELS
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 70.0); // 80.0 if have current design.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_GOTOSCREEN; //
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls"); //Also add "-hover.png" ...
			strcpy(Storyboard.Nodes[node].output_title[7], " CONTROLS -> Connect to Scene ");
			strcpy(Storyboard.Nodes[node].output_action[7], "controls.lua"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[7] = STORYBOARD_TYPE_SCREEN;
		}
	}
	if (orgnode == 3)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "loadgame.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}
		//3 Default Load Game screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].widgets_available = allWidgets;
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if (bRestoring == false)
			{
				if (bForce)
					Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
				else
					Storyboard.Nodes[node].restore_position = ImVec2(area_width * 0.5 - (node_width * 0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
			}
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Load Game Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_loadgame.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "loadgame.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");
			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOAD GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "load-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			for (int l = 1; l < 9; l++)
			{
				button++;
				//These should be blank and filled out using: TextCenterOnX
				strcpy(Storyboard.Nodes[node].widget_label[button], "");
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[node].widget_read_only[button] = 1;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (l * 7)); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_RETURNVALUETOLUA; //Just used for a title.
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[node].widget_name[button], "load-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...
				Storyboard.Nodes[node].widget_font_size[button] = 0.5;
			}

			button++;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-load-game"); //NOTE: DUP (back) - Also add "-hover.png" ...
			/* done elsewhere and another way now
			bool bAddLoadGameButton = true;
			int iFirstFreeButton = -1;
			for (int i = 0; i < STORYBOARD_MAXWIDGETS;i++)
			{
				if (Storyboard.Nodes[iTitleScreenNodeID].widget_used[i] == 1)
				{
					if (stricmp(Storyboard.Nodes[iTitleScreenNodeID].widget_name[i], "load-game") == 0)
					{
						bAddLoadGameButton = false;
						break;
					}
				}
				else
				{
					if (iFirstFreeButton < 0) iFirstFreeButton = i;
				}
			}
			//PE: Check if "load game" button is added to title menu.
			if (bAddLoadGameButton && iFirstFreeButton >= 0)
			{
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_label[iFirstFreeButton], "LOAD GAME");
				Storyboard.Nodes[iTitleScreenNodeID].widget_used[iFirstFreeButton] = 1;
				Storyboard.Nodes[iTitleScreenNodeID].widget_type[iFirstFreeButton] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[iTitleScreenNodeID].widget_size[iFirstFreeButton] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[iTitleScreenNodeID].widget_pos[iFirstFreeButton] = ImVec2(50.0, 20.0 + 40.0); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[iTitleScreenNodeID].widget_action[iFirstFreeButton] = STORYBOARD_ACTIONS_GOTOSCREEN;
				Storyboard.Nodes[iTitleScreenNodeID].widget_layer[iFirstFreeButton] = 0;
				Storyboard.Nodes[iTitleScreenNodeID].widget_font_color[iFirstFreeButton] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_font[iFirstFreeButton], "Default Font"); // ?
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_normal_thumb[iFirstFreeButton], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_highlight_thumb[iFirstFreeButton], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_selected_thumb[iFirstFreeButton], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].widget_name[iFirstFreeButton], "load-game"); //Also add "-hover.png" ...
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].output_title[iFirstFreeButton], " LOAD GAME -> Connect to Scene ");
				strcpy(Storyboard.Nodes[iTitleScreenNodeID].output_action[iFirstFreeButton], "loadscene"); //Not defined this yet.
				Storyboard.Nodes[iTitleScreenNodeID].output_can_link_to_type[iFirstFreeButton] = STORYBOARD_TYPE_SCREEN;
				//Storyboard.Nodes[iTitleScreenNodeID].output_linkto[iFirstFreeButton] = Storyboard.Nodes[node].input_id[0];
			}
			//PE: setup output links on "game paused" screen. , they are already there so fixed output links.
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_title[0], " LOAD GAME -> Connect to Scene ");
			strcpy(Storyboard.Nodes[iGamePausedNodeID].output_action[0], "loadscene"); //Not defined this yet.
			Storyboard.Nodes[iGamePausedNodeID].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
			//Storyboard.Nodes[iGamePausedNodeID].output_linkto[0] = Storyboard.Nodes[node].input_id[0];
			*/
		}
	}

	//Save game.
	if (orgnode == 9)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "savegame.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}
		//9 Default Save Game screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].widgets_available = allWidgets;
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if (bRestoring == false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 1);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Save Game Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_savegame.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "savegame.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SAVE GAME");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "save-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...
			for (int l = 1; l < 9; l++)
			{
				button++;
				//These should be blank and filled out using: TextCenterOnX
				strcpy(Storyboard.Nodes[node].widget_label[button], "");
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
				Storyboard.Nodes[node].widget_read_only[button] = 1;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (l * 7)); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_RETURNVALUETOLUA; //Just used for a title.
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
				strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
				strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
				strcpy(Storyboard.Nodes[node].widget_name[button], "save-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...
				Storyboard.Nodes[node].widget_font_size[button] = 0.5;
			}

			button++;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-save-game"); //NOTE: DUP (back) - Also add "-hover.png" ...
		}
	}


	//Graphics
	if (orgnode == 10)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "graphics.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}


		//PE: Change old node label.
		if (stricmp(Storyboard.Nodes[node].widget_label[4], "FOV") == 0)
		{
			strcpy(Storyboard.Nodes[node].widget_label[4], "FIELD OF VIEW");
		}

		//10 Default graphics screen
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if (bRestoring == false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 2);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Graphics Settings Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_graphics.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "graphics.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;
			Storyboard.Nodes[node].readouts_available = READOUT_GRAPHICS;
			Storyboard.Nodes[node].widgets_available = allWidgets;

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "GRAPHICS SETTINGS");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "graphics-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOW");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_RADIOTYPE;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button*10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "lowest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "MEDIUM");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_RADIOTYPE;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "medium"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "HIGHEST");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_RADIOTYPE;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "highest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "FIELD OF VIEW");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "highest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_SLIDER;

			int iPlayerFOVPerc = (((t.visuals.CameraFOV_f * t.visuals.CameraASPECT_f) - 20.0) / 180.0) * 114.0f;// *100.0;
			if (iPlayerFOVPerc < 0) iPlayerFOVPerc = 33; //default FOV
			if (iPlayerFOVPerc > 100) iPlayerFOVPerc = 33; //default FOV
			Storyboard.NodeSliderValues[node][button] = iPlayerFOVPerc;

			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "highest"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 6;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-save-game"); //NOTE: DUP (back) - Also add "-hover.png" ...
		}
	}

	//Sounds
	if (orgnode == 11)
	{
		if (bUpdateStoryboardToV2)
		{
			strcpy(Storyboard.widget_readout[node][2], "Sound Effects Volume");
			strcpy(Storyboard.widget_readout[node][4], "Music Volume");
		}
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "sounds.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		if (stricmp(Storyboard.Nodes[node].widget_label[0], "SOUND LEVELS") == 0)
		{
			strcpy(Storyboard.Nodes[node].widget_label[0], "SOUND VOLUME SETTINGS");
		}

		//11 Default sounds screen
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if (bRestoring == false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 3);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Sound Settings Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_sounds.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "sounds.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;
			Storyboard.Nodes[node].readouts_available = READOUT_SOUND;
			Storyboard.Nodes[node].widgets_available = allWidgets;

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SOUND VOLUME SETTINGS"); //"SOUND LEVELS"
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "sounds-game-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "SOUND EFFECTS");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "sound-effects-label"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_SLIDER;
			strcpy(Storyboard.widget_readout[node][button], "Sound Effects Volume");
			Storyboard.NodeSliderValues[node][button] = 100.0;

			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "slider-bar-empty"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "MUSIC");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "music-label"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_SLIDER;
			strcpy(Storyboard.widget_readout[node][button], "Music Volume");
			Storyboard.NodeSliderValues[node][button] = 100.0;

			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "slider-bar-empty"); //NOTE: DUP (load-game) - Also add "-hover.png" ...


			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-save-game"); //NOTE: DUP (back) - Also add "-hover.png" ...
		}
	}


	//Controls
	if (orgnode == 12)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "controls.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		//12 Default controls screen
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;
			if (bRestoring == false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5) - ((node_width + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 4);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Controls Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_controls.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "controls.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;
			Storyboard.Nodes[node].readouts_available = READOUT_INPUT;
			Storyboard.Nodes[node].widgets_available = allWidgets;

			//Input.
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			//No Output.

			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "CONTROLS"); //"SOUND LEVELS"
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 8); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-title"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], "Movement");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(14.0, 20 ); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-movement"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "W - Forward\nA - Strafe Left\nS - Back\nD - Strafe Right\nMouse - Look Around\nSpace - Jump\nShift - Run");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(20.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-movement-textarea"); //Also add "-hover.png" ...


			button = 3;
			strcpy(Storyboard.Nodes[node].widget_label[button], "Weapons");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(47.0, 20); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-weapons"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 4;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LMB - Shoot\nRMB - Aim\nAlt - Melee Attack\nR - Reload\n1 - 9 Weapons Slots");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(53.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-weapons-textarea"); //Also add "-hover.png" ...



			button = 5;
			strcpy(Storyboard.Nodes[node].widget_label[button], "Action");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(76.0, 20); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE; //Just used for a title.
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-actions"); //NOTE: DUP (load-game) - Also add "-hover.png" ...

			button = 6;
			strcpy(Storyboard.Nodes[node].widget_label[button], "F - Flash Light\nE - Use\nEsc - Menu");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXTAREA;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(80.0, 30.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "controls-actions-textarea"); //Also add "-hover.png" ...



			button = 7;
			strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 20 + (button * 10)); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
			strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
			strcpy(Storyboard.Nodes[node].widget_name[button], "back-control-game"); //NOTE: DUP (back) - Also add "-hover.png" ...
		}
	}
	

	//Loading screen
	if (orgnode == 2)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true)
				{
					if (strcmp(Storyboard.Nodes[i].lua_name, "loading.lua") == 0)
					{
						//Found it and its active.
						bValid = false;
						node = i;
						//PE: Fix old bug where loading screen was set to wrong type.
						if (Storyboard.Nodes[node].type != STORYBOARD_TYPE_LEVEL)
							Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
						break;
					}
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}

		//PE: Check if current project is missing the new text and inject it.
		if (!bValid && Storyboard.Nodes[node].used == true && !bForce )
		{
			//PE: Inject new text into current projects, where its missing.
			int button = 2;
			if (Storyboard.Nodes[node].widget_used[button] != 1)
			{
				strcpy(Storyboard.Nodes[node].widget_label[button], "When in game, press the Escape key for controls and other settings.");
				Storyboard.Nodes[node].widget_used[button] = 1;
				Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
				Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
				Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 95.0); //Pos in percent. using pivot center on X only.
				Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
				Storyboard.Nodes[node].widget_layer[button] = 0;
				Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
				Storyboard.Nodes[node].widget_font_size[button] = 0.5;
				strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
				strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...
			}
		}

		//2 Default Loading screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].widgets_available = ALLOW_TEXT | ALLOW_IMAGE | ALLOW_VIDEO;
			//iLoadingScreenNodeID;
			//2 Default Loading screen.
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
			if (bRestoring == false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 0);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "Loading Screen");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_loading.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "loading.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");
			strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
			strcpy(Storyboard.Nodes[node].output_title[0], " LOAD LEVEL -> Connect to Level ");
			strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
			Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_LEVEL;
			int button = 0;
			strcpy(Storyboard.Nodes[node].widget_label[button], "LOADING LEVEL");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...
			button = 1;
			strcpy(Storyboard.Nodes[node].widget_label[button], ""); //Progressbar
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_PROGRESS;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
			strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");
			button = 2;
			strcpy(Storyboard.Nodes[node].widget_label[button], "When in game, press the Escape key for controls and other settings.");
			Storyboard.Nodes[node].widget_used[button] = 1;
			Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
			Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
			Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 95.0); //Pos in percent. using pivot center on X only.
			Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
			Storyboard.Nodes[node].widget_layer[button] = 0;
			Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
			Storyboard.Nodes[node].widget_font_size[button] = 0.5;
			strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
			strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...
		}
	}

	// In-Game HUD
	if (orgnode == 13)
	{
		bool bValid = true;
		if (!bForce)
		{
			//Do we have this node ?
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used == true && strcmp(Storyboard.Nodes[i].title, "In-Game HUD") == 0)
				{
					//Found it and its active.
					bValid = false;
					node = i;
					break;
				}
			}
			if (bValid)
			{
				//Find first free node and use that. start from 8
				for (int i = 8; i < STORYBOARD_MAXNODES; i++)
				{
					if (Storyboard.Nodes[i].used == false)
					{
						node = i;
						break;
					}
				}
			}
		}
		// 13 Default In-Game HUD screen.
		if (bValid && (Storyboard.Nodes[node].used == false || bForce))
		{
			Storyboard.Nodes[node].used = true;
			Storyboard.Nodes[node].type = STORYBOARD_TYPE_HUD;
			if (bRestoring == false) Storyboard.Nodes[node].restore_position = ImVec2(area_width*0.5 - (node_width*0.5), STORYBOARD_YSTART + (node_height + NODE_HEIGHT_PADDING) * 3);
			Storyboard.Nodes[node].iEditEnable = true;
			strcpy(Storyboard.Nodes[node].title, "In-Game HUD");
			strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\hud.lua.png");
			strcpy(Storyboard.Nodes[node].lua_name, "hud0.lua");
			strcpy(Storyboard.Nodes[node].screen_backdrop, "");
			Storyboard.Nodes[node].screen_backdrop_transparent = true;
			Storyboard.Nodes[node].widgets_available = allWidgets;
			Storyboard.Nodes[node].readouts_available = READOUT_GAMEPLAY;

			// Storyboard does not yet have a HUD screen, so add one (copy from default template HUD in below filepath)
			// In future, any screen default states should be saved into this file
			StoryboardStruct templateStoryboard;
			const char* filepath = "editors\\templates\\ScreenEditor\\project.dat";
			extern bool load__storyboard_into_struct(const char*, StoryboardStruct&);
			if (load__storyboard_into_struct(filepath, templateStoryboard))
			{
				StoryboardNodesStruct& thisNode = Storyboard.Nodes[node];
				StoryboardNodesStruct& source = templateStoryboard.Nodes[orgnode];
				for (int j = 0; j < STORYBOARD_MAXWIDGETS; j++)
				{
					thisNode.widget_used[j] = source.widget_used[j];
					strcpy(thisNode.widget_label[j], source.widget_label[j]);
					thisNode.widget_size[j] = source.widget_size[j];
					thisNode.widget_pos[j] = source.widget_pos[j];
					strcpy(thisNode.widget_normal_thumb[j], source.widget_normal_thumb[j]);
					strcpy(thisNode.widget_highlight_thumb[j], source.widget_highlight_thumb[j]);
					strcpy(thisNode.widget_selected_thumb[j], source.widget_selected_thumb[j]);
					strcpy(thisNode.widget_click_sound[j], source.widget_click_sound[j]);
					thisNode.widget_action[j] = source.widget_action[j];
					strcpy(thisNode.widget_font[j],source.widget_font[j]);
					thisNode.widget_font_color[j] = source.widget_font_color[j];
					thisNode.widget_font_size[j] = source.widget_font_size[j];
					thisNode.widget_type[j] = source.widget_type[j];
					thisNode.widget_read_only[j] = source.widget_read_only[j];
					thisNode.widget_layer[j] = source.widget_layer[j];
					thisNode.widget_initial_value[j] = source.widget_initial_value[j];
					strcpy(thisNode.widget_name[j], source.widget_name[j]);
					Storyboard.widget_colors[node][j] = templateStoryboard.widget_colors[orgnode][j];
					strcpy(Storyboard.widget_readout[node][j], templateStoryboard.widget_readout[orgnode][j]);
					Storyboard.widget_textoffset[node][j] = templateStoryboard.widget_textoffset[orgnode][j];
					Storyboard.widget_ingamehidden[node][j] = templateStoryboard.widget_ingamehidden[orgnode][j];
					Storyboard.widget_drawordergroup[node][j] = templateStoryboard.widget_drawordergroup[orgnode][j];
				}
			}
		}
	}

	if (node == iLoadingScreenNodeID)
		Storyboard.Nodes[node].widgets_available = ALLOW_TEXT | ALLOW_IMAGE | ALLOW_VIDEO;
	else
		Storyboard.Nodes[node].widgets_available = defaultWidgets;
	
	if (strcmp(Storyboard.Nodes[node].title, "In-Game HUD") == 0)
	{
		Storyboard.Nodes[node].readouts_available = READOUT_GAMEPLAY;
	}
	else
	{
		Storyboard.Nodes[node].readouts_available = 0;
	}
	
	return(node);
}

int ImGui_GetWindowOrder(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)
		if (g.WindowsFocusOrder[i] == window)
			return i;
	return(-1);
}

int iZOrderIsSorting = 0;
void CheckWindowsOnTop(ImGuiWindow* storyboard_window)
{
	//PE: We need special attension on window that need to be placed on top of storyboard as its fullscreen.
	if (iZOrderIsSorting > 0)
	{
		iZOrderIsSorting--;
		return;
	}

	int storyboard_idx = ImGui_GetWindowOrder(storyboard_window);
	if (storyboard_idx < 0) return;
	int secondscreen_idx = -1;

	//PE: From Small Tutorials Videos, check this directly as there can be many, but only one at the same time.
	if (bLastSmallVideoPlayerMaximized)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Tutorial Video##VideosMaxSize");
		if (win)
		{
			bool bSwitchOrder = false;
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx) bSwitchOrder = true;
			//if (!bSwitchOrder && secondscreen_idx > 0 && settings_idx < secondscreen_idx) bSwitchOrder = true; //On top of second window.
			if (bSwitchOrder)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Tutorial Video##VideosMaxSize");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
		}
	}


	if (bAbout_Window)
	{

		
		ImGuiWindow* win = ImGui::FindWindowByName("##Credits##AboutWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "##Credits##AboutWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}

		win = ImGui::FindWindowByName("##About##AboutWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "##About##AboutWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	if (bPreferences_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Settings");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Settings");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	if (bEditGameSettings)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Edit Game Settings##Storyboard");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Edit Game Settings##Storyboard");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}
	//"Edit Game Settings##Storyboard"

	if (bExternal_Entities_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("##Object Library ExternalWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "##Object Library ExternalWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	if (bInfo_Window)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Information##InformationWindow");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Information##InformationWindow");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
			secondscreen_idx = settings_idx;
		}
	}

	//PE: Tutorial video.
	if (bVideoPlayerMaximized)
	{
		ImGuiWindow* win = ImGui::FindWindowByName("Tutorial Video##Videos2MaxSize");
		if (win)
		{
			int settings_idx = ImGui_GetWindowOrder(win);
			if (settings_idx < storyboard_idx)
			{
				//Focus settings
				strcpy(cNextWindowFocus, "Tutorial Video##Videos2MaxSize");
				iSkibFramesBeforeLaunch = 2;
				iZOrderIsSorting = iSkibFramesBeforeLaunch + 2;
				iLaunchAfterSync = 81; //Delayed window focus.
			}
		}
	}
}

bool bPopModalStoryboard = false;
bool bStoryboardWindowLast = false;
int iLastPrefStyle = -1;
int iWaitForNewLevel = 0;
int iWaitForNewScreenshot = 0;
int iWaitFor2DEditor = 0;
int iWaitFor2DEditorNode = -1;
int iNewLevelNode = -1;
int iScreenshotNode = -1;
bool bDuplicateLevel = false;
int iDuplicateNode = false;
bool bRenameLevel = false;
int iRenameNode = false;

bool bBlockNextMouseCheck = false;
int iFakeLoadGameTest = 0;
bool bStartLoadingGame = false;
int iExecuteMenuCommand = 0;
static int iCurrentSelectedWidget = -1;
static bool bTestStandalone = false;

#define INCLUDE_GAME_SETTINGS

void process_storeboard(bool bInitOnly)
{
	bool bModal = false; //Use a modal window.

	//Emulate standalone.
	static int iFramesBeforeEmulate = 0;
	static char startpage[255], lastpage[255], playerrors[255] = "\0";

	if (!bInitOnly)
	{
		if (bStoryboardWindowLast != bStoryboardWindow || iLastPrefStyle != pref.current_style)
		{
			//PE: Map each time we enter.
			mapNodeStyle();
			bStoryboardWindowLast = bStoryboardWindow;
			iLastPrefStyle = pref.current_style;
		}
	}

	if (!bStoryboardWindow && !bInitOnly)
	{
		if (!bWelcomeScreen_Window && (pref.iDisplayWelcomeScreen == 0 || pref.iLastInStoryboard == 0 ) && bTriggerWhatsNewInStoryboard)
		{
			if (g.gshowannouncements == 1)
			{
				if (g_iWelcomeLoopPage == WELCOME_ANNOUNCEMENTS)
				{
					if (gbWelcomeSystemActive == false)
					{
						welcome_init(1);
						welcome_init(2);
					}
					bool welcome_get_change_log(void);
					if (welcome_get_change_log() == true)
					{
						welcome_runloop(WELCOME_ANNOUNCEMENTS);
						iTriggerWelcomeSystemStuff = 99; //PE: Start welcome system.
					}

					welcome_init(0);
				}
				bTriggerWhatsNewInStoryboard = false;
			}
		}
	}

	if (bStoryboardWindow || bInitOnly)
	{

		//PE: setup fixed ID's
		Storyboard.game_thumb_id = STORYBOARD_THUMBS + 420;
		Storyboard.game_icon_id = STORYBOARD_THUMBS + 421;

		if (!bInitOnly)
		{
			//PE: You cant get here, without level has already asked you to save changes, so always disable project save flag here.
			g.projectmodified = 0; gridedit_changemodifiedflag();
			g.projectmodifiedstatic = 0;
		}

		if (!bInitOnly)
		{
			if (gbWelcomeSystemActive)
			{
				//PE: Hide everything in the background (wicked 3D stuff).
				ImGuiWindow* window = ImGui::FindWindowByName("Toolbar");//ImGui::GetCurrentWindow();
				ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
				window->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				return;
			}
			else
			{
				static int iHideWindowForFrames = 8;
				if (iHideWindowForFrames > 0)
				{
					iHideWindowForFrames--;
					//PE: Hide everything in the background (wicked 3D stuff).
					ImGuiWindow* window = ImGui::FindWindowByName("Toolbar");//ImGui::GetCurrentWindow();
					ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
					window->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
					return;
				}
				if (bTriggerWhatsNewInStoryboard)
				{
					if (g.gshowannouncements == 1)
					{
						//bAddWhatNewToMenu = true;
						//welcome_init(1);
						//welcome_init(0);
						//welcome_show(WELCOME_ANNOUNCEMENTS);
						if (g_iWelcomeLoopPage == WELCOME_ANNOUNCEMENTS)
						{
							if (gbWelcomeSystemActive == false)
							{
								welcome_init(1);
								welcome_init(2);
							}
							bool welcome_get_change_log(void);
							if (welcome_get_change_log() == true)
							{
								welcome_runloop(WELCOME_ANNOUNCEMENTS);
								iTriggerWelcomeSystemStuff = 99; //PE: Start welcome system.
							}

							welcome_init(0);
						}
						bTriggerWhatsNewInStoryboard = false;
					}
				}
			}
		}

		pref.iLastInStoryboard = true;
		int isize = sizeof(Storyboard); //Test.

		//PE: Use full available area.
		int preview_size_x = ImGui::GetMainViewport()->Size.x - 300.0;
		int preview_size_y = ImGui::GetMainViewport()->Size.y - 60.0;
		float fNodeWidth = 180.0f;
		float fNodeHeight = 130.0f;
		float fImgRatio = fNodeWidth/512.0;
		ImVec2 iThumbSize = ImVec2(fNodeWidth, 288.0 * fImgRatio);
		static int iLastHoveredId = -1;
		static int iLastHoveredNodeId = -1;

		//PE: Only execute this one time.
		static bool bInitStartupProject = true;
		if (bStoryboardInitNodes && bInitStartupProject)
		{
			static int iDelayLoadFrames = 2;
			if (iDelayLoadFrames == 0)
			{
				extern bool bSpecialEditorFromStandalone;
				if (bSpecialEditorFromStandalone)
				{
					extern char cSpecialStandaloneProject[MAX_PATH];
					load_storyboard(cSpecialStandaloneProject);
					iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iHUDScreenNodeID = storyboard_add_missing_nodex(13, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					//Nothing could have changed we are going directly to storyboard.
					g.projectmodified = 0;
					g.projectmodifiedstatic = 0;
				}
				else if (!pref.iDisplayWelcomeScreen)
				{
					if (strlen(pref.cLastUsedStoryboardProject) > 0)
					{
						load_storyboard(pref.cLastUsedStoryboardProject);
						iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
						iHUDScreenNodeID = storyboard_add_missing_nodex(13, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);

						//Nothing could have changed we are going directly to storyboard.
						g.projectmodified = 0;
						g.projectmodifiedstatic = 0;

					}
				}
				bInitStartupProject = false;
			}
			else iDelayLoadFrames--;
		}

		static int iStoryboardAdvancedChanged = -1;

		if (bInitOnly) iStoryboardAdvancedChanged = -1; //PE: Make sure to reload after new project on welcome screen.
		if (!bInitOnly)
		{
			if (!bStoryboardInitNodes)
			{
				iStoryboardAdvancedChanged = pref.iStoryboardAdvanced;
			}
			if (iStoryboardAdvancedChanged != pref.iStoryboardAdvanced)
			{
				//PE: If we get a change we must reload the project.
				if (strlen(Storyboard.gamename) > 0)
				{
					load_storyboard(Storyboard.gamename);
					iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					
				}
				else
				{
					//We got a empty level , setup everything again.
					bStoryboardInitNodes = false; //Just init again.
					bStoryboardFirstRunSetInitPos = false;
					strcpy(pref.cLastUsedStoryboardProject, "");
					bTriggerSaveAsAfterNewLevel = true;
					bTriggerSaveAs = true;
					strcpy(SaveProjectAsName, "");
					strcpy(SaveProjectAsError, "");
				}
				iStoryboardAdvancedChanged = pref.iStoryboardAdvanced;
			}
		}

		storeboard_init_nodes(preview_size_x, fNodeWidth, fNodeHeight+20.0);

		if (bInitOnly) return;

		if (TriggerLoadGameProject != "")
		{
			load_storyboard((char *)TriggerLoadGameProject.Get());
			iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
			iHUDScreenNodeID = storyboard_add_missing_nodex(13, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);

			TriggerLoadGameProject = "";
			bTriggerSaveAsAfterNewLevel = false;
			bTriggerSaveAs = false;
		}

		static bool bGotAThumb = false;
		
		if (iWaitFor2DEditor > 0 && iWaitFor2DEditorNode >= 0)
		{
			if (!bScreen_Editor_Window)
			{
				if (iWaitFor2DEditor == 1)
				{
					//Closed.
					GG_SetWritablesToRoot(true);
					if (FileExist("thumbbank\\lastnewlevel.jpg"))
					{
						image_setlegacyimageloading(true);
						//Use a tmp unique image id
						LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 401, 512, 288);
						image_setlegacyimageloading(false);

						if (ImageExist(STORYBOARD_THUMBS + 401))
						{
							//Get it into the correct id.
							image_setlegacyimageloading(true);
							LoadImageSize("thumbbank\\lastnewlevel.jpg", Storyboard.Nodes[iWaitFor2DEditorNode].thumb_id, 512, 288);
							image_setlegacyimageloading(false);

							if (ImageExist(Storyboard.Nodes[iWaitFor2DEditorNode].thumb_id))
							{
								//Save into thumbbank , and save thumb filename in node.
								//PE: Needed to add Storyboard.gamename so we dont get duplicates.
								/*cstr name = cstr("screen_") + cstr(Storyboard.gamename) + cstr("_") + cstr(Storyboard.Nodes[iWaitFor2DEditorNode].lua_name);*/
								// name of thumb is now based on screen title, to prevent multiple screens with same thumb name
								cstr name = cstr("screen_") + cstr(Storyboard.gamename) + cstr("_") + cstr(Storyboard.Nodes[iWaitFor2DEditorNode].title);
								CreateBackBufferCacheNameEx(name.Get(), 512, 288, true);
								SaveImage(BackBufferCacheName.Get(), Storyboard.Nodes[iWaitFor2DEditorNode].thumb_id);
								if (FileExist(BackBufferCacheName.Get()))
								{
									if (CopyToProjectFolder(BackBufferCacheName.Get()))
									{
										//PE: Use relative projectbank filename.
										strcpy(Storyboard.Nodes[iWaitFor2DEditorNode].thumb, ProjectCacheName.Get());
									}
									else
									{
										strcpy(Storyboard.Nodes[iWaitFor2DEditorNode].thumb, BackBufferCacheName.Get());
									}
								}
							}
						}
					}
					GG_SetWritablesToRoot(false);

					//Close down.
					iWaitFor2DEditor = 0;
					iWaitFor2DEditorNode = -1;
				}
				else
					iWaitFor2DEditor--;
			}
		}
		if (iWaitForNewScreenshot > 0 && iScreenshotNode >= 0)
		{
			//PE: Start process after a load.
			if (iSkibFramesBeforeLaunch <= 0)
			{
				//PE: Let level load settle and terrain generation finish before starting.
				if (!bProceduralLevel && iWaitForNewScreenshot == 3)
				{
					//Startup take screenshot.
					extern bool bPopModalOpenProceduralCameraMode;
					bPopModalOpenProceduralCameraMode = true;
					bProceduralLevel = true;
					iWaitForNewScreenshot = 2;
					bProceduralLevelFromStoryboard = true; //So it dont quit.
				}
				else
				{
					if (iWaitForNewScreenshot == 2)
					{
						//Now wait for screenshot window to close.
						if (!bProceduralLevel)
						{
							//Closed, check created screenshot.
							bGotAThumb = false;
							GG_SetWritablesToRoot(true);
							if (FileExist("thumbbank\\lastnewlevel.jpg"))
							{
								image_setlegacyimageloading(true);
								//Use a tmp unique image id
								LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 401, 512, 288);
								image_setlegacyimageloading(false);
								if (ImageExist(STORYBOARD_THUMBS + 401))
									bGotAThumb = true;
							}
							GG_SetWritablesToRoot(false);

							if(!bGotAThumb)
							{
								//No screenshot created just quit.
								iWaitForNewScreenshot = 0;
							}
							else
							{
								iWaitForNewScreenshot = 1;
							}
						}
					}
					else if (iWaitForNewScreenshot == 1)
					{
						//Last step. ask if they like to save new screenshot.
						ImGui::OpenPopup("Screenshot#Storyboard");
						ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
						static int popwinheight = 0;
						if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
						{
							ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
						}
						ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
						bool bScreenshotWindow = true;
						if (ImGui::BeginPopupModal("Screenshot#Storyboard", &bScreenshotWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
						{
							popwinheight = ImGui::GetWindowSize().y;
							ImGui::Indent(10);
							ImGui::Text("");
							ImGui::SetWindowFontScale(1.4);
							extern bool bPopModalTakeMapSnapshot;
							if(bPopModalTakeMapSnapshot==true)
								ImGui::TextCenter("Use New Map Snapshot ?");
							else
								ImGui::TextCenter("Use New Screenshot ?");
							ImGui::Separator();
							if (ImageExist(STORYBOARD_THUMBS + 401))
							{
								ImGui::ImgBtn(STORYBOARD_THUMBS + 401, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
								ImGui::Separator();
							}
							ImGui::SetWindowFontScale(1.0);

							ImGui::SetWindowFontScale(1.4);
							LPSTR pUseNewSnapTitle = "Use New Screenshot";
							if (bPopModalTakeMapSnapshot == true) pUseNewSnapTitle = "Use New Map Snapshot";
							if (ImGui::StyleButton(pUseNewSnapTitle, ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
							{
								//screenshot or map snapshot
								bool bDoScreenshotForThumb = false;
								if (bPopModalTakeMapSnapshot == true)
								{
									// Load into map snapshot image then save alongside mapbank FPM level file
									GG_SetWritablesToRoot(true);
									int iMapImageID = Storyboard.Nodes[iScreenshotNode].thumb_id;
									image_setlegacyimageloading(true);
									LoadImageSize("thumbbank\\lastnewlevel.jpg", iMapImageID, 2048, 2048);
									image_setlegacyimageloading(false);
									GG_SetWritablesToRoot(false);
									if (ImageExist(iMapImageID)==1)
									{
										// filename to save map image alongside mapbank FPM file
										char pMapImageFile[MAX_PATH];
										strcpy(pMapImageFile, g.fpscrootdir_s.Get());
										strcat(pMapImageFile, "\\Files\\");
										strcat(pMapImageFile, Storyboard.Nodes[iScreenshotNode].level_name);
										if (strnicmp(pMapImageFile + strlen(pMapImageFile) - 4, ".fpm", 4) == NULL)
										{
											pMapImageFile[strlen(pMapImageFile) - 4] = 0;
										}
										strcat(pMapImageFile, ".png");
										GG_GetRealPath(pMapImageFile, 1);
										SaveImage(pMapImageFile, iMapImageID);
									}

									// and restore screenshot thumb if one exists
									if (FileExist(Storyboard.Nodes[iScreenshotNode].thumb))
									{
										image_setlegacyimageloading(true);
										LoadImageSize(Storyboard.Nodes[iScreenshotNode].thumb, Storyboard.Nodes[iScreenshotNode].thumb_id, 512, 288);
										image_setlegacyimageloading(false);
									}
									else
									{
										// no screenshot when did map snapshot, so do screenshot at same time to have something to show
										bDoScreenshotForThumb = true;
									}
								}
								else
								{
									// screenshot mode
									bDoScreenshotForThumb = true;
								}
								if(bDoScreenshotForThumb==true)
								{
									//Load into node slot.
									GG_SetWritablesToRoot(true);
									image_setlegacyimageloading(true);
									LoadImageSize("thumbbank\\lastnewlevel.jpg", Storyboard.Nodes[iScreenshotNode].thumb_id, 512, 288);
									image_setlegacyimageloading(false);
									GG_SetWritablesToRoot(false);
									if (ImageExist(Storyboard.Nodes[iScreenshotNode].thumb_id))
									{
										//Save into thumbbank , and save thumb filename in node.
										CreateBackBufferCacheNameEx(Storyboard.Nodes[iScreenshotNode].level_name, 512, 288, true);
										SaveImage(BackBufferCacheName.Get(), Storyboard.Nodes[iScreenshotNode].thumb_id);
										if (FileExist(BackBufferCacheName.Get()))
										{
											if (CopyToProjectFolder(BackBufferCacheName.Get()))
											{
												//PE: Use relative projectbank filename.
												strcpy(Storyboard.Nodes[iScreenshotNode].thumb, ProjectCacheName.Get());
											}
											else
											{
												strcpy(Storyboard.Nodes[iScreenshotNode].thumb, BackBufferCacheName.Get());
											}
										}
									}
								}
								iWaitForNewScreenshot = 0;
							}
							ImGui::SameLine();
							if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
							{
								//Cancel.
								iWaitForNewScreenshot = 0;
							}

							ImGui::SetWindowFontScale(1.0);
							ImGui::Text("");

							bImGuiGotFocus = true;
							ImGui::Indent(-10);
							ImGui::EndPopup();
						}
					}
					else
					{
						iWaitForNewScreenshot--;
					}
				}
			}

			if (iWaitForNewScreenshot == 0)
			{
				//Quit.
				iScreenshotNode = -1;
				extern bool bPopModalOpenProceduralCameraMode;
				extern bool bPopModalTakeMapSnapshot;
				bPopModalOpenProceduralCameraMode = false;
				if (bPopModalTakeMapSnapshot == true)
				{
					// and restore camera projection override
					wiScene::GetCamera().SetCustomProjectionEnabled(false);
					wiScene::GetCamera().UpdateCamera();
					bPopModalTakeMapSnapshot = false;
				}
			}
		}

		//#########################
		//#### Duplicate Level ####
		//#########################

		static char DuplicateLevelName[256] = "\0";
		static char DuplicateLevelError[256] = "\0";
		if (bDuplicateLevel && iDuplicateNode >= 0)
		{
			//Ask to save duplicate level.
			ImGui::OpenPopup("Duplicate Level#Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bDuplicateLevelWindow = true;
			if (ImGui::BeginPopupModal("Duplicate Level#Storyboard", &bDuplicateLevelWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Duplicate Level As");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::Separator();
				if (ImageExist(Storyboard.Nodes[iDuplicateNode].thumb_id))
				{
					ImGui::ImgBtn(Storyboard.Nodes[iDuplicateNode].thumb_id, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
					ImGui::Separator();
				}
				else
				{
					ImGui::Dummy(ImVec2(512, 288));
					ImGui::Separator();
				}
				ImGui::SetWindowFontScale(1.0);

				ImGui::TextWrapped("To duplicate this level, please give it a new name and click 'Save'");
				ImGui::Text("");
				if (strlen(DuplicateLevelError) > 0)
				{
					ImGui::Text(DuplicateLevelError);
					ImGui::Text("");
				}
				ImGui::Text("Duplicate Level Name");
				ImGui::PushItemWidth(-10);
				ImGui::InputText("##DuplicateLevelNameStoryboard", DuplicateLevelName, 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (ImGui::StyleButton("Save Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
				{
					if (strlen(DuplicateLevelName) > 0)
					{
						char tmp[MAX_PATH];
						strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
						//Relative.
						char *find = (char *)pestrcasestr(tmp, "mapbank\\");
						if (find && find != &tmp[0]) strcpy(&tmp[0], find);
						strcat(tmp, DuplicateLevelName);

						t.returnstring_s = tmp;

						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave)
						{
							//Add newly saved fpm level to recent list.
							int firstempty = -1;
							int i = 0;
							for (; i < REMEMBERLASTFILES; i++) {
								if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
									firstempty = i;
								if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
									break;
								}
							}
							if (i >= REMEMBERLASTFILES) {
								if (firstempty == -1) {
									//No empty slots , rotate.
									for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
										strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
									}
									strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
								}
								else
									strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
							}

							//PE: Find next level from nodes.
							int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
							FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

							if (iFirstNodeFree >= 0)
							{
								//Create new level.
								char tmp[255];
								int node = iFirstNodeFree;
								int nodeposy = iNextLevel;
								if (levelname > 0)
								{
									sprintf(tmp, "Level %d", levelname);
									nodeposy = levelname - 1;
								}
								else
									sprintf(tmp, "Level %d", iNextLevel + 1);

								//PE: Make sure any old data is removed, also thumbs.
								reset_single_node(node);

								Storyboard.Nodes[node].used = true;
								Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x*0.5 - (fNodeWidth*0.5) + ((fNodeWidth + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
								Storyboard.Nodes[node].iEditEnable = true;
								strcpy(Storyboard.Nodes[node].title, tmp);
								strcpy(Storyboard.Nodes[node].levelnumber, tmp);

								strcpy(Storyboard.Nodes[node].thumb, "");
								//Input.
								strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
								//Output.
								strcpy(Storyboard.Nodes[node].output_title[0], " WIN LEVEL -> Connect to Scene ");
								strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
								Storyboard.Nodes[node].output_linkto[0] = 0;

								strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
								strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
								Storyboard.Nodes[node].output_linkto[1] = 0;

								strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
								strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].output_linkto[2] = 0;
								ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);


								iLaunchAfterSync = 503; //Do the actualy save here.
								iSkibFramesBeforeLaunch = 3;
								strcpy(cTriggerMessage, "Saving Level ...");
								bTriggerMessage = true;

								strcpy(Storyboard.Nodes[node].title, DuplicateLevelName);
								strcpy(Storyboard.Nodes[node].level_name, g.projectfilename_s.Get());

								if (ImageExist(Storyboard.Nodes[iDuplicateNode].thumb_id))
								{
									//Save old thumb to new thumb.
									CreateBackBufferCacheNameEx(Storyboard.Nodes[node].level_name, 512, 288, true);
									SaveImage(BackBufferCacheName.Get(), Storyboard.Nodes[iDuplicateNode].thumb_id);
									if (FileExist(BackBufferCacheName.Get()))
									{
										if (CopyToProjectFolder(BackBufferCacheName.Get()))
										{
											//PE: Use relative projectbank filename.
											strcpy(Storyboard.Nodes[node].thumb, ProjectCacheName.Get());
										}
										else
										{
											strcpy(Storyboard.Nodes[node].thumb, BackBufferCacheName.Get());
										}
										//PE: Load in new thumb to own id.
										SetMipmapNum(1); //PE: mipmaps not needed.
										image_setlegacyimageloading(true);
										LoadImageSize(Storyboard.Nodes[node].thumb, Storyboard.Nodes[node].thumb_id, 512, 288);
										image_setlegacyimageloading(false);
										SetMipmapNum(-1);
									}
								}
								bDuplicateLevel = false;
							}
							else
							{
								char pErrMess[256];
								sprintf(pErrMess, "Error: Number of allocated nodes reached. The maximum nodes is %d.", STORYBOARD_MAXNODES);
								strcpy(DuplicateLevelError, pErrMess);
							}
						}
						else
						{
							//Cancel just ignore.
						}

						//strcpy(Storyboard.Nodes[node].level_name, "");
						//Overwrite ?
					}
					else
					{
						strcpy(DuplicateLevelError, "Error: Please give your level a name before save.");
					}
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bDuplicateLevel = false;
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();
			}

		}


		//######################
		//#### Rename Level ####
		//######################

		static char RenameLevelName[256] = "\0";
		static char RenameOriginalLevelName[MAX_PATH] = "\0";
		static char RenameLevelError[256] = "\0";
		if (bRenameLevel && iRenameNode >= 0)
		{
			//Ask to Rename level.
			ImGui::OpenPopup("Rename Level##Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bRenameLevelWindow = true;
			if (ImGui::BeginPopupModal("Rename Level##Storyboard", &bRenameLevelWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Rename Level");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::Separator();
				if (ImageExist(Storyboard.Nodes[iRenameNode].thumb_id))
				{
					ImGui::ImgBtn(Storyboard.Nodes[iRenameNode].thumb_id, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
					ImGui::Separator();
				}
				else
				{
					ImGui::Dummy(ImVec2(512, 288));
					ImGui::Separator();
				}
				ImGui::SetWindowFontScale(1.0);

				ImGui::TextWrapped("To rename this level, please give it a new name and click 'Rename'");
				ImGui::Text("");
				if (strlen(RenameLevelError) > 0)
				{
					ImGui::Text(RenameLevelError);
					ImGui::Text("");
				}
				ImGui::Text("Rename Level To");
				ImGui::PushItemWidth(-10);
				ImGui::InputText("##RenameLevelNameStoryboard", RenameLevelName, 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (ImGui::StyleButton("Rename Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
				{
					if (strlen(RenameLevelName) > 0)
					{
						char tmp[MAX_PATH];
						strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
						//Relative.
						char *find = (char *)pestrcasestr(tmp, "mapbank\\");
						if (find && find != &tmp[0]) strcpy(&tmp[0], find);
						strcat(tmp, RenameLevelName);

						t.returnstring_s = tmp;

						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave)
						{
							//PE: Just rename level.
							//PE: Also remember thumb ?

							//PE: If level is not from doc write do not delete the original, but only make a copy.
							bool bIsInstallFolder = false;
							extern char szRootDir[MAX_PATH];
							if (pestrcasestr(RenameOriginalLevelName, szRootDir)) bIsInstallFolder = true;

							char destination[MAX_PATH];
							strcpy(destination, g.projectfilename_s.Get());
							GG_GetRealPath(destination, 1); //Resolve name. need full path.

							if (bIsInstallFolder)
							{
								CopyFileA(RenameOriginalLevelName, destination,false);
							}
							else
							{
								rename(RenameOriginalLevelName, destination);
							}

							if (FileExist(destination))
							{

								//Now setup new level name include relative only.
								strcpy(tmp, destination);
								char *find = (char *)pestrcasestr(tmp, "mapbank\\");
								if (find && find != &tmp[0]) strcpy(&tmp[0], find);
								strcpy(Storyboard.Nodes[iRenameNode].level_name, tmp);

								//Setup new title.
								std::string sLevelTitle = Storyboard.Nodes[iRenameNode].level_name;
								replaceAll(sLevelTitle, ".fpm", "");
								replaceAll(sLevelTitle, "mapbank\\", "");
								strcpy(Storyboard.Nodes[iRenameNode].title, sLevelTitle.c_str());

								bRenameLevel = false;

								//PE: Save changes if possible.
								if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
								{
									save_storyboard(Storyboard.gamename, false);
								}

							}
							else
							{
								strcpy(RenameLevelError, "Error: Rename failed no changes done.");
							}
						}
						else
						{
							//Cancel just ignore.
						}
					}
					else
					{
						strcpy(RenameLevelError, "Error: Please give your level a new name before renaming.");
					}
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bRenameLevel = false;
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();
			}
		}

		bool bReadyToOpen = false;
		if (bTriggerOpenProject)
		{
			if (iDelayTriggerOpenProject > 0)
			{
				iDelayTriggerOpenProject--;
				if (iDelayTriggerOpenProject == 0)
				{
					strcpy(cNextWindowFocus, "Open Project##Storyboard");
					iSkibFramesBeforeLaunch = 2;
					iLaunchAfterSync = 81; //Delayed window focus.
				}
			}
			else
			{
				bReadyToOpen = true;
			}
		}
		if (bReadyToOpen)
		{
			//Open Project window.
			static char OpenProjectName[256] = "\0";
			static char OpenProjectError[256] = "\0";

			ImGui::OpenPopup("Open Project##Storyboard");
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}
			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bOpenWindow = true;
			//PE: Somehow cant get this window ontop ?
			if (ImGui::BeginPopupModal("Open Project##Storyboard", &bOpenWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
			{
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Open Game Project");
				ImGui::Separator();

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::Text("Select the project to open and click 'Open Project'");
				ImGui::SameLine(); ImGui::Text(" ");
				ImGui::Text("");
				if (strlen(OpenProjectError) > 0)
				{
					ImGui::Text(OpenProjectError);
					ImGui::Text("");
				}
				//Ignore _backup files.

				// when in a remote project, need to rebuild the latest writables based project list
				GG_SetWritablesToRoot(true);
				GetProjectList("projectbank\\");
				GG_SetWritablesToRoot(false);

				static std::string current_project_selected = "";
				ImVec2 size = { ImGui::GetContentRegionAvailWidth(),0 };

				float fHeight = ImGui::GetFontSize() * 10.0;

				ImGui::Text("Projects");
				ImGui::SameLine();
				static bool bDisplayBackups = false;
				float fBoxWidth = ImGui::CalcTextSize("Display Backups").x;
				ImGui::SetCursorPosX((ImGui::GetCursorPosX() + ImGui::GetContentRegionAvail().x) - 10.0 - 30.0 - fBoxWidth);
				ImGui::Checkbox("Display Backups", &bDisplayBackups);
				ImGui::BeginChild("Projects##FileOpenStoryboard", ImVec2(ImGui::GetContentRegionAvail().x - 10.0, fHeight), true, iGenralWindowsFlags);
				bool bTriggerLoad = false;
				if (projectbank_list.size() > 0)
				{
					float fRegAvail = ImGui::GetContentRegionAvailWidth() - 10.0;
					for (int i = 0; i < projectbank_list.size(); i++)
					{
						if (bDisplayBackups || !pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
						{
							bool bSelected = false;
							if (current_project_selected == projectbank_list[i]) bSelected = true;
							if (ImGui::Selectable(projectbank_list[i].c_str(), bSelected))
							{
								current_project_selected = projectbank_list[i];
							}
							if(ImGui::IsItemHovered())
							{
								if (ImGui::IsMouseDoubleClicked(0))
								{
									current_project_selected = projectbank_list[i];
									bTriggerLoad = true;
								}
							}
						}
					}
				}
				else
				{
					ImGui::Text("No Projects Found.");
				}
				ImGui::EndChild();
				ImGui::PushItemWidth(-10);
				ImGui::InputText("##OpenProjectStoryboardText", (char *) current_project_selected.c_str(), 250, ImGuiInputTextFlags_ReadOnly); //ImGuiInputTextFlags_None
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (bTriggerLoad || ImGui::StyleButton("Open Project", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)))
				{
					// and in case this was a remote project, restore to writables regular
					extern void switch_to_regular_projects(void);
					switch_to_regular_projects();

					//Open
					load_storyboard( (char *) current_project_selected.c_str());
					iGamePausedNodeID = storyboard_add_missing_nodex(8, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadGameNodeID = storyboard_add_missing_nodex(3, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSaveGameNodeID = storyboard_add_missing_nodex(9, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iGraphicsNodeID = storyboard_add_missing_nodex(10, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iSoundsNodeID = storyboard_add_missing_nodex(11, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iControlNodeID = storyboard_add_missing_nodex(12, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iLoadingScreenNodeID = storyboard_add_missing_nodex(2, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);
					iHUDScreenNodeID = storyboard_add_missing_nodex(13, preview_size_x, fNodeWidth, fNodeHeight + 20.0, false);

					bTriggerOpenProject = false;
					bOpenProjectsFromWelcome = false;
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bTriggerOpenProject = false;
					if (bOpenProjectsFromWelcome)
					{
						bWelcomeScreen_Window = true;
						bStoryboardWindow = false;
						bOpenProjectsFromWelcome = false;
					}
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();

				bBlockNextMouseCheck = true;
			}
		}
		if (bStoryboardWindowOpenLoad)
		{
			bTriggerOpenProject = true;
			bStoryboardWindowOpenLoad = false;
			bTriggerSaveAs = false;
			bTriggerSaveAsAfterNewLevel = false;
		}

		int iCreateRet = save_create_storyboard_project();

		if (!bPopModalStoryboard)
		{
			if (bModal)
				ImGui::OpenPopup("##StoryboardWindow");
		}
		static int UpdateThumbOnNode = -1;
		if (UpdateThumbOnNode >= 0)
		{
			image_setlegacyimageloading(true);
			if (Storyboard.Nodes[UpdateThumbOnNode].type == STORYBOARD_TYPE_SPLASH)
			{
				//PE: On splash load directly. Splash always get a center positons.
				bool bUseRealSplash = true;
				if ( strcmp(Storyboard.Nodes[UpdateThumbOnNode].thumb, "editors\\uiv3\\loadingsplash.jpg") == 0)
				{
					LoadImage("editors\\uiv3\\user-splash-screen.png", Storyboard.Nodes[UpdateThumbOnNode].thumb_id);
					if(ImageExist(Storyboard.Nodes[UpdateThumbOnNode].thumb_id)) bUseRealSplash = false;
				}

				if(bUseRealSplash)
					LoadImage(Storyboard.Nodes[UpdateThumbOnNode].thumb, Storyboard.Nodes[UpdateThumbOnNode].thumb_id);
			}
			else
			{
				LoadImageSize(Storyboard.Nodes[UpdateThumbOnNode].thumb, Storyboard.Nodes[UpdateThumbOnNode].thumb_id, 512, 288);
			}
			image_setlegacyimageloading(false);

			UpdateThumbOnNode = -1;
		}
		if (!bStoryboardFirstRunSetInitPos)
		{

			if (Storyboard.iStoryboardVersion != STORYBOARDVERSION)
			{
				//PE: Convert old storyboard setups if needed.
				if (Storyboard.iStoryboardVersion == 100 && Storyboard.project_readonly == 0)
				{
					Storyboard.iStoryboardVersion = STORYBOARDVERSION;
					Storyboard.iChanged = true;
					//PE: Convert old thumb path to new projectbank path, and copy thumbs.
					for (int i = 0; i < STORYBOARD_MAXNODES; i++)
					{
						bool bValid = true;
						if (bValid && Storyboard.Nodes[i].used)
						{
							if (strlen(Storyboard.Nodes[i].thumb) > 0)
							{
								char *find = (char *)pestrcasestr(Storyboard.Nodes[i].thumb, "thumbbank\\");
								if (find)
								{
									if (CopyToProjectFolder(Storyboard.Nodes[i].thumb))
									{
										//PE: Use relative projectbank filename.
										if (FileExist(ProjectCacheName.Get()))
										{
											strcpy(Storyboard.Nodes[i].thumb, ProjectCacheName.Get());
										}
									}
								}
							}
							if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
							{
								if (strlen(Storyboard.Nodes[i].level_name) > 0)
								{
									//CreateBackBufferCacheName(Storyboard.Nodes[i].level_name, 512, 288);
									char *find = (char *)pestrcasestr(Storyboard.Nodes[i].thumb, "thumbbank\\");
									if (find)
									{
										if (CopyToProjectFolder(Storyboard.Nodes[i].thumb))
										{
											//PE: Use relative projectbank filename.
											if (FileExist(ProjectCacheName.Get()))
											{
												strcpy(Storyboard.Nodes[i].thumb, ProjectCacheName.Get());
											}
										}
									}
								}
							}
						}
					}
				}
			}

			//PE: Initial position. and initial nodes.
			if (ImageExist(Storyboard.game_icon_id)) DeleteImage(Storyboard.game_icon_id);
			if (ImageExist(Storyboard.game_thumb_id)) DeleteImage(Storyboard.game_thumb_id);
			if (strlen(Storyboard.game_thumb) > 0)
			{
				image_setlegacyimageloading(true);
				LoadImage(Storyboard.game_thumb, Storyboard.game_thumb_id);
				image_setlegacyimageloading(false);
			}
			if (strlen(Storyboard.game_icon) > 0)
			{
				image_setlegacyimageloading(true);
				//LoadImage(Storyboard.game_icon, Storyboard.game_icon_id);
				LoadImageSize(Storyboard.game_icon, Storyboard.game_icon_id, 256, 256);
				image_setlegacyimageloading(false);
			}

			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				bool bValid = true;
				if (bValid && Storyboard.Nodes[i].used)
				{

					if (ImageExist(Storyboard.Nodes[i].screen_backdrop_id)) DeleteImage(Storyboard.Nodes[i].screen_backdrop_id);
					if (strlen(Storyboard.Nodes[i].screen_backdrop) > 0)
					{
						//Backdrop.
						image_setlegacyimageloading(true);
						LoadImage(Storyboard.Nodes[i].screen_backdrop, Storyboard.Nodes[i].screen_backdrop_id);
						image_setlegacyimageloading(false);
					}

					ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[i].id, Storyboard.Nodes[i].restore_position);

					if (ImageExist(Storyboard.Nodes[i].thumb_id)) DeleteImage(Storyboard.Nodes[i].thumb_id);
					if (!ImageExist(Storyboard.Nodes[i].thumb_id) && strlen(Storyboard.Nodes[i].thumb) > 0)
					{
						image_setlegacyimageloading(true);
						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
						{
							//PE: On splash load directly. Splash always get a center positons.
							bool bUseRealSplash = true;
							if (strcmp(Storyboard.Nodes[i].thumb, "editors\\uiv3\\loadingsplash.jpg") == 0)
							{
								LoadImage("editors\\uiv3\\user-splash-screen.png", Storyboard.Nodes[i].thumb_id);
								if (ImageExist(Storyboard.Nodes[i].thumb_id)) bUseRealSplash = false;
							}

							if (bUseRealSplash)

							LoadImage(Storyboard.Nodes[i].thumb, Storyboard.Nodes[i].thumb_id);
						}
						else
						{
							LoadImageSize(Storyboard.Nodes[i].thumb, Storyboard.Nodes[i].thumb_id, 512, 288);
							if (!ImageExist(Storyboard.Nodes[i].thumb_id))
							{
								//PE: Try relative path.
								char tmp[MAX_PATH];
								strcpy(tmp, Storyboard.Nodes[i].thumb);
								char *find = (char *) pestrcasestr(tmp, "\\thumbbank\\");
								if (find)
								{
									find++;
									LoadImageSize(find, Storyboard.Nodes[i].thumb_id, 512, 288);
									if (ImageExist(Storyboard.Nodes[i].thumb_id))
									{
										//PE: Update thumb path.
										strcpy(Storyboard.Nodes[i].thumb,find);
									}
									else
									{
										//Relative also failed, use default.
										if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == iTitleScreenNodeID)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_title.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == 2)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_loading.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == iLoadGameNodeID)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_loadgame.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i == 4)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_about.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title,"Game Won Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_win.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Game Over Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_lose.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Game Paused") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_gamemenu.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Load Game Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_loadgame.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Save Game Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_savegame.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Sound Settings Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_sounds.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Graphics Settings Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_graphics.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && strcmp(Storyboard.Nodes[i].title, "Controls Screen") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\screen_controls.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
										// LB latest
										else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD && strcmp(Storyboard.Nodes[i].title, "In-Game HUD") == 0)
										{
											LoadImageSize("editors\\templates\\thumbs\\hud.lua.png", Storyboard.Nodes[i].thumb_id, 512, 288);
										}
									}
								}

							}
						}
						image_setlegacyimageloading(false);
					}
				}
			}
			if (GImNodes)
			{
				//Reset grid.
				ImNodes::EditorContextResetPanning(Storyboard.vEditorPanning);
			}

			bStoryboardFirstRunSetInitPos = true;
		}

		//#### Init Done ####

		#ifdef INCLUDE_GAME_SETTINGS

		if (bEditGameSettings)
		{
			//PE: Cant use modal, as we use the objectlib.

			int iWindowWidth = 1100;
			int iWindowHeight = 600;
			float buttonwide = 200.0f;
			//ImGui::OpenPopup("Edit Game Settings##Storyboard");
			//ImGui::SetNextWindowSize(ImVec2(iWindowWidth, iWindowHeight), ImGuiCond_Always);
			//ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			ImGui::SetNextWindowSize(ImVec2(iWindowWidth, iWindowHeight), ImGuiCond_Always);
			//static bool bUpdateWinPos = false;
			//static ImVec2 winpos = ImVec2(iWindowWidth, iWindowHeight);
			//if (bUpdateWinPos)
			//{
			//	ImGui::SetNextWindowPos(winpos,ImGuiCond_Always);
			//	bUpdateWinPos = false;
			//}
			//else
			//{
				ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			//}
			bool bOpenWindow = true;
			//if (ImGui::BeginPopupModal("Edit Game Settings##Storyboard", &bOpenWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))

			if (ImGui::Begin("Edit Game Settings##Storyboard", &bEditGameSettings, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings))
			{
				//PE: Header look.
				ImGuiWindow* window = ImGui::GetCurrentWindow();
				float fToolbarHeight = 74.0f;
				ImVec4 style_headerback = ImGui::GetStyle().Colors[ImGuiCol_TitleBgActive];
				style_headerback.w = 1.0f;
				ImRect rHeader = { ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImVec2(ImGui::GetWindowSize().x, fToolbarHeight) };
				if(window) window->DrawList->AddRectFilled(rHeader.Min, rHeader.Max, ImGui::GetColorU32(style_headerback), 0.0f, ImDrawCornerFlags_None);

				ImVec4 style_back = ImGui::GetStyle().Colors[ImGuiCol_WindowBg] * ImVec4(0.9, 0.9, 0.9, 0.9); //A Little darker.
				style_back.w = 1.0f;


				/*
				static bool bDragTitleActive = false;
				if ( (ImGui::IsMouseHoveringRect(rHeader.Min, rHeader.Max, true) || bDragTitleActive) && ImGui::IsMouseDragging())
				{
					if (ImGui::IsMouseDragging())
					{
						float offsetx = ImGui::GetIO().MouseDelta.x;
						float offsety = ImGui::GetIO().MouseDelta.y;
						winpos += ImVec2(offsetx, offsety);
						bDragTitleActive = true;
						bUpdateWinPos = true;
					}
				}
				if (!ImGui::IsMouseDown(0))
					bDragTitleActive = false;
				*/

				ImGui::Text("");
				ImGui::SetWindowFontScale(1.8);
				ImGui::TextCenter("Editing: Game Project Settings.");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImVec2 vIconSize = { (float)ImGui::GetFontSize()*4.0f, (float)ImGui::GetFontSize()*4.0f };
				ImGui::SetCursorPos(ImVec2(3.0f, 7.0 + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bEditGameSettings = false;
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to Storyboard");
				ImGui::SetCursorPos(vCurPos);

				ImGui::Columns(2, "StoryboardWindowGameSettingsColumns", false);  //false no border
				ImGui::SetColumnOffset(0, 0.0f);
				ImGui::SetColumnOffset(1, (float)iWindowWidth * 0.75);


				//Storyboard.game_icon_id

				static int iChangeTab = 0;
				if (ImGui::BeginTabBar("GameSettingstabbar"))
				{
					int tabflags = 0;
					if (iChangeTab == 1)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}

					static bool bUpdateThumbImage = false;
					if (bUpdateThumbImage)
					{
						bUpdateThumbImage = false;
						if (ImageExist(Storyboard.game_thumb_id)) DeleteImage(Storyboard.game_thumb_id);
						if (strlen(Storyboard.game_thumb) > 0)
						{
							image_setlegacyimageloading(true);
							LoadImage(Storyboard.game_thumb, Storyboard.game_thumb_id);
							image_setlegacyimageloading(false);
						}
					}

					static bool bUpdateIconImage = false;
					if (bUpdateIconImage)
					{
						bUpdateIconImage = false;
						if (ImageExist(Storyboard.game_icon_id)) DeleteImage(Storyboard.game_icon_id);
						if (strlen(Storyboard.game_icon) > 0)
						{
							image_setlegacyimageloading(true);
							LoadImage(Storyboard.game_icon, Storyboard.game_icon_id);
							image_setlegacyimageloading(false);
						}
					}

					if (ImGui::BeginTabItem(" Thumbnail ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Change Game Thumbnail");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						ImGui::TextCenter("For best result use a 16:9 ratio image like 19201080.");

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512*0.5), 0.0f));
						ImGui::SetCursorPos(cPos);
						if (ImageExist(Storyboard.game_thumb_id))
						{
							//Need ratio here. fit to 288 height.
							ImGui::ImgBtn(Storyboard.game_thumb_id, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
						}
						else
						{
							if (window) window->DrawList->AddRectFilled(window->DC.CursorPos, window->DC.CursorPos + ImVec2(512, 288), ImGui::GetColorU32(style_back), 0.0f, ImDrawCornerFlags_None);
							ImGui::Dummy(ImVec2(512, 288));
						}

						cstr UniqueThumbnailSelect = "##StoryboardSelectThumbnail";
						if (iSelectedLibraryStingReturnID == window->GetID(UniqueThumbnailSelect.Get()))
						{
							strcpy(Storyboard.game_thumb, sSelectedLibrarySting.Get());
							bUpdateThumbImage = true; //Update thumb.
							sSelectedLibrarySting = "";
							iSelectedLibraryStingReturnID = -1; //disable.
							Storyboard.iChanged = true;
						}


						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");

						cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
						ImGui::SetCursorPos(cPos);

						if (ImGui::StyleButton("Select a New Image", ImVec2(buttonwide, 0.0f)))
						{
							bExternal_Entities_Window = true;
							iDisplayLibraryType = 2; //Image
							iLibraryStingReturnToID = window->GetID(UniqueThumbnailSelect.Get());
							if (strlen(Storyboard.game_thumb) > 0)
							{
								sMakeDefaultSelecting = Storyboard.game_thumb;
								bSelectLibraryViewAll = true;
							}
						}
						ImGui::SetWindowFontScale(1.0);

						ImGui::EndTabItem();
					}

					tabflags = 0;
					if (iChangeTab == 2)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}
					if (ImGui::BeginTabItem(" Description ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Edit Text Description");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512 * 0.5), 0.0f));
						ImGui::SetCursorPos(cPos);
						//PE: Need to be a little bit smaller then welcome screen that display description.

						ImGui::SetWindowFontScale(1.2);
						float width = 586.0; //480.0;
						//if (ImGui::InputTextMultiline("##Game Description", &Storyboard.game_description[0], 2048, ImVec2(480, 288), ImGuiInputTextFlags_CallbackAlways, CLB, &(width)))
						//if (ImGui::InputTextMultiline("##Game Description", &Storyboard.game_description[0], 2048, ImVec2(width, 288 ),0,NULL,(void*)-1 ) )
						if (ImGui::InputTextMultiline("##Game Description", &Storyboard.game_description[0], 2048, ImVec2(width, ImGui::GetFontSize()*19+12.0), 0, NULL, (void*)-1))
						{
							//PE: Simple Wrap input.

							char tmp[4096];
							char cmp[4096];
							strcpy(tmp, Storyboard.game_description);

							//PE: Get a avg. char wide.
							int wraparound = width / ((float) ImGui::CalcTextSize("abcdefghijkABCDEFGHIJK").x / 22.0);

							int len = strlen(tmp);
							int bBestMatch = -1;
							int count = 0;
							for (int i = 0; i < len; i++)
							{
								cmp[count] = tmp[i]; cmp[count + 1] = 0;

								if ( i > bBestMatch && tmp[i] == ' ') bBestMatch = i;
								if (tmp[i] == '\n') count = 0;

								if (count++ >= wraparound && (ImGui::CalcTextSize(cmp).x > (width - 18.0)) )
								{
									if (bBestMatch > 0)
									{
										tmp[bBestMatch] = '\n';
									}
									bBestMatch = -1;
									count = 0;
								}
							}
							strcpy(Storyboard.game_description, tmp);
							Storyboard.iChanged = true;
						}
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndTabItem();
					}

					tabflags = 0;
					if (iChangeTab == 3)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}
					if (ImGui::BeginTabItem(" Edge of Game World ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Edit Edge of Game World Message");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						// gameplayercontro.lua: Prompt ( "You cannot leave the area of play" )

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512 * 0.5), 0.0f));
						ImGui::SetCursorPos(cPos);

						ImGui::PushItemWidth(512);
						if (ImGui::InputText("##game_world_edge_textStoryboardInput", Storyboard.game_world_edge_text, 512, ImGuiInputTextFlags_None))
						{
							Storyboard.iChanged = true;
						}
						ImGui::PopItemWidth();

						ImGui::EndTabItem();
					}

					tabflags = 0;
					if (iChangeTab == 4)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}

					if (strlen(Storyboard.gamename) > 0)
					{
						if (ImGui::BeginTabItem(" Icon ", NULL, tabflags))
						{
							cstr UniqueIconnailSelect = "##StoryboardSelectIconnail";
							if (iSelectedLibraryStingReturnID == window->GetID(UniqueIconnailSelect.Get()))
							{
								strcpy(Storyboard.game_icon, sSelectedLibrarySting.Get());
								//bUpdateIconImage = true; //Update icon.
								sSelectedLibrarySting = "";
								iSelectedLibraryStingReturnID = -1; //disable.
								Storyboard.iChanged = true;

								if (ImageExist(Storyboard.game_icon_id)) DeleteImage(Storyboard.game_icon_id);
								if (strlen(Storyboard.game_icon) > 0)
								{
									image_setlegacyimageloading(true);
									//LoadImage(Storyboard.game_icon, Storyboard.game_icon_id);
									LoadImageSize(Storyboard.game_icon, Storyboard.game_icon_id, 256, 256);
									image_setlegacyimageloading(false);
								}

								if (ImageExist(Storyboard.game_icon_id))
								{
									//Save and convert to ico.

									char projectpng[MAX_PATH];
									strcpy(projectpng, Storyboard.game_icon);
									GG_GetRealPath(projectpng, 0);

									//ffmpeg -i maxicon.png -vf scale=256:256 maxicon.ico

									extern char g_pAbsPathToConverter[MAX_PATH];
									std::string process_name = g_pAbsPathToConverter;
									replaceAll(process_name, "\\Guru-Converter.exe", "\\ffmpeg.exe");

									DARKSDK BOOL DB_ExecuteFile(HANDLE* phExecuteFileProcess, char* Operation, char* Filename, char* String, char* Path, bool bWaitForTermination);
									char parameters[MAX_PATH];

									::SetCursor(::LoadCursor(NULL, IDC_WAIT));

									for (int a = 0; a < 1; a++) //PE: (a < 6) for now only use 256x256
									{

										strcpy(parameters, "-i \"");
										strcat(parameters, projectpng);

										//Delete old ico.
										char projectico[MAX_PATH];
										strcpy(projectico, "projectbank\\");
										strcat(projectico, Storyboard.gamename);

										//PE: in MAX 256x256 is 256 colors only, so use 128x128 as main icon.
										//strcat(parameters, "\" -vf scale=256:256 \"");
										//palettegen=max_colors=256
										if (a == 0)
										{
											strcat(parameters, "\" -vf scale=256:256 \"");
											strcat(projectico, "\\project256.ico");
										}
										else if (a == 1)
										{
											strcat(parameters, "\" -vf scale=128:128 \"");
											strcat(projectico, "\\project128.ico");
										}
										else if (a == 2)
										{
											strcat(parameters, "\" -vf scale=64:64 \"");
											strcat(projectico, "\\project64.ico");
										}
										else if (a == 3)
										{
											strcat(parameters, "\" -vf scale=48:48 \"");
											strcat(projectico, "\\project32.ico");
										}
										else if (a == 4)
										{
											strcat(parameters, "\" -vf scale=32:32 \"");
											strcat(projectico, "\\project32.ico");
										}
										else
										{
											strcat(parameters, "\" -vf scale=16:16 \"");
											strcat(projectico, "\\project16.ico");
										}

										GG_GetRealPath(projectico, 1);
										DeleteFileA(projectico);

										strcat(parameters, projectico);
										strcat(parameters, "\"");

										HANDLE g_hConvertPngToIcoProcess = NULL;

										DB_ExecuteFile(&g_hConvertPngToIcoProcess, "hide", (char *)process_name.c_str(), parameters, "", true);
										int iRunning = 1;
										int timeout = 0;
										while (iRunning == 1)
										{
											iRunning = 0;
											DWORD dwStatus;
											if (GetExitCodeProcess(g_hConvertPngToIcoProcess, &dwStatus) == TRUE)
											{
												if (dwStatus == STILL_ACTIVE)
												{
													iRunning = 1;
													Sleep(1);
													if (timeout++ > 4000) iRunning = 0; //Timeout
												}
											}
										}
										CloseHandle(g_hConvertPngToIcoProcess);
										Sleep(10);
									}
									::SetCursor(::LoadCursor(NULL, IDC_ARROW));
								}
							}

							ImGui::SetWindowFontScale(1.4);
							ImGui::Text("");
							ImGui::TextCenter("Edit Game Executable Icon");
							ImGui::Text("");
							ImGui::SetWindowFontScale(1.0);

							ImGui::TextCenter("For best result use a 256x256 png image.");

							ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (256 * 0.5), 0.0f));
							ImGui::SetCursorPos(cPos);
							if (ImageExist(Storyboard.game_icon_id))
							{
								//Need ratio here. fit to 288 height.
								ImGui::ImgBtn(Storyboard.game_icon_id, ImVec2(256, 256), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
							}
							else
							{
								if (window) window->DrawList->AddRectFilled(window->DC.CursorPos, window->DC.CursorPos + ImVec2(256, 256), ImGui::GetColorU32(style_back), 0.0f, ImDrawCornerFlags_None);
								ImGui::Dummy(ImVec2(256, 256));
							}

							ImGui::SetWindowFontScale(1.4);
							ImGui::Text("");

							cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
							ImGui::SetCursorPos(cPos);

							if (ImGui::StyleButton("Select a New Icon", ImVec2(buttonwide, 0.0f)))
							{
								bExternal_Entities_Window = true;
								iDisplayLibraryType = 2; //Image
								iLibraryStingReturnToID = window->GetID(UniqueIconnailSelect.Get());
								if (strlen(Storyboard.game_icon) > 0)
								{
									sMakeDefaultSelecting = Storyboard.game_icon;
									bSelectLibraryViewAll = true;
								}
							}
							ImGui::SetWindowFontScale(1.0);

							//TEST
							//#define TESTICONINJECT
							#ifdef TESTICONINJECT
							if (ImGui::StyleButton("TEST -> FISHLAKE.exe", ImVec2(buttonwide, 0.0f)))
							{
								void InjectIconToExe(char *icon, char *exe, int intresourcenumber);
								char projectico[MAX_PATH];
								char projectfinal_ico[MAX_PATH];
								strcpy(projectico, "projectbank\\");
								strcat(projectico, Storyboard.gamename);

								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project256.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "C:\\Users\\leeba\\Documents\\GameGuruApps\\GameGuruMAX\\My Games\FISHLAKE\\FISHLAKE.exe", 1);

								//strcpy(projectfinal_ico, projectico);
								//strcat(projectfinal_ico, "\\project16.ico");
								//GG_GetRealPath(projectfinal_ico, 1);
								//InjectIconToExe(projectfinal_ico, "C:\\Users\\leeba\\Documents\\GameGuruApps\\GameGuruMAX\\My Games\FISHLAKE\\FISHLAKE.exe", 6);

								//PE: Only 256 used for now.
								/*
								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project128.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe",2);
								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project64.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 3);
								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project48.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 4);
								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project32.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 5);
								strcpy(projectfinal_ico, projectico);
								strcat(projectfinal_ico, "\\project16.ico");
								GG_GetRealPath(projectfinal_ico, 1);
								InjectIconToExe(projectfinal_ico, "c:\\DEV\\standalone\\char1\\char1.exe", 6);
								*/
							}
							#endif
							ImGui::EndTabItem();
						}
					}
					tabflags = 0;
					if (iChangeTab == 4)
					{
						iChangeTab = 0;
						tabflags = ImGuiTabItemFlags_SetSelected;
					}
					if (ImGui::BeginTabItem(" Game Developer ", NULL, tabflags))
					{
						ImGui::SetWindowFontScale(1.4);
						ImGui::Text("");
						ImGui::TextCenter("Game Developer Description");
						ImGui::Text("");
						ImGui::SetWindowFontScale(1.0);

						ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (512 * 0.5), 0.0f));
						ImGui::SetCursorPos(cPos);

						ImGui::SetWindowFontScale(1.2);
						float width = 586.0; //480.0;

						if (ImGui::InputTextMultiline("##Developer Description", &Storyboard.game_developer_desc[0], 1023, ImVec2(width, ImGui::GetFontSize() * 10 + 12.0), 0, NULL, (void*)-1))
						{
							char tmp[4096];
							char cmp[4096];
							strcpy(tmp, Storyboard.game_developer_desc);

							//PE: Get a avg. char wide.
							int wraparound = width / ((float)ImGui::CalcTextSize("abcdefghijkABCDEFGHIJK").x / 22.0);

							int len = strlen(tmp);
							int bBestMatch = -1;
							int count = 0;
							for (int i = 0; i < len; i++)
							{
								cmp[count] = tmp[i]; cmp[count + 1] = 0;

								if (i > bBestMatch && tmp[i] == ' ') bBestMatch = i;
								if (tmp[i] == '\n') count = 0;

								if (count++ >= wraparound && (ImGui::CalcTextSize(cmp).x > (width - 18.0)))
								{
									if (bBestMatch > 0)
									{
										tmp[bBestMatch] = '\n';
									}
									bBestMatch = -1;
									count = 0;
								}
							}
							strcpy(Storyboard.game_developer_desc, tmp);
							Storyboard.iChanged = true;
						}
						ImGui::SetWindowFontScale(1.0);
						ImGui::EndTabItem();
					}
					ImGui::EndTabBar();
				}
				//####

				/*
				ImGui::Indent(10);
				ImGui::Text("");
				ImVec2 cPos = ImVec2(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
				cPos.y = ImGui::GetWindowSize().y - 30.0;
				ImGui::SetCursorPos(cPos);
				if (ImGui::StyleButton("Close", ImVec2(buttonwide, 0.0f)))
				{
					//Close.
					bEditGameSettings = false;
				}
				ImGui::Indent(-10);
				*/

				//####
				ImGui::NextColumn();

				if (ImGui::StyleCollapsingHeader("Game Description", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
				{
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Change Game Thumbnail", ImVec2(buttonwide, 0.0f)))
					{
						//code
						iChangeTab = 1;
					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Edit Text Description", ImVec2(buttonwide, 0.0f)))
					{
						//code
						iChangeTab = 2;
					}
					ImGui::Indent(-10);
				}
				if (ImGui::StyleCollapsingHeader("In-Game Settings", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
				{
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Edge of Game World Message", ImVec2(buttonwide, 0.0f)))
					{
						//code
						iChangeTab = 3;
					}
					ImGui::Indent(-10);
				}

				if (strlen(Storyboard.gamename) > 0)
				{
					if (ImGui::StyleCollapsingHeader("Export Settings", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
					{
						ImGui::Indent(10);
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Game Executable Icon", ImVec2(buttonwide, 0.0f)))
						{
							//code
							iChangeTab = 4;
						}
						ImGui::Indent(-10);
					}
				}
				ImGui::EndColumns();

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				//ImGui::EndPopup();
				bBlockNextMouseCheck = true;
			}
			ImGui::End();

			if (!bOpenWindow)
			{
				bEditGameSettings = false;
			}
		}
		#endif


		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;

		static ImVec2 old_viewPortSize = { -1,-1 };
		if (old_viewPortSize.x != viewPortSize.x || old_viewPortSize.y != viewPortSize.y)
		{
			ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
			ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always);
			old_viewPortSize = viewPortSize;
		}
		else if (bModal)
		{
			ImGui::SetNextWindowPos(viewPortPos);
			ImGui::SetNextWindowSize(viewPortSize);
		}
		else
		{
			ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Once);
			ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Once);
		}

		//ImGuiWindowFlags_MenuBar , ImGuiWindowFlags_NoTitleBar, ImGuiWindowFlags_NoBringToFrontOnFocus
		if (bModal)
		{
			bPopModalStoryboard = ImGui::BeginPopupModal("##StoryboardWindow", &bStoryboardWindow, ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize); // ImGuiWindowFlags_NoScrollbar
		}
		else
		{
			ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
			style_winback.w = 1.0f;
			ImGui::PushStyleColor(ImGuiCol_WindowBg, style_winback);
			int flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
			if (!bScreen_Editor_Window) flags |= ImGuiWindowFlags_MenuBar;
			bPopModalStoryboard = ImGui::Begin("##StoryboardWindow", &bStoryboardWindow, flags); // ImGuiWindowFlags_NoScrollbar
		}
		if (bPopModalStoryboard)
		{

			if (!bProceduralLevel)
			{
				ImGuiWindow* storyboard_window = ImGui::GetCurrentWindow();
				CheckWindowsOnTop(storyboard_window);
			}

			if (bScreen_Editor_Window)
			{
				screen_editor(iScreen_Editor_Node);
			}
			else
			{
				storyboard_menubar(preview_size_x, fNodeWidth, fNodeHeight);

				float fStartWinPosY = ImGui::GetCursorPosY();

				ImGui::Columns(2, "StoryboardWindowColumns", false);  //false no border
				ImGui::SetColumnOffset(0, 0.0f);
				ImGui::SetColumnOffset(1, preview_size_x);
				ImNodesContext* gImNodes = ImNodes::GetCurrentContext();
				if (gImNodes)
				{
					gImNodes->Style.PinOffset = 6.0f;
					gImNodes->Style.PinTriangleSideLength = ImGui::GetFontSize() - 2.0;
					gImNodes->Style.PinQuadSideLength = ImGui::GetFontSize() - 4.0;
					if (bStoryboardFirstRunSetInitPos)
						Storyboard.vEditorPanning = ImNodes::EditorContextGetPanning();
				}
				static ImVec2 vTooltipPos;
				static cstr sTooltip = "";

				float fRatio = preview_size_x / 1200.0f;
				float fHeaderHeight = g_Storyboard_header_height * fRatio;

				ID3D11ShaderResourceView* lpTexture;
				
				lpTexture = GetImagePointerView(STORYBOARD_HEADER);
				ImVec2 vHeaderDim = { (float)preview_size_x, fHeaderHeight };
//				static ImVec4 fade_heading = ImVec4(1.0, 1.0, 1.0, 0.5);
				static ImVec4 fade_heading = ImVec4(1.0, 1.0, 1.0, 1.0); //New header no fading.
				if (lpTexture)
				{
					ImGuiWindow* window = ImGui::GetCurrentWindow();
					ImVec2 header_pos = ImGui::GetWindowPos() + ImVec2(0.0, fStartWinPosY);
					window->DrawList->AddImage((ImTextureID)lpTexture, header_pos, header_pos + vHeaderDim, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(fade_heading));
				}
				
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0, fStartWinPosY + 6.0f));

				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImVec2 vIconSize = { (float)ImGui::GetFontSize()*3.5f, (float)ImGui::GetFontSize()*3.5f };
				ImGui::SetCursorPos(ImVec2(3.0f, fStartWinPosY + 1.0f));
				ImGui::SetItemAllowOverlap();
				if (pref.iDisplayWelcomeScreen != 0)
				{
					// now only allows backing from storyboard if have a HUB to go to
					if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
					{
						bool bAbort = false;
						if (Storyboard.iChanged)
						{
							if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
							{
								save_storyboard(Storyboard.gamename, false);
							}
							else
							{
								int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
								if (iAction == 1)
								{
									//Save.
									if (strlen(Storyboard.gamename) > 0)
										save_storyboard(Storyboard.gamename, false);
									else
									{
										bAbort = true;
										save_storyboard(Storyboard.gamename, true);
									}
								}
							}
						}
						if (!bAbort)
						{
							iLevelEditorFromStoryboardID = -1;
							//if (pref.iDisplayWelcomeScreen == 0) no longer can be called
							//{
							//	//Welcome not open , so to level editor.
							//	bStoryboardWindow = false;
							//}
							//else
							{
								//Back to welcome.
								bWelcomeScreen_Window = true;
								bStoryboardWindow = false;
								cLastProjectList = ""; //Trigger a reload of projects, if anything changed.
								bSortProjects = true;

								// and in case this was a remote project, restore to writables regular
								extern void switch_to_regular_projects(void);
								switch_to_regular_projects();
							}
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to GameGuru MAX Hub"); //Welcome Screen
				}
				// Bouncing between storyboard and 'last' level breaks the flow and use of storyboard as the parent
				// and this also prevents levels from potentially floating free and causing other connected issues
				//if (pref.iDisplayWelcomeScreen == 0)
				//{
				//	if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to Level Editor");
				//}
				//else
				//{
				//	if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to GameGuru MAX Hub"); //Welcome Screen
				//}
				//

				ImGui::SetWindowFontScale(2.0); //1.4
				//ImGui::TextCenter("GAME STORYBOARD");
				ImGui::TextCenter(""); //New header already have this text.

				//ImGui::Text(""); //Without a header use this.

				//Display game project name in a inputtext.
//				ImGui::SetWindowFontScale(1.4);
//				float fInputWidth = 300.0;
//				ImGui::PushItemWidth(fInputWidth);
//				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(ImGui::GetContentRegionAvailWidth()*0.5 - ((fInputWidth + 16)*0.5), 28)); //Center with new header.
//				ImGui::InputText("##GamenameStoryboardInput", Storyboard.gamename, 250, ImGuiInputTextFlags_ReadOnly); //ImGuiInputTextFlags_None
//				if (ImGui::MaxIsItemFocused())
//				{
//					bImGuiGotFocus = true;
//				}
//				ImGui::PopItemWidth();
//				ImGui::SetWindowFontScale(1.0);
				//PE: changed inputtext to just displying the project name.
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
				ImGui::SetWindowFontScale(2.0);
				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX(), fHeaderHeight * 0.70));
				ImGui::TextCenter(Storyboard.gamename);
				ImGui::SetWindowFontScale(1.0);

				ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x, fStartWinPosY + fHeaderHeight + 6.0f));

				if (sTooltip != "")
				{
					ImVec2 cposback = ImGui::GetCursorPos();
					ImGui::SetCursorPos(vTooltipPos);
					ImGui::SetTooltip(sTooltip.Get());
					sTooltip = "";
					ImGui::SetCursorPos(cposback);
				}


				ImVec2 vNodeAreaStart = ImGui::GetCursorScreenPos();
				int iUniqueIds = STORYBOARD_THUMBS;

				//PE: Make sure if we focus another window and go back , mouse dragging is reset.
				extern bool g_bAppActiveStat;
				const ImGuiIO& io = ImGui::GetIO();
				if (!g_bAppActiveStat)
				{
					ImGuiContext& g = *GImGui;
					GImGui->IO.MousePos = ImVec2(-10000, -10000);
					g.IO.MouseDelta = ImVec2(0, 0);
					g_bAppActiveStat = true;
				}

				ImNodes::BeginNodeEditor();

				ImNodes::PushAttributeFlag(ImNodesAttributeFlags_EnableLinkDetachWithDragClick);

				for (int i = 0; i < STORYBOARD_MAXNODES; i++)
				{
					bool bValid = true;

					if (!pref.iStoryboardAdvanced && Storyboard.Nodes[i].used)
					{
						//PE: Hide nodes if not in advanced.
						if (i == iLoadGameNodeID ||
							i == iGamePausedNodeID ||
							i == iSaveGameNodeID ||
							i == iGraphicsNodeID ||
							i == iControlNodeID ||
							i == iSoundsNodeID)
							bValid = false;
					}

					if (bValid && Storyboard.Nodes[i].used)
					{
						//PE: Store current location for restore/save.
						if (bStoryboardFirstRunSetInitPos)
							Storyboard.Nodes[i].restore_position = ImNodes::GetNodeGridSpacePos(Storyboard.Nodes[i].id);

						//PE: Setup node.
						ImNodes::BeginNode(Storyboard.Nodes[i].id);

						//#### Title bar ####
						ImNodes::BeginNodeTitleBar();
						ImGui::Dummy(ImVec2(fNodeWidth, 0));
						ImVec2 cpos = ImGui::GetCursorPos();
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0, -3.0));

						ImVec2 text_size = ImGui::CalcTextSize(Storyboard.Nodes[i].title);
						if (text_size.x > fNodeWidth - 50.0)
						{
							char tmp[255];
							strncpy(tmp, Storyboard.Nodes[i].title, 19);
							tmp[19] = 0;
							strcat(tmp, "...");
							ImGui::TextUnformatted(tmp);
							if (ImGui::IsItemHovered())
							{
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = Storyboard.Nodes[i].title;
							}
						}
						else
						{
							ImGui::TextUnformatted(Storyboard.Nodes[i].title);
						}

						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
						{
							//Reverse push's from BeginNodeEditor
							ImGui::PopStyleColor(); // pop child window background color
							ImGui::PopStyleVar();   // pop window padding
							ImGui::PopStyleVar();   // pop frame padding

							//Combo.
							const char* items_storyboard_level[] = { "Duplicate Level", "Rename Level", "Delete Level", "Take Screenshot", "Take Map Snapshot" };
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 48.0f, cpos.y - 8.0));
							int selection = 0;
							char iUniqueString[255];
							sprintf(iUniqueString, "##ComboStoryboardLevels%d", i);

							int iComboEntries = 3;
							if (strlen(Storyboard.Nodes[i].level_name) > 0)
							{
								// Only screenshot if we got a level.
								iComboEntries = 5;
							}

							int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
							ImGui::PushItemWidth(20);
							if (ImGui::BeginCombo(iUniqueString, "", comboflags))
							{
								for (int n = 0; n < iComboEntries; n++)
								{
									//PE: Only display rename and duplicate if we got a name.
									if (!(iComboEntries == 3 && n <= 1))
									{
										if (ImGui::Selectable(items_storyboard_level[n], false))
										{
											Storyboard.iChanged = true;
											bBlockNextMouseCheck = true;
											selection = n;
											if (selection == 0)
											{
												//Duplicate Level.
												iDuplicateNode = i;
												bDuplicateLevel = true;

												//Load in old level if any.
												if (strlen(Storyboard.Nodes[i].level_name) > 0)
												{
													//Load and edit.
													if (stricmp(Storyboard.Nodes[i].level_name, g.projectfilename_s.Get()) == NULL)
													{
														//Already open , just start dup screen.
													}
													else
													{
														//Load level and exit to level editor.
														strcpy(cDirectOpen, Storyboard.Nodes[i].level_name);
														iLaunchAfterSync = 7; //Direct load.
														iSkibFramesBeforeLaunch = 3;
													}
												}
												strcpy(DuplicateLevelName, Storyboard.Nodes[i].title);
												strcat(DuplicateLevelName, " (copy)");
												strcpy(DuplicateLevelError, "");

											}
											if (selection == 1)
											{
												//Rename Level
												if (strlen(Storyboard.Nodes[i].level_name) > 0)
												{
													bRenameLevel = true;
													iRenameNode = i;

													std::string sLevelTitle = Storyboard.Nodes[i].level_name;
													replaceAll(sLevelTitle, ".fpm", "");
													replaceAll(sLevelTitle, "mapbank\\", "");

													char destination[MAX_PATH];
													strcpy(destination, Storyboard.Nodes[i].level_name);
													GG_GetRealPath(destination, 0); //Resolve name. need full path.
													strcpy(RenameOriginalLevelName, destination);
													strcpy(RenameLevelName, sLevelTitle.c_str());
													strcpy(RenameLevelError, "");
												}

											}
											if (selection == 2)
											{
												//Delete Level
												int iAction = askBoxCancel("This will delete the level from your storyboard, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
												if (iAction == 1)
												{
													//Delete any links to this level.
													for (int il = 0; il < STORYBOARD_MAXNODES; il++)
													{
														if (Storyboard.Nodes[il].used)
														{
															for (int ll = 0; ll < STORYBOARD_MAXOUTPUTS; ll++)
															{
																if (Storyboard.Nodes[il].output_linkto[ll] > 0)
																{
																	for (int a = 0; a < STORYBOARD_MAXOUTPUTS; a++)
																	{
																		//Check all inputs.
																		if (Storyboard.Nodes[i].input_id[a] > 0)
																		{
																			if (Storyboard.Nodes[il].output_linkto[ll] == Storyboard.Nodes[i].input_id[a])
																				Storyboard.Nodes[il].output_linkto[ll] = 0;
																		}
																	}
																}
															}
														}
													}
													reset_single_node(i);
													Storyboard.Nodes[i].used = false;
													bBlockNextMouseCheck = true;
												}
											}
											if (selection == 3 || selection == 4)
											{
												//Take Screenshot.
												extern bool bPopModalOpenProceduralCameraMode;
												bPopModalOpenProceduralCameraMode = true;

												// option to snap a map snapshot
												extern bool bPopModalTakeMapSnapshot;
												if (selection == 3) bPopModalTakeMapSnapshot = false;
												if (selection == 4) bPopModalTakeMapSnapshot = true;

												//PE: Do we need to load this level ?
												if (strlen(Storyboard.Nodes[i].level_name) > 0)
												{
													//Load and edit.
													if (stricmp(Storyboard.Nodes[i].level_name, g.projectfilename_s.Get()) == NULL)
													{
														//Already open , just start screenshot
													}
													else
													{
														//Load level and start screenshot.
														strcpy(cDirectOpen, Storyboard.Nodes[i].level_name);
														iLaunchAfterSync = 7; //Direct load.
														iSkibFramesBeforeLaunch = 5;
													}
												}

												iWaitForNewScreenshot = 10;
												iScreenshotNode = i;

												//Make sure we have a fresh thumb.
												GG_SetWritablesToRoot(true);
												if (FileExist("thumbbank\\lastnewlevel.jpg")) DeleteAFile("thumbbank\\lastnewlevel.jpg");
												GG_SetWritablesToRoot(false);
											}
										}
									}
								}
								ImGui::EndCombo();
							}
							if (ImGui::IsItemHovered()) 
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = " Duplicate, delete or take a screen shot ";
							}
							ImGui::PopItemWidth();

							//Add push to BeginNodeEditor.
							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
							ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
							ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);
						}

						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && pestrcasestr(Storyboard.Nodes[i].lua_name, "loading") && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading.lua") )
						{
							ImGui::PopStyleColor();
							ImGui::PopStyleVar();
							ImGui::PopStyleVar();
							const char* items_storyboard_hud[] = { "Delete Loading Screen" };
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 48.0f, cpos.y - 8.0));
							int selection = 0;
							char iUniqueString[255];
							sprintf(iUniqueString, "##ComboStoryboardCustom%d", i);
							int iComboEntries = 1;
							int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
							ImGui::PushItemWidth(20);
							if (ImGui::BeginCombo(iUniqueString, "", comboflags))
							{
								for (int n = 0; n < iComboEntries; n++)
								{
									if (ImGui::Selectable(items_storyboard_hud[n], false))
									{
										Storyboard.iChanged = true;
										bBlockNextMouseCheck = true;
										selection = n;
										if (selection == 0)
										{
											int iAction = askBoxCancel("This will delete the loading screen from your storyboard, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												reset_single_node(i);
												Storyboard.Nodes[i].used = false;
												bBlockNextMouseCheck = true;
											}
										}
									}
								}
								ImGui::EndCombo();
							}
							if (ImGui::IsItemHovered())
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = " Delete Loading Screen ";
							}
							ImGui::PopItemWidth();
							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
							ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
							ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);

						}

						bool bIsCustomScreen = pestrcasestr(Storyboard.Nodes[i].title, "Custom Screen");
						if (bIsCustomScreen)
						{
							ImGui::PopStyleColor();
							ImGui::PopStyleVar();
							ImGui::PopStyleVar();
							const char* items_storyboard_hud[] = { "Delete Custom Screen" };
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 48.0f, cpos.y - 8.0));
							int selection = 0;
							char iUniqueString[255];
							sprintf(iUniqueString, "##ComboStoryboardCustom%d", i);
							int iComboEntries = 1;
							int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
							ImGui::PushItemWidth(20);
							if (ImGui::BeginCombo(iUniqueString, "", comboflags))
							{
								for (int n = 0; n < iComboEntries; n++)
								{
									if (ImGui::Selectable(items_storyboard_hud[n], false))
									{
										Storyboard.iChanged = true;
										bBlockNextMouseCheck = true;
										selection = n;
										if (selection == 0)
										{
											int iAction = askBoxCancel("This will delete the custom screen from your storyboard, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												reset_single_node(i);
												Storyboard.Nodes[i].used = false;
												bBlockNextMouseCheck = true;
											}
										}
									}
								}
								ImGui::EndCombo();
							}
							if (ImGui::IsItemHovered())
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = " Delete Custom screen ";
							}
							ImGui::PopItemWidth();
							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
							ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
							ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);
						}

						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD)
						{
							ImGui::PopStyleColor();
							ImGui::PopStyleVar();
							ImGui::PopStyleVar();
							const char* items_storyboard_hud[] = { "Delete HUD Screen" };
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 48.0f, cpos.y - 8.0));
							int selection = 0;
							char iUniqueString[255];
							sprintf(iUniqueString, "##ComboStoryboardHUD%d", i);
							int iComboEntries = 1;
							int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
							ImGui::PushItemWidth(20);
							if (ImGui::BeginCombo(iUniqueString, "", comboflags))
							{
								for (int n = 0; n < iComboEntries; n++)
								{
									if (ImGui::Selectable(items_storyboard_hud[n], false))
									{
										Storyboard.iChanged = true;
										bBlockNextMouseCheck = true;
										selection = n;
										if (selection == 0)
										{
											int iAction = askBoxCancel("This will delete the HUD screen from your storyboard, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												reset_single_node(i);
												Storyboard.Nodes[i].used = false;
												bBlockNextMouseCheck = true;
											}
										}
									}
								}
								ImGui::EndCombo();
							}
							if (ImGui::IsItemHovered()) 
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = " Delete HUD screen ";
							}
							ImGui::PopItemWidth();
							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
							ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
							ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);
						}

						if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN && i>=0 && i<=12)
						{
							ImGui::PopStyleColor();
							ImGui::PopStyleVar();
							ImGui::PopStyleVar();
							const char* items_storyboard_screen_restore[] = { "Restore Screen" };
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 48.0f, cpos.y - 8.0));
							int selection = 0;
							char iUniqueString[255];
							sprintf(iUniqueString, "##ComboStoryboardScreenRestore%d", i);
							int iComboEntries = 1;
							int comboflags = ImGuiComboFlags_NoPreview | ImGuiComboFlags_PopupAlignLeft | ImGuiComboFlags_HeightLarge;
							ImGui::PushItemWidth(20);
							if (ImGui::BeginCombo(iUniqueString, "", comboflags))
							{
								for (int n = 0; n < iComboEntries; n++)
								{
									if (ImGui::Selectable(items_storyboard_screen_restore[n], false))
									{
										Storyboard.iChanged = true;
										bBlockNextMouseCheck = true;
										selection = n;
										if (selection == 0)
										{
											int iAction = askBoxCancel("This will restore the screen to original, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												reset_single_node_interscreen(i);
												storyboard_add_missing_nodex(i, 0, 0, 0, true, true);
												extern void RefreshThumbImagesForNode(int, int);
												RefreshThumbImagesForNode(i, 0);
												strcpy(Storyboard.Nodes[i].thumb, "editors\\uiv3\\click-here-box-screen.png");
												SetMipmapNum(1);
												image_setlegacyimageloading(true);
												LoadImageSize(Storyboard.Nodes[i].thumb, Storyboard.Nodes[i].thumb_id, 512, 288);
												image_setlegacyimageloading(false);
												SetMipmapNum(-1);
												bBlockNextMouseCheck = true;
											}
										}
									}
								}
								ImGui::EndCombo();
							}
							if (ImGui::IsItemHovered())
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								sTooltip = " Restore Screen ";
							}
							ImGui::PopItemWidth();
							ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
							ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
							ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);
						}

						bool bExecutePencelEdit = false;
						char UniqueFileString[MAX_PATH];
						sprintf(UniqueFileString, "##GetFileStoryboard%d", i);
						ImGuiWindow* window = ImGui::GetCurrentWindow();
						int iSplashID = window->GetID(UniqueFileString);

						if (Storyboard.Nodes[i].iEditEnable)
						{
							ImGui::SetItemAllowOverlap();
							ImGui::SetCursorPos(ImVec2(cpos.x + fNodeWidth - 20.0f, cpos.y - 3.0));
							ImGui::PushID(Storyboard.Nodes[i].id + 500);

							if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
							{
								if (iSelectedLibraryStingReturnID == iSplashID)
								{
									//Update selected var.
									strcpy(Storyboard.Nodes[i].thumb, sSelectedLibrarySting.Get());
									sSelectedLibrarySting = "";
									iSelectedLibraryStingReturnID = -1; //disable.
									//Update thumb.
									UpdateThumbOnNode = i;
								}
							}

							if (ImGui::ImgBtn(TOOL_PENCIL, ImVec2(16, 16), ImColor(255, 255, 255, 0)))
							{
								bExecutePencelEdit = true;
							}
							if (ImGui::IsItemHovered())
							{
								bBlockNextMouseCheck = true;
								vTooltipPos = ImGui::GetCursorPos();
								if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
									sTooltip = " Edit Splash Screen ";
								else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
									sTooltip = " Edit Screen ";
								else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
									sTooltip = " Edit Level ";
								else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
									sTooltip = " Edit Loading Screen ";
							}
							ImGui::PopID();
						}
						ImNodes::EndNodeTitleBar();

						//#### Input attibs ####
						cpos = ImGui::GetCursorPos();
						for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
						{
							if (strlen(Storyboard.Nodes[i].input_title[l]) > 0)
							{
								int iPinId = Storyboard.Nodes[i].input_id[l];
								ImNodes::BeginInputAttribute(iPinId, ImNodesPinShape_QuadFilled);
								ImGui::Text("");
								if (iLastHoveredId == iPinId) { vTooltipPos = ImGui::GetCursorPos(); sTooltip = Storyboard.Nodes[i].input_title[l]; }
								ImNodes::EndInputAttribute();
							}

						}
						ImGui::SetCursorPos(cpos);

						//#### Preview Thumb ####
						int TextureID = BOX_CLICK_HERE; //MARKETPLACE_FILLER;
						if (ImageExist(Storyboard.Nodes[i].thumb_id))
						{
							TextureID = Storyboard.Nodes[i].thumb_id;
						}
						cpos = ImGui::GetCursorPos();

						//#### Add button so can click to edit, pencil function ####
						//ImGui::Dummy(iThumbSize);
						char UniqueButName[128];
						sprintf(UniqueButName, "##Dummy%d", i);
						if (iLastHoveredNodeId > 0 && iLastHoveredNodeId == Storyboard.Nodes[i].id)
						{
							if (ImGui::ButtonEx(UniqueButName, iThumbSize, 0))
							{
								bExecutePencelEdit = true;
							}
						}
						else
						{
							ImGui::Dummy(iThumbSize);
						}
						//#### Execute Edit With Pencil ####
						if (bExecutePencelEdit)
						{

							Storyboard.iChanged = true;

							//ImGuiWindow* window = ImGui::GetCurrentWindow();
							if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
							{
								//Edit splash.
								bExternal_Entities_Window = true;
								iDisplayLibraryType = 2;
								iLibraryStingReturnToID = iSplashID;
								if (strlen(Storyboard.Nodes[i].thumb) > 0)
								{
									sMakeDefaultSelecting = Storyboard.Nodes[i].thumb;
									bSelectLibraryViewAll = true;
								}

								if (pref.iSplashStartMessage == 0)
								{
									strcpy(cTriggerMessage, "Select the backdrop image you want to appear when your game is first launched");
									bTriggerMessage = true;
									pref.iSplashStartMessage = 1;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}

							}
							else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN || pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
							{

								if (i == iTitleScreenNodeID && pref.iTitleStartMessage == 0)
								{
									pref.iTitleStartMessage = 1;
									strcpy(cTriggerMessage, "Design your game start menus");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								if (i == 2 && pref.iLoadingStartMessage == 0)
								{
									pref.iLoadingStartMessage = 1;
									strcpy(cTriggerMessage, "Create the screen shown before each level loads");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								if (i == 5 && pref.iGameWonStartMessage == 0)
								{
									pref.iGameWonStartMessage = 1;
									strcpy(cTriggerMessage, "Design the screen shown when the game is won");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								if (i == 6 && pref.iGameOverStartMessage == 0)
								{
									pref.iGameOverStartMessage = 1;
									strcpy(cTriggerMessage, "Create the screen when the player loses the game");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}

								bScreen_Editor_Window = true;
								iScreen_Editor_Node = i;
							}
							else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
							{
								//Edit level.
								CloseAllOpenTools();

								if (strlen(Storyboard.Nodes[i].level_name) > 0)
								{
									//Load and edit.
									if (stricmp(Storyboard.Nodes[i].level_name, g.projectfilename_s.Get()) == NULL)
									{
										//Already open , just exit to level editor.
										if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
										if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
										if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
										if (bEntity_Properties_Window) bEntity_Properties_Window = false;
										if (t.ebe.on == 1) ebe_hide();
										//
										bool bAbort = false;
										if (Storyboard.iChanged)
										{
											bBlockNextMouseCheck = true;
											if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
											{
												save_storyboard(Storyboard.gamename, false);
											}
											else
											{
												int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
												if (iAction == 1)
												{
													//Save.
													if (strlen(Storyboard.gamename) > 0)
														save_storyboard(Storyboard.gamename, false);
													else
													{
														bAbort = true;
														save_storyboard(Storyboard.gamename, true);
													}
												}
											}
										}
										if (!bAbort)
										{
											//Object Tools as default.
											bForceKey = true;
											csForceKey = "o";
											bTerrain_Tools_Window = false;
											Entity_Tools_Window = true;

											bStoryboardWindow = false;
											iLevelEditorFromStoryboardID = i;
										}

									}
									else
									{
										//Load level and exit to level editor.
										strcpy(cDirectOpen, Storyboard.Nodes[i].level_name);
										iLaunchAfterSync = 7; //Direct load.
										iSkibFramesBeforeLaunch = 5;
										bCloseStoryboardAfterLoad = true;
										//bStoryboardWindow = false;
										iLevelEditorFromStoryboardID = i;
									}
								}
								else
								{
									//PE: If empty node level , start level editor.
									//PE: Default to terrain tools , like when we launch Max.

									//PE: New default to object mode.
									bForceKey = true;
									csForceKey = "o";
									bTerrain_Tools_Window = false;
									Entity_Tools_Window = true;

									//bForceKey = true;
									//csForceKey = "t";
									//bForceKey2 = true;
									//csForceKey2 = "6";
									//t.inputsys.domodeterrain = 1; t.inputsys.dowaypointview = 0;
									//t.gridentitymarkersmodeonly = 0; t.grideditselect = 0;
									//t.terrain.terrainpaintermode = 6;
									//bTerrain_Tools_Window = true;
									bProceduralLevelFromStoryboard = true;
									iLaunchAfterSync = 5;
									iBlackoutForFrames = 5;
									iSkibFramesBeforeLaunch = 2;
									iWaitForNewLevel = 10;
									iNewLevelNode = i;

									//Make sure we have a fresh thumb. if generated by new level.
									GG_SetWritablesToRoot(true);
									if (FileExist("thumbbank\\lastnewlevel.jpg")) DeleteAFile("thumbbank\\lastnewlevel.jpg");
									GG_SetWritablesToRoot(false);

									//PE: Switch to normal message.
									strcpy(cTriggerMessage, "Preparing the Terrain Generator. Please wait...");
									bTriggerMessage = true;
									//PE: We need the message in this frame so.
									//bool bForceMessageNoFade = false;
									//void gridedit_triggermessagehandler(bool bForceMessageNoFade);
									//gridedit_triggermessagehandler(bForceMessageNoFade);

								}
							}
							else if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD)
							{
								if (i == iHUDScreenNodeID && pref.iTitleStartMessage == 0)
								{
									pref.iTitleStartMessage = 1;
									strcpy(cTriggerMessage, "Design your in-game HUD");
									bTriggerMessage = true;
									iTriggerMessageDelay = 2;
									iTriggerMessageY = 1;
								}
								bScreen_Editor_Window = true;
								iScreen_Editor_Node = i;
							}
						}

						ImGui::SetCursorPos(cpos);
						lpTexture = GetImagePointerView(TextureID);
						if (lpTexture && Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
						{
							//Center image.
							float img_w = ImageWidth(TextureID);
							float img_h = ImageHeight(TextureID);

							if (img_w > iThumbSize.x || img_h > iThumbSize.y) {
								float fRatio = 1.0f / (img_w / img_h);
								img_w = iThumbSize.x;
								img_h = iThumbSize.x * fRatio;
								if (img_h > iThumbSize.y) {
									float fRatio = 1.0f / (img_h / img_w);
									img_h = iThumbSize.y;
									img_w = iThumbSize.y * fRatio;
								}
							}

							ImGuiWindow* window = ImGui::GetCurrentWindow();
							ImVec2 img_pos = ImGui::GetWindowPos() + cpos;

							img_pos.x += (iThumbSize.x - img_w) * 0.5;
							img_pos.y += (iThumbSize.y - img_h) * 0.5;
							window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.8)));

						}
						else
						{
							if (lpTexture)
							{
								ImGuiWindow* window = ImGui::GetCurrentWindow();
								ImVec2 img_pos = ImGui::GetWindowPos() + cpos;
								window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + iThumbSize, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.8)));
							}
						}
						//ImGui::SetCursorPos(cpos + ImVec2(0, iThumbSize.y)); Start output from top and down.

						//#### Output attibs ####
						for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
						{
							bool bValid = true;
							int iPinId = Storyboard.Nodes[i].output_id[l];
							int linkto = Storyboard.Nodes[i].output_linkto[l];
							if (!pref.iStoryboardAdvanced && strlen(Storyboard.Nodes[i].output_title[l]) > 0)
							{
								//PE: Hide nodes if not in advanced.
								if (linkto == Storyboard.Nodes[iLoadGameNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iGamePausedNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iSaveGameNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iGraphicsNodeID].input_id[0] ||
									linkto == Storyboard.Nodes[iSoundsNodeID].input_id[0] )
									bValid = false;
							}

							if (bValid && strlen(Storyboard.Nodes[i].output_title[l]) > 0)
							{
								ImNodes::BeginOutputAttribute(iPinId, ImNodesPinShape_TriangleFilled);
								ImGui::Text("");
								if (iLastHoveredId == iPinId) { vTooltipPos = ImGui::GetCursorPos(); sTooltip = Storyboard.Nodes[i].output_title[l]; }
								ImNodes::EndOutputAttribute();
							}
						}


						ImNodes::EndNode();
					}
				}

				ImNodes::PopAttributeFlag();

				std::map<int, int> no_duplicates;
				int linkid = 0;
				for (int i = 0; i < STORYBOARD_MAXNODES; i++)
				{
					bool bValid = true;

					if (!pref.iStoryboardAdvanced && Storyboard.Nodes[i].used)
					{
						//PE: Hide nodes if not in advanced.
						if (i == iLoadGameNodeID ||
							i == iGamePausedNodeID ||
							i == iSaveGameNodeID ||
							i == iGraphicsNodeID ||
							i == iSoundsNodeID)
							bValid = false;
					}

					if (bValid && Storyboard.Nodes[i].used)
					{
						for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
						{
							int linkfrom = Storyboard.Nodes[i].output_id[l];
							int linkto = Storyboard.Nodes[i].output_linkto[l];
							if (linkfrom > 0 && linkto > 0)
							{
								bool bLinkValid = true;
								if (!pref.iStoryboardAdvanced )
								{
									//PE: Hide nodes if not in advanced.
									if (linkto == Storyboard.Nodes[iLoadGameNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iGamePausedNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iSaveGameNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iGraphicsNodeID].input_id[0] ||
										linkto == Storyboard.Nodes[iSoundsNodeID].input_id[0])
										bLinkValid = false;
								}

								if (bLinkValid)
								{
									bool bVisible = true;
									int is = no_duplicates.size();
									no_duplicates.insert(std::make_pair(linkfrom, linkto));
									if (is == no_duplicates.size())
										bVisible = false;
									if (bVisible)
									{
										if (linkid < STORYBOARD_MAXNODES)
										{
											ImNodes::Link(linkid, linkfrom, linkto);
											StoryboardiActiveLinksId[linkid] = linkto;
											StoryboardiActiveLinksIdFrom[linkid] = linkfrom;
											linkid++;
										}
									}
								}
							}
						}
					}
				}
				no_duplicates.clear();


				ImNodes::MiniMap(0.15f, ImNodesMiniMapLocation_BottomRight); //PE: size,corner.
				ImNodes::EndNodeEditor();

				ImVec2 vNodeAreaEnd = ImGui::GetCursorScreenPos();
				vNodeAreaEnd.x += ImGui::GetContentRegionAvailWidth();
				if (ImGui::IsMouseHoveringRect(vNodeAreaStart, vNodeAreaEnd))
				{
					static bool bGetMouseDown = false;
					static bool bWaitOnRelease = false;
					if (!bTriggerSaveAs && !bTriggerOpenProject && !bProceduralLevel && !bBlockNextMouseCheck)
					{
						if (bWaitOnRelease && !ImGui::IsMouseDown(0))
						{
							bWaitOnRelease = false;
						}
						else
						{
							//Need a down and release to trigger.
							if (bGetMouseDown && ImGui::IsMouseReleased(0))
							{
								Storyboard.iChanged = true; //PE: Anything trigger a change in project.
								bGetMouseDown = false;
							}
							if (ImGui::IsMouseDown(0)) bGetMouseDown = true; //PE: Anything trigger a change in project.
						}
					}
					else
					{
						bWaitOnRelease = true;
						bBlockNextMouseCheck = false;
						bGetMouseDown = false;
					}
				}


				int start_attr, end_attr;
				if (ImNodes::IsLinkCreated(&start_attr, &end_attr))
				{
					bool valid_link = false; // type goes to correct type.
					int iInNode = -1, iOutNode = -1, iInAttr = -1, iOutAttr = -1;
					for (int i = 0; i < STORYBOARD_MAXNODES; i++)
					{
						if (Storyboard.Nodes[i].used)
						{
							for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
							{
								int linkfrom = Storyboard.Nodes[i].output_id[l];
								int linkto = Storyboard.Nodes[i].input_id[l];

								if (start_attr == linkfrom)
								{
									iInNode = i;
									iInAttr = l;
								}
								if (end_attr == linkto)
								{
									iOutNode = i;
									iOutAttr = l;
								}
							}
						}
					}
					if (iInNode >= 0 && iOutNode >= 0 && iInAttr >= 0 && iOutAttr >= 0)
					{
						//PE: Check if connect type match
						if (Storyboard.Nodes[iOutNode].type == Storyboard.Nodes[iInNode].output_can_link_to_type[iInAttr])
						{
							valid_link = true;
						}
						/* Not so, there is some hardcoded stuff still; START to loading to LEVEL
						else
						{
							// can also allow screen and level types to interconnect
							if (Storyboard.Nodes[iOutNode].type == STORYBOARD_TYPE_SCREEN && Storyboard.Nodes[iInNode].output_can_link_to_type[iInAttr] == STORYBOARD_TYPE_LEVEL)
							{
								valid_link = true;
							}
							if (Storyboard.Nodes[iOutNode].type == STORYBOARD_TYPE_LEVEL && Storyboard.Nodes[iInNode].output_can_link_to_type[iInAttr] == STORYBOARD_TYPE_SCREEN)
							{
								valid_link = true;
							}
						}
						*/
					}

					if (valid_link)
					{
						Storyboard.Nodes[iInNode].output_linkto[iInAttr] = end_attr;
					}
				}

				int link_id;
				if (ImNodes::IsLinkDestroyed(&link_id))
				{
					if (link_id < STORYBOARD_MAXNODES && link_id >= 0)
					{
						int linkfrom = StoryboardiActiveLinksId[link_id];
						int linkto = StoryboardiActiveLinksIdFrom[link_id];

						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used)
							{
								for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
								{

									if (linkfrom == Storyboard.Nodes[i].output_linkto[l] && linkto == Storyboard.Nodes[i].output_id[l])
										Storyboard.Nodes[i].output_linkto[l] = 0;
								}
							}
						}
					}

				}

				ImGui::NextColumn();

				const ImNodesEditorContext& editor = ImNodes::EditorContextGet();
				if (gImNodes->HoveredPinIdx.HasValue() && gImNodes->HoveredPinIdx.Value() >= 0)
					iLastHoveredId = editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()].Id;
				else
					iLastHoveredId = 0;

				if (!ImGui::IsMouseDown(0))
				{
					iLastHoveredNodeId = 0;
					if (gImNodes->HoveredNodeIdx.HasValue() && gImNodes->HoveredNodeIdx.Value() >= 0)
					{
						if (gImNodes->HoveredNodeIdx.Value() < editor.Nodes.Pool.Size)
							iLastHoveredNodeId = editor.Nodes.Pool[gImNodes->HoveredNodeIdx.Value()].Id;
					}
				}

				float buttonwide = 200.0f;

				// extra help for users to know maximum limits of node creation
				bool bShowNoMoreScreensError = false;
				char pToolTipForAddingNewScreens[256];
				sprintf(pToolTipForAddingNewScreens, "The game project can contain up to %d screens or levels.", STORYBOARD_MAXNODES);

				if (ImGui::StyleCollapsingHeader("Add and Edit Storyboard", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0) //"Add New"
				{
					int iAutoConnectNode = -1;
					ImGui::Indent(10);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Add New Level", ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == 'N')
					{
						iStoryboardExecuteKey = 0;
						//PE: Find next level from nodes.
						int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
						FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

						if (iFirstNodeFree >= 0)
						{
							//Create new level.
							char tmp[255];
							int node = iFirstNodeFree;
							int nodeposy = iNextLevel;
							if (levelname > 0)
							{
								sprintf(tmp, "Level %d", levelname);
								nodeposy = levelname - 1;
							}
							else
								sprintf(tmp, "Level %d", iNextLevel + 1);

							//PE: Make sure any old data is removed, also thumbs.
							reset_single_node(node);

							Storyboard.Nodes[node].used = true;
							Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
							Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x*0.5 - (fNodeWidth*0.5) + ((fNodeWidth + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
							Storyboard.Nodes[node].iEditEnable = true;
							strcpy(Storyboard.Nodes[node].title, tmp);
							strcpy(Storyboard.Nodes[node].levelnumber, tmp);

							strcpy(Storyboard.Nodes[node].thumb, "");
							//Input.
							strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
							//Output.
							strcpy(Storyboard.Nodes[node].output_title[0], " WIN LEVEL -> Connect to Scene ");
							strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
							Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
							Storyboard.Nodes[node].output_linkto[0] = 0;

							strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
							strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
							Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
							Storyboard.Nodes[node].output_linkto[1] = 0;

							strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
							strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
							Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
							Storyboard.Nodes[node].output_linkto[2] = 0;
							ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
							iAutoConnectNode = node;
						}
						else
						{
							bShowNoMoreScreensError = true;
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pToolTipForAddingNewScreens);

					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x * 0.5) - (buttonwide * 0.5), 0.0f));
					if (ImGui::StyleButton("Add New Screen", ImVec2(buttonwide, 0.0f)))
					{
						int iScreenCount = 1;
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used && Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
							{
								if(pestrcasestr(Storyboard.Nodes[i].title,"Custom Screen"))
									iScreenCount++;
							}
						}
						char cScreenCount[8];
						sprintf_s(cScreenCount, "%d", iScreenCount);
						// Find first free storyboard node that we can use for the new screen.
						int node = -1;
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used == 0)
							{
								// Reset node to default state, in case any old data remains.
								node = i;
								reset_single_node(node);

								//PE: Setup new unique id's
								int iUniqueId = STORYBOARD_THUMBS + node;
								Storyboard.Nodes[node].id = iUniqueId;
								Storyboard.Nodes[node].thumb_id = iUniqueId;
								for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
								{
									//PE: input_id,output_id ID's broken in checkproject.
									Storyboard.Nodes[node].widget_normal_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 600;
									Storyboard.Nodes[node].widget_highlight_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 700;
									Storyboard.Nodes[node].widget_selected_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 800;
								}
								for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
								{
									Storyboard.Nodes[node].input_id[l] = iUniqueId + 1000 + (1000 * l);
									Storyboard.Nodes[node].output_id[l] = iUniqueId + 1000 + (1000 * l) + 500;
								}

								Storyboard.Nodes[node].screen_backdrop_id = iUniqueId + 500;

								// New node defaults to a HUD screen
								Storyboard.Nodes[node].used = true;
								Storyboard.Nodes[node].type = STORYBOARD_TYPE_SCREEN;

								Storyboard.Nodes[node].restore_position = ImVec2(Storyboard.Nodes[iAboutScreenNodeID].restore_position.x + 200 * iScreenCount, Storyboard.Nodes[iAboutScreenNodeID].restore_position.y);

								ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
								Storyboard.Nodes[node].iEditEnable = true;
								strcpy(Storyboard.Nodes[node].title, "Custom Screen ");
								strcat(Storyboard.Nodes[node].title, cScreenCount);
								//strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\hud.lua.png");
								strcpy(Storyboard.Nodes[node].lua_name, "custom");
								strcat(Storyboard.Nodes[node].lua_name, cScreenCount);
								strcpy(Storyboard.Nodes[node].screen_backdrop, "");
								Storyboard.Nodes[node].screen_backdrop_transparent = true;
								Storyboard.Nodes[node].readouts_available = 0;
								Storyboard.Nodes[node].widgets_available = ALLOW_BUTTON | ALLOW_TEXT | ALLOW_IMAGE | ALLOW_RADIOTYPE | ALLOW_SLIDER | ALLOW_TICKBOX | ALLOW_VIDEO | ALLOW_PROGRESS | ALLOW_TEXTAREA;

								strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_about.lua.png");
								strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\about.png");

								strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
								int button = 0;
								strcpy(Storyboard.Nodes[node].widget_label[button], "BACK");
								Storyboard.Nodes[node].widget_used[button] = 1;
								Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_BUTTON;
								Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
								Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80); //Pos in percent. using pivot center on X only.
								Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_BACK;
								Storyboard.Nodes[node].widget_layer[button] = 0;
								Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
								strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
								strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\default.png");
								strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\default-hover.png");
								strcpy(Storyboard.Nodes[node].widget_selected_thumb[button], "editors\\templates\\buttons\\default-selected.png");
								strcpy(Storyboard.Nodes[node].widget_name[button], "continue"); //NOTE: DUP (continue) - Also add "-hover.png" ...
								break;
							}
						}
						if (node < 0)
						{
							bShowNoMoreScreensError = true;
						}
						else
						{
							// Trigger creation of a new thumbnail for the newly created screen
							iWaitFor2DEditor = 5;
							iWaitFor2DEditorNode = node;
							if (BitmapExist(99))
							{
								DeleteBitmapEx(99);
							}
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pToolTipForAddingNewScreens);
					
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x * 0.5) - (buttonwide * 0.5), 0.0f));
					if (ImGui::StyleButton("Add New Loading Screen", ImVec2(buttonwide, 0.0f)))
					{
						int iLoadingScreenCount = 1;
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used && Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL)
							{
								if(pestrcasestr(Storyboard.Nodes[i].title,"Loading Screen"))
									iLoadingScreenCount++;
							}
						}
						char cLoadingScreenCount[8];
						sprintf_s(cLoadingScreenCount, "%d", iLoadingScreenCount);
						// Find first free storyboard node that we can use for the new screen.
						int node = -1;
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used == 0)
							{
								// Reset node to default state, in case any old data remains.
								node = i;
								reset_single_node(node);

								//PE: Setup new unique id's
								int iUniqueId = STORYBOARD_THUMBS + node;
								Storyboard.Nodes[node].id = iUniqueId;
								Storyboard.Nodes[node].thumb_id = iUniqueId;
								for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
								{
									//PE: input_id,output_id ID's broken in checkproject.
									Storyboard.Nodes[node].widget_normal_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 600;
									Storyboard.Nodes[node].widget_highlight_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 700;
									Storyboard.Nodes[node].widget_selected_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 800;
								}
								for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
								{
									Storyboard.Nodes[node].input_id[l] = iUniqueId + 1000 + (1000 * l);
									Storyboard.Nodes[node].output_id[l] = iUniqueId + 1000 + (1000 * l) + 500;
								}

								Storyboard.Nodes[node].screen_backdrop_id = iUniqueId + 500;

								//PE: New loading screen.
								Storyboard.Nodes[node].widgets_available = ALLOW_TEXT | ALLOW_IMAGE | ALLOW_VIDEO;
								Storyboard.Nodes[node].used = true;
								Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].restore_position = ImVec2(Storyboard.Nodes[iLoadingScreenNodeID].restore_position.x + 200 * iLoadingScreenCount, Storyboard.Nodes[iLoadingScreenNodeID].restore_position.y);
								ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);

								Storyboard.Nodes[node].iEditEnable = true;
								strcpy(Storyboard.Nodes[node].title, "Loading Screen ");
								strcat(Storyboard.Nodes[node].title, cLoadingScreenCount);
								strcpy(Storyboard.Nodes[node].lua_name, "loading");
								strcat(Storyboard.Nodes[node].lua_name, cLoadingScreenCount);
								strcat(Storyboard.Nodes[node].lua_name, ".lua");

								strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\screen_loading.lua.png");
								strcpy(Storyboard.Nodes[node].screen_backdrop, "editors\\templates\\backdrops\\loading.png");

								//Input.
								strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
								//Output.
								strcpy(Storyboard.Nodes[node].output_title[0], " LOAD LEVEL -> Connect to Level ");
								strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].output_linkto[0] = 0;

								int button = 0;
								strcpy(Storyboard.Nodes[node].widget_label[button], "LOADING LEVEL");
								Storyboard.Nodes[node].widget_used[button] = 1;
								Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
								Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
								Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 80.0); //Pos in percent. using pivot center on X only.
								Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
								Storyboard.Nodes[node].widget_layer[button] = 0;
								Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
								strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
								strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...

								button = 1;

								strcpy(Storyboard.Nodes[node].widget_label[button], ""); //Progressbar
								Storyboard.Nodes[node].widget_used[button] = 1;
								Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_PROGRESS;
								Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
								Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 90.0); //Pos in percent. using pivot center on X only.
								Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
								Storyboard.Nodes[node].widget_layer[button] = 0;
								Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
								strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
								strcpy(Storyboard.Nodes[node].widget_normal_thumb[button], "editors\\templates\\buttons\\slider-bar-empty.png");
								strcpy(Storyboard.Nodes[node].widget_highlight_thumb[button], "editors\\templates\\buttons\\slider-bar-full.png");


								button = 2;
								strcpy(Storyboard.Nodes[node].widget_label[button], "When in game, press the Escape key for controls and other settings.");
								Storyboard.Nodes[node].widget_used[button] = 1;
								Storyboard.Nodes[node].widget_type[button] = STORYBOARD_WIDGET_TEXT;
								Storyboard.Nodes[node].widget_size[button] = ImVec2(1.0, 1.0); //Only for scaling. else but image size.
								Storyboard.Nodes[node].widget_pos[button] = ImVec2(50.0, 95.0); //Pos in percent. using pivot center on X only.
								Storyboard.Nodes[node].widget_action[button] = STORYBOARD_ACTIONS_NONE;
								Storyboard.Nodes[node].widget_layer[button] = 0;
								Storyboard.Nodes[node].widget_font_color[button] = ImVec4(1.0, 1.0, 1.0, 1.0);
								Storyboard.Nodes[node].widget_font_size[button] = 0.5;
								strcpy(Storyboard.Nodes[node].widget_font[button], "Default Font"); // ?
								strcpy(Storyboard.Nodes[node].widget_name[button], "loading-text"); //Also add "-hover.png" ...

								break;
							}
						}
						if (node < 0)
						{
							bShowNoMoreScreensError = true;
						}
						else
						{
							// Trigger creation of a new thumbnail for the newly created screen
							iWaitFor2DEditor = 5;
							iWaitFor2DEditorNode = node;
							if (BitmapExist(99))
							{
								DeleteBitmapEx(99);
							}
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pToolTipForAddingNewScreens);

					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x * 0.5) - (buttonwide * 0.5), 0.0f));
					if (ImGui::StyleButton("Add New HUD Screen", ImVec2(buttonwide, 0.0f)))
					{
						int iLastKnownNode = -1;
						int hudScreenCount = 2;
						while (hudScreenCount < 2 + STORYBOARD_MAXNODES)
						{
							char pTryHUDScreenName[256];
							sprintf(pTryHUDScreenName, "HUD Screen %d", hudScreenCount);
							bool bHUDScreenExists = false;
							for (int i = 0; i < STORYBOARD_MAXNODES; i++)
							{
								if (Storyboard.Nodes[i].used && stricmp(Storyboard.Nodes[i].title, pTryHUDScreenName)==NULL)
								{
									bHUDScreenExists = true;
									iLastKnownNode = i;
									break;
								}
							}
							if (bHUDScreenExists == false)
							{
								// found next available HUD Screen number
								break;
							}
							else
							{
								// try next one
								hudScreenCount++;
							}
						}
						char cHudCount[8];
						sprintf_s(cHudCount, "%d", hudScreenCount);
						// Find first free storyboard node that we can use for the new screen.
						int node = -1;
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used == 0)
							{
								// Reset node to default state, in case any old data remains.
								node = i;
								reset_single_node(node);

								//PE: Setup new unique id's
								int iUniqueId = STORYBOARD_THUMBS + node;
								Storyboard.Nodes[node].id = iUniqueId;
								Storyboard.Nodes[node].thumb_id = iUniqueId;
								for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
								{
									//PE: input_id,output_id ID's broken in checkproject.
									Storyboard.Nodes[node].widget_normal_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 600;
									Storyboard.Nodes[node].widget_highlight_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 700;
									Storyboard.Nodes[node].widget_selected_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 800;
								}
								for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
								{
									Storyboard.Nodes[node].input_id[l] = iUniqueId + 1000 + (1000 * l);
									Storyboard.Nodes[node].output_id[l] = iUniqueId + 1000 + (1000 * l) + 500;
								}

								Storyboard.Nodes[node].screen_backdrop_id = iUniqueId + 500;

								// New node defaults to a HUD screen
								Storyboard.Nodes[node].used = true;
								Storyboard.Nodes[node].type = STORYBOARD_TYPE_HUD;

								// locate new screen next to last known HUD screen
								if (iLastKnownNode >= 0)
								{
									Storyboard.Nodes[node].restore_position = ImVec2(Storyboard.Nodes[iLastKnownNode].restore_position.x + 20, Storyboard.Nodes[iLastKnownNode].restore_position.y + 20);
								}
								else
								{
									Storyboard.Nodes[node].restore_position = ImVec2(Storyboard.Nodes[iHUDScreenNodeID].restore_position.x + 200 * hudScreenCount, Storyboard.Nodes[iHUDScreenNodeID].restore_position.y);
								}
								ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
								Storyboard.Nodes[node].iEditEnable = true;
								strcpy(Storyboard.Nodes[node].title, "HUD Screen ");
								strcat(Storyboard.Nodes[node].title, cHudCount);
								//strcpy(Storyboard.Nodes[node].thumb, "editors\\templates\\thumbs\\hud.lua.png");
								strcpy(Storyboard.Nodes[node].lua_name, "hud.lua");
								strcpy(Storyboard.Nodes[node].screen_backdrop, "");
								Storyboard.Nodes[node].screen_backdrop_transparent = true;
								Storyboard.Nodes[node].widgets_available = ALLOW_TEXT | ALLOW_TEXTAREA | ALLOW_IMAGE | ALLOW_BUTTON;
								Storyboard.Nodes[node].readouts_available = READOUT_GAMEPLAY | READOUT_GRAPHICS | READOUT_INPUT | READOUT_SOUND;
								break;
							}
						}
						if (node < 0)
						{
							bShowNoMoreScreensError = true;
						}
						else
						{
							// Trigger creation of a new thumbnail for the newly created screen
							iWaitFor2DEditor = 5;
							iWaitFor2DEditorNode = node;
							if (BitmapExist(99))
							{
								DeleteBitmapEx(99);
							}
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pToolTipForAddingNewScreens);

					static int ClassicConversion = 0;
					static char pReconstructGameGuruRootFiles[MAX_PATH];

					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Add Existing Level", ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == 'L')
					{
						iStoryboardExecuteKey = 0;
						cStr tOldDir = GetDir();

						// we know we need to focus on the mapbank associated with the current storyboard
						cstr correctFPMLocation_s = Storyboard.customprojectfolder;
						if (correctFPMLocation_s.Len() > 0)
						{
							correctFPMLocation_s += Storyboard.gamename;
							correctFPMLocation_s += "\\Files\\mapbank";
						}
						else
						{
							correctFPMLocation_s = g.mysystem.mapbankAbs_s.Get();
						}
						//cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "fpm\0*.fpm\0", g.mysystem.mapbankAbs_s.Get(), NULL, true);
						char* cFileSelected = (char*)noc_file_dialog_open(NOC_FILE_DIALOG_OPEN, "fpm\0*.fpm\0", correctFPMLocation_s.Get(), NULL, true);

						SetDir(tOldDir.Get());
						if (cFileSelected && strlen(cFileSelected) > 0)
						{
							t.returnstring_s = cFileSelected;
							if (t.returnstring_s != "")
							{
								if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
								{

									//Only relative.
									char tmp[MAX_PATH];
									strcpy(tmp, t.returnstring_s.Get());

									//PE: Vaidate path, must be inside the mapbank to work.
									extern char szRootDir[MAX_PATH];
									extern char szWriteDir[MAX_PATH];
									extern char szAddWriteDirAdditional[MAX_PATH];

									bool bValidPath = false;
									int rootLen = strlen(szWriteDir);
									if (strnicmp(tmp, szWriteDir, rootLen) == 0)
									{
										bValidPath = true;
									}
									rootLen = strlen(szAddWriteDirAdditional);
									if (!bValidPath && strnicmp(tmp, szAddWriteDirAdditional, rootLen) == 0)
									{
										bValidPath = true;
									}
									rootLen = strlen(szRootDir);
									if (!bValidPath && strnicmp(tmp, szRootDir, rootLen) == 0)
									{
										bValidPath = true;
									}


									char *find = (char *)pestrcasestr(tmp, "mapbank\\");
									if (find && find != &tmp[0]) strcpy(&tmp[0], find);

									if (bValidPath && !find)
									{
										//PE: Must be located inside mapbank.
										bValidPath = false;;
									}

									//PE: check if this is a Classic map we need to import.
									bool bImportClassicMap = false;
									{
										strcpy(pReconstructGameGuruRootFiles, "");
										char pReconstructGameGuruFolder[MAX_PATH];
										strcpy(pReconstructGameGuruFolder, "");
										char pReconstructGameGuruEXE[MAX_PATH];
										strcpy(pReconstructGameGuruEXE, cFileSelected);
										char* pFindClassicFolder = (char *) pestrcasestr(pReconstructGameGuruEXE, "Game Guru\\Files\\mapbank\\");
										if (pFindClassicFolder != NULL)
										{
											*pFindClassicFolder = 0;
											strcpy(pReconstructGameGuruRootFiles, pReconstructGameGuruEXE);
											strcat(pReconstructGameGuruRootFiles, "Game Guru\\Files\\");
											strcpy(pReconstructGameGuruFolder, pReconstructGameGuruEXE);
											strcat(pReconstructGameGuruFolder, "Game Guru\\Files\\entitybank\\");
											strcat(pReconstructGameGuruEXE, "Game Guru\\GameGuru.exe");
											if (FileExist(pReconstructGameGuruEXE) == 1)
											{
												bImportClassicMap = true;
												bValidPath = false;
											}
										}
									}

									if (!bValidPath)
									{
										if (bImportClassicMap)
										{
											int iAction = askBoxCancel("You have selected a classic map, do you want to import this level ?", "GameGuru Classic Map!"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												//Import map.
												ClassicConversion = 1;
												sNextLevelToLoad = t.returnstring_s;
											}
										}
										else
										{
											MessageBoxA(NULL, "All levels added to storyboard must be saved inside the default 'mapbank' folder.", "Error:", 0);
										}
									}
									if (bValidPath)
									{
										std::string sLevelPath = &tmp[0];

										//Dont actual load, just use filename.
										int iPos;
										for (iPos = strlen(tmp); iPos >= 0; iPos--)
											if (tmp[iPos] == '\\') break;
										if (iPos > 0) iPos++;
										std::string sLevelTitle = &tmp[iPos];
										replaceAll(sLevelTitle, ".fpm", "");

										//PE: Find next level from nodes.
										int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
										FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

										if (iFirstNodeFree >= 0)
										{
											//Create new level.
											char tmp[255];
											int node = iFirstNodeFree;
											int nodeposy = iNextLevel;
											if (levelname > 0)
											{
												sprintf(tmp, "Level %d", levelname);
												nodeposy = levelname - 1;
											}
											else
												sprintf(tmp, "Level %d", iNextLevel + 1);

											//PE: Make sure any old data is removed, also thumbs.
											reset_single_node(node);

											Storyboard.Nodes[node].used = true;
											Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
											Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x*0.5 - (fNodeWidth*0.5) + ((fNodeWidth + NODE_WIDTH_PADDING)*2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
											Storyboard.Nodes[node].iEditEnable = true;
											strcpy(Storyboard.Nodes[node].title, sLevelTitle.c_str());
											strcpy(Storyboard.Nodes[node].level_name, sLevelPath.c_str());
											strcpy(Storyboard.Nodes[node].levelnumber, tmp);

											strcpy(Storyboard.Nodes[node].thumb, "");
											//Input.
											strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
											//Output.
											strcpy(Storyboard.Nodes[node].output_title[0], " WIN LEVEL -> Connect to Scene ");
											strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
											Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
											Storyboard.Nodes[node].output_linkto[0] = 0;

											strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
											strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
											Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
											Storyboard.Nodes[node].output_linkto[1] = 0;

											strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
											strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
											Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
											Storyboard.Nodes[node].output_linkto[2] = 0;
											ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
											iAutoConnectNode = node;
											//Check if level already got a thumb.
											CreateBackBufferCacheNameEx(Storyboard.Nodes[node].level_name, 512, 288, true);
											if (FileExist(BackBufferCacheName.Get()))
											{
												if (CopyToProjectFolder(BackBufferCacheName.Get()))
												{
													//PE: Use relative projectbank filename.
													if (FileExist(ProjectCacheName.Get()))
														BackBufferCacheName = ProjectCacheName;
												}

												//PE: Load in old thumb.
												SetMipmapNum(1); //PE: mipmaps not needed.
												image_setlegacyimageloading(true);
												LoadImageSize(BackBufferCacheName.Get(), Storyboard.Nodes[node].thumb_id, 512, 288);
												image_setlegacyimageloading(false);
												SetMipmapNum(-1); //PE: mipmaps not needed.
												if (ImageExist(Storyboard.Nodes[node].thumb_id))
												{
													//PE: Success update thumb filename.
													strcpy(Storyboard.Nodes[node].thumb, BackBufferCacheName.Get());
												}
											}
										}
										else
										{
											bShowNoMoreScreensError = true;
										}
									}
								}
							}
						}
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pToolTipForAddingNewScreens);

					if (ClassicConversion > 0 && bShowNoMoreScreensError == false)
					{
						if (ClassicConversion <= 3)
						{
							strcpy(cTriggerMessage, "Importing Classic Level ...");
							bTriggerMessage = true;
							iTriggerMessageDelay = 0;
							iTriggerMessageY = 0;
							if(ClassicConversion == 1) iMessageTimer = 0;
							ClassicConversion++;
						}
						else if (ClassicConversion == 4)
						{
							//PE: Load fpm from original location.
							g.projectfilename_s = sNextLevelToLoad;

							extern bool g_bAllowBackwardCompatibleConversion;
							g_bAllowBackwardCompatibleConversion = true;
							extern bool g_bDisplayWarnings;
							g_bDisplayWarnings = false;
							gridedit_load_map();
							g_bDisplayWarnings = true;
							g_bAllowBackwardCompatibleConversion = false;
							strcpy(cTriggerMessage, "Converting Settings ...");
							bTriggerMessage = true;
							iTriggerMessageDelay = 0;
							iTriggerMessageY = 0;
							iMessageTimer = 0;

							ClassicConversion++;
						}
						else if (ClassicConversion == 5)
						{
							//PE: Converting settings.
							//PE: ALL ai_ lua scripts will not work in wicked.
							extern bool g_bMakingAStandaloneUsingFileCollectionArray;
							if (g_bMakingAStandaloneUsingFileCollectionArray == false)
							{
								Undim(t.filecollection_s);
								g.filecollectionmax = 0;
								Dim(t.filecollection_s, 500);

								for (int i = 1; i <= g.entityelementmax; i++)
								{
									t.e = i;
									int masterid = t.entityelement[t.e].bankindex;
									if (masterid > 0)
									{
										if (t.entityprofile[masterid].ischaractercreator == 1)
										{
											//Delete Old Character Creator
											t.tentitytoselect = t.e;
											g_UndoSysObjectIsBeingMoved = false;
											entity_deleteentityfrommap();
											//gridedit_deleteentityfrommap();
										}
										if (t.entityelement[t.e].eleprof.aimain_s.Len() > 0)
										{
											t.entityelement[t.e].eleprof.soundset5_s = t.entityelement[t.e].eleprof.soundset4_s;
											t.entityelement[t.e].eleprof.soundset4_s = "";

											//PE: Map scripts.
											if (t.entityelement[t.e].eleprof.aimain_s != "no_behavior_selected.lua")
											{
												char script[MAX_PATH];

												strcpy(script, t.entityelement[t.e].eleprof.aimain_s.Get());
												bool bIncludeMarker = pestrcasestr(script, "markers");
												bool bIncludeObjects = pestrcasestr(script, "objects");

												//PE: Convert old script to new DLUA versions.
												if (!bIncludeMarker && pestrcasestr(script, "winzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\winzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "teleport.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\teleport.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "plrinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\plrinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "FlameLight.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\FlameLight.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "soundinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\soundinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "ToggleLight.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\ToggleLight.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "StrobeLight.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\StrobeLight.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "FlickerLight.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\FlickerLight.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "RotateLight.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\RotateLight.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "ambienceinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\ambienceinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "imageinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\imageinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "fadezone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\fadezone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "electrocute.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\electrocute.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "textinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\textinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "envirozone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\envirozone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "hurt.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\hurt.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "npcinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\npcinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "heal.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\heal.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "stealthzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\stealthzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "watercontrol.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\watercontrol.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "slip.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\slip.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "bounce.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\bounce.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "FreezePlayer.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\FreezePlayer.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "videoinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\videoinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "checkpoint.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\checkpoint.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "ambienceonceinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\ambienceonceinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "soundrepeatinzone.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\soundrepeatinzone.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "module_lightcontrol.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\module_lightcontrol.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "ConstantLight.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\ConstantLight.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "sendpulse.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\sendpulse.lua";
												else if (!bIncludeMarker && pestrcasestr(script, "particle.lua")) t.entityelement[t.e].eleprof.aimain_s = "markers\\particle.lua";
												//PE: new DLUA in Objects.
												else if (!bIncludeObjects && pestrcasestr(script, "proximity_mine.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\proximity_mine.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "ladder.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\ladder.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "healthbar.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\healthbar.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "change_texture.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\change_texture.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "door_rotate.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\door_rotate.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "secmon.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\secmon.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "winswitch.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\winswitch.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "spin.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\spin.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "dynamite.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\dynamite.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "seccam.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\seccam.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "hideshow.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\hideshow.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "boat.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\boat.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "door_sliding.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\door_sliding.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "carry_object.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\carry_object.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "door.lua"))
												{
													//door_properties(0\"70\",0\"1000\",3\"0\",2\"Door locked. Find key\",3\"0\",2\"Press E To Open\")
													//g_Entity[e]['haskey'] ?
													t.entityelement[t.e].eleprof.soundset4_s = "door_properties(0\"70\",0\"1000\",3\"1\",2\"Door locked. Find key\",3\"0\",2\"Press E To Open\")";
													t.entityelement[t.e].eleprof.aimain_s = "objects\\door.lua";
												}
												else if (!bIncludeObjects && pestrcasestr(script, "decalshow.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\decalshow.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "sentry.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\sentry.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "mines.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\mines.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "proximine.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\mines.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "face_object.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\face_object.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "document.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\document.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "switch.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\switch.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "move_near.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\move_near.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "invisible.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\invisible.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "move_away.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\move_away.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "loopwaypoint.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\loopwaypoint.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "invisibleprompt.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\invisibleprompt.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "hover.lua")) t.entityelement[t.e].eleprof.aimain_s = "objects\\hover.lua";

												else if (!bIncludeObjects && pestrcasestr(script, "health.lua")) t.entityelement[t.e].eleprof.aimain_s = "rpg\\health.lua";
												else if (!bIncludeObjects && pestrcasestr(script, "radar.lua")) t.entityelement[t.e].eleprof.aimain_s = "rpg\\radar.lua";

												else if (pestrcasestr(script, "invisible_wall.lua"))
													t.entityelement[t.e].eleprof.aimain_s = "objects\\invisible.lua";
												else if (pestrcasestr(script, "ai_") && t.entityprofile[masterid].ischaracter == 1)
												{
													//PE: No old AI_ is working in max.
													t.entityelement[t.e].eleprof.aimain_s = "";
												}
												else if (pestrcasestr(script, "stories\\T"))
												{
													//PE: TBE stories dont work., LoadImages("The Big Escape",0)
													t.entityelement[t.e].eleprof.aimain_s = "";
												}
												else
												{
													//PE: Missing. copy to docwrite script folder , old lua script might work.
													//PE: Check if its already in max scripts.
													char scriptfile[MAX_PATH];
													strcpy(scriptfile, "scriptbank\\");
													strcat(scriptfile, t.entityelement[t.e].eleprof.aimain_s.Get());
													if (!FileExist(scriptfile))
													{
														char WriteTo[MAX_PATH];
														char ReadFrom[MAX_PATH];
														strcpy(WriteTo, scriptfile);
														GG_GetRealPath(WriteTo, 1);
														strcpy(ReadFrom, pReconstructGameGuruRootFiles);
														strcat(ReadFrom, scriptfile);
														bool bRet = CopyFileA(ReadFrom, WriteTo, TRUE);
														scanscriptfileandaddtocollection(ReadFrom, &pReconstructGameGuruRootFiles[0]);
													}
												}
											}
										}

										if (t.entityprofile[masterid].model_s.Len() > 0)
										{
											//PE: 24 bits dds.
											if (pestrcasestr(t.entityprofile[masterid].model_s.Get(), "FireFlies.X"))
											{
												//Remove.
												t.entityelement[t.e].bankindex = 0;
											}
										}
										char pGameCoreAsset[MAX_PATH];
										strcpy(pGameCoreAsset, "");
										//#define INCLUDECLASSICWEAPONS
	#ifdef INCLUDECLASSICWEAPONS
										if (t.entityprofile[masterid].ischaracter == 1)
										{
											strcpy(pGameCoreAsset, t.entityprofile[masterid].hasweapon_s.Get());
										}
										if (t.entityprofile[masterid].ismarker == 1)
										{
											strcpy(pGameCoreAsset, t.entityelement[t.e].eleprof.hasweapon_s.Get());
										}
	#endif
										if (strlen(pGameCoreAsset) > 0)
										{
											char pGameCoreFolder[MAX_PATH];
											strcpy(pGameCoreFolder, pGameCoreAsset);
											LPSTR pOldDir = GetDir();
											char pSrcFolder[MAX_PATH];
											strcpy(pSrcFolder, pReconstructGameGuruRootFiles);
											strcat(pSrcFolder, "gamecore\\guns\\");
											strcat(pSrcFolder, pGameCoreFolder);
											if (PathExist(pSrcFolder))
											{
												SetDir(pSrcFolder);
												ChecklistForFiles();
												SetDir(pOldDir);
												strcat(pGameCoreFolder, "\\");
												strcat(pSrcFolder, "\\");
												for (int c = 1; c <= ChecklistQuantity(); c++)
												{
													LPSTR pFileName = ChecklistString(c);
													if (strcmp(pFileName, ".") != NULL && strcmp(pFileName, "..") != NULL)
													{
														char pSrcFile[MAX_PATH];
														char pDestFile[MAX_PATH];
														strcpy(pSrcFile, pSrcFolder);
														strcat(pSrcFile, pFileName);
														strcpy(pDestFile, "gamecore\\guns\\");
														strcat(pDestFile, pGameCoreFolder);
														strcat(pDestFile, pFileName);
														if (!FileExist(pDestFile))
														{
															GG_GetRealPath(pDestFile, 1);
															CopyFileA(pSrcFile, pDestFile, TRUE);
														}
													}
												}
											}
										}

									}
								}
								if (g.filecollectionmax > 0)
								{
									for (int i = 0; i <= g.filecollectionmax; i++)
									{
										LPSTR pThisFile = t.filecollection_s[i].Get();
										int iThisSize = strlen(pThisFile);
										if (iThisSize > 0)
										{
											// must have a file specified
											if (pThisFile[iThisSize - 1] == '\\' || pThisFile[iThisSize - 1] == '/')
											{
												// ignore folders
											}
											else
											{
												char ReadFrom[MAX_PATH];
												strcpy(ReadFrom, pReconstructGameGuruRootFiles);
												strcat(ReadFrom, pThisFile);
												if (FileExist(ReadFrom) == 1)
												{
													char WriteTo[MAX_PATH];
													strcpy(WriteTo, pThisFile);
													if (!FileExist(pThisFile))
													{
														GG_GetRealPath(WriteTo, 1);
														bool bRet = CopyFileA(ReadFrom, WriteTo, TRUE);
													}
												}
											}
										}
									}
									Undim(t.filecollection_s);
									g.filecollectionmax = 0;
									Dim(t.filecollection_s, 500);
								}
							}

							t.tentitytoselect = 0;
							strcpy(cTriggerMessage, "Creating New Level ...");
							bTriggerMessage = true;
							iTriggerMessageDelay = 0;
							iTriggerMessageY = 0;
							iMessageTimer = 0;

							ClassicConversion++;
						}
						else if (ClassicConversion == 6)
						{
							//PE: Check for missing .dbo files.
							extern char szWriteDir[MAX_PATH];
							extern char g_pAbsPathToConverter[MAX_PATH];

							char pOldDir[MAX_PATH];
							GetCurrentDirectoryA(MAX_PATH, pOldDir);

							SetDir(szWriteDir);
							HINSTANCE hinstance = ShellExecuteA(NULL, "open", g_pAbsPathToConverter, "", "", SW_SHOWDEFAULT);
							Sleep(3000);
							SetDir(pOldDir);

							//PE: saving new level.
							char pNewGameGuruLevel[MAX_PATH];
							strcpy(pNewGameGuruLevel, g.projectfilename_s.Get());
							char* level = (char *) pestrcasestr(pNewGameGuruLevel, "mapbank\\");
							if (level > 0)
							{
								char tmp[MAX_PATH];
								strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
								//Relative.
								char* find = (char*)pestrcasestr(tmp, "mapbank\\");
								if (find && find != &tmp[0]) strcpy(&tmp[0], find);
								strcat(tmp, level+8);

								t.returnstring_s = tmp;
								g.projectfilename_s = tmp;
								g.projectmodifiedstatic = 1;
								g.projectmodifiedstatic = 1;

								for (t.e = 1; t.e <= g.entityelementlist; t.e++)
								{
									t.entid = t.entityelement[t.e].bankindex;
									if (t.entityprofile[t.entid].ismarker == 1)
									{
										//PE: set camera to Player Start Marker Settings
										PositionCamera( t.entityelement[t.e].x, t.entityelement[t.e].y+50, t.entityelement[t.e].z);
										t.cx_f = t.editorfreeflight.c.x_f = GetCameraPosition().x;
										t.editorfreeflight.c.y_f = GetCameraPosition().y;
										t.cy_f = t.editorfreeflight.c.z_f = GetCameraPosition().z;
										break;
									}
								}

								gridedit_save_map();
								g.projectmodified = 0; gridedit_changemodifiedflag();
								g.projectmodifiedstatic = 0;
								ClassicConversion++;
								strcpy(cTriggerMessage, "Loading Converted Level ...");
								bTriggerMessage = true;
								iMessageTimer = 0;
								iTriggerMessageDelay = 0;
								iTriggerMessageY = 0;
							}
							else
							{
								ClassicConversion = 10;
							}
						}
						else if (ClassicConversion == 7)
						{
							strcpy(cTriggerMessage, "Loading Converted Level ...");
							bTriggerMessage = true;
							iMessageTimer = 0;
							iTriggerMessageDelay = 0;
							iTriggerMessageY = 0;

							ClassicConversion++;
						}
						else if (ClassicConversion == 8)
						{
							//PE: Loading new converted map.

							char tmp[MAX_PATH];
							strcpy(tmp, g.projectfilename_s.Get());

							char* find = (char*)pestrcasestr(tmp, "mapbank\\");
							if (find && find != &tmp[0]) strcpy(&tmp[0], find);

							int iPos;
							for (iPos = strlen(tmp); iPos >= 0; iPos--)
								if (tmp[iPos] == '\\') break;
							if (iPos > 0) iPos++;
							std::string sLevelTitle = &tmp[iPos];
							replaceAll(sLevelTitle, ".fpm", "");

							std::string sLevelPath = &tmp[0];

							//PE: Find next level from nodes.
							int iNextLevel = 0, levelname = -1, iFirstNodeFree = -1;
							FindFreeLevelNode(iNextLevel, levelname, iFirstNodeFree);

							if (iFirstNodeFree >= 0)
							{
								//Create new level.
								char tmp[255];
								int node = iFirstNodeFree;
								int nodeposy = iNextLevel;
								if (levelname > 0)
								{
									sprintf(tmp, "Level %d", levelname);
									nodeposy = levelname - 1;
								}
								else
									sprintf(tmp, "Level %d", iNextLevel + 1);

								//PE: Make sure any old data is removed, also thumbs.
								reset_single_node(node);

								Storyboard.Nodes[node].used = true;
								Storyboard.Nodes[node].type = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].restore_position = ImVec2(preview_size_x * 0.5 - (fNodeWidth * 0.5) + ((fNodeWidth + NODE_WIDTH_PADDING) * 2.0), STORYBOARD_YSTART + ((fNodeHeight + 20.0 + NODE_HEIGHT_PADDING) * (nodeposy)));
								Storyboard.Nodes[node].iEditEnable = true;
								strcpy(Storyboard.Nodes[node].title, sLevelTitle.c_str());
								strcpy(Storyboard.Nodes[node].level_name, sLevelPath.c_str());
								strcpy(Storyboard.Nodes[node].levelnumber, tmp);

								strcpy(Storyboard.Nodes[node].thumb, "");
								//Input.
								strcpy(Storyboard.Nodes[node].input_title[0], " Input ");
								//Output.
								strcpy(Storyboard.Nodes[node].output_title[0], " WIN LEVEL -> Connect to Scene ");
								strcpy(Storyboard.Nodes[node].output_action[0], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[0] = STORYBOARD_TYPE_SCREEN;
								Storyboard.Nodes[node].output_linkto[0] = 0;

								strcpy(Storyboard.Nodes[node].output_title[1], " GAME OVER -> Connect to Scene ");
								strcpy(Storyboard.Nodes[node].output_action[1], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[1] = STORYBOARD_TYPE_SCREEN;
								Storyboard.Nodes[node].output_linkto[1] = 0;

								strcpy(Storyboard.Nodes[node].output_title[2], " NEXT LEVEL -> Connect to Level ");
								strcpy(Storyboard.Nodes[node].output_action[2], "loadlevel"); //Not defined this yet.
								Storyboard.Nodes[node].output_can_link_to_type[2] = STORYBOARD_TYPE_LEVEL;
								Storyboard.Nodes[node].output_linkto[2] = 0;
								ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[node].id, Storyboard.Nodes[node].restore_position);
								iAutoConnectNode = node;
								//Check if level already got a thumb.
								CreateBackBufferCacheNameEx(Storyboard.Nodes[node].level_name, 512, 288, true);
								if (FileExist(BackBufferCacheName.Get()))
								{
									if (CopyToProjectFolder(BackBufferCacheName.Get()))
									{
										//PE: Use relative projectbank filename.
										if (FileExist(ProjectCacheName.Get()))
											BackBufferCacheName = ProjectCacheName;
									}

									//PE: Load in old thumb.
									SetMipmapNum(1); //PE: mipmaps not needed.
									image_setlegacyimageloading(true);
									LoadImageSize(BackBufferCacheName.Get(), Storyboard.Nodes[node].thumb_id, 512, 288);
									image_setlegacyimageloading(false);
									SetMipmapNum(-1); //PE: mipmaps not needed.
									if (ImageExist(Storyboard.Nodes[node].thumb_id))
									{
										//PE: Success update thumb filename.
										strcpy(Storyboard.Nodes[node].thumb, BackBufferCacheName.Get());
									}
								}
							}

							gridedit_load_map();
							bUpdateVeg = true;
							ClassicConversion++;
						}
						else if (ClassicConversion == 9)
						{
							ClassicConversion = 0;
						}

						if (ClassicConversion == 10)
						{
							//Failed.
							strcpy(cTriggerMessage, "ERROR: Importing Classic Level Failed!");
							bTriggerMessage = true;
							iMessageTimer = 0;
							iTriggerMessageDelay = 0;
							iTriggerMessageY = 0;
							ClassicConversion = 0;
						}
					}
					#ifdef INCLUDE_GAME_SETTINGS
					if (pref.iStoryboardAdvanced)
					{
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Edit Game Settings", ImVec2(buttonwide, 0.0f)))
						{
							bEditGameSettings = true;
						}
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x * 0.5) - (buttonwide * 0.5), 0.0f));
						if (ImGui::StyleButton("Reset HUD Screens", ImVec2(buttonwide, 0.0f)))
						{
							// Force a reset of the In-Game HUD screen, and reset node position
							for (int i = 0; i < STORYBOARD_MAXNODES; i++)
							{
								if (Storyboard.Nodes[i].used && Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD)
								{
									Storyboard.Nodes[i].used = false;
								}
							}
							int areaWidth = ImGui::GetMainViewport()->Size.x - 300;
							int nodeWidth = 180;
							int nodeHeight = 150;
							//PE: We cant force it to 13, it might overwrite another node.
							iHUDScreenNodeID = storyboard_add_missing_nodex(13,areaWidth , nodeWidth, nodeHeight, false);
							ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[iHUDScreenNodeID].id, ImVec2(areaWidth * 0.5 - (nodeWidth * 0.5), STORYBOARD_YSTART + (nodeHeight + NODE_HEIGHT_PADDING) * 3));
							iCurrentSelectedWidget = -1;
							// Also ensure that any user defined globals are removed when resetting HUD screens
							for (int i = 0; i < STORYBOARD_MAXNODES; i++)
							{
								if (strnicmp(Storyboard.Nodes[i].lua_name, "hud", 3) == NULL)
								{
									for (int j = 0; j < STORYBOARD_MAXWIDGETS; j++)
									{
										if (strnicmp(Storyboard.widget_readout[i][j], "user defined", 12) == 0)
										{
											Storyboard.widget_readout[i][j][0] = 0;
										}
									}
								}
							}
							g_bRefreshGlobalList = true;
						}
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x * 0.5) - (buttonwide * 0.5), 0.0f));
						if (ImGui::StyleButton("Add RPG Screens", ImVec2(buttonwide, 0.0f)))
						{
							g_bRefreshGlobalList = true;

							// check if RPG screens already exist
							int iCountNewHUDScreensNeeded = 0;
							bool bRPGHUDSMissing[10];
							memset(bRPGHUDSMissing, 0, sizeof(bRPGHUDSMissing));
							bool bAllRPGScreensAlreadyExist = true;
							for (int hudi = 1; hudi <= 9; hudi++) // include RPG Templates VR screen :)
							{
								// assume HUD screen missing
								bRPGHUDSMissing[hudi] = true;
								char pTitleLabel[256];
								if (hudi == 1)
								{
									sprintf(pTitleLabel, "In-Game HUD");
								}
								else
								{
									sprintf(pTitleLabel, "HUD Screen %d", hudi);
								}
								for (int i = 0; i < STORYBOARD_MAXNODES; i++)
								{
									if (Storyboard.Nodes[i].used)
									{
										if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_HUD)
										{
											if (pestrcasestr(Storyboard.Nodes[i].title, pTitleLabel))
											{
												// found the HUD, not missing
												bRPGHUDSMissing[hudi] = false;
												break;
											}
										}
									}
								}
								if (bRPGHUDSMissing[hudi] == true)
								{
									iCountNewHUDScreensNeeded++;
									bAllRPGScreensAlreadyExist = false;
								}
							}
							if (bAllRPGScreensAlreadyExist == false && iCountNewHUDScreensNeeded > 0)
							{
								// need to find this many free nodes, or throw error
								int iCountRemainingFreeOnes = 0;
								for (int i = 14; i < STORYBOARD_MAXNODES; i++)
								{
									if (Storyboard.Nodes[i].used == 0)
									{
										iCountRemainingFreeOnes++;
									}
								}
								if (iCountRemainingFreeOnes < iCountNewHUDScreensNeeded)
								{
									bShowNoMoreScreensError = true;
								}
							}
							if (bAllRPGScreensAlreadyExist == false && bShowNoMoreScreensError==false)
							{
								// load in template screens from "RPG Template" project
								char project[MAX_PATH];
								strcpy(project, "projectbank\\RPG Template\\project.dat");
								FILE* projectfile = GG_fopen(project, "rb");
								if (projectfile)
								{
									StoryboardStruct* checkproject = new StoryboardStruct;
									memset(checkproject, 0, sizeof(StoryboardStruct));
									size_t size = fread(checkproject, 1, sizeof(StoryboardStruct), projectfile);
									char sig[12] = "Storyboard\0";
									if (checkproject->sig[0] == 'S' && checkproject->sig[8] == 'r')
									{
										// go through and find all HUD Screens related to RPG
										for (int i = 0; i < STORYBOARD_MAXNODES; i++)
										{
											if (checkproject->Nodes[i].used)
											{
												if (checkproject->Nodes[i].type == STORYBOARD_TYPE_HUD)
												{
													//for (int hudi = 1; hudi <= 8; hudi++)
													for (int hudi = 1; hudi <= 9; hudi++)
													{
														// only add those that are missing
														if (bRPGHUDSMissing[hudi] == true )
														{
															char pTitleLabel[256];
															if ( hudi == 1 )
																sprintf(pTitleLabel, "In-Game HUD");
															else
																sprintf(pTitleLabel, "HUD Screen %d", hudi);
															if (pestrcasestr(checkproject->Nodes[i].title, pTitleLabel))
															{
																// find spare node
																int newnodeid = 0;
																for (int i = 14; i < STORYBOARD_MAXNODES; i++)
																{
																	if (Storyboard.Nodes[i].used == 0 )
																	{
																		newnodeid = i;
																		break;
																	}
																}
																if (newnodeid > 0)
																{
																	// must use unique NODEIDs for IMNODE
																	int iFoundNodeID = 0;
																	int iTryNodeID = STORYBOARD_THUMBS;
																	while (iFoundNodeID == 0)
																	{
																		int i = 0;
																		for (; i < STORYBOARD_MAXNODES; i++)
																		{
																			if (Storyboard.Nodes[i].used)
																			{
																				if (Storyboard.Nodes[i].id == iTryNodeID)
																				{
																					iTryNodeID++;
																					break;
																				}
																			}
																		}
																		if (i >= STORYBOARD_MAXNODES)
																		{
																			iFoundNodeID = iTryNodeID;
																		}
																	}
																	if (iFoundNodeID > 0)
																	{
																		// copy node from RPG Template project to current storyboard
																		Storyboard.Nodes[newnodeid] = checkproject->Nodes[i];
																		Storyboard.Nodes[newnodeid].id = iFoundNodeID;
																		Storyboard.NodeRadioButtonSelected[newnodeid] = checkproject->NodeRadioButtonSelected[i];
																		for (int iWidgetIndex = 0; iWidgetIndex < STORYBOARD_MAXWIDGETS; iWidgetIndex++)
																		{
																			Storyboard.NodeSliderValues[newnodeid][iWidgetIndex] = checkproject->NodeSliderValues[i][iWidgetIndex];
																			Storyboard.widget_colors[newnodeid][iWidgetIndex] = checkproject->widget_colors[i][iWidgetIndex];
																			for (int n = 0; n < 128; n++)
																			{
																				Storyboard.widget_readout[newnodeid][iWidgetIndex][n] = checkproject->widget_readout[i][iWidgetIndex][n];
																			}
																			Storyboard.widget_textoffset[newnodeid][iWidgetIndex] = checkproject->widget_textoffset[i][iWidgetIndex];
																			Storyboard.widget_ingamehidden[newnodeid][iWidgetIndex] = checkproject->widget_ingamehidden[i][iWidgetIndex];
																			Storyboard.widget_drawordergroup[newnodeid][iWidgetIndex] = checkproject->widget_drawordergroup[i][iWidgetIndex];
																		}

																		//PE: unique ids are wrong in checkproject so assign new here.
																		int iUniqueId = STORYBOARD_THUMBS + newnodeid;
																		Storyboard.Nodes[newnodeid].id = iUniqueId;
																		Storyboard.Nodes[newnodeid].thumb_id = iUniqueId;
																		for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
																		{
																			//PE: input_id,output_id ID's broken in checkproject.
																			Storyboard.Nodes[newnodeid].widget_normal_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 600;
																			Storyboard.Nodes[newnodeid].widget_highlight_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 700;
																			Storyboard.Nodes[newnodeid].widget_selected_thumb_id[l] = iUniqueId + 1000 + (1000 * l) + 800;
																		}
																		for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
																		{
																			Storyboard.Nodes[newnodeid].input_id[l] = iUniqueId + 1000 + (1000 * l);
																			Storyboard.Nodes[newnodeid].output_id[l] = iUniqueId + 1000 + (1000 * l) + 500;
																		}
																		Storyboard.Nodes[newnodeid].screen_backdrop_id = iUniqueId + 500;

																		// update thumbs
																		SetMipmapNum(1);
																		image_setlegacyimageloading(true);
																		LoadImageSize(Storyboard.Nodes[newnodeid].thumb, Storyboard.Nodes[newnodeid].thumb_id, 512, 288);
																		image_setlegacyimageloading(false);
																		SetMipmapNum(-1);

																		// indicate a change
																		ImNodes::SetNodeGridSpacePos(Storyboard.Nodes[newnodeid].id, Storyboard.Nodes[newnodeid].restore_position);
																		Storyboard.iChanged = true;
																	}
																}
															}
														}
													}
												}
											}
										}
										fclose(projectfile);
									}
									if (checkproject)
									{
										delete checkproject;
										checkproject = NULL;
									}
								}
							}
						}
						if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", pToolTipForAddingNewScreens);
					}
					#endif

					// generic warning of no more screens
					if (bShowNoMoreScreensError == true)
					{
						char pErrMess[256];
						sprintf(pErrMess, "Number of allocated screens/levels reached. The maximum is %d.", STORYBOARD_MAXNODES);
						strcpy(cTriggerMessage, pErrMess);
						bTriggerMessage = true;
					}

					//PE: Auto connect node.
					if (iAutoConnectNode >= 0)
					{
						for (int i = 0; i < STORYBOARD_MAXNODES; i++)
						{
							if (Storyboard.Nodes[i].used)
							{
								if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
								{
									if (Storyboard.Nodes[i].output_linkto[2] == 0 && i != iAutoConnectNode)
									{
										Storyboard.Nodes[i].output_linkto[2] = Storyboard.Nodes[iAutoConnectNode].input_id[0];
										break;
									}
								}
							}
						}
						iAutoConnectNode = -1;
					}

					ImGui::Indent(-10);
				}
				if (ImGui::StyleCollapsingHeader("Play Game", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0 )
				{
					ImGui::Indent(10);
					if (strlen(playerrors) > 0) ImGui::TextWrapped(playerrors);

					static bool bStandalone = false;
					float tw = ImGui::CalcTextSize("Standalone Test All Levels").x;
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5) - (tw*0.5) - (ImGui::GetFrameHeight()*0.5), 0.0f));
					ImGui::Checkbox("Standalone Test All Levels", &bStandalone);
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "NOTE: This will exit the editor and start a full standalone version of your game.");

					cstr but1 = "Normal Single Level";
					cstr but2 = "Invulnerable Single Level";

					if (bStandalone)
					{
						but1 = "Normal Standalone";
						but2 = "Invulnerable Standalone";
					}

					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton(but1.Get(), ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == ' ')
					{
						strcpy(playerrors, "");

						iStoryboardExecuteKey = 0;

						g.projectmodified = 0; gridedit_changemodifiedflag();
						g.projectmodifiedstatic = 0;

						//Try loading level first.
						if (strlen(Storyboard.gamename) <= 0)
						{
							BoxerInfo("You should save your game project first.", "Information");
						}
						else
						{
							FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm, true);
							if (g_Storyboard_First_Level_Node == -1)
							{
								strcpy(playerrors, "You do not have any levels in your setup.");
							}
							else
							{
								bool bAbort = false;
								if (Storyboard.iChanged)
								{
									bBlockNextMouseCheck = true;
									if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
									{
										save_storyboard(Storyboard.gamename, false);
									}
									else
									{
										int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
										if (iAction == 1)
										{
											//Save.
											if (strlen(Storyboard.gamename) > 0)
												save_storyboard(Storyboard.gamename, false);
											else
											{
												bAbort = true;
												save_storyboard(Storyboard.gamename, true);
											}
										}
									}
								}
								if (!bAbort)
								{
									if (bStandalone)
									{
										Sleep(100); //PE: Write done,
										extern bool g_bCascadeQuitFlag;
										g_bCascadeQuitFlag = true;
										PostQuitMessage(0);
										SetCurrentDirectoryA("..\\");
										char par[MAX_PATH];
										sprintf(par, "project=0%s", Storyboard.gamename);
										ExecuteFile("GameGuruMAX.exe", par, "", 0);
										Sleep(500);
										//ExitProcess(0); PostQuitMessage(0); above should take care of this.
									}
									else
									{
										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);

										if (g.projectfilename_s != g_Storyboard_First_fpm)
										{
											//Load level if not already loaded.
											strcpy(cDirectOpen, g_Storyboard_First_fpm);
											iLaunchAfterSync = 7; //Direct load.
											iSkibFramesBeforeLaunch = 2;
											iFramesBeforeEmulate = 10;
										}
										else
										{
											iFramesBeforeEmulate = 2;
										}
										g.projectfilename_s = g_Storyboard_First_fpm;
										bTestStandalone = true;
										strcpy(startpage, "title");
										strcpy(lastpage, "title");
										strcpy(playerrors, "");
									}
								}
							}
						}


					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton(but2.Get(), ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == '!' )
					{
						strcpy(playerrors, "");

						iStoryboardExecuteKey = 0;
						 //Try loading level first.
						if (strlen(Storyboard.gamename) <= 0)
						{
							BoxerInfo("You should save your game project first.", "Information");
						}
						else
						{
							FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm, true);
							if (g_Storyboard_First_Level_Node == -1)
							{
								strcpy(playerrors, "You do not have any levels in your setup.");
							}
							else
							{
								bool bAbort = false;
								if (Storyboard.iChanged)
								{
									bBlockNextMouseCheck = true;
									if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
									{
										save_storyboard(Storyboard.gamename, false);
									}
									else
									{
										int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
										if (iAction == 1)
										{
											//Save.
											if (strlen(Storyboard.gamename) > 0)
												save_storyboard(Storyboard.gamename, false);
											else
											{
												bAbort = true;
												save_storyboard(Storyboard.gamename, true);
											}
										}
									}
								}
								if (!bAbort)
								{
									if (bStandalone)
									{
										extern bool g_bCascadeQuitFlag;
										g_bCascadeQuitFlag = true;
										PostQuitMessage(0);
										SetCurrentDirectoryA("..\\");
										char par[MAX_PATH];
										sprintf(par, "project=1%s", Storyboard.gamename);
										ExecuteFile("GameGuruMAX.exe", par, "", 0);
										Sleep(500);
										ExitProcess(0);
									}
									else
									{
										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);

										if (g.projectfilename_s != g_Storyboard_First_fpm)
										{
											//Load level if not already loaded.
											strcpy(cDirectOpen, g_Storyboard_First_fpm);
											iLaunchAfterSync = 7; //Direct load.
											iSkibFramesBeforeLaunch = 2;
											iFramesBeforeEmulate = 10;
										}
										else
										{
											iFramesBeforeEmulate = 2;
										}
										g.projectfilename_s = g_Storyboard_First_fpm;
										bTestStandalone = true;
										strcpy(startpage, "title");
										strcpy(lastpage, "title");
										strcpy(playerrors, "");
										bStartInvulnerableMode = true;
									}
								}
							}
						}
					}
					ImGui::Indent(-10);
				}
				if (ImGui::StyleCollapsingHeader("Export Game", ImGuiTreeNodeFlags_DefaultOpen) || iStoryboardExecuteKey != 0)
				{
					ImGui::Indent(10);
					static char errors[256] = "\0";
					if (strlen(errors) > 0) ImGui::TextWrapped(errors);
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvail().x*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Save Standalone Game", ImVec2(buttonwide, 0.0f)) || iStoryboardExecuteKey == 'E')
					{
						strcpy(errors, "");

						//PE: Deselect any objects, if we load a level with less entityties then t.widget.pickedEntityIndex it will crash.
						t.widget.pickedEntityIndex = 0;
						t.gridentity = 0;

						iStoryboardExecuteKey = 0;
						//PE: We need to store a list of levels to generate,
						if (strlen(Storyboard.gamename) <= 0)
						{
							BoxerInfo("You should save your game project before making a standalone.", "Information");
						}
						else
						{
							CloseAllOpenTools();
							int iRet = AskSaveBeforeNewAction();
							if (iRet != 2)
							{
								g.bUseStoryBoardSetup = true;
								FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm, true);
								if (g_Storyboard_First_Level_Node == -1)
								{
									strcpy(errors, "You do not have any levels in your setup.");
								}
								else
								{
									bool bAbort = false;
									if (Storyboard.iChanged)
									{
										bBlockNextMouseCheck = true;
										if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
										{
											save_storyboard(Storyboard.gamename, false);
										}
										else
										{
											int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
											if (iAction == 1)
											{
												//Save.
												if (strlen(Storyboard.gamename) > 0)
													save_storyboard(Storyboard.gamename, false);
												else
												{
													bAbort = true;
													save_storyboard(Storyboard.gamename, true);
												}
											}
										}
									}
									if (!bAbort)
									{

										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);

										if (g.projectfilename_s != g_Storyboard_First_fpm)
										{
											//Load level if not already loaded.
											strcpy(cDirectOpen, g_Storyboard_First_fpm);
											iLaunchAfterSync = 7; //Direct load.
											iSkibFramesBeforeLaunch = 2;
											//PE: Delay open standalone.
											bLaunchSaveStandalonefterLoad = true;
										}
										else
										{									
											//PE: Already loaded directly to export.
											bExport_Standalone_Window = true;
										}
										g.projectfilename_s = g_Storyboard_First_fpm;

										//Use fullpath to levels.
										char destination[MAX_PATH];
										strcpy(destination, g.projectfilename_s.Get());
										GG_GetRealPath(destination, 1);
										g.projectfilename_s = destination;
									}
								}
							}
						}
					}
					ImGui::Indent(-10);
				}

				if(bModal)
					ControlAdvancedSetting(pref.iStoryboardAdvanced, "advanced storyboard features", &bStoryboardWindow);
				else
					ControlAdvancedSetting(pref.iStoryboardAdvanced, "advanced storyboard features", NULL);

				if (pref.iStoryboardAdvanced)
				{
					//Advanced options.
				}

				if (!pref.bHideTutorials)
				{
					if (ImGui::StyleCollapsingHeader("Tutorial", ImGuiTreeNodeFlags_DefaultOpen))
					{
						ImGui::Indent(10);
						char* my_combo_itemsp[] = { "0701 - Game Storyboard", "0501 - Terrain Generator" };
						int my_combo_items = 0;
						int iVideoSection = 0;
						cstr cShowTutorial = "0701 - Game Storyboard";
						iVideoSection = SECTION_STORYBOARD;//LB: SECTION_SCULPT_TERRAIN;
						SmallTutorialVideo(cShowTutorial.Get(), my_combo_itemsp, ARRAYSIZE(my_combo_itemsp), iVideoSection);
						float but_gadget_size = ImGui::GetFontSize()*12.0;
						float w = ImGui::GetWindowContentRegionWidth() - 10.0;
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((w*0.5) - (but_gadget_size*0.5), 0.0f));
						ImGui::Indent(-10);
					}
				}

				// insert a keyboard shortcut component into panel
				UniversalKeyboardShortcut(eKST_Storyboard);

				if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
					//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
					ImGui::Text("");
					ImGui::Text("");
				}

				ImGui::Columns(1);
			}

			if (bModal)
				ImGui::EndPopup();
			else
				ImGui::End();
		}

		if (!bModal) ImGui::PopStyleColor();

		if (!bPopModalStoryboard)
		{
			//Close down everything.
		}

		//Emulate standalone.
		bool bBlackOut = false;
		if (iFramesBeforeEmulate > 0)
		{
			iFramesBeforeEmulate--;
			//PE: Hide everything.
			if (iFramesBeforeEmulate < 4)
			{
				bBlackOut = true;
			}
		}
		else
		{
			if (bStartLoadingGame)
			{
				if (iFakeLoadGameTest-- > 0)
				{
					strcpy(lastpage, startpage);
					//strcpy(startpage, "loading");
					extern cstr g_Storyboard_LoaderScreen_Name;
					strcpy(startpage, g_Storyboard_LoaderScreen_Name.Get());
					int iret = screen_editor(-1, true, startpage);
				}
				else
				{
					bTestStandalone = false;
					bStartLoadingGame = false;
					bFakeStandaloneTest = true;
					//Start test game.
					iLaunchAfterSync = 1;
					bBlackOut = true;
				}
			}
			else if (bTestStandalone)
			{
				int iret = screen_editor(-1, true, startpage);

				if (iret == STORYBOARD_ACTIONS_GOTOLEVEL)
				{
					//PE: Need to load the level before emulating loading.
					if (g.projectfilename_s != g_Storyboard_Current_fpm)
					{
						t.returnstring_s = g_Storyboard_Current_fpm;
						if (t.returnstring_s != "")
						{
							if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) == ".fpm")
							{
								GGTerrain_CancelRamp();
								t.gridentity = 0;
								t.inputsys.constructselection = 0;
								editor_refresheditmarkers();
								g.projectfilename_s = t.returnstring_s;

								extern bool g_bAllowBackwardCompatibleConversion;
								g_bAllowBackwardCompatibleConversion = true;
								gridedit_load_map();
								g_bAllowBackwardCompatibleConversion = false;

								t.terrain.grassregionx1 = t.terrain.grassregionx2;
								grass_init();

								iLastUpdateVeg = 0;
								bUpdateVeg = true;
								extern int g_iSuperTriggerFullGrassReveal; // hmm, shoved in to get the damn grass showing on initial load!
								g_iSuperTriggerFullGrassReveal = 10;
								iLaunchAfterSync = 80; //Update env
								iSkibFramesBeforeLaunch = 5;
							}
						}
					}
					bStartLoadingGame = true;
					iFakeLoadGameTest = 100;
					extern bool g_Storyboard_Starting_New_Level;
					g_Storyboard_Starting_New_Level = true; //PE: Always start fresh when linking directly to a level.

				}
				if (iret == STORYBOARD_ACTIONS_CONTINUE)
				{
					//Restart
					strcpy(startpage, "title");
					strcpy(lastpage, "title");
					strcpy(playerrors, "");
				}
				if (iret == STORYBOARD_ACTIONS_BACK)
				{
					strcpy(startpage, lastpage);
				}
				if (iret == STORYBOARD_ACTIONS_EXITGAME)
				{
					bTestStandalone = false;
				}
				if (iret == STORYBOARD_ACTIONS_STARTGAME)
				{
					bStartLoadingGame = true;
					iFakeLoadGameTest = 100;
					extern bool g_Storyboard_Starting_New_Level;
					g_Storyboard_Starting_New_Level = true; //PE: Start a fresh game.
				}
				if (iret == STORYBOARD_ACTIONS_GOTOSCREEN)
				{
					if (strlen(t.game.pSwitchToPage) == 0)
					{
						strcpy(lastpage, startpage);
						extern cstr g_Storyboard_LoaderScreen_Name;
						strcpy(startpage, g_Storyboard_LoaderScreen_Name.Get());
					}
					else
					{
						strcpy(lastpage, startpage);
						strcpy(startpage, t.game.pSwitchToPage);
					}
				}
			}
		}
		if (bBlackOut)
		{
			ImGuiViewport* mainviewport = ImGui::GetMainViewport();
			if (mainviewport)
			{
				ImDrawList* drawlist = ImGui::GetForegroundDrawList(mainviewport);
				if (drawlist)
				{
					ImVec4 monitor_col = ImVec4(0.0, 0.0, 0.0, 1.0 - t.postprocessings.fadeinvalue_f); //Fade in.
					drawlist->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(40.0f, 40.0f), ImGui::GetColorU32(monitor_col));
				}
			}
		}

	}
	else
	{
		pref.iLastInStoryboard = false;
	}
}


extern bool bTriggerTerrainSaveAsWindow;
int iTerrainSaveAsProcess = 0;

int save_level_as( void )
{
	int iRet = 0;
	static bool bGotAThumb = false;
	static int iSetKeyboardFocusHere = 10;

	// LB: allow levels to be saved, even if not currently connected to game project (for HUB skippers)
	//if (iNewLevelNode < 0) return(0);

	if (bTriggerTerrainSaveAsWindow)
	{
		static char NewLevelName[256] = "\0";
		static char NewLevelError[256] = "\0";

		if (iTerrainSaveAsProcess == 0)
		{
			bGotAThumb = false;
			//Grab any thumbs created.
			if (ImageExist(STORYBOARD_THUMBS + 402)) DeleteImage(STORYBOARD_THUMBS + 402);

			GG_SetWritablesToRoot(true);
			if (FileExist("thumbbank\\lastnewlevel.jpg"))
			{
				image_setlegacyimageloading(true);
				LoadImageSize("thumbbank\\lastnewlevel.jpg", STORYBOARD_THUMBS + 402, 512, 288);
				image_setlegacyimageloading(false);
				if (ImageExist(STORYBOARD_THUMBS + 402))
					bGotAThumb = true;
			}
			GG_SetWritablesToRoot(false);
			strcpy(NewLevelName, "");
			strcpy(NewLevelError, "");
			iSetKeyboardFocusHere = 10;
			iTerrainSaveAsProcess++;
		}
		
		if (iTerrainSaveAsProcess == 1)
		{
			static int popwinheight = 0;
			if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
			{
				ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
			}

			//Ask to save new level.
			ImGui::OpenPopup("Save New Level##Storyboard");

			ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
			bool bSaveNewLevelWindow = true;

			ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings;
			if (bDigAHoleToHWND) window_flags |= ImGuiWindowFlags_ForceRender;

			if (ImGui::BeginPopupModal("Save New Level##Storyboard", &bSaveNewLevelWindow, window_flags))
			{
				ImGuiWindow* bwindow = ImGui::GetCurrentWindow(); // ImGui::FindWindowByName("Save New Level##Storyboard");
				if (bDigAHoleToHWND)
				{
					if (bwindow)
					{
						bwindow->DrawList->AddCallback((ImDrawCallback)10, NULL); //force render.
						ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
						style_winback.w = 1.0f;
						ImGui::GetCurrentWindow()->DrawList->AddRectFilled(ImGui::GetWindowPos(), ImGui::GetWindowPos() + ImGui::GetWindowSize(), ImGui::GetColorU32(style_winback), 0.0f, ImDrawCornerFlags_None);
					}
				}
				popwinheight = ImGui::GetWindowSize().y;
				ImGui::Indent(10);
				ImGui::Text("");
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Save New Level As");
				ImGui::Separator();
				if (bGotAThumb && ImageExist(STORYBOARD_THUMBS + 402))
				{
					ImGui::ImgBtn(STORYBOARD_THUMBS + 402, ImVec2(512, 288), ImColor(0, 0, 0, 0), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), ImColor(255, 255, 255, 255), 0, 0, 0, 0, false, false, false);
					ImGui::Separator();
				}
				else
				{
					ImGui::Dummy(ImVec2(512, 10));
				}
				ImGui::SetWindowFontScale(1.0);
				ImGui::TextWrapped("You have just created a new level, to save this level please give it a name and click 'save'");
				ImGui::Text("");
				if (strlen(NewLevelError) > 0)
				{
					ImGui::Text(NewLevelError);
					ImGui::Text("");
				}
				ImGui::Text("Level Name");
				ImGui::PushItemWidth(-10);
				if (iSetKeyboardFocusHere > 0)
				{
					iSetKeyboardFocusHere--;
					ImGui::SetKeyboardFocusHere();
				}
				bool bTriggerReturnSave = false;
				if (ImGui::InputText("##NewLevelNameStoryboard", NewLevelName, 250, ImGuiInputTextFlags_EnterReturnsTrue)) //ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
				{
					bTriggerReturnSave = true;
				}
				ImGui::PopItemWidth();

				ImGui::Text("");

				ImGui::SetWindowFontScale(1.4);
				if (ImGui::StyleButton("Save Level", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f)) || bTriggerReturnSave )
				{
					if (strlen(NewLevelName) > 0)
					{
						char tmp[MAX_PATH];
						strcpy(tmp, g.mysystem.mapbankAbs_s.Get());
						//Relative.
						char *find = (char *)pestrcasestr(tmp, "mapbank\\");
						if (find && find != &tmp[0]) strcpy(&tmp[0], find);
						strcat(tmp, NewLevelName);

						t.returnstring_s = tmp;

						if (cstr(Lower(Right(t.returnstring_s.Get(), 4))) != ".fpm")  t.returnstring_s = t.returnstring_s + ".fpm";
						g.projectfilename_s = t.returnstring_s;

						bool oksave = true;
						if (FileExist(g.projectfilename_s.Get())) {
							oksave = overWriteFileBox(g.projectfilename_s.Get());
						}
						if (oksave)
						{
							//Add newly saved fpm level to recent list.
							int firstempty = -1;
							int i = 0;
							for (; i < REMEMBERLASTFILES; i++) {
								if (firstempty == -1 && strlen(pref.last_open_files[i]) <= 0)
									firstempty = i;
								if (strlen(pref.last_open_files[i]) > 0 && pestrcasestr(g.projectfilename_s.Get(), pref.last_open_files[i])) { //already there
									break;
								}
							}
							if (i >= REMEMBERLASTFILES) {
								if (firstempty == -1) {
									//No empty slots , rotate.
									for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
										strcpy(pref.last_open_files[ii], pref.last_open_files[ii + 1]);
									}
									strcpy(pref.last_open_files[REMEMBERLASTFILES - 1], g.projectfilename_s.Get());
								}
								else
									strcpy(pref.last_open_files[firstempty], g.projectfilename_s.Get());
							}

							iLaunchAfterSync = 503; //Do the actualy save here.
							iSkibFramesBeforeLaunch = 3;
							iLaunchAfterSyncAction = 11;
							strcpy(cTriggerMessage, "Saving Level ...");
							bTriggerMessage = true;

							if (iNewLevelNode >= 0)
							{
								strcpy(Storyboard.Nodes[iNewLevelNode].title, NewLevelName);
								strcpy(Storyboard.Nodes[iNewLevelNode].level_name, g.projectfilename_s.Get());
								if (bGotAThumb)
								{
									CreateBackBufferCacheNameEx(Storyboard.Nodes[iNewLevelNode].level_name, 512, 288, true);
									SaveImage(BackBufferCacheName.Get(), STORYBOARD_THUMBS + 402);
									if (FileExist(BackBufferCacheName.Get()))
									{
										if (CopyToProjectFolder(BackBufferCacheName.Get()))
										{
											//PE: Use relative projectbank filename.
											if (FileExist(ProjectCacheName.Get()))
												BackBufferCacheName = ProjectCacheName;
										}

										//Load to correct id.
										SetMipmapNum(1);
										image_setlegacyimageloading(true);
										LoadImageSize(BackBufferCacheName.Get(), Storyboard.Nodes[iNewLevelNode].thumb_id, 512, 288);
										image_setlegacyimageloading(false);
										SetMipmapNum(-1);
										strcpy(Storyboard.Nodes[iNewLevelNode].thumb, BackBufferCacheName.Get());
									}
								}
							}

							bTriggerTerrainSaveAsWindow = false; //Close down window.
							iRet = 2;
						}
						else
						{
							//Cancel just ignore.
						}
					}
					else
					{
						strcpy(NewLevelError, "Error: Please give your level a name before save.");
					}
				}
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bTriggerTerrainSaveAsWindow = false; //Close down window.
					iRet = 1;
				}

				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");

				bImGuiGotFocus = true;
				ImGui::Indent(-10);
				ImGui::EndPopup();

				if (bDigAHoleToHWND && bwindow)
				{
					bwindow->DrawList->AddCallback((ImDrawCallback)11, NULL); //disable force render.
				}
			}
		}
	}
	else
	{
		iTerrainSaveAsProcess = 0;
	}
	return(iRet);
}

void switch_to_remote_project(LPSTR ProjectAsName)
{
	// store writables folder
	char pStoreWriteable[MAX_PATH];
	strcpy(pStoreWriteable, pref.cCustomWriteFolder);

	// before move to new project folder, create projectbank marker so can load this remove located project
	char pRemoteProject[MAX_PATH];
	strcpy(pRemoteProject, "projectbank\\");
	strcat(pRemoteProject, ProjectAsName);
	strcat(pRemoteProject, "\\remoteproject.txt");
	GG_GetRealPath(pRemoteProject, 1);

	// create new project folder area
	strcpy(pref.cCustomWriteFolder, Storyboard.customprojectfolder);
	if (pref.cCustomWriteFolder[strlen(pref.cCustomWriteFolder) - 1] != '\\') strcat(pref.cCustomWriteFolder, "\\");
	strcat(pref.cCustomWriteFolder, ProjectAsName);
	if (pref.cCustomWriteFolder[strlen(pref.cCustomWriteFolder) - 1] != '\\') strcat(pref.cCustomWriteFolder, "\\");
	SetUpdaterWritePathFile(pref.cCustomWriteFolder);
	FileRedirectChangeWritableArea("");

	// create remote project marker
	OpenToWrite(1, pRemoteProject);
	WriteString(1, Storyboard.customprojectfolder);
	CloseFile(1);

	// restore writables folder
	strcpy(pref.cCustomWriteFolder, pStoreWriteable);
}

void switch_to_regular_projects(void)
{
	// generate app folder using exe name
	HMODULE hModule = GetModuleHandle(NULL);
	char szModule[MAX_PATH] = "";
	char szDrive[10] = "";
	char szDir[MAX_PATH] = "";
	char szEXE[MAX_PATH] = "";
	GetModuleFileNameA(hModule, szModule, MAX_PATH);
	_splitpath_s(szModule, szDrive, 10, szDir, MAX_PATH, szEXE, MAX_PATH, NULL, 0);
	FileRedirectRestoreWritableArea(szEXE);
	FileRedirectChangeWritableArea(szEXE);
}

int save_create_storyboard_project(void)
{
	int iRet = 0;
	static int iSetKeyboardFocusHere = 10;
	if (bTriggerSaveAs)
	{
		//Ask to save as.

		ImGui::OpenPopup("Save As#Storyboard");
		ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Once);
		static int popwinheight = 0;
		if (popwinheight > 800 || iSkibFramesBeforeLaunch > 0)
		{
			ImGui::SetNextWindowSize(ImVec2(0, 532), ImGuiCond_Always);
		}
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		bool bSaveAsWindow = true;
		if (ImGui::BeginPopupModal("Save As#Storyboard", &bSaveAsWindow, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
		{
			popwinheight = ImGui::GetWindowSize().y;

			if (bTriggerSaveAsAfterNewLevel)
			{
				ImVec2 vCurPos = ImGui::GetCursorPos();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(3.0f, 8.0f));
				ImGui::SetItemAllowOverlap();
				ImVec2 vIconSize = { (float)ImGui::GetFontSize()*3.5f, (float)ImGui::GetFontSize()*3.5f };
				if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
				{
					bTriggerSaveAs = false;
					bTriggerSaveAsAfterNewLevel = false;
					iRet = 2;

				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Close");
				ImGui::SetCursorPos(vCurPos);
			}

			ImGui::Indent(10);
			ImGui::Text("");

			ImGui::SetWindowFontScale(1.6);
			if (bTriggerSaveAsAfterNewLevel)
			{
				ImGui::TextCenter("Create a New Game Project");
				ImGui::SetWindowFontScale(1.0);
				ImGui::Text("");
			}
			else
			{
				ImGui::TextCenter("Save Game Project As");
			}
			ImGui::Separator();

			if (bTriggerSaveAsAfterNewLevel)
				ImGui::Dummy(ImVec2(580, 1));
			else
				ImGui::Dummy(ImVec2(510, 1));
			ImGui::SetWindowFontScale(1.2);
			ImGui::Text("");
			if (bTriggerSaveAsAfterNewLevel)
			{
				ImGui::TextCenter("All new games need a name. This is so they can be saved to the");
				ImGui::TextCenter("hard drive and identified when edited in the future.");
				ImGui::Text("");
				ImGui::TextCenter("If you have a name in mind that's great! Just enter it below.");
				ImGui::Text("");
				ImGui::TextCenter("Make sure you choose a good name for your project, you will");
				ImGui::TextCenter("not be able to change it later on.");
			}
			else
			{
				ImGui::Text("To save your game project, please give your project a name and click 'save'");
				ImGui::Text("");
				ImGui::TextWrapped("NOTE: This name will also be used as your standalone game name.");
			}
			ImGui::Text("");


			if (strlen(SaveProjectAsError) > 0)
			{
				ImGui::Text(SaveProjectAsError);
				ImGui::Text("");
			}
			if (bTriggerSaveAsAfterNewLevel)
			{
				ImGui::SetWindowFontScale(1.4);
				ImGui::TextCenter("Enter Your Game Name Here");
				ImGui::SetWindowFontScale(1.2);
			}
			else
			{
				ImGui::Text("Game Project Name");
			}
			ImGui::PushItemWidth(-10);

			bool bClicked = false;
			bool bForceClicked = false;

			if (iSetKeyboardFocusHere > 0)
			{
				iSetKeyboardFocusHere--;
				ImGui::SetKeyboardFocusHere();
			}
			if (ImGui::InputText("##SaveAsNameStoryboard", SaveProjectAsName, 250, ImGuiInputTextFlags_None | ImGuiInputTextFlags_EnterReturnsTrue))//ImGuiInputTextFlags_None ImGuiInputTextFlags_ReadOnly
			{
				//Clean name.
				std::string sCleanName = SaveProjectAsName;
				replaceAll(sCleanName, """", "");
				replaceAll(sCleanName, "\\", "");
				replaceAll(sCleanName, "/", "");
				replaceAll(sCleanName, "^", "");
				replaceAll(sCleanName, "?", "");
				replaceAll(sCleanName, "@", "");
				replaceAll(sCleanName, "\t", "");
				replaceAll(sCleanName, ":", "");
				strcpy(SaveProjectAsName, sCleanName.c_str());
				if(bTriggerSaveAsAfterNewLevel) bForceClicked = true; // Enter now just create the game.
			}
			ImGui::PopItemWidth();

			ImGui::Text("");
			ImGui::SetWindowFontScale(1.4);

			#ifdef NEWPROJSYSWORKINPROGRESS
			// New project Systemn Setting
			ImGui::TextCenter("Optional Project Folder");
			ImGui::SetWindowFontScale(1.2);
			ImGui::TextCenter("By default all projects are stored in the projectbank area.");
			ImGui::TextCenter("You have the option to create your game project folder at any location");
			ImGui::TextCenter("and ensure that all media used in your game is copied to this separate");
			ImGui::TextCenter("location, allowing your project to keep all necessary files in one place");
			float path_gadget_size = ImGui::GetFontSize() * 2.0;
			ImGui::PushItemWidth(-10 - path_gadget_size);
			static bool bSeparateProjectFolder = false;
			if (strlen(Storyboard.customprojectfolder) == 0) bSeparateProjectFolder = false;
			if (strlen(Storyboard.customprojectfolder) > 0) bSeparateProjectFolder = true;
			if (ImGui::Checkbox("Separate project folder", &bSeparateProjectFolder))
			{
				if(bSeparateProjectFolder==false)
				{
					strcpy(Storyboard.customprojectfolder, "");
				}
				else
				{
					if (strlen(Storyboard.customprojectfolder) == 0)
					{
						strcpy(Storyboard.customprojectfolder, "C:\\Dropbox\\");
					}
				}
			}
			if (ImGui::IsItemHovered()) ImGui::SetTooltip("Choose whether the game project should be a completely separate project area");
			if (bSeparateProjectFolder)
			{
				ImGui::InputText("##InputCustomNewProjectFolder", &Storyboard.customprojectfolder[0], 250, ImGuiInputTextFlags_ReadOnly);
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Location of separate project folder");
				if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
				ImGui::SameLine();
				ImGui::PushItemWidth(path_gadget_size);
				if (ImGui::StyleButton("...##pathCustomNewProjectFolder"))
				{
					cStr tOldDir = GetDir();
					char* cFileSelected;
					cstr fulldir = pref.cCustomWriteFolder;
					cFileSelected = (char*)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
					SetDir(tOldDir.Get());
					if (cFileSelected && strlen(cFileSelected) > 0)
					{
						strcpy(Storyboard.customprojectfolder, cFileSelected);
						if (Storyboard.customprojectfolder[strlen(Storyboard.customprojectfolder) - 1] != '\\') strcat(Storyboard.customprojectfolder, "\\");
					}
				}
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify location for separate project folder");
				ImGui::PopItemWidth();
			}
			ImGui::PopItemWidth();
			ImGui::Text("");
			#endif
#
			// Create Project Button
			if (bTriggerSaveAsAfterNewLevel)
			{
				bClicked = ImGui::StyleButton("Create Game Project", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f));
			}
			else
				bClicked = ImGui::StyleButton("Save As", ImVec2(ImGui::GetContentRegionAvail().x*0.5 - 20.0f, 0.0f));

			if (bClicked || bForceClicked)
			{
				// and in case this was a remote project, restore to writables regular
				extern void switch_to_regular_projects(void);
				switch_to_regular_projects();

				// if custom project folder, new wriables
				if (strlen(Storyboard.customprojectfolder) > 0)
				{
					GG_SetWritablesToRoot(true);
					switch_to_remote_project(SaveProjectAsName);
					GG_SetWritablesToRoot(false);
				}

				//PE: Trim
				std::string sCleanName = SaveProjectAsName;
				sCleanName.erase(sCleanName.find_last_not_of(" \t") + 1); //PE: No spaces tab at end.
				strcpy(SaveProjectAsName, sCleanName.c_str());

				if (strlen(SaveProjectAsName) > 0)
				{
					char destination[MAX_PATH];
					strcpy(destination, "projectbank\\");
					strcat(destination, SaveProjectAsName);
					GG_GetRealPath(destination, 1);
					int bOkSave = true;
					if (PathExist(destination) == 1)
					{
						int iAction = askBoxCancel("Project already exists, do you want to overwrite ?", "Confirmation"); //1==Yes 2=Cancel 0=No
						if (iAction == 1)
						{
							//backup old folder.
							int i_loop = 1;
							char backup[MAX_PATH];
							sprintf(backup, "%s_backup_%d", destination, i_loop++);
							while (MoveFileA(destination, backup) == 0)
								sprintf(backup, "%s_backup_%d", destination, i_loop++);
						}
						else
						{
							//Cancel.
							bOkSave = false;
						}
					}
					if (bOkSave)
					{
						// Create the new project folder, and place project.dat inside it
						MakeDirectory(destination);
						strcat(destination, "\\project.dat");
						strcpy(Storyboard.gamename, SaveProjectAsName);
						Storyboard.project_readonly = 0;
						save_storyboard(Storyboard.gamename, false);
						bTriggerSaveAs = false;
						bTriggerSaveAsAfterNewLevel = false;
						iRet = 1;

						// to allow completely isolated files for per-project customization
						// copy files that ALL standalone games will load by default
						if (strlen(Storyboard.customprojectfolder) > 0)
						{
							extern bool g_bMakingAStandaloneUsingFileCollectionArray;
							if (g_bMakingAStandaloneUsingFileCollectionArray == false)
							{
								// clear file collection
								g.filecollectionmax = 0;
								Undim (t.filecollection_s);
								Dim (t.filecollection_s, 500);

								// all the files/folders that are needed by the standalone regardless
								addfoldertocollection ("audiobank\\materials");
								addfoldertocollection ("audiobank\\materials\\dirt");
								addfoldertocollection ("audiobank\\materials\\grass");
								addfoldertocollection ("audiobank\\materials\\gravel");
								addfoldertocollection ("audiobank\\materials\\metal");
								addfoldertocollection ("audiobank\\materials\\puddle");
								addfoldertocollection ("audiobank\\materials\\sand");
								addfoldertocollection ("audiobank\\materials\\snow");
								addfoldertocollection ("audiobank\\materials\\underwater");
								addfoldertocollection ("audiobank\\materials\\wood");
								addtocollection ("audiobank\\misc\\ammo.wav");
								addtocollection ("audiobank\\misc\\explode.wav");
								addtocollection ("audiobank\\misc\\silence.wav");
								addtocollection ("audiobank\\misc\\bullet_flyby_01.wav");
								addtocollection ("audiobank\\misc\\bullet_flyby_02.wav");
								addtocollection ("audiobank\\misc\\bullet_flyby_03.wav");
								addtocollection ("audiobank\\misc\\bullet_flyby_04.wav");
								addfoldertocollection ("charactercreatorplus\\skins");
								addfoldertocollection ("databank");
								addtocollection ("editors\\keymap\\default.ini");
								addfoldertocollection ("editors\\lut");
								addfoldertocollection ("editors\\templates\\backdrops");
								addfoldertocollection ("editors\\templates\\buttons");
								addfoldertocollection ("editors\\templates\\fonts");
								addfoldertocollection ("editors\\templates\\screeneditor");
								addtocollection ("editors\\uiv3\\loadingsplash.jpg");
								addtocollection ("editors\\uiv3\\roboto-medium.ttf");
								addfoldertocollection ("effectbank\\common");
								addfoldertocollection ("effectbank\\explosion");
								addfoldertocollection ("effectbank\\particles");
								addfoldertocollection ("effectbank\\particles\\weather");
								addfoldertocollection ("languagebank\\english\\artwork\\watermark");
								addfoldertocollection ("languagebank\\english\\textfiles");
								addfoldertocollection ("languagebank\\neutral\\gamecore\\huds\\ammohealth");
								//addfoldertocollection ("languagebank\\neutral\\gamecore\\huds\\sliders");
								addfoldertocollection ("languagebank\\neutral\\gamecore\\huds\\panels"); // used in LUA command
								addfoldertocollection ("fontbank");
								addfoldertocollection ("gamecore\\bulletholes");
								addfoldertocollection ("gamecore\\decals\\splat");
								addfoldertocollection ("gamecore\\decals\\bloodsplat");
								addfoldertocollection ("gamecore\\decals\\dust");
								addfoldertocollection ("gamecore\\decals\\impact");
								addfoldertocollection ("gamecore\\decals\\gunsmoke");
								addfoldertocollection ("gamecore\\decals\\smoke1");
								addfoldertocollection ("gamecore\\decals\\sparks");
								addfoldertocollection ("gamecore\\decals\\muzzleflash4");
								addfoldertocollection ("gamecore\\decals\\splash_droplets");
								addfoldertocollection ("gamecore\\decals\\splash_foam");
								addfoldertocollection ("gamecore\\decals\\splash_large");
								addfoldertocollection ("gamecore\\decals\\splash_misty");
								addfoldertocollection ("gamecore\\decals\\splash_ripple");
								addfoldertocollection ("gamecore\\decals\\splash_small");
								addfoldertocollection ("gamecore\\decals\\splinters");
								addfoldertocollection ("gamecore\\vrcontroller");
								addfoldertocollection ("gamecore\\vrcontroller\\oculus");
								addfoldertocollection ("gamecore\\muzzleflash");
								addfoldertocollection ("gamecore\\projectiletypes");
								addfoldertocollection ("gamecore\\projectiletypes\\common\\explode");
								addfoldertocollection ("gamecore\\projectiletypes\\enhanced\\m67");
								addfoldertocollection ("gamecore\\vrcontroller");
								addfoldertocollection ("grassbank");
								addfoldertocollection ("imagebank\\hud");
								addfoldertocollection ("imagebank\\hud library\\max");
								addfoldertocollection ("lensflares");
								addallinfoldertocollection("particlesbank", "particlesbank"); // all particles so do not miss any for standalone (only 4MB for defaults)
								addfoldertocollection ("terraintextures");
								addfoldertocollection ("terraintextures\\mat1");
								addfoldertocollection ("terraintextures\\mat2");
								addfoldertocollection ("terraintextures\\mat3");
								addfoldertocollection ("terraintextures\\mat4");
								addfoldertocollection ("terraintextures\\mat5");
								addfoldertocollection ("terraintextures\\mat6");
								addfoldertocollection ("terraintextures\\mat7");
								addfoldertocollection ("terraintextures\\mat8");
								addfoldertocollection ("terraintextures\\mat9");
								addfoldertocollection ("terraintextures\\mat10");
								addfoldertocollection ("terraintextures\\mat11");
								addfoldertocollection ("terraintextures\\mat12");
								addfoldertocollection ("terraintextures\\mat13");
								addfoldertocollection ("terraintextures\\mat14");
								addfoldertocollection ("terraintextures\\mat15");
								addfoldertocollection ("terraintextures\\mat16");
								addfoldertocollection ("terraintextures\\mat17");
								addfoldertocollection ("terraintextures\\mat18");
								addfoldertocollection ("terraintextures\\mat19");
								addfoldertocollection ("terraintextures\\mat20");
								addfoldertocollection ("terraintextures\\mat21");
								addfoldertocollection ("terraintextures\\mat22");
								addfoldertocollection ("terraintextures\\mat23");
								addfoldertocollection ("terraintextures\\mat24");
								addfoldertocollection ("terraintextures\\mat25");
								addfoldertocollection ("terraintextures\\mat26");
								addfoldertocollection ("terraintextures\\mat27");
								addfoldertocollection ("terraintextures\\mat28");
								addfoldertocollection ("terraintextures\\mat29");
								addfoldertocollection ("terraintextures\\mat30");
								addfoldertocollection ("terraintextures\\mat31");
								addfoldertocollection ("terraintextures\\mat32");
								addtocollection ("titlesbank\\default\\cursor.png");
								addtocollection ("titlesbank\\default\\cursor-33.png");
								addtocollection ("titlesbank\\default\\cursor-big.png");
								addfoldertocollection ("treebank");
								addfoldertocollection ("treebank\\billboards");
								addfoldertocollection ("treebank\\textures");

								// finally copy all indicated files to remote project area for initial file set
								extern void mapfile_copyallfilecollectiontopreferredprojectfolder (void);
								mapfile_copyallfilecollectiontopreferredprojectfolder();
							}
						}
					}
				}
				else
				{
					strcpy(SaveProjectAsError, "Error: Please give your game project a name before saving.");
				}
			}
			if (!bTriggerSaveAsAfterNewLevel)
			{
				ImGui::SameLine();
				if (ImGui::StyleButton("Cancel", ImVec2(ImGui::GetContentRegionAvail().x - 10.0f, 0.0f)))
				{
					//Cancel.
					bTriggerSaveAs = false;
					bTriggerSaveAsAfterNewLevel = false;
					iRet = 2;
				}
			}
			ImGui::SetWindowFontScale(1.0);
			ImGui::Text("");

			bImGuiGotFocus = true;
			ImGui::Indent(-10);
			ImGui::EndPopup();
		}
	}
	else
	{
		iSetKeyboardFocusHere = 10;
	}
	return iRet;
}


//FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm);
//if( g_Storyboard_First_Level_Node == -1) // Not Found.
//g_Storyboard_Current_Level MUST be set by load_fpm , so "load game" will also work.
//g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
//strcpy(g_Storyboard_Current_fpm,g_Storyboard_First_fpm);
//Win
// int a = Find NextLevel(g_Storyboard_Current_Level, g_Storyboard_Current_fpm)
//if( a == 0 ) // No more levels found, go to won.lua
// if( a == 1 ) //Goto a new level.
// if( a == 2 ) //Goto a new lua screen.
//Lost
// int a = Find NextLevel(g_Storyboard_Current_Level, g_Storyboard_Current_lua , 1)
// jump to g_Storyboard_Current_lua.


int FindOutputScreenNode(int iNode, int index)
{
	//Storyboard.Nodes[iNextNode].lua_name
	if (iNode >= 0)
	{
		int iOutPutLinkTo = index;
		if (Storyboard.Nodes[iNode].widget_type[index] == STORYBOARD_WIDGET_BUTTON)
			iOutPutLinkTo = get_output_linkindex(iNode, index);

		//Find connected to:
		int iLinkTo = Storyboard.Nodes[iNode].output_linkto[iOutPutLinkTo];
			//Find input.
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					if (iLinkTo > 0 && iLinkTo == Storyboard.Nodes[i].input_id[l])
					{
						return(i);
					}
				}
			}
		}
	}
	return(-1);
}

int FindNextLevel(int &iNextLevelNode, char *level_name, int action)
{
	// action: 0-No more levels found, go to won.lua  1-Goto a new level.  2-/Goto a new lua screen.

	int iNextNode = -1;
	int iNextWinScreenNode = -1;
	int iNextLostScreenNode = -1;

	if (iNextLevelNode >= 0)
	{
		//Find connected to:
		int iLinkToWin = Storyboard.Nodes[iNextLevelNode].output_linkto[0]; //2=Next Won screen.
		int iLinkToLost = Storyboard.Nodes[iNextLevelNode].output_linkto[1]; //2=Next Lost screen.
		int iLinkTo = Storyboard.Nodes[iNextLevelNode].output_linkto[2]; //2=Next level.

		//PE: If Storyboard.Nodes[iNextLevelNode] is a loading screen , take output from there.
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					if (iLinkTo > 0 && iLinkTo == Storyboard.Nodes[i].input_id[l])
					{
						if (pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
						{
							iLinkTo = Storyboard.Nodes[i].output_linkto[0];
						}
					}
				}
			}
		}

		//Find input.
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					if (iLinkTo > 0 && iLinkTo == Storyboard.Nodes[i].input_id[l])
					{
						iNextNode = i;
					}
					if (iLinkToWin > 0 && iLinkToWin == Storyboard.Nodes[i].input_id[l])
					{
						iNextWinScreenNode = i;
					}
					if (iLinkToLost > 0 && iLinkToLost == Storyboard.Nodes[i].input_id[l])
					{
						iNextLostScreenNode = i;
					}
				}
			}
		}
	}
	if (action == 1)
	{
		//Get lost screen.
		if (iNextLostScreenNode > 0)
		{
			//Found it.
			iNextLevelNode = iNextLostScreenNode;
			strcpy(level_name, Storyboard.Nodes[iNextLostScreenNode].lua_name);
			return(2); //Goto next lua script.
		}
		//Not connected for lose.lua
		strcpy(level_name, "lose.lua");
		return(2); //Goto next lua script.
	}

	if (iNextNode > 0)
	{
		//Found next level.
		if (strlen(Storyboard.Nodes[iNextNode].level_name) > 0)
		{
			iNextLevelNode = iNextNode;
			strcpy(level_name, Storyboard.Nodes[iNextNode].level_name);
			return(1); //Goto next level.
		}
	}

	//Not linking to a level, check if we have a linking won screen.
	if (iNextWinScreenNode > 0)
	{
		if (strlen(Storyboard.Nodes[iNextWinScreenNode].lua_name) > 0)
		{
			iNextLevelNode = iNextWinScreenNode;
			strcpy(level_name, Storyboard.Nodes[iNextWinScreenNode].lua_name);
			if (stricmp(level_name, "win.lua") == NULL)
			{
				return(3); //Goto final game won lua script.
			}
			else
			{
				return(2); //Goto next won lua script.
			}
		}
	}

	//Not linking to anything, force a win.lua
	strcpy(level_name, "win.lua");
	return(2); //Goto next lua script.
}

void FindFirstSplash(char *splash_name)
{
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
			{
				if (strlen(Storyboard.Nodes[i].thumb) > 0)
				{
					// replace stock splash with custom one specified by storybaord game project
					strcpy(splash_name, Storyboard.Nodes[i].thumb);

					/* LB: reason was simpler, the splash image file was not copied over - and the public repo code does not contain the encryption code so could not be tested/verified. Sorted now :)
					//PE: Need decrypt support here.
					strcpy(splash_name, Storyboard.Nodes[i].thumb);
					if (!pestrcasestr(splash_name, "Files\\"))
					{
						int GG_GetRealPath(char* fullPath, int create);
						GG_GetRealPath(splash_name, 0);
					}
					if (!GG_FileExists(splash_name))
					{
						//Try 
						void SetCanUse_e_(int flag);
						SetCanUse_e_(1);
						char VirtualFilename[MAX_PATH];
						strcpy(VirtualFilename, splash_name);
						bool CheckForWorkshopFile(LPSTR VirtualFilename);
						CheckForWorkshopFile(VirtualFilename);
						// Decrypt and use media
						g_pGlob->Decrypt(VirtualFilename);
						if (FileExist(VirtualFilename))
						{
							strcpy(splash_name, VirtualFilename);
						}

						//PE: We cant do this, need another way to later clean up decrypt area.
						//PE: Wait until the actual g_pGlob->Decrypt works so we can see how it works.
						//g_pGlob->Encrypt(VirtualFilename);
					}
					*/
				}
			}
		}
	}
}

int FindLuaScreenNode(char *name)
{
	if (g.tabmodehidehuds > 0 && strnicmp(name, "hud", 3) == 0) //stricmp(name, "hud.lua") == 0)
	{
		// Do not render in-game HUD when HideHuds() has been called
		return -1;
	}
	if (strlen(Storyboard.gamename) <= 0) return(-1);

	// node id or name
	if (strncmp (name, ":node:", 6) == NULL)
	{
		//Find by node id passed in via string
		int iNode = atoi(&name[6]);
		if (iNode >= 0 && iNode < STORYBOARD_MAXNODES)
		{
			if (Storyboard.Nodes[iNode].used)
			{
				return iNode;
			}
		}
	}
	else
	{
		// regular name search (prone to finding a duplicate if old corrupt project nodes)
		std::string lua_name = name;
		replaceAll(lua_name, ".lua", "");
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				std::string check_lua_name = Storyboard.Nodes[i].lua_name;
				replaceAll(check_lua_name, ".lua", "");
				if (stricmp(check_lua_name.c_str(), lua_name.c_str()) == NULL)
				{
					return i;
				}
			}
		}
	}
	return -1;
}

int FindLuaScreenTitleNode(char* name)
{
	if (strlen(Storyboard.gamename) <= 0) return(-1);
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			std::string check_lua_title = Storyboard.Nodes[i].title;
			if (stricmp(check_lua_title.c_str(), name) == NULL)
			{
				return i;
			}
		}
	}
	return -1;
}

int FindLuaScreenTitleNodeByKey(char* key)
{
	if (strlen(Storyboard.gamename) <= 0) return(-1);
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			char scanCodeName[128];
			extern unsigned int GetScancodeName(unsigned int scancode, char* buffer, unsigned int bufferLength);
			int result = GetScancodeName(Storyboard.Nodes[i].toggleKey, scanCodeName, 128);
			if (key[0] == scanCodeName[0])
			{
				return i;
			}
		}
	}
	return -1;
}

void FindLoadingScreen( void )
{
	strcpy(g_Storyboard_Current_Loading_Page, "loading.lua");

	if (g_Storyboard_Current_Level <= 0) return;
	int i = g_Storyboard_Current_Level;

	if (Storyboard.Nodes[i].used)
	{
		int iLinkTo = Storyboard.Nodes[i].input_id[0];

		//Find output.
		for (int i = 0; i < STORYBOARD_MAXNODES; i++)
		{
			if (Storyboard.Nodes[i].used)
			{
				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					if (iLinkTo == Storyboard.Nodes[i].output_linkto[l])
					{
						strcpy(g_Storyboard_Current_Loading_Page, Storyboard.Nodes[i].lua_name);
						return;
					}
				}
			}
		}

	}
	return;
}

void FindFirstLevel(int &iFirstLevelNode, char *level_name, bool bFailIfNoLink)
{
	//Get loading screen connected to:
	iFirstLevelNode = -1;
	int iLoadingScreenNode = -1;
	int iLevelNode = -1;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (stricmp(Storyboard.Nodes[i].lua_name, "loading.lua") == 0)
			{
				iLoadingScreenNode = i;
			}
		}
	}
	if (iLoadingScreenNode >= 0)
	{
		//Find connected to:
		int iLinkTo = Storyboard.Nodes[iLoadingScreenNode].output_linkto[0];
		if (iLinkTo > 0)
		{
			//Find input.
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used)
				{
					for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
					{
						if (iLinkTo == Storyboard.Nodes[i].input_id[l])
						{
							iLevelNode = i;
							break;
						}
					}
				}
				if (iLevelNode > 0) break;
			}
		}
	}

	if (iLevelNode > 0)
	{
		//Found first level.
		if (strlen(Storyboard.Nodes[iLevelNode].level_name) > 0)
		{
			iFirstLevelNode = iLevelNode;
			strcpy(level_name, Storyboard.Nodes[iFirstLevelNode].level_name);
			return;
		}
		else
		{
			// may have connected loading screen to another screen, that in turn connected to a level, and so on, so find that
			int iNextLinkTo = Storyboard.Nodes[iLevelNode].output_linkto[0];
			iLevelNode = -1;
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used)
				{
					for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
					{
						if (iNextLinkTo == Storyboard.Nodes[i].input_id[l])
						{
							iLevelNode = i;
							break;
						}
					}
				}
				if (iLevelNode > 0) break;
			}
			if (iLevelNode > 0)
			{
				if (strlen(Storyboard.Nodes[iLevelNode].level_name) > 0)
				{
					iFirstLevelNode = iLevelNode;
					strcpy(level_name, Storyboard.Nodes[iFirstLevelNode].level_name);
					return;
				}
			}
		}
	}

	if (bFailIfNoLink)
	{
		return;
	}

	//No level connected to the loading.lua page.
	//Just use the level with the internal name "Level 1"

	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
			{
				if (strcmp("Level 1", Storyboard.Nodes[i].levelnumber) == 0)
				{
					if (strlen(Storyboard.Nodes[i].level_name) > 0)
					{
						iFirstLevelNode = i;
						strcpy(level_name, Storyboard.Nodes[i].level_name);
						return;
					}
				}
			}
		}
	}
	return;
}

bool FindFreeLevelNode( int &iNextLevel,int &levelname ,int &iFirstNodeFree)
{
	//PE: Find next level from nodes.
	iNextLevel = 0;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (Storyboard.Nodes[i].used)
		{
			if (Storyboard.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
				iNextLevel++;
		}
	}
	//Free level name.
	levelname = -1;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		char tmp[255];
		sprintf(tmp, "Level %d", i + 1);
		bool bFound = false;
		for (int a = 0; a < STORYBOARD_MAXNODES; a++)
		{
			if (Storyboard.Nodes[a].used)
			{
				if (strcmp(tmp, Storyboard.Nodes[a].levelnumber) == 0)
				{
					bFound = true;
				}
			}
		}
		if (!bFound)
		{
			levelname = i + 1;
			break;
		}
	}

	iFirstNodeFree = -1;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		if (!Storyboard.Nodes[i].used)
		{
			iFirstNodeFree = i;
			break;
		}
	}

	return true;
}

void mapNodeStyle(void)
{
	//PE: We might need to tweek this for other styes.
	//PE: These grey with transparent to get some style colors looks better.

	ImVec4* colors = ImGui::GetStyle().Colors;
	ImVec4 fade = colors[ImGuiCol_Button] * ImVec4(0.8, 0.8, 0.8, 0.75);

	GImNodes->Style.Colors[ImNodesCol_NodeBackground] = IM_COL32(128, 128, 128, 130); //ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_WindowBg]);
	GImNodes->Style.Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(128, 128, 128,200); //ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	GImNodes->Style.Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(128, 128, 128, 200); //ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	GImNodes->Style.Colors[ImNodesCol_NodeOutline] = IM_COL32(128, 128, 128, 200); //ImGui::ColorConvertFloat4ToU32(fade);

	// title bar colors match ImGui's titlebg colors
	GImNodes->Style.Colors[ImNodesCol_TitleBar] = ImGui::ColorConvertFloat4ToU32(fade);
	GImNodes->Style.Colors[ImNodesCol_TitleBarHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	GImNodes->Style.Colors[ImNodesCol_TitleBarSelected] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
//	GImNodes->Style.Colors[ImNodesCol_TitleBar] = ImGui::ColorConvertFloat4ToU32(fade);
//	GImNodes->Style.Colors[ImNodesCol_TitleBarHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_TitleBg]);
//	GImNodes->Style.Colors[ImNodesCol_TitleBarSelected] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_TitleBg]);


	GImNodes->Style.Colors[ImNodesCol_Link] = IM_COL32(180, 180, 180, 200);
	GImNodes->Style.Colors[ImNodesCol_LinkHovered] = IM_COL32(180, 180, 180, 255);
	GImNodes->Style.Colors[ImNodesCol_LinkSelected] = IM_COL32(180, 180, 180, 255);
	// pin colors match ImGui's button colors
	GImNodes->Style.Colors[ImNodesCol_Pin] = IM_COL32(180, 180, 180, 200);
	GImNodes->Style.Colors[ImNodesCol_PinHovered] = IM_COL32(180, 180, 180, 255);

	// link colors match ImGui's slider grab colors
	//GImNodes->Style.Colors[ImNodesCol_Link] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	//GImNodes->Style.Colors[ImNodesCol_LinkHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_ButtonHovered]);
	//GImNodes->Style.Colors[ImNodesCol_LinkSelected] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_ButtonHovered]);
	// pin colors match ImGui's button colors
	//GImNodes->Style.Colors[ImNodesCol_Pin] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_Button]);
	//GImNodes->Style.Colors[ImNodesCol_PinHovered] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_ButtonHovered]);

	GImNodes->Style.Colors[ImNodesCol_BoxSelector] = IM_COL32(128, 128, 128, 30);
	GImNodes->Style.Colors[ImNodesCol_BoxSelectorOutline] = ImGui::ColorConvertFloat4ToU32(colors[ImGuiCol_PlotLines]);

	GImNodes->Style.Colors[ImNodesCol_GridBackground] = IM_COL32(0, 0, 0, 0);
	GImNodes->Style.Colors[ImNodesCol_GridLine] = IM_COL32(200, 200, 200, 25);

	// minimap colors
	GImNodes->Style.Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 150);
	GImNodes->Style.Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);
	GImNodes->Style.Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);
	GImNodes->Style.Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundHovered] = IM_COL32(200, 200, 200, 255);
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundSelected] = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundHovered];
	GImNodes->Style.Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);
	GImNodes->Style.Colors[ImNodesCol_MiniMapLink] = GImNodes->Style.Colors[ImNodesCol_Link];
	GImNodes->Style.Colors[ImNodesCol_MiniMapLinkSelected] = GImNodes->Style.Colors[ImNodesCol_LinkSelected];
	GImNodes->Style.Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);
	GImNodes->Style.Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);
}

void hub_menubar(void)
{
	if (ImGui::BeginMenuBar())
	{
		ImVec2 CursorMenuStart = ImGui::GetCursorPos();
		if (ImGui::BeginMenu("File##Hub"))
		{
			if (ImGui::MenuItem("Exit to Desktop"))
			{
				int iAction = askBoxCancel("Are you sure you would like to exit to desktop?", "Confirmation"); //1==Yes 2=Cancel 0=No
				if (iAction == 1)
				{
					bStoryboardWindow = false;
					g_bCascadeQuitFlag = true;
				}
			}
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("Edit##Storyboard"))
		{
			if (ImGui::MenuItem("Settings", ""))
			{
				strcpy(cPreferencesMessage, "");
				bPreferences_Window = true;
			}
			ImGui::EndMenu();
		}
		ImGui::EndMenuBar();
	}
}

void storyboard_menubar(float area_width, float node_width, float node_height)
{
	static int iCloseDownCount = 100;
	static int iCloseDownCount2 = 100;
	static int iCloseDownCount3 = 100;

	if (ImGui::BeginMenuBar())
	{
		ImVec2 CursorMenuStart = ImGui::GetCursorPos();
		if (ImGui::BeginMenu("File##Storyboard"))
		{
			bool bIsMenuHovered = false;
			if (bPreferences_Window == false)
			{
				if (ImGui::MenuItem("New Game Project", ""))
				{
					CloseAllOpenTools();
					bool bAbort = false;
					if (Storyboard.iChanged)
					{
						if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
						{
							save_storyboard(Storyboard.gamename, false);
						}
						else
						{
							int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								//Save.
								if (strlen(Storyboard.gamename) > 0)
									save_storyboard(Storyboard.gamename, false);
								else
								{
									bAbort = true;
									save_storyboard(Storyboard.gamename, true);
								}
							}
						}
					}
					if (!bAbort)
					{
						bStoryboardInitNodes = false; //Just init again.
						bStoryboardFirstRunSetInitPos = false;
						strcpy(pref.cLastUsedStoryboardProject, "");
						bTriggerSaveAsAfterNewLevel = true;
						bTriggerSaveAs = true;
						strcpy(SaveProjectAsName, "");
						strcpy(SaveProjectAsError, "");

						//
					}
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				if (ImGui::MenuItem("Open Game Project", ""))
				{
					CloseAllOpenToolsThatNeedSave();
					bool bAbort = false;
					if (Storyboard.iChanged)
					{
						if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
						{
							save_storyboard(Storyboard.gamename, false);
						}
						else
						{
							int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								//Save.
								if (strlen(Storyboard.gamename) > 0)
									save_storyboard(Storyboard.gamename, false);
								else
								{
									bAbort = true;
									save_storyboard(Storyboard.gamename, true);
								}
							}
						}
					}

					if (!bAbort)
					{
						//Open Game Project
						bTriggerOpenProject = true;
					}
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				//PE: Only use save if we already have a Project Name.
				if (strlen(Storyboard.gamename) > 0)
				{
					if (Storyboard.project_readonly != 1)
					{
						if (ImGui::MenuItem("Save Game Project", ""))
						{
							CloseAllOpenToolsThatNeedSave();
							//
							save_storyboard(Storyboard.gamename, false);
						}
						if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
					}
				}

				if (ImGui::MenuItem("Save Game Project As...", ""))//CTRL+R" ) )//F12") )
				{
					CloseAllOpenToolsThatNeedSave();
					//
					save_storyboard(Storyboard.gamename, true);
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();


				ImGui::Separator();
				//for (int ii = 0; ii < REMEMBERLASTFILES; ii++) { //reverse
				for (int ii = REMEMBERLASTFILES - 1; ii >= 0; ii--) {
					if (strlen(pref.last_project_files[ii]) > 0) {

						//std::string s_tmp = std::to_string(1+ii); //Reverse
						std::string s_tmp = std::to_string(REMEMBERLASTFILES - ii);
						s_tmp += ": ";
						s_tmp += pref.last_project_files[ii];

						if (ImGui::MenuItem(s_tmp.c_str())) {
							if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
							if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
							if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
							if (bEntity_Properties_Window) bEntity_Properties_Window = false;
							if (t.ebe.on == 1) ebe_hide();
							bool bAbort = false;
							if (Storyboard.iChanged)
							{
								if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
								{
									save_storyboard(Storyboard.gamename, false);
								}
								else
								{
									int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
									if (iAction == 1)
									{
										//Save.
										if (strlen(Storyboard.gamename) > 0)
											save_storyboard(Storyboard.gamename, false);
										else
										{
											bAbort = true;
											save_storyboard(Storyboard.gamename, true);
										}
									}
								}
							}
							if (!bAbort)
							{
								load_storyboard(pref.last_project_files[ii]);
								iGamePausedNodeID = storyboard_add_missing_nodex(8, area_width, node_width, node_height + 20.0, false);
								iLoadGameNodeID = storyboard_add_missing_nodex(3, area_width, node_width, node_height + 20.0, false);
								iSaveGameNodeID = storyboard_add_missing_nodex(9, area_width, node_width, node_height + 20.0, false);
								iGraphicsNodeID = storyboard_add_missing_nodex(10, area_width, node_width, node_height + 20.0, false);
								iSoundsNodeID = storyboard_add_missing_nodex(11, area_width, node_width, node_height + 20.0, false);
								iControlNodeID = storyboard_add_missing_nodex(12, area_width, node_width, node_height + 20.0, false);
								iLoadingScreenNodeID = storyboard_add_missing_nodex(2, area_width, node_width, node_height + 20.0, false);
								iHUDScreenNodeID = storyboard_add_missing_nodex(13, area_width, node_width, node_height + 20.0, false);
							}
						}
						if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
					}
				}

				ImGui::Separator();
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Exit to Desktop"))
				{
					if (bWaypointDrawmode || bWaypoint_Window) { bWaypointDrawmode = false; bWaypoint_Window = false; }
					if (bImporter_Window) { importer_quit(); bImporter_Window = false; }
					if (g_bCharacterCreatorPlusActivated) g_bCharacterCreatorPlusActivated = false;
					if (bEntity_Properties_Window) bEntity_Properties_Window = false;
					if (t.ebe.on == 1) ebe_hide();
					//
					bool bAbort = false;
					if (Storyboard.iChanged)
					{
						if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
						{
							save_storyboard(Storyboard.gamename, false);
						}
						else
						{
							int iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								//Save.
								if (strlen(Storyboard.gamename) > 0)
									save_storyboard(Storyboard.gamename, false);
								else
								{
									bAbort = true;
									save_storyboard(Storyboard.gamename, true);
								}
							}
						}
					}
					if (!bAbort)
					{
						bStoryboardWindow = false;
						g_bCascadeQuitFlag = true;
					}
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			}
			ImGui::EndMenu();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (pref.bAutoOpenMenuItems)
			{
				if (!bIsMenuHovered)
				{
					if (iCloseDownCount-- <= 0)
					{
						ImGui::OpenPopup("##DummyClose##Storyboard");
						if (ImGui::BeginMenu("##DummyClose##Storyboard"))
						{
							ImGui::EndMenu();
						}
					}
				}
				else
				{
					iCloseDownCount = 100;
				}
			}
		}
		else
		{
			if (pref.bAutoOpenMenuItems)
			{
				if (ImGui::IsItemHovered())
				{
					ImGui::OpenPopup("File##Storyboard");
					iCloseDownCount = 100;
				}
			}
		}

		//###################
		//#### Edit menu ####
		//###################

		if (ImGui::BeginMenu("Edit##Storyboard"))
		{
			bool bIsMenuHovered = false;
			if (bPreferences_Window == false)
			{
				if (ImGui::MenuItem("Add New Level", "CTRL+N"))
				{
					iStoryboardExecuteKey = 'N';
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Add Existing Level", "CTRL+L"))
				{
					iStoryboardExecuteKey = 'L';
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				ImGui::Separator();
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Play Game", "CTRL+SPACE"))
				{
					iStoryboardExecuteKey = ' ';
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Play Game With Invulnerability", ""))
				{
					iStoryboardExecuteKey = '!';
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				ImGui::Separator();
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Export Standalone Game", "CTRL+E"))
				{
					iStoryboardExecuteKey = 'E';
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				ImGui::Separator();
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Settings", ""))
				{
					strcpy(cPreferencesMessage, "");
					bPreferences_Window = true;
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
			}
			ImGui::EndMenu();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (pref.bAutoOpenMenuItems)
			{
				if (!bIsMenuHovered)
				{
					if (iCloseDownCount2-- <= 0)
					{
						ImGui::OpenPopup("##DummyClose##Storyboard");
						if (ImGui::BeginMenu("##DummyClose##Storyboard"))
						{
							ImGui::EndMenu();
						}
					}
				}
				else
				{
					iCloseDownCount2 = 100;
				}
			}
		}
		else
		{
			if (pref.bAutoOpenMenuItems)
			{
				if (ImGui::IsItemHovered())
				{
					ImGui::OpenPopup("Edit##Storyboard");
					iCloseDownCount2 = 100;
				}
			}
		}


		//###################
		//#### Help menu ####
		//###################

		if (ImGui::BeginMenu("Help##Storyboard"))
		{
			bool bIsMenuHovered = false;
			if (bPreferences_Window == false)
			{
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				if (ImGui::MenuItem("Read User Manual"))
				{
					ExecuteFile("..\\Guides\\User Manual\\GameGuru MAX - User Guide.pdf", "", "", 0);
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				if (ImGui::MenuItem("Guides Folder"))
				{
					ExecuteFile("..\\Guides\\", "", "", 0);
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

				/*
				if (g_bUpdateAppAvailable == true)
				{
					if (ImGui::MenuItem("Check For Updates"))
					{
						int iRet = AskSaveBeforeNewAction();
						if (iRet != 2)
						{
							g.projectmodified = 0;
							g.projectmodifiedstatic = 0;
							ExecuteFile("..\\..\\GameGuru MAX Updater.exe", "", "", 0);
							g_bCascadeQuitFlag = true;
						}
					}
					if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				}
				*/

				if (ImGui::MenuItem("Report an Issue (GitHub)"))
				{
					ExecuteFile("https://github.com/TheGameCreators/GameGuruRepo/issues/new", "", "", 0);
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();


#ifdef USEWELCOMESCREEN
				if (ImGui::MenuItem("GameGuru MAX Hub")) //"Welcome Screen"
				{
					bWelcomeScreen_Window = true;
					bStoryboardWindow = false;
					cLastProjectList = ""; //Trigger a reload of projects, if anything changed.
					bWelcomeNoBackButton = true;
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
#endif

				image_setlegacyimageloading(true);
				/*
				if (ImGui::MenuItem("Level Shortcuts")) {
					strcpy(cHelpMenuImage, "languagebank\\english\\artwork\\testgamelayout.png");
					LoadImage(cHelpMenuImage, HELPMENU_IMAGE);
					bHelp_Menu_Image_Window = true;
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				*/

				if (bAddWhatNewToMenu)
				{
					if (ImGui::MenuItem("What's New?")) //Change Log
					{
						//welcome_show(WELCOME_ANNOUNCEMENTS);
						bool welcome_get_change_log(void);
						if (gbWelcomeSystemActive == false)
						{
							welcome_init(1);
							welcome_init(2);
						}
						welcome_init(0);
						if (welcome_get_change_log() == true)
						{
							welcome_runloop(WELCOME_ANNOUNCEMENTS);
							iTriggerWelcomeSystemStuff = 99; //PE: Start welcome system.
						}
					}
				}

				if (ImGui::MenuItem("About")) {
					bAbout_Window = true;
					bAbout_Window_First_Run = true;
				}
				if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();
				image_setlegacyimageloading(false);
			}
			ImGui::EndMenu();
			if (!bIsMenuHovered) bIsMenuHovered = ImGui::IsItemHovered();

			if (pref.bAutoOpenMenuItems)
			{
				if (!bIsMenuHovered)
				{
					if (iCloseDownCount3-- <= 0)
					{
						ImGui::OpenPopup("##DummyClose##Storyboard");
						if (ImGui::BeginMenu("##DummyClose##Storyboard"))
						{
							ImGui::EndMenu();
						}
					}
				}
				else
				{
					iCloseDownCount3 = 100;
				}
			}
		}
		else
		{
			if (pref.bAutoOpenMenuItems)
			{
				if (ImGui::IsItemHovered())
				{
					ImGui::OpenPopup("Help##Storyboard");
					iCloseDownCount3 = 100;
				}
			}
		}

		ImVec2 CursorMenuEnd = ImGui::GetCursorPos();
		if (ImGui::IsMouseHoveringRect(ImGui::GetWindowPos()+CursorMenuStart+ImVec2(-4,0), ImGui::GetWindowPos() + CursorMenuEnd+ImVec2(0,24)))
		{
			iCloseDownCount = 100;
			iCloseDownCount2 = 100;
			iCloseDownCount3= 100;
		}
		ImGui::EndMenuBar();
	}
}


void save_storyboard(char *name,bool bSaveAs)
{
	cstr savename;
	if (!name) return;
	if (Storyboard.project_readonly == 1 && !bSaveAs) return;
	savename = name;
	if (bSaveAs)
	{
		//Select name.
		bTriggerSaveAs = true;
		return;
		//cStr tOldDir = GetDir();
		//char * cFileSelected;
		//cstr fulldir = "projectbank\\";
		//cFileSelected = (char *)noc_file_dialog_open(NOC_FILE_DIALOG_DIR, "All\0*.*\0", fulldir.Get(), NULL);
		//SetDir(tOldDir.Get());

		//if (cFileSelected && strlen(cFileSelected) > 0) {
		//	cstr tmp = cFileSelected;
		//	//D:\dev\GameGuru MAX\Max\Files\projectbank\My New Game
		//	//PathExist()
		//	return;
		//}
	}
	if (savename.Len() <= 0)
	{
		//Use save as.
		strcpy(cTriggerMessage, "Missing NAME of Game Project.");
		bTriggerMessage = true;
		return;
	}

	cLastProjectList = ""; //PE: Update project files.

	char project[MAX_PATH];
	strcpy(project, "projectbank\\");
	strcat(project, savename.Get());
	strcat(project, "\\project.dat");
	FILE* projectfile = GG_fopen(project, "wb+");
	if (projectfile) 
	{
		fwrite(&Storyboard, 1, sizeof(Storyboard), projectfile);
		fclose(projectfile);
		strcpy(pref.cLastUsedStoryboardProject, savename.Get());

		// save all RPG data (MAX can amend collection lists, and labels, etc)
		save_rpg_system(savename.Get(),false);
	}
	else
	{
		//Failed ?
		return;
	}
	if (1)
	{
		//Add newly saved project to recent list.
		int firstempty = -1;
		int i = 0;
		for (; i < REMEMBERLASTFILES; i++) {
			if (firstempty == -1 && strlen(pref.last_project_files[i]) <= 0)
				firstempty = i;
			if (strlen(pref.last_project_files[i]) > 0 && stricmp(savename.Get(), pref.last_project_files[i]) == 0) { //already there
				break;
			}
		}
		if (i >= REMEMBERLASTFILES) {
			if (firstempty == -1) {
				//No empty slots , rotate.
				for (int ii = 0; ii < REMEMBERLASTFILES - 1; ii++) {
					strcpy(pref.last_project_files[ii], pref.last_project_files[ii + 1]);
				}
				strcpy(pref.last_project_files[REMEMBERLASTFILES - 1], savename.Get());
			}
			else
				strcpy(pref.last_project_files[firstempty], savename.Get());
		}
	}

	Storyboard.iChanged = false;
}

static int iLastNode = -1;

// When storyboards were loaded, they were not zeroed out first, so any new arrays that were added would be filled with garbage data after load...
// ...The storyboards are now zeroed before load, but still need to ensure there is no garbage data in old projects...
void storyboard_reset_ingamehidden(StoryboardStruct* pStoryboard)
{
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		for (int j = 0; j < STORYBOARD_MAXWIDGETS; j++)
		{
			// Any garbage data can be reset here:
			// widget_ingamehidden is 1 if set by user, if it's not 0 or 1, its garbage data
			if (pStoryboard->widget_ingamehidden[i][j] != 1)
			{
				pStoryboard->widget_ingamehidden[i][j] = 0;
			}
		}
	}
}

void load_storyboard(char *name)
{
	extern void ResetStoryboardListenForKeys();
	ResetStoryboardListenForKeys();

	if (!name) return;
	if (strlen(name) <= 0) return;

	bool bProjectLoaded = false;
	char project[MAX_PATH];
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\project.dat");
	FILE* projectfile = GG_fopen(project, "rb");
	if (projectfile==NULL)
	{
		// switch to remote project
		strcpy(project, "projectbank\\");
		strcat(project, name);
		strcat(project, "\\remoteproject.txt");
		if (GG_FileExists(project))
		{
			// get remote folder
			OpenToRead(1, project);
			LPSTR pRemoteProject = ReadString(1);
			CloseFile(1);

			// switch to it now
			strcpy(Storyboard.customprojectfolder, pRemoteProject);
			switch_to_remote_project(name);

			// proceed as normal, loading now from the remote folder
			strcpy(project, "projectbank\\");
			strcat(project, name);
			strcat(project, "\\project.dat");
			projectfile = GG_fopen(project, "rb");

			// remote project has own media, so update the library to include them!
			extern int g_iRefreshLibraryFoldersAfterDelay;
			g_iRefreshLibraryFoldersAfterDelay = 10;
		}
	}
	if (projectfile)
	{
		//this sets ALL fields data to zero, and only filled with known structure (members added at end not part of the copy to remain zeros)
		memset(&checkproject, 0, sizeof(StoryboardStruct));

		size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);
		char sig[12] = "Storyboard\0";
		if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
		{
			//Valid Sig - Cleanup old project.
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				if (Storyboard.Nodes[i].used)
				{
					if (ImageExist(Storyboard.Nodes[i].thumb_id)) DeleteImage(Storyboard.Nodes[i].thumb_id);
				}
			}

			//PE: set defaults.
			iLoadGameNodeID = 3;
			iTitleScreenNodeID = 1;
			iGamePausedNodeID = 8;
			iHUDScreenNodeID = 13;
			Storyboard = checkproject;
			bStoryboardFirstRunSetInitPos = false; //Load new thumbs, and reposition new nodes.
			Storyboard.iChanged = false;
			strcpy(pref.cLastUsedStoryboardProject, name);
			fclose(projectfile);

			//PE: Check if this is a readonly project.
			char fullPath[MAX_PATH];
			strcpy(fullPath, project);
			GG_GetRealPath(fullPath, 0);
			extern char szRootDir[MAX_PATH];
			int rootLen = strlen(szRootDir);
			if (strnicmp(fullPath, szRootDir, rootLen) == 0)
			{
				//PE: Read only folder.
				Storyboard.project_readonly = 1;
				//PE: If game has been renamed.
				if (strcmp(name, Storyboard.gamename) != 0)
				{
					strcpy(Storyboard.gamename, name);
				}
			}
			else
			{
				//Read from write folder.
				Storyboard.project_readonly = 0;
			}

			// reset/repair any newly added fields
			storyboard_reset_ingamehidden(&Storyboard);

			// project loaded successfully
			bProjectLoaded = true;
		}
		else
		{
			strcpy(cTriggerMessage, "Could not load project, bad signature.");
			bTriggerMessage = true;
			fclose(projectfile);
		}
	}
	else
	{
		strcpy(cTriggerMessage, "Could not find project.");
		bTriggerMessage = true;
	}

	// Reset all node and image IDs to default - they don't need their state retained by saving, and under some circumstances when loading them, they can be duplicated, causing problems with selecting nodes and images.
	int iUniqueIds = STORYBOARD_THUMBS;
	for (int i = 0; i < STORYBOARD_MAXNODES; i++)
	{
		Storyboard.Nodes[i].id = iUniqueIds;
		Storyboard.Nodes[i].thumb_id = iUniqueIds;
		for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
		{
			Storyboard.Nodes[i].widget_normal_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 600;
			Storyboard.Nodes[i].widget_highlight_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 700;
			Storyboard.Nodes[i].widget_selected_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 800;
		}
		Storyboard.Nodes[i].screen_backdrop_id = iUniqueIds + 500;

		iUniqueIds++;
	}

	//PE: Fix all output input unique id problems.
	storeboard_fix_uniqueids();

	// and load game project rpg databases, including item collection data
	init_rpg_system();
	load_rpg_system(name);

	// as we load a storyboard project, ensure correct grass and lensflare assets are being used for editor mode
	extern void ReloadLensFlareImages();
	if (strlen(Storyboard.customprojectfolder) > 0)
	{
		// load grass and lensflare from remote project area
		char pRemotePathToGrass[MAX_PATH];
		strcpy(pRemotePathToGrass, Storyboard.customprojectfolder);
		strcat(pRemotePathToGrass, "\\");
		strcat(pRemotePathToGrass, Storyboard.gamename);
		strcat(pRemotePathToGrass, "\\Files\\");
		GGGrass_Init_Textures(pRemotePathToGrass);
		ReloadLensFlareImages();
	}
	else
	{
		// load grass and lensflare from stock assets
		GGGrass_Init_Textures("");
		ReloadLensFlareImages();
	}

	// also refresh SKY LIST as custom skies might exist there
	t.tsplashstatusprogress_s = "REFRESH SKY ASSETS";
	timestampactivity(0, t.tsplashstatusprogress_s.Get());
	version_splashtext_statusupdate();
	sky_init();

	// complete
	iLastNode = -1;
}

bool load_checkproject_storyboard(char *name)
{
	if (!name) return false;
	if (strlen(name) <= 0) return false;

	char project[MAX_PATH];
	strcpy(project, "projectbank\\");
	strcat(project, name);
	strcat(project, "\\project.dat");

	bool bReadProjectDetails = false;
	FILE* projectfile = GG_fopen(project, "rb");
	if (projectfile)
	{
		bReadProjectDetails = true;
	}
	else
	{
		// may be a remote project
		strcpy(project, "projectbank\\");
		strcat(project, name);
		strcat(project, "\\remoteproject.txt");
		if (FileExist(project) == 1)
		{
			OpenToRead(1, project);
			strcpy(project, ReadString(1));
			strcat(project, name);
			strcat(project, "\\Files\\projectbank\\");
			strcat(project, name);
			strcat(project, "\\project.dat");
			CloseFile(1);
		}
		projectfile = GG_fopen(project, "rb");
		if (projectfile)
		{
			bReadProjectDetails = true;
		}
	}
	if (bReadProjectDetails==true)
	{
		memset(&checkproject, 0, sizeof(StoryboardStruct));
		size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);
		//Valid pref:
		fclose(projectfile);
		char sig[12] = "Storyboard\0";
		if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
		{
			storyboard_reset_ingamehidden(&checkproject);
			return true;
		}
	}
	return false;
}

bool load__storyboard_into_struct(const char *filepath, StoryboardStruct& storyboard)
{
	if (!filepath) return false;
	if (strlen(filepath) <= 0) return false;

	FILE* projectfile = GG_fopen(filepath, "rb");
	if (projectfile)
	{
		memset(&storyboard, 0, sizeof(StoryboardStruct));
		size_t size = fread(&storyboard, 1, sizeof(storyboard), projectfile);
		//Valid pref:
		fclose(projectfile);
		char sig[12] = "Storyboard\0";
		if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
		{
			return true;
		}
	}
	return false;
}

//SmallStoryboardStruct smallcheckproject; //PE: Switched to full as we have game settings now.

void GetProjectList(char *path, bool bGetThumbs)
{
	if (!path) return;
	int uniqueId = 16000;

	if (cLastProjectList != path)
	{
		projectbank_list.clear();
		projectbank_imageid.clear();
		projectbank_image.clear();

		cLastProjectList = path;
		LPSTR pOldDir = GetDir();

		char destination[MAX_PATH];
		strcpy(destination, path);
		GG_GetRealPath(destination, 1); //We need to path to the write folder.

		SetDir(destination);
		ChecklistForFiles();
		SetDir(pOldDir);
		for (int c = 1; c <= ChecklistQuantity(); c++)
		{
			if (ChecklistValueA(c) != 0)
			{
				// only folders
				cstr folder = ChecklistString(c);
				if (folder != "." && folder != "..")
				{
					bool bIgnore = true;

					bool bHaveAProject = false;
					char project[MAX_PATH];
					strcpy(project, destination);
					strcat(project, folder.Get());
					strcat(project, "\\project.dat");
					if (GG_FileExists(project))
					{
						bHaveAProject = true;
					}
					else
					{
						strcpy(project, destination);
						strcat(project, folder.Get());
						strcat(project, "\\remoteproject.txt");
						if (GG_FileExists(project))
						{
							bHaveAProject = true;
						}
					}
					//PE: Must have a project.
					if (bHaveAProject == true)
					{
						bIgnore = false;
					}
					if (!bIgnore)
					{
						projectbank_list.push_back(folder.Get());
						if (!bGetThumbs)
						{
							projectbank_image.push_back(""); //Just use CLICK HERE.
						}
						projectbank_imageid.push_back(0);
					}
				}
			}
		}
		SetDir(pOldDir);

		//Find project thumbs.
		if (bGetThumbs)
		{
			for (int i = 0; i < projectbank_list.size(); i++)
			{
				if (!pestrcasestr((char *)projectbank_list[i].c_str(), "_backup_"))
				{
					char project[MAX_PATH];
					strcpy(project, "projectbank\\");
					strcat(project, projectbank_list[i].c_str());
					strcat(project, "\\remoteproject.txt");
					FILE* projectfile = NULL;
					if (GG_FileExists(project))
					{
						// this project is a remote project (aproj7\Files\projectbank\aproj7)
						char pAbsTrueProjectPath[MAX_PATH];
						OpenToRead(1, project);
						strcpy(pAbsTrueProjectPath, ReadString(1));
						CloseFile(1);
						GG_GetRealPath(pAbsTrueProjectPath, 0);
						strcpy(project, pAbsTrueProjectPath);
						strcat(project, projectbank_list[i].c_str());
						strcat(project, "\\Files\\projectbank\\");
					}
					else
					{
						// regular projectbank project
						strcpy(project, "projectbank\\");
					}
					strcat(project, projectbank_list[i].c_str());
					strcat(project, "\\project.dat");
					projectfile = GG_fopen(project, "rb");
					if (projectfile)
					{
						//PE: Need full load now, as we can have Game Settings.
						size_t size = fread(&checkproject, 1, sizeof(checkproject), projectfile);

						char sig[12] = "Storyboard\0";
						if (checkproject.sig[0] == 'S' && checkproject.sig[8] == 'r')
						{
							cstr bestfound = "";
							//Valid Sig - Cleanup old project.
							if (strlen(checkproject.game_thumb) > 0 && FileExist(checkproject.game_thumb) )
							{
								bestfound = checkproject.game_thumb;
							}
							else
							{
								for (int i = 0; i < STORYBOARD_MAXNODES; i++) //SMALL_STORYBOARD_MAXNODES
								{
									if (checkproject.Nodes[i].used)
									{
										if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SPLASH)
										{
											//Splash if no level found.
											if (bestfound == "")
											{
												if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\uiv3\\"))
												{
													//custom use.
													bestfound = checkproject.Nodes[i].thumb;
												}
											}
										}
										if (checkproject.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
										{
											if (pestrcasestr(checkproject.Nodes[i].title, "title screen"))
											{
												//Splash if no level found.
												if (!pestrcasestr(checkproject.Nodes[i].thumb, "editors\\templates\\"))
												{
													//custom use.
													bestfound = checkproject.Nodes[i].thumb;
												}
											}
										}
										//PE: Try finding level that loading.lua is pointing to ?
										if (checkproject.Nodes[i].type == STORYBOARD_TYPE_LEVEL && !pestrcasestr(Storyboard.Nodes[i].lua_name, "loading"))
										{
											if (strlen(checkproject.Nodes[i].level_name) > 0)
											{
												CreateBackBufferCacheNameEx(checkproject.Nodes[i].level_name, 512, 288, true);
												if (CreateProjectCacheName(checkproject.gamename, BackBufferCacheName.Get()) &&
													FileExist(ProjectCacheName.Get()))
												{
													bestfound = ProjectCacheName.Get();
													break;
												}
												else if (FileExist(BackBufferCacheName.Get()))
												{
													bestfound = BackBufferCacheName.Get();
													break;
												}
											}
										}

									}
								}
							}
							projectbank_image.push_back(bestfound.Get());
						}
						else
						{
							projectbank_image.push_back(""); //Just use CLICK HERE.
						}
						fclose(projectfile);
					}
					else
					{
						//PE: Was missing if not found. https://github.com/TheGameCreators/GameGuruRepo/issues/1722
						projectbank_image.push_back(""); //Just use CLICK HERE.
					}
				}
				else
				{
					projectbank_image.push_back(""); //Backup just use CLICK HERE.
				}
			}
		}
	}
}


bool bWidgetMouseDraggin = false;
void storyboard_control_widget(int nodeid, int index, ImVec2 pos, ImVec2 size, ImRect rMonitorArea, ImVec2 vMonitorStart, ImVec2 vScale)
{

	ImGuiWindow* window = ImGui::GetCurrentWindow();
	ImVec2 ocpos = ImGui::GetCursorPos();
	ImGui::SetCursorPos(vMonitorStart);
	ImVec4 tool_selected_col = ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
	ImVec2 padding = { 2.0, 2.0 };
	window->DrawList->AddRect(rMonitorArea.Min + pos - padding, rMonitorArea.Min + pos + size + padding, ImGui::GetColorU32(tool_selected_col));

	ImVec2 but_size = ImVec2(12.0, 12.0);
	ImVec2 fp = ImGui::GetStyle().FramePadding;
	float fpb = ImGui::GetStyle().FrameBorderSize;
	ImVec4 *style_colors = ImGui::GetStyle().Colors;
	ImVec4 oldbutA = style_colors[ImGuiCol_ButtonActive];
	ImVec4 oldbutH = style_colors[ImGuiCol_ButtonHovered];
	ImVec4 oldbutN = style_colors[ImGuiCol_Button];
	style_colors[ImGuiCol_Button] = tool_selected_col;
	style_colors[ImGuiCol_ButtonHovered] = tool_selected_col;
	style_colors[ImGuiCol_ButtonHovered].w *= 0.80f;
	style_colors[ImGuiCol_ButtonActive] = tool_selected_col;

	ImGui::GetStyle().FramePadding = ImVec2(0, 0);
	ImGui::GetStyle().FrameBorderSize = 0;

	ImGui::SetCursorPos(vMonitorStart + pos - (but_size*0.5) );
	ImGui::SetItemAllowOverlap();
	bool bSizeHover = false;
	bool bSizeHover2 = false;
	if (ImGui::ButtonEx("##TopLeftCorner", but_size , 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover2 = true;
	ImGui::SetCursorPos(vMonitorStart + pos + ImVec2(size.x,0) - (but_size*0.5));
	ImGui::SetItemAllowOverlap();
	if (ImGui::ButtonEx("##TopRightCorner", but_size, 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover = true;
	ImGui::SetCursorPos(vMonitorStart + pos + ImVec2(0, size.y) - (but_size*0.5));
	ImGui::SetItemAllowOverlap();
	if (ImGui::ButtonEx("##BotLeftCorner", but_size, 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover2 = true;
	ImGui::SetCursorPos(vMonitorStart + pos + size - (but_size*0.5));
	ImGui::SetItemAllowOverlap();
	if (ImGui::ButtonEx("##BotRightCorner", but_size, 0))
	{
		//Resize, todo if time.
	}
	if (ImGui::IsItemHovered()) bSizeHover = true;

	ImGui::GetStyle().FramePadding = fp;
	ImGui::GetStyle().FrameBorderSize = fpb;
	style_colors[ImGuiCol_Button] = oldbutN;
	style_colors[ImGuiCol_ButtonHovered] = oldbutH;
	style_colors[ImGuiCol_ButtonActive] = oldbutA;

	static ImVec2 vMovePos;
	static int iMoveType = 0;

	static bool bWaitForRelease = false;
	if (bWaitForRelease)
	{
		if (!ImGui::IsMouseDown(0))
		{
			bWaitForRelease = false;
		}
	}
	else if (ImGui::IsMouseDown(0))
	{
		iMoveType = 0;
		if (bSizeHover)
			iMoveType = 1;
		if (bSizeHover2)
			iMoveType = 2;
		bWaitForRelease = true;
	}
	
	if (!bExternal_Entities_Window && !bVideoPlayerMaximized && !bPreferences_Window && !bLastSmallVideoPlayerMaximized)
	{
		static int bShowCenterLines = 0;
		static bool bNoSnapping = false;
		float fAdjustX = 0.0, fAdjustY = 0.0;
		ImVec2 fMouseToPercent = ImVec2(100.0 / (1920.0*vScale.x), 100.0 / (1080.0*vScale.y));
		int grid = Storyboard.Nodes[nodeid].screen_grid_size;
		ImVec2 mPos = ImGui::GetMousePos();
		if (mPos.x > rMonitorArea.Min.x && mPos.x < rMonitorArea.Max.x && mPos.y > rMonitorArea.Min.y && mPos.y < rMonitorArea.Max.y)
		{
			// only if within monitor area
			if (ImGui::IsKeyPressed(39, true))
			{
				if (grid > 0)
					fAdjustX = grid;
				else
					fAdjustX = 1.0 * fMouseToPercent.x;
			}
			if (ImGui::IsKeyPressed(37, true))
			{
				if (grid > 0)
					fAdjustX = -grid;
				else
					fAdjustX = -1.0 * fMouseToPercent.x;
			}
			if (ImGui::IsKeyPressed(38, true))
			{
				if (grid > 0)
					fAdjustY = -grid;
				else
					fAdjustY = -1.0 * fMouseToPercent.y;
			}
			if (ImGui::IsKeyPressed(40, true))
			{
				if (grid > 0)
					fAdjustY = grid;
				else
					fAdjustY = 1.0 * fMouseToPercent.y;
			}
		}
		if (fAdjustX != 0.0 || fAdjustY != 0.0)
		{
			if (fAdjustX != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].x += fAdjustX;
			if (fAdjustY != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].y += fAdjustY;
			if (grid > 0)
			{
				if (fAdjustX != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].x -= fmod(Storyboard.Nodes[nodeid].widget_pos[index].x, grid);
				if (fAdjustY != 0.0) Storyboard.Nodes[nodeid].widget_pos[index].y -= fmod(Storyboard.Nodes[nodeid].widget_pos[index].y, grid);
			}
			bShowCenterLines = 30; //PE: This adds snapping so we cant move after this.
			bNoSnapping = true;
		}

		ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
		if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + pos - vLargerGrabArea, rMonitorArea.Min + pos + size + vLargerGrabArea) || bWidgetMouseDraggin)
		{
			//Drag if mouse down.
			if (ImGui::IsMouseDown(0) && ImGui::IsMouseDragging(0))
			{
				if (!bWidgetMouseDraggin)
				{
					vMovePos = Storyboard.Nodes[nodeid].widget_pos[index];
				}
				if (iMoveType == 1)
				{
					float fAdjust = ImGui::GetIO().MouseDelta.x / 350.0;
					fAdjust += ImGui::GetIO().MouseDelta.y / 350.0;
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON 
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_PROGRESS
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BAR)
					{
						Storyboard.Nodes[nodeid].widget_size[index].x += fAdjust;
						if (Storyboard.Nodes[nodeid].widget_size[index].x > 4.0) Storyboard.Nodes[nodeid].widget_size[index].x = 4.0;
						Storyboard.Nodes[nodeid].widget_size[index].y = Storyboard.Nodes[nodeid].widget_size[index].x;
					}
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXT 
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
					{
						Storyboard.Nodes[nodeid].widget_font_size[index] += fAdjust;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] > 3.0) Storyboard.Nodes[nodeid].widget_font_size[index] = 3.0;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0.05) Storyboard.Nodes[nodeid].widget_font_size[index] = 0.05;
					}
				}
				else if (iMoveType == 2)
				{			
					float fAdjust = ImGui::GetIO().MouseDelta.x / 350.0;
					fAdjust += ImGui::GetIO().MouseDelta.y / 350.0;
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON 
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_PROGRESS
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BAR)
					{
						Storyboard.Nodes[nodeid].widget_size[index].x -= fAdjust;
						if (Storyboard.Nodes[nodeid].widget_size[index].x > 4.0) Storyboard.Nodes[nodeid].widget_size[index].x = 4.0;
						Storyboard.Nodes[nodeid].widget_size[index].y = Storyboard.Nodes[nodeid].widget_size[index].x;
					}
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXT 
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
					{
						Storyboard.Nodes[nodeid].widget_font_size[index] -= fAdjust;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] > 3.0) Storyboard.Nodes[nodeid].widget_font_size[index] = 3.0;
						if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0.05) Storyboard.Nodes[nodeid].widget_font_size[index] = 0.05;
					}
				}
				else
				{
					vMovePos.x += ImGui::GetIO().MouseDelta.x * fMouseToPercent.x;
					vMovePos.y += ImGui::GetIO().MouseDelta.y * fMouseToPercent.y;

					if (Storyboard.Nodes[nodeid].screen_grid_size > 0)
					{
						int grid = Storyboard.Nodes[nodeid].screen_grid_size;
						float adjustx = fmod(vMovePos.x, grid);
						float adjusty = fmod(vMovePos.y, grid);
						Storyboard.Nodes[nodeid].widget_pos[index].x = vMovePos.x - adjustx;
						Storyboard.Nodes[nodeid].widget_pos[index].y = vMovePos.y - adjusty;
					}
					else
					{
						Storyboard.Nodes[nodeid].widget_pos[index] = vMovePos;
					}
					bShowCenterLines = 1;
					bNoSnapping = false;
				}
				bWidgetMouseDraggin = true;

			}
			if (!ImGui::IsMouseDown(0))
			{
				bWidgetMouseDraggin = false;
			}
		}

		if (bShowCenterLines > 0)
		{
			bShowCenterLines--;
			float minsnapping = 49.8;
			float maxsnapping = 50.2;
			if (bNoSnapping)
			{
				//PE: One pixel.
				minsnapping = 50.0 - ((1.0 * fMouseToPercent.x) * 0.5);
				maxsnapping = 50.0 + ((1.0 * fMouseToPercent.x) * 0.5);
			}
			//Show center lines.
			if (Storyboard.Nodes[nodeid].widget_pos[index].x >= minsnapping && Storyboard.Nodes[nodeid].widget_pos[index].x <= maxsnapping)
			{
				//if(!bNoSnapping) 
				Storyboard.Nodes[nodeid].widget_pos[index].x = 50.0; //Align to center
				//Draw center line.
				float centerx = (rMonitorArea.Max.x - rMonitorArea.Min.x) * 0.5;
				centerx += rMonitorArea.Min.x;
				window->DrawList->AddLine(ImVec2(centerx, rMonitorArea.Min.y), ImVec2(centerx, rMonitorArea.Max.y), ImGui::GetColorU32(tool_selected_col));
			}

			if (bNoSnapping)
			{
				//PE: One pixel.
				minsnapping = 50.0 - ((1.0 * fMouseToPercent.y) * 0.5);
				maxsnapping = 50.0 + ((1.0 * fMouseToPercent.y) * 0.5);
			}

			float fPercent = (rMonitorArea.Max.y - rMonitorArea.Min.y) / 100.0;
			float fSizePivotCenterY = (size.y*0.5) / fPercent;
			//Show center Y line
			if (Storyboard.Nodes[nodeid].widget_pos[index].y + fSizePivotCenterY >= minsnapping && Storyboard.Nodes[nodeid].widget_pos[index].y + fSizePivotCenterY <= maxsnapping)
			{
				Storyboard.Nodes[nodeid].widget_pos[index].y = 50.0 - fSizePivotCenterY; //Align to center Y
				//Draw center line.
				float centery = (rMonitorArea.Max.y - rMonitorArea.Min.y) * 0.5;
				centery += rMonitorArea.Min.y;
				window->DrawList->AddLine(ImVec2(rMonitorArea.Min.x, centery), ImVec2(rMonitorArea.Max.x, centery), ImGui::GetColorU32(tool_selected_col));
			}
		}
	}
	ImGui::SetCursorPos(ocpos);
}

extern ImFont* customfont;
extern ImFont* customfontlarge;
float WidgetSelectUsedFont(int nodeid, int index)
{
	
	for (int i = 0; i < StoryboardFonts.size(); i++)
	{
		bool bIsSelected = false;
		if (strcmp(cstr((char*)StoryboardFonts[i].second.c_str()).Lower().Get(), cstr(Storyboard.Nodes[nodeid].widget_font[index]).Lower().Get()) == NULL)
		{
			ImGui::PushFont(StoryboardFonts[i].first);  //storyboard special fonts.
			return 2.0; //2.0=60,2.5=48
		}
	}
	ImGui::PushFont(customfontlarge);  //defaultfont
	return 2.0;
}

static int iUpdateBackDropNode = -1;
static int iUpdateWidgetThumbNode = -1;
static int iUpdateWidgetThumbButton = -1;
static bool bPreviewScreen = false;
static bool bLastStandalone = false;
static bool bDisplayGrid = false;
static bool bPlacingNewWidget = false;
std::vector<int> Storyboard_ActiveWidgets;

bool IsHardcodedID (int nodeID, int widgetID)
{
	bool bHardcoded = false;
	if (nodeID == iTitleScreenNodeID && widgetID <= 4) bHardcoded = true;
	if (nodeID == iAboutScreenNodeID && widgetID <= 2) bHardcoded = true;
	if (nodeID == iGamePausedNodeID && widgetID <= 7) bHardcoded = true;
	if (nodeID == iGraphicsNodeID && widgetID <= 6) bHardcoded = true;
	if (nodeID == iSoundsNodeID && widgetID <= 5) bHardcoded = true;
	if (nodeID == iSaveGameNodeID && widgetID <= 9) bHardcoded = true;
	if (nodeID == iLoadGameNodeID && widgetID <= 9) bHardcoded = true;
	if (nodeID == iLoadingScreenNodeID && widgetID <= 2) bHardcoded = true;
	if (nodeID == iControlNodeID && widgetID <= 7) bHardcoded = true;
	return bHardcoded;
}

int AddWidgetToScreen(int nodeID, STORYBOARD_WIDGET_ type, std::string readoutTitle = "")
{
	StoryboardNodesStruct& node = Storyboard.Nodes[nodeID];

	// Find a free slot to add the widget to
	int widgetSlot = -1;
	for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
	{
		bool bHardcodedIDForNow = IsHardcodedID(nodeID, i);
		if (bHardcodedIDForNow == false)
		{
			if (node.widget_used[i] == 0)
			{
				widgetSlot = i;
				node.widget_used[i] = 1;
				break;
			}
		}
	}
	if (widgetSlot < 0)
	{
		// No free space for widgets
		return widgetSlot;
	}

	// Set widget defaults
	node.widget_type[widgetSlot] = type;
	Storyboard.widget_colors[nodeID][widgetSlot] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
	Storyboard.Nodes[nodeID].widget_size[widgetSlot] = ImVec2(1.0f, 1.0f);
	node.widget_pos[widgetSlot].x = 200 / ImGui::GetMainViewport()->Size.x * 100;
	node.widget_pos[widgetSlot].y = 200 / ImGui::GetMainViewport()->Size.y * 100;
	if (readoutTitle.length() > 0)
	{
		strcpy(Storyboard.widget_readout[nodeID][widgetSlot], readoutTitle.c_str());
	}
	else
	{
		// Reset in case this widget was previously used as a readout but no longer is
		Storyboard.widget_readout[nodeID][widgetSlot][0] = 0;
	}
	Storyboard.widget_textoffset[nodeID][widgetSlot] = ImVec2(0.0f, 0.0f);
	Storyboard.widget_ingamehidden[nodeID][widgetSlot] = 0;
	Storyboard.widget_drawordergroup[nodeID][widgetSlot] = 0;

	// Settings specific to widget type:
	if (type == STORYBOARD_WIDGET_IMAGE)
	{
		if (readoutTitle.length() > 0)
		{
			if (strcmp(readoutTitle.c_str(),"Weapon Held") == 0)
			{
				strcpy(node.widget_normal_thumb[widgetSlot], "languagebank\\neutral\\gamecore\\huds\\ammohealth\\icon-colt.png");
			}
			else if (strcmp(readoutTitle.c_str(), "Weapon Firemode") == 0)
			{
				strcpy(node.widget_normal_thumb[widgetSlot], "languagebank\\neutral\\gamecore\\huds\\ammohealth\\ammo-icon-handgun.png");
			}
			else
			{
				strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\panels\\image-panel.png");
			}
		}
		else
		{
			strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\panels\\image-panel.png");
		}
		// used as GRID ROW and COLUMN default (1x1)
		Storyboard.widget_textoffset[nodeID][widgetSlot] = ImVec2(1, 1);
	}
	else if (type == STORYBOARD_WIDGET_VIDEO)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\panels\\video-panel.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], ""); // will ne used to store MP4 file
	}
	else if (type == STORYBOARD_WIDGET_TEXT || type == STORYBOARD_WIDGET_TEXTAREA)
	{
		if (readoutTitle.length() > 0)
		{
			char valueStr[64];
			sprintf(valueStr, "%d", node.widget_initial_value[widgetSlot]);
			strcpy(node.widget_label[widgetSlot], valueStr);// "999");
			node.widget_font_size[widgetSlot] = 0.8f;
		}
	}
	else if (type == STORYBOARD_WIDGET_BUTTON)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\buttons\\default.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], "editors\\templates\\buttons\\default-hover.png");
	}
	else if (type == STORYBOARD_WIDGET_RADIOTYPE)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\buttons\\default.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], "editors\\templates\\buttons\\default-hover.png");
		strcpy(node.widget_selected_thumb[widgetSlot], "editors\\templates\\buttons\\default-selected.png");
	}
	else if (type == STORYBOARD_WIDGET_TICKBOX)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\buttons\\tick-box-off.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], "editors\\templates\\buttons\\tick-box-off.png");		
		strcpy(node.widget_selected_thumb[widgetSlot], "editors\\templates\\buttons\\tick-box-on.png");
		Storyboard.widget_textoffset[nodeID][widgetSlot] = ImVec2(-60, 0);
		if (readoutTitle.length() > 0)
		{
			strcpy(node.widget_label[widgetSlot], readoutTitle.c_str());
		}
	}
	else if (type == STORYBOARD_WIDGET_SLIDER)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\buttons\\slider-bar-empty.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], "editors\\templates\\buttons\\slider-bar-full.png");
		Storyboard.widget_textoffset[nodeID][widgetSlot] = ImVec2(0, -50);
		if (readoutTitle.length() > 0)
		{
			strcpy(node.widget_label[widgetSlot], readoutTitle.c_str());
		}
	}
	else if (type == STORYBOARD_WIDGET_PROGRESS)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\buttons\\slider-bar-empty.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], "editors\\templates\\buttons\\slider-bar-full.png");
	}
	else if (type == STORYBOARD_WIDGET_BAR)
	{
		strcpy(node.widget_normal_thumb[widgetSlot], "editors\\templates\\bars\\bar-empty.png");
		strcpy(node.widget_highlight_thumb[widgetSlot], "editors\\templates\\bars\\bar-full.png");
	}

	iUpdateWidgetThumbNode = widgetSlot;
	iUpdateWidgetThumbButton = widgetSlot;
	iCurrentSelectedWidget = widgetSlot;
	Storyboard_ActiveWidgets.push_back(widgetSlot);
	bPlacingNewWidget = true;
	return widgetSlot;
}

void RefreshThumbImagesForNode(int nodeID, int indexToActiveWidget)
{
	StoryboardNodesStruct& node = Storyboard.Nodes[nodeID];
	image_setlegacyimageloading(true);
	for (int i = indexToActiveWidget; i < STORYBOARD_MAXWIDGETS; i++)
	{
		DeleteImage(node.widget_normal_thumb_id[i]);
		if (strlen(node.widget_normal_thumb[i]) > 0)
		{
			LoadImage(node.widget_normal_thumb[i], node.widget_normal_thumb_id[i]);
		}
		DeleteImage(node.widget_highlight_thumb_id[i]);
		if (strlen(node.widget_highlight_thumb[i]) > 0)
		{
			LoadImage(node.widget_highlight_thumb[i], node.widget_highlight_thumb_id[i]);
		}
		DeleteImage(node.widget_selected_thumb_id[i]);
		if (strlen(node.widget_selected_thumb[i]) > 0)
		{
			LoadImage(node.widget_selected_thumb[i], node.widget_selected_thumb_id[i]);
		}
	}
	image_setlegacyimageloading(false);
}

void RemoveWidgetFromScreen(int nodeID, int widgetID)
{
	bool bHardcodedID = IsHardcodedID(nodeID, widgetID);
	if (Storyboard.Nodes[nodeID].type != STORYBOARD_TYPE_HUD)
	{
		if ( bHardcodedID==true )
		{
			bool bHardWidgetsThatCanBeDeleted = false;
			if (nodeID == iTitleScreenNodeID && (widgetID == 1 || widgetID == 2)) bHardWidgetsThatCanBeDeleted = true;
			if (nodeID == iAboutScreenNodeID && (widgetID != 2)) bHardWidgetsThatCanBeDeleted = true;
			if (nodeID == iGamePausedNodeID && (widgetID == 2 || widgetID == 3)) bHardWidgetsThatCanBeDeleted = true;
			if (bHardWidgetsThatCanBeDeleted==true)
			{
				// allow user to delete certain hard buttons (LOAD and SAVE and ABOUT etc)
			}
			else
			{
				return;
				//if (!(widgetID == 0 && Storyboard.Nodes[nodeID].widget_type[widgetID] != STORYBOARD_WIDGET_TEXT))
				//	return;
			}
			//if (nodeID == iGraphicsNodeID && widgetID <= 6) return;
			//if (nodeID == iSoundsNodeID && widgetID <= 5) return;
			//if (nodeID == iSaveGameNodeID && widgetID <= 9) return;
			//if (nodeID == iLoadGameNodeID && widgetID <= 9) return;
			//if (nodeID == iLoadingScreenNodeID && widgetID <= 2) return;
			//if (nodeID == iControlNodeID && widgetID <= 7) return;
		}

		//Also not all pages got add sliders.
		if(Storyboard.Nodes[nodeID].widget_type[widgetID] == STORYBOARD_WIDGET_SLIDER) return;

		//Progress bar cant be added yet.
		if (Storyboard.Nodes[nodeID].widget_type[widgetID] == STORYBOARD_WIDGET_PROGRESS) return;

		//PE: Loading screens must have a progress bar.
		if (pestrcasestr(Storyboard.Nodes[nodeID].lua_name, "loading"))
		{
			if (Storyboard.Nodes[nodeID].widget_type[widgetID] == STORYBOARD_WIDGET_PROGRESS) return;
		}
	}

	// hard coded are just reset
	StoryboardNodesStruct& node = Storyboard.Nodes[nodeID];
	if (bHardcodedID == true)
	{
		// hard widget
		node.widget_used[widgetID] = 0;
	}
	else
	{
		// custom widget
		// First, check that the widget is actually on the screen and able to be removed.
		int indexToActiveWidget = -1;
		for (int i = 0; i < Storyboard_ActiveWidgets.size(); i++)
		{
			if (Storyboard_ActiveWidgets[i] == widgetID)
			{
				indexToActiveWidget = i;
				break;
			}
		}
		if (indexToActiveWidget < 0)
		{
			return;
		}

		// Remove the widget from the active widgets rendered on-screen
		for (int i = indexToActiveWidget; i < Storyboard_ActiveWidgets.size(); i++)
		{
			Storyboard_ActiveWidgets[i] -= 1;
		}
		Storyboard_ActiveWidgets.erase(Storyboard_ActiveWidgets.begin() + indexToActiveWidget);

		// Mark the widget as unused in the storyboard struct and move any widgets after the deleted slot down a slot, to keep the active widgets continguous
		for (int i = indexToActiveWidget; i < STORYBOARD_MAXWIDGETS - 1; i++)
		{
			node.widget_used[i] = node.widget_used[i + 1];
			strcpy(node.widget_label[i], node.widget_label[i + 1]);
			node.widget_size[i] = node.widget_size[i + 1];
			node.widget_pos[i] = node.widget_pos[i + 1];
			strcpy(node.widget_normal_thumb[i], node.widget_normal_thumb[i + 1]);
			strcpy(node.widget_highlight_thumb[i], node.widget_highlight_thumb[i + 1]);
			strcpy(node.widget_selected_thumb[i], node.widget_selected_thumb[i + 1]);
			strcpy(node.widget_click_sound[i], node.widget_click_sound[i + 1]);
			node.widget_action[i] = node.widget_action[i + 1];
			strcpy(node.widget_font[i], node.widget_font[i + 1]);
			node.widget_font_color[i] = node.widget_font_color[i + 1];
			node.widget_font_size[i] = node.widget_font_size[i + 1];
			node.widget_type[i] = node.widget_type[i + 1];
			node.widget_read_only[i] = node.widget_read_only[i + 1];
			node.widget_layer[i] = node.widget_layer[i + 1];
			//node.widget_output_pin[i] = node.widget_output_pin[i + 1];
			node.widget_initial_value[i] = node.widget_initial_value[i + 1];
			strcpy(node.widget_name[i], node.widget_name[i + 1]);
			Storyboard.widget_colors[nodeID][i] = Storyboard.widget_colors[nodeID][i + 1];
			strcpy(Storyboard.widget_readout[nodeID][i], Storyboard.widget_readout[nodeID][i + 1]);
			Storyboard.widget_textoffset[nodeID][i] = Storyboard.widget_textoffset[nodeID][i + 1];
			Storyboard.widget_ingamehidden[nodeID][i] = Storyboard.widget_ingamehidden[nodeID][i + 1];
			Storyboard.widget_drawordergroup[nodeID][i] = Storyboard.widget_drawordergroup[nodeID][i + 1];
		}

		// Reload any images after the deleted widget, to ensure they remain in the correct slot
		RefreshThumbImagesForNode(nodeID, indexToActiveWidget);
	}
	
	iCurrentSelectedWidget = -1;
}

// TODO: this is very unsafe, would be better to have the desired type as a parameter to ensure we only return expected types
void* GetReadoutAddress(char* readoutTitle)
{
	if (strcmp(readoutTitle, "User Defined Global") == 0)
	{
		return nullptr;
	}
	if (strcmp(readoutTitle, "User Defined Global Text") == 0)
	{
		return nullptr;
	}
	else if (strcmp(readoutTitle, "User Defined Global Statusbar") == 0)
	{
		return nullptr;
	}
	else if (strcmp(readoutTitle, "User Defined Global Imagw") == 0)
	{
		return (void*)&t.iTmpImgID;
	}
	else if (strcmp(readoutTitle, "User Defined Global Panel") == 0)
	{
		return (void*)&t.iTmpImgID;
	}
	else if (strcmp(readoutTitle, "Health Remaining") == 0)
	{
		return (void*)&t.player[t.plrid].health;
	}
	else if(strcmp(readoutTitle, "Maximum Health") == 0)
	{
		return (void*)&t.playercontrol.startstrength;
	}
	else if (strcmp(readoutTitle, "Health Panel") == 0)
	{
		return (void*)&t.iTmpImgID;
	}
	else if (strcmp(readoutTitle, "Ammo Remaining") == 0 && t.gunid > 0 && t.gun[t.gunid].weapontype != 51)
	{
		return (void*)&t.slidersmenuvalue[1][1].value;
	}
	else if (strcmp(readoutTitle, "Maximum Ammo") == 0 && t.gunid > 0 && t.gun[t.gunid].weapontype != 51)
	{
		return (void*)&t.slidersmenuvalue[1][2].value;
	}
	else if (strcmp(readoutTitle, "Ammo Panel") == 0 && t.gunid > 0 && t.gun[t.gunid].weapontype != 51)
	{
		return (void*)&t.iTmpImgID;
	}
	else if (strcmp(readoutTitle, "Weapon Held") == 0 && t.gun[t.gunid].weapontype != 51)
	{
		return (void*)&g.firemodes[t.gunid][g.firemode].iconimg;
	}
	else if (strcmp(readoutTitle, "Weapon Firemode") == 0 && t.gun[t.gunid].weapontype != 51)
	{
		return (void*)&g.firemodes[t.gunid][g.firemode].ammoimg;
	}
	else if (strcmp(readoutTitle, "Lives Remaining") == 0)
	{
		return (void*)&t.player[t.plrid].lives;
	}
	else if (strcmp(readoutTitle, "VSync") == 0)
	{
		return (void*)&master.bVsyncEnabled;
	}
	else if (strcmp(readoutTitle, "Music Volume") == 0)
	{
		return (void*)&t.gamesounds.music;
	}
	else if (strcmp(readoutTitle, "Sound Effects Volume") == 0)
	{
		return (void*)&t.gamesounds.sounds;
	}
	
	return nullptr;
}

// Find the index of the readout with the passed in title
int GetReadoutIndex(char* readoutTitle)
{
	for (int i = 0; i < readoutTitles.size(); i++)
	{
		if (strcmp(readoutTitle, readoutTitles[i].c_str()) == 0)
		{
			return i;
		}
	}

	return 0;
}

void ExecuteReadoutCallback(int indexToCallback)
{
	// Obtain function callback pointer and call
	auto& fn = readoutCallbacks[indexToCallback];
	if (fn != nullptr)
	{
		fn();
	}
}

int GetReadoutValueInt(char* readoutTitle)
{
	void* pReadout = GetReadoutAddress(readoutTitle);
	if (pReadout)
	{
		int readoutIndex = GetReadoutIndex(readoutTitle);
		ReadoutTypes type = readoutTypes[readoutIndex];
		int value = 0;
		if (type == READOUT_BOOL)
		{
			// 1 byte
			value = *(bool*)pReadout;
		}
		else
		{
			// 4 bytes
			value = *(int*)pReadout;
		}
		return value;
	}
	else
	{
		// For now, a special value to indicate failure getting readout
		return -INT_MAX;
	}
}

// Set the variable that the readout represents (also executes callback, if one exists)
void SetReadoutValueInt(char* readoutTitle, int value)
{
	void* pReadout = GetReadoutAddress(readoutTitle);
	if (pReadout)
	{
		int readoutIndex = GetReadoutIndex(readoutTitle);
		ReadoutTypes type = readoutTypes[readoutIndex];
		if (type == READOUT_BOOL)
		{
			// 1 byte
			*(bool*)pReadout = value;
		}
		else
		{
			// 4 bytes
			*(int*)pReadout = value;
		}
		ExecuteReadoutCallback(readoutIndex);
	}
}

// Swap the contents of two widgets (must be part of same node)
void SwapWidgets(int nodeID, int widgetA, int widgetB)
{
	StoryboardNodesStruct& node = Storyboard.Nodes[nodeID];
	std::swap(node.widget_used[widgetA], node.widget_used[widgetB]);
	std::swap(node.widget_label[widgetA], node.widget_label[widgetB]);
	std::swap(node.widget_size[widgetA], node.widget_size[widgetB]);
	std::swap(node.widget_pos[widgetA], node.widget_pos[widgetB]);
	std::swap(node.widget_normal_thumb[widgetA], node.widget_normal_thumb[widgetB]);
	std::swap(node.widget_normal_thumb_id[widgetA], node.widget_normal_thumb_id[widgetB]);
	std::swap(node.widget_highlight_thumb[widgetA], node.widget_highlight_thumb[widgetB]);
	std::swap(node.widget_highlight_thumb_id[widgetA], node.widget_highlight_thumb_id[widgetB]);
	std::swap(node.widget_selected_thumb[widgetA], node.widget_selected_thumb[widgetB]);
	std::swap(node.widget_selected_thumb_id[widgetA], node.widget_selected_thumb_id[widgetB]);
	std::swap(node.widget_click_sound[widgetA], node.widget_click_sound[widgetB]);
	std::swap(node.widget_action[widgetA], node.widget_action[widgetB]);
	std::swap(node.widget_font[widgetA], node.widget_font[widgetB]);
	std::swap(node.widget_font_color[widgetA], node.widget_font_color[widgetB]);
	std::swap(node.widget_font_size[widgetA], node.widget_font_size[widgetB]);
	std::swap(node.widget_type[widgetA], node.widget_type[widgetB]);
	std::swap(node.widget_read_only[widgetA], node.widget_read_only[widgetB]);
	std::swap(node.widget_layer[widgetA], node.widget_layer[widgetB]);
	//std::swap(node.widget_output_pin[widgetA], node.widget_output_pin[widgetB]);
	std::swap(node.widget_initial_value[widgetA], node.widget_initial_value[widgetB]);	
	std::swap(node.widget_name[widgetA], node.widget_name[widgetB]);
	std::swap(Storyboard.widget_colors[nodeID][widgetA], Storyboard.widget_colors[nodeID][widgetB]);
	std::swap(Storyboard.widget_readout[nodeID][widgetA], Storyboard.widget_readout[nodeID][widgetB]);
	std::swap(Storyboard.widget_textoffset[nodeID][widgetA], Storyboard.widget_textoffset[nodeID][widgetB]);
	std::swap(Storyboard.widget_ingamehidden[nodeID][widgetA], Storyboard.widget_ingamehidden[nodeID][widgetB]);
	std::swap(Storyboard.widget_drawordergroup[nodeID][widgetA], Storyboard.widget_drawordergroup[nodeID][widgetB]);
}

void SendWidgetToFront(int nodeID, int widgetID)
{
	StoryboardNodesStruct& node = Storyboard.Nodes[nodeID];

	// Find the last widget in the array (the one that is drawn last so is at the 'front' of the screen)
	int lastIndex = -1;
	for (int i = STORYBOARD_MAXWIDGETS - 1; i >= 0; i--)
	{
		if (node.widget_used[i])
		{
			lastIndex = i;
			break;
		}
	}
	if (lastIndex < 1)
		return;

	// normal order group (draws in ID order)
	Storyboard.widget_drawordergroup[nodeID][widgetID]++;
	if (Storyboard.widget_drawordergroup[nodeID][widgetID] > 1) Storyboard.widget_drawordergroup[nodeID][widgetID] = 1;
	bool bHardcodedID = IsHardcodedID(nodeID, widgetID);
	if (bHardcodedID == true)
		return;

	// Keep swapping widgetID with its neighbour until it reaches the end of the array (the front of the screen)
	int iSwap = widgetID;
	while (iSwap < lastIndex)
	{
		bool bHardcodedID1 = IsHardcodedID(nodeID, iSwap);
		if (bHardcodedID1 == false)
		{
			bool bHardcodedID2 = IsHardcodedID(nodeID, iSwap + 1);
			if (bHardcodedID2 == false)
			{
				SwapWidgets(nodeID, iSwap, iSwap + 1);
				iCurrentSelectedWidget = iSwap + 1;
			}
		}
		iSwap++;
	}
}

void SendWidgetToBack(int nodeID, int widgetID)
{
	StoryboardNodesStruct& node = Storyboard.Nodes[nodeID];

	// draw early sort order group (and then draws in ID order)
	Storyboard.widget_drawordergroup[nodeID][widgetID]--;
	if (Storyboard.widget_drawordergroup[nodeID][widgetID] < -1) Storyboard.widget_drawordergroup[nodeID][widgetID] = -1;
	bool bHardcodedID = IsHardcodedID(nodeID, widgetID);
	if (bHardcodedID == true)
		return;

	// Keep swapping widgetID with its neighbour until it reaches the front of the array (the back of the screen)
	int iSwap = widgetID;
	while (iSwap > 0)//bRestrictShuffleWidgetsToBeyond)
	{
		bool bHardcodedID1 = IsHardcodedID(nodeID, iSwap);
		if (bHardcodedID1 == false)
		{
			bool bHardcodedID2 = IsHardcodedID(nodeID, iSwap - 1);
			if (bHardcodedID2 == false)
			{
				SwapWidgets(nodeID, iSwap, iSwap - 1);
				iCurrentSelectedWidget = iSwap - 1;
			}
		}
		iSwap--;
	}
}

unsigned int GetScancodeName(unsigned int scancode, char* buffer, unsigned int bufferLength) 
{

	// bit 16 - 23 contains the first byte of the scancode
	// bit 24 indicates that the scancode is 2 bytes(extended)
	unsigned int result = 0;
	unsigned int extended = scancode & 0xffff00;
	unsigned int lParam = 0;

	if (extended) 
	{
		if (extended == 0xE11D00) 
		{
			lParam = 0x45 << 16;
		}
		else 
		{
			lParam = (0x100 | (scancode & 0xff)) << 16;
		}
	}
	else 
	{
		lParam = scancode << 16;
		if (scancode == 0x45) 
		{
			lParam |= (0x1 << 24);
		}
	}

	result = GetKeyNameTextA(lParam, buffer, bufferLength);
	return result;
}

// Check all of the storyboard nodes for their key to toggle them. If it matches the keyboard input then make the screen appear
static std::vector<int> listenForKeys;
void TriggerScreenFromKeyPress()
{
	if (g.tabmode == 0 )
	{
		static std::vector<int> scans;
		if (listenForKeys.empty())
		{
			// Initialise listenForKeys - we only want to check for keys that will toggle a screen, if we let e.g. player movement keys through, then it will trigger the wait to release it before allowing us to toggle a screen.
			// This will allow us to trigger screens whilst moving  
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				int keyToListenFor = Storyboard.Nodes[i].toggleKey;
				if (keyToListenFor > 0)
				{
					listenForKeys.push_back(keyToListenFor);
				}
			}
		}

		// Early exit: this project has no screens that are toggled with keypresses.
		if (listenForKeys.empty())
		{
			return;
		}

		// Need to check all keys, in case we need to ignore any in m_KeyBuffer, that come before our toggle keys
		scans.clear();
		UpdateKeyboard();
		extern unsigned char m_KeyBuffer[256];
		for (int i = 0; i < 256; i++)
		{
			if (m_KeyBuffer[i] > 0)
			{
				scans.push_back(i);
			}
		}

		static bool bWaitForKeyRelease = false;
		if (scans.empty())
		{
			// No keys pressed
			bWaitForKeyRelease = false;
			return;
		}

		int scan = 0;
		// Check if the keys that are pressed are used for toggling screens
		for (int i = 0; i < scans.size(); i++)
		{
			if (std::find(listenForKeys.begin(), listenForKeys.end(), scans[i]) != listenForKeys.end())
			{
				scan = scans[i];
				break;
			}
			if (i == scans.size() - 1)
			{
				// No keys are pressed that are being 'listened' to
				bWaitForKeyRelease = false;
				return;
			}
		}

		if (bWaitForKeyRelease == false)
		{
			// If we reached here, then a key is pressed that should toggle a screen, find the screen to toggle.
			for (int i = 0; i < STORYBOARD_MAXNODES; i++)
			{
				StoryboardNodesStruct& node = Storyboard.Nodes[i];
				if (node.used && scan > 0 && node.toggleKey == scan && strlen(node.level_name) == 0) // only HUDs
				{
					if (node.type == STORYBOARD_TYPE_HUD)
					{
						// Only HUD types (not loading screens, etc)
						bWaitForKeyRelease = true;
						if (t.game.activeStoryboardScreen == i)
						{
							// Screen is already active, turn it off
							t.game.activeStoryboardScreen = -1;
						}
						else
						{
							t.game.activeStoryboardScreen = i;
						}
						return;
					}
				}
			}
		}
	}
}
void ResetStoryboardListenForKeys()
{
	listenForKeys.clear();
}

float LuaMousePosPercentX, LuaMousePosX, LuaMousePosPercentY, LuaMousePosY;
int LuaMouseClick = 0;
static char LoadGameTitle[9][256];
char cCopyToAllScreens[MAX_PATH];

void screen_editor_setscalemod (float fGlobalScaleMod)
{
	g.globalhudscale = fGlobalScaleMod;
}
float screen_editor_scalemod (float fGlobalScaleIn)
{
	return fGlobalScaleIn * g.globalhudscale;
}

int screen_editor(int nodeid, bool standalone, char *screen)
{
	extern bool g_bNoGGUntilGameGuruMainCalled;
	extern int iSpecialLuaReturn;
	iSpecialLuaReturn = -1;
	if (!g_bNoGGUntilGameGuruMainCalled)
		return -1;
	{
		ImGuiContext& gi = *GImGui;
		if (!gi.Font->IsLoaded())
			return -1;
	}

	int iRet = -1;
	int nodeidStore = nodeid;
	static bool bScreenToggleKeyWindow = false;

	ImGuiWindow* window = NULL; //ImGui::GetCurrentWindow();
	if (standalone)
	{
		bJustRederedScreenEditor = true;
		// new frame if about to use imgui to render this sprite draw list
		if ((bImGuiInTestGame) && !bRenderTabTab && !bImGuiFrameState)
		{
			//We need a new frame.
			ImGui_ImplDX11_NewFrame();
			ImGui_ImplWin32_NewFrame();
			ImGui::NewFrame();
			bRenderTabTab = true;
			bBlockImGuiUntilNewFrame = false;
			extern bool bSpriteWinVisible;
			bSpriteWinVisible = false;
			bImGuiRenderWithNoCustomTextures = false;
		}
		if (bImGuiInTestGame)
		{
			//From lua, we need to update imgui mousepos ...
			int mclick = 0;
			ImGuiIO& io = ImGui::GetIO();
			io.MouseDown[0] = 0; //PE: Mouse (release) is also lost inside blocking dialogs. Reset!
			io.MouseDown[1] = 0;
			io.MouseDown[2] = 0;
			io.MouseDown[3] = 0;
			if (g.luaactivatemouse > 0)
			{
				//PE: Use fFinalPercX,Y so VR is also supported.
				float mouseposx = LuaMousePosPercentX * ( (float) GetDisplayWidth() / 100.0f );
				float mouseposy = LuaMousePosPercentY * ( (float) GetDisplayHeight() / 100.0f);

				mclick = LuaMouseClick;
				io.MousePos.x = mouseposx; //LuaMousePosX; //MouseX();
				io.MousePos.y = mouseposy; //LuaMousePosY; //MouseY();
			}
			else
			{
				mclick = MouseClick();
			}
			if (mclick == 1) io.MouseDown[0] = 1;
			if (mclick == 2) io.MouseDown[1] = 1;
			if (mclick == 4) io.MouseDown[2] = 1;
		}
	}

	if (standalone && screen != NULL)
	{
		//Find node to display in standalone.
		nodeid = FindLuaScreenNode(screen);
		if (nodeid < 0 && g.tabmodehidehuds <= 0 && stricmp(screen, "hud0") == 0) //&& stricmp(screen, "hud0.lua") == 0)
		{
			// Special case to handle the In-Game HUD screen missing from storyboard project (from playing an old project before it was added)
			// This would not work in standalone since the default project.dat is missing 
			// Don't want to always add that file to all standalones (extra bloat) and its only for old projects that haven't had their storyboard loaded...
			// ... so this should cover 99% of cases where it is missing
			int preview_size_x = ImGui::GetMainViewport()->Size.x - 270;
			float fNodeWidth = 180.0f;
			float fNodeHeight = 130.0f;
			nodeid = storyboard_add_missing_nodex(13, preview_size_x, fNodeWidth, fNodeHeight + 20, false);
			{
				// Some users report runtime error 501, when the above code is called, regenerate unique IDs for the images just in-case
				int iUniqueIds = STORYBOARD_THUMBS;
				Storyboard.Nodes[nodeid].id = iUniqueIds;
				Storyboard.Nodes[nodeid].thumb_id = iUniqueIds;

				for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
				{
					Storyboard.Nodes[nodeid].input_id[l] = iUniqueIds + 1000 + (1000 * l);
					Storyboard.Nodes[nodeid].output_id[l] = iUniqueIds + 1000 + (1000 * l) + 500;
				}

				for (int l = 0; l < STORYBOARD_MAXWIDGETS; l++)
				{
					Storyboard.Nodes[nodeid].widget_normal_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 600;
					Storyboard.Nodes[nodeid].widget_highlight_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 700;
					Storyboard.Nodes[nodeid].widget_selected_thumb_id[l] = iUniqueIds + 1000 + (1000 * l) + 800;
				}
				Storyboard.Nodes[nodeid].screen_backdrop_id = iUniqueIds + 500;

				iUniqueIds++;
			}
		}
	}
	
	if (standalone) bPreviewScreen = true;

	if (nodeid >= 0 && ( iLastNode != nodeid || bLastStandalone != standalone ) )
	{
		//Load in lua ...
		//editors\\templates\\lua\\loading.lua
		//PE: Get loadgame data.
		//savegames\\gameslot1.dat
		bool bLoadSlots = false;
		if (stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0 || stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0)
		{
			bLoadSlots = true;
		}

		for (int i = 1; i <= 8;i++)
		{
			char slotname[256];
			sprintf(LoadGameTitle[i], "%d: EMPTY PROGRESS SLOT", i);
			if (!standalone)
			{
				// Storyboard (i.e. NOT STANDALONE) should only show placeholder slot text
				strcpy(LoadGameTitle[i], "EMPTY PROGRESS SLOT");
			}
			else
			{
				sprintf(slotname, "savegames\\gameslot%d.dat", i);
				FILE* fFile = GG_fopen(slotname, "r");
				if (fFile)
				{
					char ctmp[256];
					bool bStart = false;
					fgets(ctmp, 256 - 1, fFile);
					fgets(ctmp, 256 - 1, fFile);
					fgets(ctmp, 256 - 1, fFile);
					if (strlen(ctmp) > 0 && ctmp[strlen(ctmp) - 1] == '\n')
						ctmp[strlen(ctmp) - 1] = 0;
					if (strlen(ctmp) > 0)
					{
						strcpy(LoadGameTitle[i], ctmp);
					}
					fclose(fFile);
				}
			}
		}

		if (standalone)
		{
			int iFreeSoundID = g.temppreviewsoundoffset + 2;
			bool bKeepPlaying = false;
			if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
			{
				if (iLastNode >= 0 && strlen(Storyboard.Nodes[iLastNode].screen_music) <= 0)
				{
					//Last node did not have any music, if still playing keep playing.
					bKeepPlaying = true;
				}
			}
			if (!bKeepPlaying)
			{
				if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
				{
					// play music
					if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
					if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
					{
						LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
						if (SoundExist(iFreeSoundID) == 1)
							PlaySound(iFreeSoundID);
					}
				}
			}
		}
		else
		{
			bPreviewScreen = false;
		}
		Storyboard_ActiveWidgets.clear();

		for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
		{
			bool bWidgetUsed = false;
			if (Storyboard.Nodes[nodeid].widget_used[i] == 1)
			{
				//Load in any images.
				image_setlegacyimageloading(true);
				if (strlen(Storyboard.Nodes[nodeid].widget_normal_thumb[i]) > 0)
				{
					LoadImage(Storyboard.Nodes[nodeid].widget_normal_thumb[i], Storyboard.Nodes[nodeid].widget_normal_thumb_id[i]);
				}
				if (strlen(Storyboard.Nodes[nodeid].widget_highlight_thumb[i]) > 0)
				{
					LoadImage(Storyboard.Nodes[nodeid].widget_highlight_thumb[i], Storyboard.Nodes[nodeid].widget_highlight_thumb_id[i]);
				}
				if (strlen(Storyboard.Nodes[nodeid].widget_selected_thumb[i]) > 0)
				{
					LoadImage(Storyboard.Nodes[nodeid].widget_selected_thumb[i], Storyboard.Nodes[nodeid].widget_selected_thumb_id[i]);
				}
				image_setlegacyimageloading(false);
				bWidgetUsed = true;
			}
			bool bHardcodedID = IsHardcodedID(nodeid, i);
			if(bWidgetUsed==true || bHardcodedID==true)
			Storyboard_ActiveWidgets.push_back(i);
		}

		iUpdateBackDropNode = nodeid;
		iCurrentSelectedWidget = -1;
		iLastNode = nodeid;
		bLastStandalone = standalone;
	}
	if (iUpdateWidgetThumbNode >= 0)
	{
		image_setlegacyimageloading(true);
		if (iUpdateWidgetThumbButton >= 0)
		{
			if (strlen(Storyboard.Nodes[nodeid].widget_normal_thumb[iUpdateWidgetThumbButton]) > 0)
			{
				LoadImage(Storyboard.Nodes[nodeid].widget_normal_thumb[iUpdateWidgetThumbButton], Storyboard.Nodes[nodeid].widget_normal_thumb_id[iUpdateWidgetThumbButton]);
			}
			if (strlen(Storyboard.Nodes[nodeid].widget_highlight_thumb[iUpdateWidgetThumbButton]) > 0)
			{
				LoadImage(Storyboard.Nodes[nodeid].widget_highlight_thumb[iUpdateWidgetThumbButton], Storyboard.Nodes[nodeid].widget_highlight_thumb_id[iUpdateWidgetThumbButton]);
			}
			if (strlen(Storyboard.Nodes[nodeid].widget_selected_thumb[iUpdateWidgetThumbButton]) > 0)
			{
				LoadImage(Storyboard.Nodes[nodeid].widget_selected_thumb[iUpdateWidgetThumbButton], Storyboard.Nodes[nodeid].widget_selected_thumb_id[iUpdateWidgetThumbButton]);
			}
		}
		image_setlegacyimageloading(false);
		iUpdateWidgetThumbNode = -1;
	}
	if (iUpdateBackDropNode >= 0)
	{
		if (iUpdateBackDropNode == 99999) //All
		{
			for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
			{
				iUpdateBackDropNode = i;
				if (Storyboard.Nodes[iUpdateBackDropNode].type == STORYBOARD_TYPE_SCREEN)
				{
					///PE: Not transparent screens.
					//if (!Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_transparent)
					{
						if (ImageExist(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id)) DeleteImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);

						//PE: Also need a thumb ?
						strcpy(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop, cCopyToAllScreens);
						
						if (strlen(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop) > 0)
						{
							//Backdrop.
							image_setlegacyimageloading(true);
							LoadImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop, Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);
							image_setlegacyimageloading(false);
						}
					}
				}
			}
		}
		else
		{
			if (ImageExist(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id)) DeleteImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);
			if (strlen(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop) > 0)
			{
				//Backdrop.
				image_setlegacyimageloading(true);
				LoadImage(Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop, Storyboard.Nodes[iUpdateBackDropNode].screen_backdrop_id);
				image_setlegacyimageloading(false);
			}
		}
		iUpdateBackDropNode = -1;
	}

	static int iQuitWindowLoop = 0;
	if ( ( bScreen_Editor_Window || standalone ) && nodeid >= 0)
	{
		if (standalone)
		{
			ImGuiViewport* viewport = ImGui::GetMainViewport();

			ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
			ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
			ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
			ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always);
			ImGui::SetNextWindowViewport(viewport->ID);

			ImVec4 style_winback = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
			style_winback.w = 1.0f;
			ImGui::PushStyleColor(ImGuiCol_WindowBg, style_winback);

			
			ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
			ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);


			int flags = ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
			bool bopen = ImGui::Begin("##StoryboardStandaloneWindow", &bStoryboardWindow, flags); // ImGuiWindowFlags_NoScrollbar
		}

		int preview_size_x = ImGui::GetMainViewport()->Size.x -270;
		int preview_size_y = ImGui::GetMainViewport()->Size.y -30.0;
		if (bPreviewScreen)
		{
			preview_size_x = ImGui::GetMainViewport()->Size.x;
			preview_size_y = ImGui::GetMainViewport()->Size.y;
		}
		float fStartWinPosY = ImGui::GetCursorPosY();

		if (!bPreviewScreen)
		{
			ImGui::Columns(2, "StoryboardEditorWindowColumns", false);  //false no border
			ImGui::SetColumnOffset(0, 0.0f);
			ImGui::SetColumnOffset(1, preview_size_x+10);
		}

		//if (!standalone) window = ImGui::GetCurrentWindow();
		window = ImGui::GetCurrentWindow();

		ImVec2 vCurPos = ImGui::GetCursorPos();
		ImVec2 vIconSize = { (float)ImGui::GetFontSize()*3.5f, (float)ImGui::GetFontSize()*3.5f };
		if (!standalone)
		{

			ImGui::SetCursorPos(ImVec2(3.0f, fStartWinPosY + 1.0f));
			ImGui::SetItemAllowOverlap();
			if (ImGui::ImgBtn(TOOL_GOBACK, vIconSize, ImVec4(0, 0, 0, 0), drawCol_normal, drawCol_hover, drawCol_Down, 0, 0, 0, 0, false, false, false, false, false, bBoostIconColors))
			{
				//Everything already saved.
				if (bPreviewScreen)
				{
					//Stop music ...
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
					}
					bPreviewScreen = false;
				}
				else
				{
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
					}

					iQuitWindowLoop = 4;
				}
			}
			if (!bPreviewScreen)
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit to Storyboard");
			}
			else
			{
				if (ImGui::IsItemHovered()) ImGui::SetTooltip("%s", "Exit Preview");
			}
		}

		//Toolbar right aligned.
		cstr UniqueBackdropSelect = "##StoryboardSelectBackdrop";
		cstr UniqueMusicSelect = "##StoryboardSelectMusic";
		if (iSelectedLibraryStingReturnID == window->GetID(UniqueBackdropSelect.Get()))
		{
			strcpy(Storyboard.Nodes[nodeid].screen_backdrop, sSelectedLibrarySting.Get());
			iUpdateBackDropNode = nodeid; //Update thumb.
			sSelectedLibrarySting = "";
			iSelectedLibraryStingReturnID = -1; //disable.
		}
		if (iSelectedLibraryStingReturnID == window->GetID(UniqueMusicSelect.Get()))
		{
			strcpy(Storyboard.Nodes[nodeid].screen_music, sSelectedLibrarySting.Get());
			sSelectedLibrarySting = "";
			iSelectedLibraryStingReturnID = -1; //disable.
		}

		if (!bPreviewScreen)
		{
			//Display title in center
			ImGui::SetCursorPos(vCurPos);
			ImGui::Text("");
			ImGui::SetWindowFontScale(1.4);
			cstr luatitle = cstr("Editing: ") + cstr(Storyboard.Nodes[nodeid].title);
			ImGui::TextCenter(luatitle.Get()); // lua_name
			ImGui::SetWindowFontScale(1.0);
			ImGui::Text("");
		}

		if ( bPreviewScreen ) ImGui::SetCursorPos(vCurPos+ImVec2(0,13));
		if ( standalone ) ImGui::SetCursorPos(vCurPos);

		ImVec2 vHeaderEnd = ImGui::GetCursorPos();

		//ImGui::Separator(); //Ruin Columns ?
		ImVec2 vMonitorPos = ImVec2(0, -8.0);
		ImVec2 vMonitorBorder = ImVec2(15, 15);/*ImVec2(20, 20);*/
		//float fRatio = 1.777777; // Default ratio 1920x1080
		ImVec2 vViewportSize = ImGui::GetMainViewport()->Size;
		float fRatio = vViewportSize.x / vViewportSize.y; // Default ratio 1920x1080
		/*float fRatioInv = 0.5625;*/
		float fRatioInv = vViewportSize.y / vViewportSize.x;
		float fMaxMonitorY = preview_size_y - vHeaderEnd.y; // -ImGui::GetFontSize();
		if (bPreviewScreen) fMaxMonitorY -= 10.0f;
		ImVec2 vMonitorSize;
		float vMonitorCenterX;
		if (standalone)
		{
			vMonitorPos = ImVec2(0, 0);
			fMaxMonitorY = preview_size_y;
			vMonitorSize = ImVec2(preview_size_x , preview_size_y);
			vMonitorSize.y = vMonitorSize.x * fRatioInv;
			if (vMonitorSize.y > fMaxMonitorY )
			{
				vMonitorSize.y = fMaxMonitorY;
				vMonitorSize.x = vMonitorSize.y * fRatio;
			}
			vMonitorCenterX = preview_size_x - vMonitorSize.x;
		}
		else
		{
			vMonitorSize = ImVec2(preview_size_x - 10.0 - vMonitorPos.x - (vMonitorBorder.x*2.0), fMaxMonitorY - vMonitorPos.y - (vMonitorBorder.y*2.0));
			vMonitorSize.y = vMonitorSize.x * fRatioInv;
			if (vMonitorSize.y > fMaxMonitorY - vMonitorPos.x - (vMonitorBorder.y*2.0))
			{
				vMonitorSize.y = fMaxMonitorY - vMonitorPos.y - (vMonitorBorder.y*2.0);
				vMonitorSize.x = (vMonitorSize.y * fRatio);
			}
			vMonitorCenterX = preview_size_x - 10.0 - (vMonitorSize.x + vMonitorPos.x + (vMonitorBorder.x*2.0));
		}

		vMonitorCenterX *= 0.5;
		if (vMonitorCenterX < 0.0) vMonitorCenterX = 0.0f;

		ImVec4 tool_selected_col = ImVec4(0.5, 0.5, 0.5, 0.5); //ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
		ImVec4 monitor_col = ImVec4(0, 0, 0, 1.0); //Black for now.
		ImVec4 monitor_border = ImVec4(0.30, 0.30, 0.30, 0.75); //gray
		ImVec2 padding = { 1.0, 1.0 };
		
		ImVec2 DCCursorPos = window->DC.CursorPos;
		int panelWidth = 250;
		ImVec2 spaceAvail;// = ImGui::GetContentRegionAvail();
		ImVec2 vScreenEditorPanelSize;// = ImVec2(spaceAvail.x - vMonitorSize.x, spaceAvail.y);
		ImRect leftPanelAABB;
		ImRect currentWidgetAABB;
		leftPanelAABB.Min = ImGui::GetCursorPos();
		if (!standalone && !bPreviewScreen)
		{
			if (ImGui::IsMouseReleased(0) && bPlacingNewWidget)
			{
				bPlacingNewWidget = false;
			}

			vMonitorPos += vMonitorBorder + ImVec2(10,0);
			// Make room for panel to add/remove gadgets
			vMonitorSize.x -= panelWidth;
			vMonitorCenterX += panelWidth;

			ImVec2 spaceAvail = ImGui::GetContentRegionAvail();
			ImVec2 vScreenEditorPanelSize = ImVec2(panelWidth, spaceAvail.y);
			leftPanelAABB.Max = leftPanelAABB.Min + vScreenEditorPanelSize;

			// can make space easily as more icons are added by shrinking the size of each icon
			int iIconsOnRow = 5;
			int iSizeOfEachIcon = ((180+48)-((iIconsOnRow-1)*16)) / iIconsOnRow;

			// also, old storyboards had old allowances, so if IMAGE allowed, can also have VIDEO
			const StoryboardNodesStruct& node = Storyboard.Nodes[nodeid];
			if (node.widgets_available & ALLOW_IMAGE)
			{
				// except for HUD Screens (which are live in game and video would hit performance)
				char pHUDScreenName[256];
				sprintf(pHUDScreenName, "HUD Screen");
				if (strnicmp (Storyboard.Nodes[nodeid].title, pHUDScreenName, strlen(pHUDScreenName)) != NULL)
				{
					Storyboard.Nodes[nodeid].widgets_available |= ALLOW_VIDEO;
				}
			}

			ImGui::BeginChild("##Screeneditorleftpanel", vScreenEditorPanelSize);
			if (ImGui::StyleCollapsingHeader("Visuals##screeneditorvisual", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);
				vIconSize = ImVec2(iSizeOfEachIcon, iSizeOfEachIcon);
				int widgetsOnDisplay = 0;
				if (node.widgets_available & ALLOW_IMAGE)
				{
					if (ImGui::ImgBtn(SCREENEDITOR_IMAGE, vIconSize))
					{
						AddWidgetToScreen(nodeid, STORYBOARD_WIDGET_IMAGE);
					}
					if (ImGui::IsItemHovered())
					{
						ImGui::SetTooltip("Add an image");
					}
					widgetsOnDisplay++;
				}
				if (node.widgets_available & ALLOW_VIDEO)
				{
					if ((widgetsOnDisplay % iIconsOnRow) != 0) ImGui::SameLine();
					if (ImGui::ImgBtn(SCREENEDITOR_VIDEO, vIconSize))
					{
						AddWidgetToScreen(nodeid, STORYBOARD_WIDGET_VIDEO);
					}
					if (ImGui::IsItemHovered())
					{
						ImGui::SetTooltip("Add a video");
					}
					widgetsOnDisplay++;
				}
				if (node.widgets_available & ALLOW_TEXT)
				{
					if ((widgetsOnDisplay % iIconsOnRow) != 0) ImGui::SameLine();
					if (ImGui::ImgBtn(SCREENEDITOR_TEXT, vIconSize)) AddWidgetToScreen(nodeid, STORYBOARD_WIDGET_TEXT);
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add text line");
					widgetsOnDisplay++;
					if ((widgetsOnDisplay % iIconsOnRow) != 0) ImGui::SameLine();
					if (ImGui::ImgBtn(SCREENEDITOR_TEXTAREA, vIconSize))
					{
						AddWidgetToScreen(nodeid, STORYBOARD_WIDGET_TEXTAREA);
					}
					if (ImGui::IsItemHovered()) ImGui::SetTooltip("Add text area");
					widgetsOnDisplay++;
				}
				if (node.widgets_available & ALLOW_BUTTON)
				{
					if ((widgetsOnDisplay % iIconsOnRow) != 0)
					{
						ImGui::SameLine();
					}
					if (ImGui::ImgBtn(SCREENEDITOR_BUTTON, vIconSize))
					{
						AddWidgetToScreen(nodeid, STORYBOARD_WIDGET_BUTTON);
					}
					if (ImGui::IsItemHovered())
					{
						ImGui::SetTooltip("Add a button");
					}
					widgetsOnDisplay++;
				}
				ImGui::Indent(-10);
			}
			if (ImGui::StyleCollapsingHeader("Readouts##screeneditorreadout", ImGuiTreeNodeFlags_DefaultOpen))
			{
				// Display readouts
				ImGui::Indent(10);
				ImGui::Spacing();
				ImVec2 offset = ImVec2(0.0f,-9.0f);
				ImVec2 readoutIconSize = ImVec2(30, 30);
				StoryboardNodesStruct& node = Storyboard.Nodes[nodeid];
				for (int i = 0; i < readoutTitles.size(); i++)
				{
					if ((readoutLayers[i] & node.readouts_available) == 0)
					{
						// This readout is not available for the current screen
						continue;
					}

					ImGui::SetCursorPos(ImGui::GetCursorPos() + offset);
					int imgID = SCREENEDITOR_TEXT;
					if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_TEXTAREA)
					{
						imgID = SCREENEDITOR_TEXTAREA;
					}
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_IMAGE)
					{
						imgID = SCREENEDITOR_IMAGE;
					}
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_VIDEO)
					{
						imgID = SCREENEDITOR_VIDEO;
					}
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_TICKBOX)
					{
						imgID = SCREENEDITOR_TICKBOX;
					}
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_BUTTON)
					{
						imgID = SCREENEDITOR_BUTTON;
					}
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_RADIOTYPE)
					{
						imgID = SCREENEDITOR_RADIOBUTTON;
					}		
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_SLIDER)
					{
						imgID = SCREENEDITOR_SLIDER;
					}
					else if (readoutWidgetTypes[i] == STORYBOARD_WIDGET_BAR)
					{
						imgID = SCREENEDITOR_SLIDER;
					}
					ImGui::PushID(78959 + i);
					if (ImGui::ImgBtn(imgID, readoutIconSize))
					{
						AddWidgetToScreen(nodeid, readoutWidgetTypes[i], readoutTitles[i]);
					}
					ImGui::PopID();
					ImGui::SameLine();
					ImGui::SetCursorPos(ImGui::GetCursorPos() - offset);
					ImGui::Text(readoutTitles[i].c_str());
				}	
				ImGui::Indent(-10);
			}
			ImGui::EndChild();
		}

		const ImRect image_bb((DCCursorPos + ImVec2(vMonitorCenterX,0) + vMonitorPos - padding), DCCursorPos + ImVec2(vMonitorCenterX, 0) + vMonitorPos + padding + vMonitorSize);

		ImRect rMonitorArea;
		rMonitorArea.Min = image_bb.Min + padding;
		rMonitorArea.Max = image_bb.Max - padding;
		g_rStealMonitorArea = rMonitorArea;
		if (standalone)
		{
			if (ImageExist(Storyboard.Nodes[nodeid].screen_backdrop_id) && !Storyboard.Nodes[nodeid].screen_backdrop_transparent ) //PE: Support transparent if no backdrop.
			{
				//Standalone Always fill hole screen.
				window->DrawList->AddRectFilled(DCCursorPos + ImVec2(-1, -1), DCCursorPos + ImVec2(preview_size_x, preview_size_y) + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				window->DrawList->AddRectFilled(image_bb.Min + padding, image_bb.Max - padding, ImGui::GetColorU32(monitor_col));
			}
			else
			{
				extern bool bMainLoopRunning;
				extern int g_iInGameMenuState;
				if ( (!bMainLoopRunning || bTestStandalone) && g_iInGameMenuState != 1 && Storyboard.Nodes[nodeid].screen_backdrop_transparent)
				{
					//PE: Hide game screen if not inside game yet ( custom button -> settings screens).
					ImVec4 monitor_col = ImVec4(0.0, 0, 0, 1.0); //Black for now.
					window->DrawList->AddRectFilled(ImVec2(-1, -1), ImGui::GetMainViewport()->Size + ImVec2(1, 1), ImGui::GetColorU32(monitor_col));
				}
			}
		}
		else
		{
			window->DrawList->AddRectFilled(image_bb.Min - vMonitorBorder, image_bb.Max + vMonitorBorder, ImGui::GetColorU32(monitor_border), 12.0, 15);
			window->DrawList->AddRectFilled(image_bb.Min + padding, image_bb.Max - padding, ImGui::GetColorU32(monitor_col));
			window->DrawList->AddRect(image_bb.Min, image_bb.Max, ImGui::GetColorU32(tool_selected_col), 0.0f, 15, 2.0f);
			if ( Storyboard.Nodes[nodeid].screen_backdrop_transparent && !bPreviewScreen) //PE: Support transparent if no backdrop.
			{
				ID3D11ShaderResourceView* lpTexture = GetImagePointerView(STORYBOARD_TRANSPARET);
				if (lpTexture)
				{
					//Display transparent backdrop. stretch.
					window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min + padding, image_bb.Max - padding, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 0.25)));
				}
			}
		}
		if (ImageExist(Storyboard.Nodes[nodeid].screen_backdrop_id))
		{
			//Draw backdrop.
			ID3D11ShaderResourceView* lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].screen_backdrop_id);
			if (lpTexture)
			{
				//Support center,stretch,zoom
				if (Storyboard.Nodes[nodeid].screen_backdrop_placement == 0)
				{
					//Center;

					float img_w = ImageWidth(Storyboard.Nodes[nodeid].screen_backdrop_id);
					float img_h = ImageHeight(Storyboard.Nodes[nodeid].screen_backdrop_id);

					ImVec2 vSize = ImVec2(preview_size_x, preview_size_y);
					if (!standalone) vSize = vMonitorSize;

					if (img_w > vSize.x || img_h > vSize.y) 
					{
						float fRatio = 1.0f / (img_w / img_h);
						img_w = vSize.x;
						img_h = vSize.x * fRatio;
						if (img_h > vSize.y) 
						{
							float fRatio = 1.0f / (img_h / img_w);
							img_h = vSize.y;
							img_w = vSize.y * fRatio;
						}
					}

					ImVec2 img_pos = rMonitorArea.Min;
					if (standalone) img_pos = DCCursorPos;

					img_pos.x += (vSize.x - img_w) * 0.5;
					img_pos.y += (vSize.y - img_h) * 0.5;
					window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
				}
				else if (Storyboard.Nodes[nodeid].screen_backdrop_placement == 2)
				{
					//Zoom
					float img_w = ImageWidth(Storyboard.Nodes[nodeid].screen_backdrop_id);
					float img_h = ImageHeight(Storyboard.Nodes[nodeid].screen_backdrop_id);

					ImVec2 vSize = ImVec2(preview_size_x, preview_size_y);
					if (!standalone) vSize = vMonitorSize;
					float fRatio = 1.0f / (img_h / img_w);
					img_h = vSize.y;
					img_w = vSize.y * fRatio;
					if (img_w < vSize.x)
					{
						float adjustx = vSize.x - img_w;
						img_w += adjustx;
						img_h += adjustx * (1.0f / (img_w / img_h)); //PE: Ups the other way around.
					}

					ImVec2 img_pos = rMonitorArea.Min;
					if (standalone) img_pos = DCCursorPos;

					img_pos.x += (vSize.x - img_w) * 0.5;
					img_pos.y += (vSize.y - img_h) * 0.5;

					if (!standalone) window->DrawList->PushClipRect(rMonitorArea.Min, rMonitorArea.Max, true);
					window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					if (!standalone) window->DrawList->PopClipRect();

				}
				else //if (Storyboard.Nodes[nodeid].screen_backdrop_placement == 1)
				{
					//Stretch
					if (standalone)
					{
						const ImRect image_bb((DCCursorPos + vMonitorPos - padding), DCCursorPos + vMonitorPos + padding + vMonitorSize);
						window->DrawList->AddImage((ImTextureID)lpTexture, DCCursorPos, DCCursorPos + ImVec2(preview_size_x, preview_size_y), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					}
					else
					{
						window->DrawList->AddImage((ImTextureID)lpTexture, image_bb.Min + padding, image_bb.Max - padding, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					}
				}
			}
		}
		if (!standalone)
		{
			//Moved grid to after backdrop.
			if (bDisplayGrid && !bPreviewScreen && iQuitWindowLoop <= 0)
			{
				if (Storyboard.Nodes[nodeid].screen_grid_size > 0)
				{
					//ImVec2 vScale = vMonitorSize / ImVec2(1980.0, 1080);
					ImVec2 vScale = vMonitorSize / vViewportSize;
					ImVec4 tool_selected_col = ImVec4(0.75, 0.75, 0.75, 0.25); //ImGui::GetStyle().Colors[ImGuiCol_PlotHistogram];
					float grid_size = Storyboard.Nodes[nodeid].screen_grid_size;
					ImVec2 fOnePercent = ImVec2(vMonitorSize.x / 100.0, vMonitorSize.y / 100.0); //PE: This can be changed in the future to support different screen ratio settings.
					float grid_step = (grid_size * fOnePercent.x); // *vScale.x;
					for (float fx = (image_bb.Min.x + padding.x); fx < (image_bb.Max.x - padding.x); fx += grid_step)
					{
						ImVec2 linefrom = ImVec2(fx, image_bb.Min.y + padding.y);
						ImVec2 lineto = ImVec2(fx, image_bb.Max.y - padding.y);
						window->DrawList->AddLine(linefrom, lineto, ImGui::GetColorU32(tool_selected_col));
					}
					grid_step = (grid_size * fOnePercent.y); // *vScale.y;
					for (float fy = (image_bb.Min.y + padding.y); fy < (image_bb.Max.y - padding.y); fy += grid_step)
					{
						ImVec2 linefrom = ImVec2(image_bb.Min.x + padding.x, fy);
						ImVec2 lineto = ImVec2(image_bb.Max.x - padding.x, fy);
						window->DrawList->AddLine(linefrom, lineto, ImGui::GetColorU32(tool_selected_col));
					}
				}
			}
		}

		extern float screen_editor_scalemod (float);
		float fGlobalScale = screen_editor_scalemod(vViewportSize.x / 1920.0f);

		ImVec2 vScale = vMonitorSize / vViewportSize;
		ImVec2 vMonitorStart = ImVec2(vMonitorCenterX, 0) + vHeaderEnd + vMonitorPos;
		ImVec2 vMonitorEnd = ImVec2(vMonitorCenterX, 0) + vHeaderEnd + vMonitorPos + vMonitorSize;

		ImGui::SetWindowFontScale(vScale.y);

		ImGui::SetCursorPos(vMonitorStart);

		ImGui::SetWindowFontScale(vScale.y);
		ImGui::SetCursorPos(vMonitorEnd);

		if (iCurrentSelectedWidget < 0) iCurrentSelectedWidget = 0;
		int iSkipWidgetSelectionForFrames = 0;

		if (standalone == false)
		{
			// Determine which widget is selected
			ImVec2 cursorStore = ImGui::GetCursorPos();
			int iWidgetSelectedThisFrame = -1;

			for (int early = 1; early >= -1; early--)
			{
				for (int i = STORYBOARD_MAXWIDGETS; i >= 0; i--)
				{
					bool bSelectThis = false;
					if (Storyboard.widget_drawordergroup[nodeid][i] == early) bSelectThis = true;
					if (bSelectThis == false)
						continue;

					ImVec2 fOnePercent = ImVec2(vMonitorSize.x / 100.0, vMonitorSize.y / 100.0);
					ImVec2 widget_pos = Storyboard.Nodes[nodeid].widget_pos[i] * fOnePercent; //Real screen pos.
					ImVec2 widget_size = ImVec2(500, 74); //Default widget size.
					widget_size = widget_size * vScale;
					widget_size = widget_size * fGlobalScale;
					float font_scale = WidgetSelectUsedFont(nodeid, i);
					ImGui::SetWindowFontScale(font_scale * vScale.x * fGlobalScale * fabs(Storyboard.Nodes[nodeid].widget_font_size[i]));
					if (ImageExist(Storyboard.Nodes[nodeid].widget_normal_thumb_id[i]))
					{
						widget_size.x = ImageWidth(Storyboard.Nodes[nodeid].widget_normal_thumb_id[i]);
						widget_size.y = ImageHeight(Storyboard.Nodes[nodeid].widget_normal_thumb_id[i]);
						widget_size = widget_size * vScale; //Scale to visible screen size.
						widget_size = widget_size * fGlobalScale;
						widget_size = widget_size * Storyboard.Nodes[nodeid].widget_size[i];
					}
					else
					{
						cstr text = Storyboard.Nodes[nodeid].widget_label[i];
						if (text.Len() <= 0) text = "Empty Text";
						widget_size = ImGui::CalcTextSize(text.Get());
					}
					widget_pos = (widget_pos - ImVec2((widget_size.x * 0.5), 0.0)); //Scale to visible screen size.
					ImGui::SetCursorPos(vMonitorStart + widget_pos);
					ImGui::Dummy(widget_size);
					if (ImGui::IsItemHovered())
					{
						if (!ImGui::IsMouseDragging(0) && ImGui::IsMouseDown(0))
						{
							if (iSkipWidgetSelectionForFrames == 0 && iWidgetSelectedThisFrame < 0)
							{
								iCurrentSelectedWidget = i;
								iWidgetSelectedThisFrame = i;
								ImGui::PopFont();
								break;
							}
						}
					}
					ImGui::PopFont();
				}
			}
			ImGui::SetCursorPos(cursorStore);
		}
		
		// Draw all widgets (early and regular)
		int iMinDraw = -1;
		int iMaxDraw =  1;
		for(int early = iMinDraw; early <= iMaxDraw; early++ )
		{
			for (int i = 0; i < Storyboard_ActiveWidgets.size(); i++)
			{
				bool bDrawThis = false;
				if (Storyboard.widget_drawordergroup[nodeid][i] < iMinDraw || Storyboard.widget_drawordergroup[nodeid][i] > iMaxDraw)
				{
					// ensure ALWAYS within the draw order slots!
					Storyboard.widget_drawordergroup[nodeid][i] = 0;
				}
				if (Storyboard.widget_drawordergroup[nodeid][i] == early) bDrawThis = true;
				if (bDrawThis == false)
					continue;
				
				int index = Storyboard_ActiveWidgets[i];
				bool bUsed = Storyboard.Nodes[nodeid].widget_used[index];
				if (bUsed == false)
					continue;

				bool bReadOnly = Storyboard.Nodes[nodeid].widget_read_only[index];
				bool bSpecialLuaReturnValue = false;
				if (bReadOnly)
				{
					if (index >= 1 && index <= 8 && (stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0 || stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0 ) )
					{
						strcpy(Storyboard.Nodes[nodeid].widget_label[index], LoadGameTitle[index]);
						bReadOnly = false;
					}
				}

				// can hide any widget if flagged as so
				bool bIsWidgetHidden = bImGuiInTestGame && Storyboard.widget_ingamehidden[nodeid][index];
				if (bIsWidgetHidden == true)
					continue;

				//ImVec2 fOnePercent = ImVec2(1920.0 / 100.0, 1080.0 / 100.0); //PE: This can be changed in the future to support different screen ratio settings.
				ImVec2 fOnePercent = ImVec2(vMonitorSize.x / 100.0, vMonitorSize.y / 100.0);
				bool bUsePivotXCenter = true;
				int iTextAdjustment = 1; // 0=left, 1=center , 2=right

				ImVec2 widget_pos = Storyboard.Nodes[nodeid].widget_pos[index] * fOnePercent; //Real screen pos.
				ImVec2 widget_size = ImVec2(500, 74); //Default widget size.
				widget_size = widget_size * vScale;
				widget_size = widget_size * fGlobalScale;

				//One widget can only use one font, so select it now and use for all functions.
				float font_scale = WidgetSelectUsedFont(nodeid, index);
				ImGui::SetWindowFontScale(font_scale*vScale.x* fGlobalScale* fabs(Storyboard.Nodes[nodeid].widget_font_size[index]));

				//Is a kind of progress bar?
				bool bProgressbar = false;
				if (   Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_PROGRESS
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER
					|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BAR)
					bProgressbar = true;

				//Widget Button
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON 
				|| bProgressbar 
				|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_RADIOTYPE 
				|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TICKBOX)
				{
					if (ImageExist(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]))
					{
						widget_size.x = ImageWidth(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
						widget_size.y = ImageHeight(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
						widget_size = widget_size * vScale; //Scale to visible screen size.
						widget_size = widget_size * fGlobalScale;
						widget_size = widget_size * Storyboard.Nodes[nodeid].widget_size[index];
					}

					if (bUsePivotXCenter)
						widget_pos = (widget_pos - ImVec2((widget_size.x*0.5), 0.0)); //Scale to visible screen size.

					ImGui::SetCursorPos(vMonitorStart + widget_pos);
					ImGui::Dummy(widget_size);
					bool bHovered = false;
					if (ImGui::IsItemHovered())
					{
						bHovered = true;
					}
					//Button Image
					ID3D11ShaderResourceView* lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
					if(!bProgressbar && bHovered) lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_RADIOTYPE)
					{
						// used by GRAPHICS SETTINGS (1,2,3)
						int iMatchToSettingValue = -1;
						if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "LOW") == NULL) iMatchToSettingValue = 1;
						if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "MEDIUM") == NULL) iMatchToSettingValue = 2;
						if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "HIGHEST") == NULL) iMatchToSettingValue = 3;
						if (Storyboard.NodeRadioButtonSelected[nodeid] < 0.0) Storyboard.NodeRadioButtonSelected[nodeid] = 3;// iMatchToSettingValue; HIGHEST always default
						if (Storyboard.NodeRadioButtonSelected[nodeid] == iMatchToSettingValue)
						{
							lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_selected_thumb_id[index]);
							if(!lpTexture) lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
						}
					}
					else if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TICKBOX)
					{
						bool bEnabled = false;
						if (strlen(Storyboard.widget_readout[nodeid][index]) > 0)
						{
							// Tickboxes - on/off
							bEnabled = GetReadoutValueInt(Storyboard.widget_readout[nodeid][index]);
						}
						else
						{
							// Using NodeSliderValues to prevent having to add to StoryboardStruct
							if (Storyboard.NodeSliderValues[nodeid][index] > 0.0f)
							{
								bEnabled = true;
							}
						}

						if (bEnabled)
						{
							lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_selected_thumb_id[index]);
							if (!lpTexture) lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
						}
					}
					if (lpTexture)
					{
						ImGui::SetCursorPos(vMonitorStart + widget_pos);
						ImVec2 img_pos = ImGui::GetWindowPos() + vMonitorStart + widget_pos;
						img_pos.y -= ImGui::GetScrollY();
						window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + widget_size, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
					}
					if (bProgressbar)
					{
						lpTexture = GetImagePointerView(Storyboard.Nodes[nodeid].widget_highlight_thumb_id[index]);
						if (lpTexture)
						{
							static float fProgress = 0.0;
							if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BAR)
							{
								if (stricmp(Storyboard.widget_readout[nodeid][index], "User Defined Global Statusbar") == NULL)
								{
									// split label (first;second) so can read globals separately
									char storeFirstEntry[MAX_PATH];
									strcpy(storeFirstEntry, "");
									strcpy(storeFirstEntry, Storyboard.Nodes[nodeid].widget_label[index]);
									char storeSecondEntry[MAX_PATH];
									strcpy(storeSecondEntry, "");
									char* pDelimit = strstr(storeFirstEntry, ";");
									if (pDelimit)
									{
										strcpy(storeSecondEntry, pDelimit + 1);
										*pDelimit = 0;
									}

									// placeholder for all user defined global values
									if (bImGuiInTestGame == false)
									{
										// placeholder shown in screen editor
										fProgress = Storyboard.Nodes[nodeid].widget_initial_value[index];
									}
									else
									{
										// read from active LUA, i.e. g_UserGlobal[yourscript.user_variable_name]
										char pUserDefinedGlobal[256];
										int readoutValueFromLUA1 = 0;
										int readoutValueFromLUA2 = 0;
										if (stricmp(storeFirstEntry, "Health Remaining") == NULL)
										{
											readoutValueFromLUA1 = t.player[t.plrid].health;
										}
										else
										{
											if (stricmp(storeFirstEntry, "Lives Remaining") == NULL)
											{
												readoutValueFromLUA1 = t.player[t.plrid].lives;
											}
											else
											{
												if (stricmp(storeFirstEntry, "Ammo Remaining") == NULL)
												{
													readoutValueFromLUA1 = t.slidersmenuvalue[1][1].value;
												}
												else
												{
													if (stricmp(storeFirstEntry, "Maximum Ammo") == NULL)
													{
														readoutValueFromLUA1 = t.slidersmenuvalue[1][2].value;
													}
													else
													{
														sprintf(pUserDefinedGlobal, "g_UserGlobal['%s']", storeFirstEntry);
														readoutValueFromLUA1 = LuaGetInt(pUserDefinedGlobal);
													}
												}
											}
										}
										if (stricmp(storeSecondEntry, "Maximum Health") == NULL)
										{
											readoutValueFromLUA2 = t.playercontrol.startstrength;
										}
										else
										{
											if (stricmp(storeSecondEntry, "Weapon Reload Quantity") == NULL)
											{
												readoutValueFromLUA2 = g.firemodes[t.gunid][g.firemode].settings.reloadqty;
											}
											else
											{
												if (stricmp(storeSecondEntry, "Maximum Clipped Ammo") == NULL)
												{ 
													int iClipCapacity = g.firemodes[t.gunid][g.firemode].settings.clipcapacity;
													if (iClipCapacity == 0) iClipCapacity = 50; // if no clip size specified, default to 50
													readoutValueFromLUA2 = g.firemodes[t.gunid][g.firemode].settings.reloadqty * iClipCapacity;
												}
												else
												{
													sprintf(pUserDefinedGlobal, "g_UserGlobal['%s']", storeSecondEntry);
													readoutValueFromLUA2 = LuaGetInt(pUserDefinedGlobal);
												}
											}
										}
										fProgress = ((float)readoutValueFromLUA1/(float)readoutValueFromLUA2)*100.0f;
									}
								}
								else
								{
									// no value if not from user global
									fProgress = 0.0f;
								}
							}
							else if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
							{
								//Must be changeable.
								if (strlen(Storyboard.widget_readout[nodeid][index]) > 0)
								{
									fProgress = GetReadoutValueInt(Storyboard.widget_readout[nodeid][index]);
								}
								else
								{
									fProgress = Storyboard.NodeSliderValues[nodeid][index];
								}
							}
							else
							{
								if (standalone)
								{
									if (bStartLoadingGame && iFakeLoadGameTest > 0)
										fProgress = 100 - iFakeLoadGameTest;
									else
										fProgress = t.game.levelloadprogress;
								}
								else
								{
									fProgress += 0.25;
								}
								if (fProgress >= 100.0) fProgress = 0.0;
							}
							ImVec2 vSize = widget_size;
							vSize.x = (widget_size.x / 100.0) * fProgress;
							ImGui::SetCursorPos(vMonitorStart + widget_pos);
							ImVec2 img_pos = ImGui::GetWindowPos() + vMonitorStart + widget_pos;
							img_pos.y -= ImGui::GetScrollY();
							window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + vSize, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
						}
					}

					//Text Label
					if (Storyboard.Nodes[nodeid].widget_type[index] != STORYBOARD_WIDGET_BAR)
					{
						// is this a special button
						char pDestStr[MAX_PATH];
						strcpy(pDestStr, "");
						LPSTR pWidgetLabel = Storyboard.Nodes[nodeid].widget_label[index];
						if (strnicmp(pWidgetLabel, "quest:", 6) == NULL && bImGuiInTestGame)
						{
							char pUserDefinedGlobal[256];
							sprintf(pUserDefinedGlobal, "g_UserGlobal['%s']", pWidgetLabel);
							LuaGetString(pUserDefinedGlobal, pDestStr);
							pWidgetLabel = pDestStr;
						}

						// render text for button and other things
						ImVec2 fTextAdjust = ImVec2(0.0f, 0.0f);
						ImVec2 fTextSize = ImGui::CalcTextSize(pWidgetLabel); //Already scaled.
						if (iTextAdjustment == 0)
							fTextAdjust.y = (widget_size.y * 0.5) - (fTextSize.y * 0.5); //y always center
						else if (iTextAdjustment == 1)
							fTextAdjust = (widget_size * 0.5) - (fTextSize * 0.5);
						else if (iTextAdjustment == 2)
						{
							fTextAdjust.x = widget_size.x - fTextSize.x - 4.0; //4.0 = padding.
							fTextAdjust.y = widget_size.y * 0.5 - fTextSize.y * 0.5; //y always center
						}
						fTextAdjust += Storyboard.widget_textoffset[nodeid][index];
						if (Storyboard.Nodes[nodeid].widget_font_size[index] > 0)
						{
							ImGui::SetCursorPos(vMonitorStart + widget_pos + fTextAdjust);
							ImGui::TextColored(Storyboard.Nodes[nodeid].widget_font_color[index], pWidgetLabel);
						}
					}
				}
			
				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXT
				|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
				{
					cstr text = Storyboard.Nodes[nodeid].widget_label[index];
					if (stricmp(Storyboard.widget_readout[nodeid][index], "User Defined Global") == NULL)
					{
						// placeholder for all user defined global values
						if (bImGuiInTestGame==false)
						{
							// placeholder shown in screen editor
							char valueStr[64];
							sprintf(valueStr, "%d", Storyboard.Nodes[nodeid].widget_initial_value[index]);
							text = valueStr;
						}
						else
						{
							// read from active LUA, i.e. g_UserGlobal[yourscript.user_variable_name]
							char pUserDefinedGlobal[256];
							sprintf(pUserDefinedGlobal, "g_UserGlobal['%s']", Storyboard.Nodes[nodeid].widget_label[index]);
							int readoutValueFromLUA = LuaGetInt(pUserDefinedGlobal);
							char valueStr[64];
							sprintf(valueStr, "%d", readoutValueFromLUA);
							text = valueStr;
						}
					}
					else if (stricmp(Storyboard.widget_readout[nodeid][index], "User Defined Global Text") == NULL)
					{
						// placeholder for all user defined global values
						if (bImGuiInTestGame == false)
						{
							// placeholder shown in screen editor
							char valueStr[64];
							sprintf(valueStr, "%s", "[text]");// Storyboard.Nodes[nodeid].widget_initial_value[index]);
							text = valueStr;
						}
						else
						{
							// read from active LUA
							char pUserDefinedGlobal[256];
							sprintf(pUserDefinedGlobal, "g_UserGlobal['%s']", Storyboard.Nodes[nodeid].widget_label[index]);
							char pDestStr[MAX_PATH];
							strcpy(pDestStr, "");
							LuaGetString(pUserDefinedGlobal, pDestStr);
							text = pDestStr;
						}
					}
					else
					{
						if ((bImGuiInTestGame || standalone) && strlen(Storyboard.widget_readout[nodeid][index]) > 0)
						{
							// special code to hide certain HUDs
							bool bHideThis = false;
							if (t.player[1].health == 99999 || t.huddamage.immunity > 0)
							{
								if (stricmp (Storyboard.widget_readout[nodeid][index], "Health Remaining") == NULL) bHideThis = true;
								if (stricmp (Storyboard.widget_readout[nodeid][index], "Maximum Health") == NULL) bHideThis = true;
								if (stricmp (Storyboard.widget_readout[nodeid][index], "Lives Remaining") == NULL) bHideThis = true;
							}
						
							// Display the variable value that this readout represents
							if (bHideThis == false)
							{
								int readoutValue = GetReadoutValueInt(Storyboard.widget_readout[nodeid][index]);
								if (readoutValue != -INT_MAX) // -INT_MAX indicates failure to get the readout value
								{
									char valueStr[64];
									sprintf(valueStr, "%d", readoutValue);
									text = valueStr;
								}
								else
								{
									text = "";
								}
							}
							else
							{
								text = "";
							}
						}
					}

					//PE: Cant have empty text, we cant see it, where to select it.
					if (!bPreviewScreen && text.Len() <= 0) text = "Empty Text";

					widget_size = ImGui::CalcTextSize(text.Get());
					if (bUsePivotXCenter)
						widget_pos = (widget_pos - ImVec2((widget_size.x * 0.5), 0.0));

					ImGui::SetCursorPos(vMonitorStart + widget_pos);
					ImGui::Dummy(widget_size);
					bool bHovered = false;
					if (ImGui::IsItemHovered())
					{
						bHovered = true;
					}

					ImGui::SetCursorPos(vMonitorStart + widget_pos);
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
						ImGui::PushTextWrapPos(0.0f);

					// show text if in edit mode, do not show text in game and hidden
					LPSTR pTextToShow = text.Get();
					if (bImGuiInTestGame == false)
					{
						if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0) pTextToShow = "(H)";
					}
					else
					{
						if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0) pTextToShow = NULL;
					}
					if(pTextToShow) ImGui::TextColored(Storyboard.Nodes[nodeid].widget_font_color[index], pTextToShow);

					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TEXTAREA)
						ImGui::PopTextWrapPos();
				}

				// monitor for screen changes to remove any lingering video
				static int g_iLastScreenNodeID = -1;
				if (g_iLastScreenNodeID != nodeid)
				{
					g_iLastScreenNodeID = nodeid;
					if (g_iStoryboardScreenVideoID > 0)
					{
						if (AnimationExist(g_iStoryboardScreenVideoID) == 1) DeleteAnimation(g_iStoryboardScreenVideoID);
						g_iStoryboardScreenVideoID = 0;
					}
				}

				if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_IMAGE
				|| Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_VIDEO)
				{
					bool bWidgetIsVideo = false;
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_VIDEO ) 
						bWidgetIsVideo = true;

					int imgID = Storyboard.Nodes[nodeid].widget_normal_thumb_id[index];
					if (nodeidStore == -1 && strlen(Storyboard.widget_readout[nodeid][index]) > 0)
					{
						// Get the image ID to display the readout
						t.iTmpImgID = Storyboard.Nodes[nodeid].widget_normal_thumb_id[index];
						imgID = GetReadoutValueInt(Storyboard.widget_readout[nodeid][index]);
						if (imgID == -INT_MAX)
						{
							imgID = 0;
						}
					}
					if (bWidgetIsVideo==false && bImGuiInTestGame == true)
					{
						// special code to hide certain HUDs
						bool bHideThis = false;
						if (t.player[1].health == 99999 || t.huddamage.immunity > 0)
						{
							if (stricmp (Storyboard.widget_readout[nodeid][index], "Health Panel") == NULL) bHideThis = true;
						}
						if (bHideThis == true)
						{
							imgID = 0;
						}
					}
					else
					{
						// only in HUD editor mode
						if (ImageExist(imgID) == 0)
						{
							// if no image, cannot grab widget or delete it, so use a placeholder
							image_setlegacyimageloading(true);
							LoadImage("imagebank\\HUD Library\\MAX\\missing.png", imgID);
							image_setlegacyimageloading(false);

							// also possible it was placed outside of screen if the missing image was large!
							Storyboard.Nodes[nodeid].widget_pos[index].x = 50.0f;
							Storyboard.Nodes[nodeid].widget_pos[index].y = 50.0f;
						}
					}
					if (ImageExist(imgID))
					{
						widget_size.x = ImageWidth(imgID);
						widget_size.y = ImageHeight(imgID);
						widget_size = widget_size * vScale; //Scale to visible screen size.
						widget_size = widget_size * fGlobalScale;
						widget_size = widget_size * Storyboard.Nodes[nodeid].widget_size[index];
					}

					if (bUsePivotXCenter)
						widget_pos = (widget_pos - ImVec2((widget_size.x*0.5), 0.0)); //Scale to visible screen size.

					ImGui::SetCursorPos(vMonitorStart + widget_pos);
					ImGui::Dummy(widget_size);
					bool bHovered = false;
					if (ImGui::IsItemHovered())
					{
						bHovered = true;
					}
					bool bIsWidgetHidden = bImGuiInTestGame && Storyboard.widget_ingamehidden[nodeid][Storyboard_ActiveWidgets[i]];
					if (bIsWidgetHidden)
					{
						// Hide images
					}
					else
					{
						// Handle Video
						if (bWidgetIsVideo == true && t.game.gameisexe == 1)
						{
							// Display and Handle Video if in Standalone
							if (g_iStoryboardScreenVideoID == 0)
							{
								for (int itl = 1; itl <= 32; itl++)
								{
									if (AnimationExist(itl) == 0) { g_iStoryboardScreenVideoID = itl; break; }
								}
								char pFinalVideoFilePath[MAX_PATH];
								strcpy(pFinalVideoFilePath, Storyboard.Nodes[nodeid].widget_highlight_thumb[index]);
								GG_GetRealPath(pFinalVideoFilePath, 0);
								if (LoadAnimation(pFinalVideoFilePath, g_iStoryboardScreenVideoID, g.videoprecacheframes, 0, 1) == false)
								{
									g_iStoryboardScreenVideoID = -999;
								}
								if (g_iStoryboardScreenVideoID > 0)
								{
									SetVideoVolume(100.0);
									if (Storyboard.Nodes[nodeid].widget_font_size[index] != 0)
									{
										LoopAnimation(g_iStoryboardScreenVideoID);
									}
									else
									{
										PlayAnimation(g_iStoryboardScreenVideoID);
									}
									SetRenderAnimToImage(g_iStoryboardScreenVideoID, true);
									UpdateAllAnimation();
								}
							}
							else
							{
								UpdateAllAnimation();
								if (g_iStoryboardScreenVideoID > 0)
								{
									if (AnimationExist(g_iStoryboardScreenVideoID) && AnimationPlaying(g_iStoryboardScreenVideoID))
									{
										ID3D11ShaderResourceView* lpVideoTexture = GetAnimPointerView(g_iStoryboardScreenVideoID);
										float fVideoW = GetAnimWidth(g_iStoryboardScreenVideoID);
										float fVideoH = GetAnimHeight(g_iStoryboardScreenVideoID);
										if (lpVideoTexture)
										{
											ImGuiWindow* window = ImGui::GetCurrentWindow();
											ImGui::SetCursorPos(vMonitorStart + widget_pos);
											ImRect image_bb(window->DC.CursorPos, window->DC.CursorPos + widget_size);
											float animU = GetAnimU(g_iStoryboardScreenVideoID);
											float animV = GetAnimV(g_iStoryboardScreenVideoID);
											ImVec2 uv0 = ImVec2(0, 0);
											ImVec2 uv1 = ImVec2(animU, animV);
											window->DrawList->AddImage((ImTextureID)lpVideoTexture, image_bb.Min, image_bb.Max, uv0, uv1, ImGui::GetColorU32(ImVec4(1.0f, 1.0f, 1.0f, 1.0f)));
										}
									}
								}
								else
								{
									// video was not loaded, so -999 in effect!
								}
							}
						}
						else
						{
							// Display Image
							void* lpTexture = GetImagePointer(imgID);
							if (lpTexture)
							{
								ImGui::SetCursorPos(vMonitorStart + widget_pos);
								ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
								ImVec4 imageColor = Storyboard.widget_colors[nodeid][Storyboard_ActiveWidgets[i]];
								ImGui::ImgBtn(imgID, widget_size, ImColor(255, 255, 255, 0), imageColor, imageColor, imageColor, 0);
								ImGui::PopItemFlag();
							}
						}
					}

					if (bWidgetIsVideo == false)
					{
						// no text if a global panel
						bool bShowText = true;
						cstr text = Storyboard.Nodes[nodeid].widget_label[index];
						if (stricmp(Storyboard.widget_readout[nodeid][index], "User Defined Global Image") == NULL) bShowText = false;
						if (stricmp(Storyboard.widget_readout[nodeid][index], "User Defined Global Panel") == NULL) bShowText = false;

						//Text Label
						if (bShowText == true)
						{
							LPSTR pTextToShow = Storyboard.Nodes[nodeid].widget_label[index];
							if (Storyboard.Nodes[nodeid].widget_font_size[index] < 0) pTextToShow = "(H)";
							ImVec2 fTextAdjust = ImVec2(0.0, 0.0);
							ImVec2 fTextSize = ImGui::CalcTextSize(Storyboard.Nodes[nodeid].widget_label[index]); //Already scaled.
							if (iTextAdjustment == 0)
								fTextAdjust.y = (widget_size.y * 0.5) - (fTextSize.y * 0.5); //y always center
							else if (iTextAdjustment == 1)
								fTextAdjust = (widget_size * 0.5) - (fTextSize * 0.5);
							else if (iTextAdjustment == 2)
							{
								fTextAdjust.x = widget_size.x - fTextSize.x - 4.0; //4.0 = padding.
								fTextAdjust.y = widget_size.y * 0.5 - fTextSize.y * 0.5; //y always center
							}
							fTextAdjust += Storyboard.widget_textoffset[nodeid][index];
							ImGui::SetCursorPos(vMonitorStart + widget_pos + fTextAdjust);
							ImGui::TextColored(Storyboard.Nodes[nodeid].widget_font_color[index], pTextToShow);
						}
					}
				}

				bool bLuaPageClosing = false;

				//PE: TODO - Need to add sound on button click somewhere here!.
				cstr cTriggerButtonClickSound = "";
				if (standalone)
				{
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON)
					{
						ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
						bool bIsPointerHoveringOver = false;
						bool bIsPointerReleased = false;

						//if (g.vrglobals.GGVREnabled > 0 && g.vrglobals.GGVRUsingVRSystem == 1)
						extern int g_iActivelyUsingVRNow;
						if (g.vrglobals.GGVREnabled > 0 && g_iActivelyUsingVRNow == 1)
						{
							// VR support
							int iObjToHit = 5997;
							float fX = 0, fY = 0, fZ = 0;
							int iHitIt = GGVR_GetLaserGuidedHit (iObjToHit, &fX, &fY, &fZ);
							float fptrrealX = ((fX + 19.0f) / 38.0f) * (rMonitorArea.Max.x - rMonitorArea.Min.x);
							float fptrrealY = ((11.0f - fY) / 22.0f) * (rMonitorArea.Max.y - rMonitorArea.Min.y);
							if (GGVR_RightController_Trigger() > 0.5f)
							{
								bIsPointerReleased = true;
								ImVec2 topLeft = rMonitorArea.Min + widget_pos - vLargerGrabArea;
								ImVec2 bottomRight = rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea;
								if (fptrrealX > topLeft.x && fptrrealX < bottomRight.x)
								{
									if (fptrrealY > topLeft.y && fptrrealY < bottomRight.y)
									{
										bIsPointerHoveringOver = true;
									}
								}
							}
						}
						else
						{
							// non VR
							if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos - vLargerGrabArea, rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea)) bIsPointerHoveringOver = true;
							if (ImGui::IsMouseReleased(0)) bIsPointerReleased = true;
						}
						if (bIsPointerHoveringOver)
						{
							//if mouse release.
							if (bIsPointerReleased)
							{
								if (strlen(Storyboard.Nodes[nodeid].widget_click_sound[index]) > 0)
								{
									cTriggerButtonClickSound = Storyboard.Nodes[nodeid].widget_click_sound[index];
								}

								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_NONE)
								{
									// depends on name of this button for the action
									int iActionTypeInternalByName = 0;
									if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "HIGHEST") == 0) iActionTypeInternalByName = 1;
									if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "MEDIUM") == 0) iActionTypeInternalByName = 3;
									if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "LOW") == 0) iActionTypeInternalByName = 4;
									if (iActionTypeInternalByName >= 1 && iActionTypeInternalByName <= 4)
									{
										extern void visuals_shaderlevels_setlevel (int, bool);
										visuals_shaderlevels_setlevel(iActionTypeInternalByName,true);
									}
								}

								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_RETURNVALUETOLUA)
								{
									iSpecialLuaReturn = index;
									iRet = STORYBOARD_ACTIONS_RETURNVALUETOLUA;
									if (stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0)
									{
										if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
											bLuaPageClosing = true;
									}
									if (stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0)
									{
										if (index >= 1 && index <= 8)
										{
											if (!pestrcasestr(LoadGameTitle[index], "EMPTY PROGRESS SLOT"))
											{
												if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
													bLuaPageClosing = true;
											}
										}
									}
								}
								//Find new node to execute. SwitchPage("")
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_BACK)
								{
									lua_switchpageback();
									if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
										bLuaPageClosing = true;
									iRet = STORYBOARD_ACTIONS_BACK;
								}
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_CONTINUE)
								{
									t.s_s = "";
									lua_switchpage();
									if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0) //PE: Only stop music if we have our own.
										bLuaPageClosing = true;
									iRet = STORYBOARD_ACTIONS_CONTINUE;
								}
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_GOTOLEVEL)
								{
									//Support go to level directly ?
									iRet = STORYBOARD_ACTIONS_GOTOLEVEL;
								
									int iNewNode = FindOutputScreenNode(nodeid, index);
									if (iNewNode >= 0)
									{
										t.s_s = "";
										lua_switchpage();
										bLuaPageClosing = true;

										// may have linked to loading screen
										if (strlen(Storyboard.Nodes[iNewNode].level_name) == 0)
										{
											// will use last 'specified' loading screen
											extern cstr g_Storyboard_LoaderScreen_Name;
											g_Storyboard_LoaderScreen_Name = Storyboard.Nodes[iNewNode].lua_name;

											// if so, find out which level it goes to
											int input_id_of_level = Storyboard.Nodes[iNewNode].output_linkto[0];
											for (int findnode = 0; findnode < STORYBOARD_MAXNODES; findnode++)
											{
												if (Storyboard.Nodes[findnode].input_id[0] == input_id_of_level)
												{
													// change from loading node to level node
													iNewNode = findnode;
													break;
												}
											}
										}
									
										// must ultimately link to a level node!
										if (strlen(Storyboard.Nodes[iNewNode].level_name) > 0)
										{
											g_Storyboard_Current_Level = iNewNode;
											strcpy(g_Storyboard_Current_fpm, Storyboard.Nodes[iNewNode].level_name);

											//Clean name.
											std::string sLevelTitle = g_Storyboard_Current_fpm;
											replaceAll(sLevelTitle, ".fpm", "");
											replaceAll(sLevelTitle, "mapbank\\", "");
											t.game.jumplevel_s = sLevelTitle.c_str();
											extern bool g_Storyboard_Starting_New_Level;
											g_Storyboard_Starting_New_Level = true; //PE: Always start fresh when linking directly to a level.
										}
									}
									else
									{
										//PE: Not linked , start first level.
										t.s_s = "";
										lua_switchpage();
										bLuaPageClosing = true;
										iRet = STORYBOARD_ACTIONS_STARTGAME;

										//PE: Always use first level.
										FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm);
										g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
										strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);
										//Clean name.
										std::string sLevelTitle = g_Storyboard_First_fpm;
										replaceAll(sLevelTitle, ".fpm", "");
										replaceAll(sLevelTitle, "mapbank\\", "");
										t.game.jumplevel_s = sLevelTitle.c_str();
										extern bool g_Storyboard_Starting_New_Level;
										g_Storyboard_Starting_New_Level = true; //PE: Start a fresh game.
										// reset 'specified' loading screen
										extern cstr g_Storyboard_LoaderScreen_Name;
										g_Storyboard_LoaderScreen_Name = "loading";
									}
								}
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_STARTGAME)
								{
									t.s_s = "";
									lua_switchpage();
									bLuaPageClosing = true;
									iRet = STORYBOARD_ACTIONS_STARTGAME;

									//PE: Always use first level.
									FindFirstLevel(g_Storyboard_First_Level_Node, g_Storyboard_First_fpm);
									g_Storyboard_Current_Level = g_Storyboard_First_Level_Node;
									strcpy(g_Storyboard_Current_fpm, g_Storyboard_First_fpm);
									//Clean name.
									std::string sLevelTitle = g_Storyboard_First_fpm;
									replaceAll(sLevelTitle, ".fpm", "");
									replaceAll(sLevelTitle, "mapbank\\", "");
									t.game.jumplevel_s = sLevelTitle.c_str();
									extern bool g_Storyboard_Starting_New_Level;
									g_Storyboard_Starting_New_Level = true; //PE: Start a fresh game.
									// reset 'specified' loading screen
									extern cstr g_Storyboard_LoaderScreen_Name;
									g_Storyboard_LoaderScreen_Name = "loading";
								}
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_LEAVEGAME)
								{
									lua_leavegame();
									bLuaPageClosing = true;
									iRet = STORYBOARD_ACTIONS_LEAVEGAME;
									bLastStandalone = false;
								}
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_RESUMEGAME)
								{
									lua_resumegame();
									bLuaPageClosing = true;
									iRet = STORYBOARD_ACTIONS_RESUMEGAME;
								}

								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_EXITGAME)
								{
									lua_quitgame();
									bLuaPageClosing = true;
									iRet = STORYBOARD_ACTIONS_EXITGAME;
									bLastStandalone = false;
									extern bool bSpecialStandalone;
									if (bSpecialStandalone)
									{
										extern bool g_bCascadeQuitFlag;
										g_bCascadeQuitFlag = true;
										PostQuitMessage(0);
										//PE: Launch editor again.
										//editorfromstandalone=
										SetCurrentDirectoryA("..\\");
										char par[MAX_PATH];
										extern bool bReturnToWelcome;
										if(bReturnToWelcome)
											sprintf(par, "editorfromstandalone2=%s", Storyboard.gamename);
										else
											sprintf(par, "editorfromstandalone=%s", Storyboard.gamename);
										ExecuteFile("GameGuruMAX.exe", par, "", 0);
										Sleep(500);
										ExitProcess(0);
									}

								}
								if (Storyboard.Nodes[nodeid].widget_action[index] == STORYBOARD_ACTIONS_GOTOSCREEN)
								{
									//if (_stricmp(Storyboard.Nodes[nodeid].lua_name, "gamemenu.lua") == 0 && strlen(Storyboard.Nodes[nodeid].output_action[index]) > 0
									//	&& Storyboard.Nodes[nodeid].output_can_link_to_type[index] == STORYBOARD_TYPE_SCREEN)
									if ( _stricmp(Storyboard.Nodes[nodeid].lua_name,"gamemenu.lua") == 0 ) // output_* CANNOT be trusted!
									{
										//PE: Special mode where we need to follow output_action.
										//PE: This is a mess, and need to be changed when we change the system to ALL buttons have outlinks.
										//LB: Agreed, seems changing the in-game menu screen messed 'output_action' list, and the code below is a narsty hack!
										//The good news is that output_title stores the correct linkages as they are correct in Storyboard :)
										//i.e. strcpy(chr, Storyboard.Nodes[node].widget_label[ll]); strcat(chr, " -> Connect to Level"); strcpy(Storyboard.Nodes[node].output_title[outlinknum], chr);
										int iNodeToLinkTo = 0;
										LPSTR pWidgetLabelName = Storyboard.Nodes[nodeid].widget_label[index];
										std::string lua_name = "";
										for (int outlinkageindex = 0; outlinkageindex < STORYBOARD_MAXOUTPUTS; outlinkageindex++)
										{
											char pOutLinkTitleName[256];
											strcpy(pOutLinkTitleName, Storyboard.Nodes[nodeid].output_title[outlinkageindex]);
											LPSTR pConnectionTag = " -> Connect to Level";
											if (strlen(pOutLinkTitleName) > strlen(pConnectionTag))
											{
												pOutLinkTitleName[strlen(pOutLinkTitleName) - strlen(pConnectionTag) - 1] = 0;
												if (strstr(pOutLinkTitleName, pWidgetLabelName) != NULL)
												{
													// found the actual outlinkageindex, find where we link to
													int iLinkTo = Storyboard.Nodes[nodeid].output_linkto[outlinkageindex];
													if (iLinkTo > 0)
													{
														for (int i = 0; i < STORYBOARD_MAXNODES; i++)
														{
															if (Storyboard.Nodes[i].used)
															{
																for (int l = 0; l < STORYBOARD_MAXOUTPUTS; l++)
																{
																	if (iLinkTo == Storyboard.Nodes[i].input_id[l])
																	{
																		iNodeToLinkTo = i;
																		break;
																	}
																}
															}
															if (iNodeToLinkTo > 0) break;
														}
													}
												}
											}
											if (iNodeToLinkTo > 0)
												break;
										}
										if (iNodeToLinkTo > 0)
										{
											// screens can have same name (old corruption issue), so new method to identify screen by node
											//lua_name = Storyboard.Nodes[iNodeToLinkTo].lua_name;
											//replaceAll(lua_name, ".lua", "");
											//t.s_s = lua_name.c_str();
											std::string node_ident_name = ":node:";
											node_ident_name += std::to_string(iNodeToLinkTo);
											t.s_s = node_ident_name.c_str();
											lua_switchpage();

											bLuaPageClosing = true; //always stop music.
											iRet = STORYBOARD_ACTIONS_GOTOSCREEN;
										}
									}
									else
									{
										int iNewNode = FindOutputScreenNode(nodeid, index);
										if (iNewNode >= 0)
										{
											//Connected.
											if (Storyboard.Nodes[iNewNode].type == STORYBOARD_TYPE_SCREEN)
											{
												if (strlen(Storyboard.Nodes[iNewNode].lua_name) > 0)
												{
													// screens can have same name (old corruption issue), so new method to identify screen by node
													//std::string lua_name = Storyboard.Nodes[iNewNode].lua_name;
													//replaceAll(lua_name, ".lua", "");
													//t.s_s = lua_name.c_str();
													std::string node_ident_name = ":node:"; 
													node_ident_name += std::to_string(iNewNode);
													t.s_s = node_ident_name.c_str();
													lua_switchpage();
													if (strlen(Storyboard.Nodes[iNewNode].screen_music) > 0) //PE: Only stop music if new swcreen have its own.
														bLuaPageClosing = true;
													iRet = STORYBOARD_ACTIONS_GOTOSCREEN;
												}
											}
										}
										else
										{
											//PE: Not linked, check if we have a direct link to screen without a pin connection.
											if (index < STORYBOARD_MAXOUTPUTS)
											{
												if (strlen(Storyboard.Nodes[nodeid].output_title[index]) <= 0) //Empty no output pin.
												{
													if (Storyboard.Nodes[nodeid].output_can_link_to_type[index] == STORYBOARD_TYPE_SCREEN)
													{
														if (strlen(Storyboard.Nodes[nodeid].output_action[index]) > 0)
														{
															if (Storyboard.Nodes[nodeid].output_linkto[index] == 0)
															{
																// screens can have same name (old corruption issue), so new method to identify screen by node
																//std::string lua_name = Storyboard.Nodes[nodeid].output_action[index];
																//replaceAll(lua_name, ".lua", "");
																//t.s_s = lua_name.c_str();
																std::string node_ident_name = ":node:";
																node_ident_name += std::to_string(nodeid);
																t.s_s = node_ident_name.c_str();
																lua_switchpage();

																bLuaPageClosing = true; //always stop music.
																iRet = STORYBOARD_ACTIONS_GOTOSCREEN;
															}
														}
													}
												}
											}

										}
									}
								}
								int iActionID = Storyboard.Nodes[nodeid].widget_action[index];
								if (iActionID >= STORYBOARD_ACTIONS_GOTOSCREENHUD2
								&&  iActionID <= STORYBOARD_ACTIONS_GOTOSCREENHUD32)
								{
									// Toggle to new HUD screen ( can be improved this 'ard use of widget_action )
									for (int i = 0; i < STORYBOARD_MAXNODES; i++)
									{
										StoryboardNodesStruct& node = Storyboard.Nodes[i];
										if (node.used && strlen(node.level_name) == 0) // only HUDs
										{
											bool bFoundHUDScreen = false;
											int iHUDNumber = 2 + (iActionID - STORYBOARD_ACTIONS_GOTOSCREENHUD2);
											char pHUDScreenName[256];
											sprintf(pHUDScreenName, "HUD Screen %d", iHUDNumber);
											if (stricmp (node.title, pHUDScreenName) == NULL) bFoundHUDScreen = true;
											if (bFoundHUDScreen == true )
											{
												t.game.activeStoryboardScreen = i;
												break;
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					if (bPreviewScreen)
					{
						//Trigger any sound from buttons.
						if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_BUTTON)
						{
							ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
							if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos - vLargerGrabArea, rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea))
							{
								//if mouse release.
								if (ImGui::IsMouseReleased(0))
								{
									if (strlen(Storyboard.Nodes[nodeid].widget_click_sound[index]) > 0)
									{
										cTriggerButtonClickSound = Storyboard.Nodes[nodeid].widget_click_sound[index];
									}
								}
							}
						}
					}
				}
				if (cTriggerButtonClickSound != "")
				{
					//Play sound.
					int iFreeSoundID = g.temppreviewsoundoffset + 4; //Button Sound.
					// play music
					if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
					if (FileExist(cTriggerButtonClickSound.Get()) == 1)
					{
						LoadSound(cTriggerButtonClickSound.Get(), iFreeSoundID, 0, 1);
						if (SoundExist(iFreeSoundID) == 1)
							PlaySound(iFreeSoundID);
					}
					cTriggerButtonClickSound = "";
				}
				if (bLuaPageClosing)
				{
					//Stop music ...
					int iFreeSoundID = g.temppreviewsoundoffset + 2;
					if (SoundExist(iFreeSoundID) == 1 && SoundPlaying(iFreeSoundID) == 1)
					{
						// stop currently playing preview
						StopSound(iFreeSoundID);
					}
				}

				//Set Slider Values.
				if (!bReadOnly && iQuitWindowLoop <= 0 && (bPreviewScreen || standalone) )
				{
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_SLIDER)
					{
						ImVec2 vLargerGrabArea = ImVec2(10.0, 10.0);
						if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos - vLargerGrabArea, rMonitorArea.Min + widget_pos + widget_size + vLargerGrabArea))
						{
							if (ImGui::IsMouseDown(0))
							{
								//Percent.
								ImVec2 mousecords = ImGui::GetMousePos();
								ImVec2 xy = mousecords - (rMonitorArea.Min + widget_pos);
								float percent = xy.x / (widget_size.x / 100.0);

								if (mousecords.x > (rMonitorArea.Min.x + widget_pos.x + widget_size.x))
									percent = 100.0;
								else if (percent < 0.0)
									percent = 0.0;
								else if (percent > 100.0)
									percent = 100.0;

								iSpecialLuaReturn = index;

								// If connected to readout, update the readout value
								if (strlen(Storyboard.widget_readout[nodeid][index]) > 0)
								{
									SetReadoutValueInt(Storyboard.widget_readout[nodeid][index], percent);
								}
								Storyboard.NodeSliderValues[nodeid][index] = percent;
							}
						}
					}
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_RADIOTYPE)
					{
						if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos , rMonitorArea.Min + widget_pos + widget_size ))
						{
							if (ImGui::IsMouseDown(0))
							{
								// used by GRAPHICS SETTINGS (1,2,3)
								int iMatchToSettingValue = -1;
								if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "LOW") == NULL) iMatchToSettingValue = 1;
								if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "MEDIUM") == NULL) iMatchToSettingValue = 2;
								if (stricmp(Storyboard.Nodes[nodeid].widget_label[index], "HIGHEST") == NULL) iMatchToSettingValue = 3;
								Storyboard.NodeRadioButtonSelected[nodeid] = iMatchToSettingValue;
								iSpecialLuaReturn = iMatchToSettingValue;
							}
						}
					}
					if (Storyboard.Nodes[nodeid].widget_type[index] == STORYBOARD_WIDGET_TICKBOX)
					{
						if (ImGui::IsMouseHoveringRect(rMonitorArea.Min + widget_pos, rMonitorArea.Min + widget_pos + widget_size))
						{
							if (ImGui::IsMouseClicked(0))
							{
								// If connected to readout, update the readout value
								if (strlen(Storyboard.widget_readout[nodeid][index]) > 0)
								{
									bool bEnabled = GetReadoutValueInt(Storyboard.widget_readout[nodeid][index]);
									bEnabled = !bEnabled;
									SetReadoutValueInt(Storyboard.widget_readout[nodeid][index], bEnabled);
								}
								else
								{
									Storyboard.NodeSliderValues[nodeid][index] = 1.0f - Storyboard.NodeSliderValues[nodeid][index];
								}
								iSpecialLuaReturn = index;
							}
						}
					}
				}
				//Control Widget.
				if (iCurrentSelectedWidget == index && !standalone)
				{
					if (!bReadOnly && iQuitWindowLoop <= 0 && !bPreviewScreen)
					{
						storyboard_control_widget(nodeid, index, widget_pos, widget_size, rMonitorArea, vMonitorStart, vScale);
					}
				}

				if (iSkipWidgetSelectionForFrames > 0) //PE: Make sure we dont select anything after a window on top.
					iSkipWidgetSelectionForFrames--;

				ImGui::SetWindowFontScale(1.0*vScale.y * fGlobalScale);
				ImGui::PopFont();
			}
		}

		ImVec4 leftPanelBoxCol = ImGui::GetStyle().Colors[ImGuiCol_ChildBg];
		leftPanelBoxCol.w = 1.0f;
		window->DrawList->AddRectFilled(leftPanelAABB.Min, leftPanelAABB.Max, ImGui::GetColorU32(leftPanelBoxCol));

		if (!bPreviewScreen && !standalone)
		{	
			int index = iCurrentSelectedWidget;
			// Check for widget being dragged to left panel (for deletion)
			ImVec2 widgetSize = ImVec2(1.0f, 1.0f);
			if (ImageExist(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]))
			{
				widgetSize.x = ImageWidth(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
				widgetSize.y = ImageHeight(Storyboard.Nodes[nodeid].widget_normal_thumb_id[index]);
			}
			else
			{
				widgetSize = ImVec2(500, 74); //Default widget size for text
			}
			widgetSize = widgetSize * vScale; //Scale to visible screen size.
			widgetSize = widgetSize * fGlobalScale;
			widgetSize = widgetSize * Storyboard.Nodes[nodeid].widget_size[index];
			ImVec2 fOnePercentScreen = ImVec2(vMonitorSize.x / 100.0, vMonitorSize.y / 100.0);
			ImVec2 widgetPos = Storyboard.Nodes[nodeid].widget_pos[index] * fOnePercentScreen; //Real screen pos.
			ImVec2 centerOffset = ImVec2(widgetSize.x / 2.0f, 0.0f);
			ImVec2 widgetMin = rMonitorArea.Min + widgetPos - centerOffset;
			ImVec2 widgetMax = rMonitorArea.Min + widgetPos + widgetSize - centerOffset;
			currentWidgetAABB = ImRect(widgetMin, widgetMax);
		}

		ImGui::SetWindowFontScale(1.0);
		ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + vMonitorCenterX + vMonitorPos.x, vHeaderEnd.y + vMonitorSize.y + vMonitorPos.y + 3.0));
		//ImGui::Text("Below monitor");

		ImGui::SetCursorPos( ImVec2(ImGui::GetCursorPosX(), vHeaderEnd.y + fMaxMonitorY + 6.0));
		//ImGui::Text("Way down : Status");

		bool bPrevPreviewScreen = bPreviewScreen;

		if (!bPreviewScreen)
			ImGui::NextColumn();

		if (!bPreviewScreen && iCurrentSelectedWidget >= 0)
		{
			float w = ImGui::GetContentRegionAvailWidth(); 
			bool bReadOnly = Storyboard.Nodes[nodeid].widget_read_only[iCurrentSelectedWidget];
			bool bSpecialNoText = false;
			if (bReadOnly)
			{
				bSpecialNoText = true;
				if (iCurrentSelectedWidget >= 1 && iCurrentSelectedWidget <= 8 && ( stricmp(Storyboard.Nodes[nodeid].lua_name, "loadgame.lua") == 0 || stricmp(Storyboard.Nodes[nodeid].lua_name, "savegame.lua") == 0 ) )
				{
					strcpy(Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], LoadGameTitle[iCurrentSelectedWidget]);
					bReadOnly = false;
				}
			}

			if (bReadOnly)
			{
				//PE: Disable ALL gadgets and moving/rotation/scaling.
				ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
				ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
			}

			if (!standalone && !bPreviewScreen)
			{
				ImGui::BeginChild("##SERightPanel", ImVec2(0,0), false, 0);
			}

			float buttonwide = 200.0f;
			if (Storyboard.Nodes[nodeid].type != STORYBOARD_TYPE_HUD)
			{
				if (ImGui::StyleCollapsingHeader("Screen Media", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);

					cstr cBackDrop = Storyboard.Nodes[nodeid].screen_backdrop;
					if (pestrcasestr(Storyboard.Nodes[nodeid].screen_backdrop, "editors\\"))
					{
						cBackDrop = "default";
					}
					cstr cNewBackDrop = imgui_setpropertyfile2_v2(0, cBackDrop.Get(), "Backdrop Image", "Select Backdrop", "imagebank\\", false, "backdrop");
					if (cNewBackDrop != cBackDrop)
					{
						strcpy(Storyboard.Nodes[nodeid].screen_backdrop, cNewBackDrop.Get());
						iUpdateBackDropNode = nodeid; //Update thumb.
					}

					if (strlen(Storyboard.Nodes[nodeid].screen_backdrop) > 0)
					{
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.f)*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Remove Backdrop", ImVec2(buttonwide, 0.0f)))
						{
							strcpy(Storyboard.Nodes[nodeid].screen_backdrop, "");
							iUpdateBackDropNode = nodeid; //Update thumb.
						}
						if (!Storyboard.Nodes[nodeid].screen_backdrop_transparent)
						{
							//PE: thump problem ?
							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.f)*0.5) - (buttonwide*0.5), 0.0f));
							if (ImGui::StyleButton("Copy Backdrop to All Screens##1", ImVec2(buttonwide, 0.0f)))
							{
								int iAction = askBoxCancel("This will copy your backdrop to all screens, are you sure ?\nNOTE: You need to edit your screens after this change, to update the thumbnails.", "Confirmation"); //1==Yes 2=Cancel 0=No
								if (iAction == 1)
								{
									strcpy(cCopyToAllScreens, Storyboard.Nodes[nodeid].screen_backdrop);
									iUpdateBackDropNode = 99999; //Update ALL thumbs. ???
								}
							}

						}
					}

					if (pref.iStoryboardAdvanced)
					{
						ImGui::TextCenter("Backdrop Position");

						const char* backdrop_placement[] = { "Backdrop Center" , "Backdrop Stretch", "Backdrop Zoom" };
						ImGui::PushItemWidth(-10);
						if (ImGui::Combo("##screen_backdrop_placement", &Storyboard.Nodes[nodeid].screen_backdrop_placement, backdrop_placement, IM_ARRAYSIZE(backdrop_placement)))
						{
							//
						}
						ImGui::PopItemWidth();


						bool bTmp = Storyboard.Nodes[nodeid].screen_backdrop_transparent;
						ImGui::Checkbox("Transparent Backdrop", &bTmp);
						Storyboard.Nodes[nodeid].screen_backdrop_transparent = bTmp;
					}

					//ImGui::TextCenter("Music Track");
					cstr cMusicTrack = Storyboard.Nodes[nodeid].screen_music;
					cstr cNewMusicTrack = imgui_setpropertyfile2_v2(0, cMusicTrack.Get(), "Music Track", "Select Music Track", "audiobank\\", false);
					if (cNewMusicTrack != cMusicTrack)
					{
						strcpy(Storyboard.Nodes[nodeid].screen_music, cNewMusicTrack.Get());
					}

					if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
					{
						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.0f)*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Remove Music", ImVec2(buttonwide, 0.0f)))
						{
							strcpy(Storyboard.Nodes[nodeid].screen_music, "");
						}

						ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.f)*0.5) - (buttonwide*0.5), 0.0f));
						if (ImGui::StyleButton("Copy Music to All Screens", ImVec2(buttonwide, 0.0f)))
						{
							int iAction = askBoxCancel("This will copy your music to all screens, are you sure?", "Confirmation"); //1==Yes 2=Cancel 0=No
							if (iAction == 1)
							{
								for (int i = 0; i < STORYBOARD_MAXWIDGETS; i++)
								{
									if (Storyboard.Nodes[i].used && Storyboard.Nodes[i].type == STORYBOARD_TYPE_SCREEN)
									{
										//PE: Only title,about,won,lost,loading
										bool bValid = false;
										if (i == iTitleScreenNodeID) bValid = true;
										if (i == iLoadingScreenNodeID) bValid = true;
										if (i == iAboutScreenNodeID) bValid = true;
										if (i == iGameWonScreenNodeID) bValid = true;
										if (i == iGameLostScreenNodeID) bValid = true;
										if (bValid && i != nodeid)
										{
											//PE: Copy music to scene.
											strcpy(Storyboard.Nodes[i].screen_music, Storyboard.Nodes[nodeid].screen_music);
										}
									}
								}
							}
						}

					}

					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.0)*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Preview Screen", ImVec2(buttonwide, 0.0f)))
					{
						bPreviewScreen = true;
						int iFreeSoundID = g.temppreviewsoundoffset + 2;
						if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
						{
							// play music
							if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
							if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
							{
								LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
								if (SoundExist(iFreeSoundID) == 1)
									PlaySound(iFreeSoundID);
							}
						}
					}

					ImGui::Indent(-10);

				}
			}
			
			if (Storyboard.Nodes[nodeid].type == STORYBOARD_TYPE_HUD)
			{
				if (ImGui::StyleCollapsingHeader("Screen", ImGuiTreeNodeFlags_DefaultOpen))
				{
					ImGui::Indent(10);
					Storyboard.Nodes[nodeid].screen_backdrop_transparent = true;

					// "In-Game HUD" is the default HUD screen, and currently cannot have its visibility conditions changed
					// If we plan to make any HUD screen a possible default then hud0.lua will need changed to accomodate this
					if (strcmp(Storyboard.Nodes[nodeid].title, "In-Game HUD") != 0)
					{
						// Display key that will make this screen appear in-game
						Storyboard.Nodes[nodeid].toggleKey;
						char* toggleKey = "NONE";
						if (Storyboard.Nodes[nodeid].toggleKey > 0)
						{
							char scanCodeName[128];
							int result = GetScancodeName(Storyboard.Nodes[nodeid].toggleKey, scanCodeName, 128);
							toggleKey = scanCodeName;
						}

						ImGui::Text("Screen Toggle Key: %s", toggleKey);
						if (ImGui::Button("Change Toggle Key"))
						{
							bScreenToggleKeyWindow = true;
						}
						bool bShowAtStart = Storyboard.Nodes[nodeid].showAtStart;
						if (ImGui::Checkbox("Show Screen At Start", &bShowAtStart))
						{
							Storyboard.Nodes[nodeid].showAtStart = bShowAtStart;
						}
					}
					ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(((ImGui::GetContentRegionAvail().x - 14.0)*0.5) - (buttonwide*0.5), 0.0f));
					if (ImGui::StyleButton("Preview Screen", ImVec2(buttonwide, 0.0f)))
					{
						bPreviewScreen = true;
						int iFreeSoundID = g.temppreviewsoundoffset + 2;
						if (strlen(Storyboard.Nodes[nodeid].screen_music) > 0)
						{
							// play music
							if (SoundExist(iFreeSoundID) == 1) DeleteSound(iFreeSoundID);
							if (FileExist(Storyboard.Nodes[nodeid].screen_music) == 1)
							{
								LoadSound(Storyboard.Nodes[nodeid].screen_music, iFreeSoundID, 0, 1);
								if (SoundExist(iFreeSoundID) == 1)
									PlaySound(iFreeSoundID);
							}
						}
					}
					ImGui::Indent(-10);
				}
			}
			if (ImGui::StyleCollapsingHeader("Grid Settings", ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);

				ImGui::TextCenter("Grid Size");
				ImGui::MaxSliderInputInt("##StoryboardGridSize", &Storyboard.Nodes[nodeid].screen_grid_size, 0, 10, "Set Grid Size");

				if (Storyboard.Nodes[nodeid].screen_grid_size > 0)
				{
					ImGui::Checkbox("Show Grid", &bDisplayGrid);
				}
				else
				{
					bool bTmp = false;
					ImGui::Checkbox("Show Grid", &bTmp);
				}

				ImGui::Indent(-10);
			}

			cstr sLabel = "Button Settings";
			cstr sPositionText = "Current Position";
			cstr sTextText = "Text";
			cstr sButtonText = "Button";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TEXT) { sLabel = "Text Settings"; sPositionText = "Current Text Position"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_IMAGE)  sLabel = "Image Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_VIDEO)  sLabel = "Video Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_PROGRESS)  sLabel = "Progress Bar Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_SLIDER)  sLabel = "Slider Settings";
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BAR) { sLabel = "Status Bar Settings"; sTextText = ""; sButtonText = "Bar"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TEXTAREA) { sLabel = "Text Area Settings"; sPositionText = "Current Text Position"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BUTTON) { sPositionText = "Current Button Position"; sTextText = "Button Text"; }
			if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_RADIOTYPE) { sLabel = "Radio Button Settings"; sTextText = "Radio Button Text"; }
		
			if (ImGui::StyleCollapsingHeader(sLabel.Get(), ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);

				char pLayerDesc[256];
				sprintf(pLayerDesc, "Current Draw Order Layer : %d", 2+Storyboard.widget_drawordergroup[nodeid][iCurrentSelectedWidget]);
				ImGui::TextCenter(pLayerDesc);

				ImGui::TextCenter(sPositionText.Get());

				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 3.0f));
				ImGui::Text("X"); //PE: No room for XYZ labels in default width ?
				ImGui::SameLine();
				ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
				float scrollSizeX = ImGui::GetCurrentWindow()->ScrollbarSizes.x / 2.0f;
				ImGui::PushItemWidth(w * 0.5 - (ImGui::GetFontSize() * 2.0) - scrollSizeX);
				if (ImGui::InputFloat("##StoryboarTextPositionX", &Storyboard.Nodes[nodeid].widget_pos[iCurrentSelectedWidget].x, 0.0f, 0.0f, "%.0f")) //"%.2f"
				{
					//
				}
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Widget Position X");
				ImGui::PopItemWidth();
				ImGui::SameLine();
				ImGui::Text("Y");
				ImGui::SameLine();
				ImGui::PushItemWidth(w * 0.5 - (ImGui::GetFontSize() * 2.0) - scrollSizeX);
				if (ImGui::InputFloat("##StoryboarTextPositionY", &Storyboard.Nodes[nodeid].widget_pos[iCurrentSelectedWidget].y, 0.0f, 0.0f, "%.0f")) //"%.2f"
				{
					//
				}
				if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip("Change Widget Position Y");
				ImGui::PopItemWidth();

				// Determine if the widget is 'a'User Defined Global' powered (if so we nick the name field for our global var name) 
				int iUserDefinedGlobal = 0;
				std::string readout = Storyboard.widget_readout[nodeid][iCurrentSelectedWidget];
				if (stricmp(readout.c_str(), "User Defined Global") == NULL) iUserDefinedGlobal = 1;
				if (stricmp(readout.c_str(), "User Defined Global Text") == NULL) iUserDefinedGlobal = 1;
				if (stricmp(readout.c_str(), "User Defined Global Statusbar") == NULL) iUserDefinedGlobal = 2;
				if (stricmp(readout.c_str(), "User Defined Global Image") == NULL) iUserDefinedGlobal = 3;
				if (stricmp(readout.c_str(), "User Defined Global Panel") == NULL) iUserDefinedGlobal = 4;

				// skip text config if no text!
				int widgetType = Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget];
				if ( strlen(sTextText.Get())>0 )
				{
					if (widgetType != STORYBOARD_WIDGET_PROGRESS && widgetType != STORYBOARD_WIDGET_IMAGE && widgetType != STORYBOARD_WIDGET_VIDEO)
					{
						// text size determines size and if visible in HUD
						float fTextSize = Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget];

						// Can hide text from HUD (using negative text size trick)
						bool bHidingText = false;
						if (fTextSize < 0) bHidingText = true;
						if (ImGui::Checkbox("Hide Text", &bHidingText))
						{
							fTextSize = fabs(fTextSize);
							if (bHidingText == true) fTextSize = -fTextSize;
							Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = fTextSize;
						}

						// Normal text handling if not hidden
						if ( fTextSize > 0.0f )
						{
							if (!bSpecialNoText && iUserDefinedGlobal == 0)
							{
								ImGui::TextCenter(sTextText.Get());
								cstr UniqueTextFiledName = cstr("##WidgetTextStoryboardInput") + cstr(iCurrentSelectedWidget);
								ImGui::PushItemWidth(-10);
								if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TEXTAREA)
								{
									ImGui::InputTextMultiline(UniqueTextFiledName.Get(), Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], 250, ImVec2(0, 6.0 * ImGui::GetFontSize()), ImGuiInputTextFlags_None); //ImGuiInputTextFlags_ReadOnly
								}
								else
								{
									ImGui::InputText(UniqueTextFiledName.Get(), Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], 250, ImGuiInputTextFlags_None); //ImGuiInputTextFlags_ReadOnly
								}
								if (ImGui::MaxIsItemFocused())
								{
									bImGuiGotFocus = true;
								}
								ImGui::PopItemWidth();
							}

							ImGui::TextCenter("Text Font");
							//	extern std::vector< std::pair<ImFont*, std::string>> StoryboardFonts;
							char FontSelected[MAX_PATH];
							strcpy(FontSelected, Storyboard.Nodes[nodeid].widget_font[iCurrentSelectedWidget]);

							ImGui::PushItemWidth(-10);
							WidgetSelectUsedFont(nodeid, iCurrentSelectedWidget);
							ImGui::SetWindowFontScale(0.75);

							if (ImGui::BeginCombo("##TextFontStoryboard", FontSelected)) // The second parameter is the label previewed before opening the combo.
							{
								bool bIsSelected = false;
								if (strcmp(FontSelected, "Default Font") == NULL) bIsSelected = true;
								ImGui::PushFont(customfontlarge);  //defaultfont
								if (ImGui::Selectable("Default Font", bIsSelected))
								{
									strcpy(Storyboard.Nodes[nodeid].widget_font[iCurrentSelectedWidget], "Default Font");
								}
								ImGui::PopFont();
								for (int i = 0; i < StoryboardFonts.size(); i++)
								{
									bool bIsSelected = false;
									if (strcmp(StoryboardFonts[i].second.c_str(), FontSelected) == NULL) bIsSelected = true;

									ImGui::PushFont(StoryboardFonts[i].first);  //defaultfont
									if (ImGui::Selectable(StoryboardFonts[i].second.c_str(), bIsSelected))
									{
										strcpy(Storyboard.Nodes[nodeid].widget_font[iCurrentSelectedWidget], StoryboardFonts[i].second.c_str());
									}
									//ImGui::PushFont(customfont);  //defaultfont
									ImGui::PopFont();
								}
								ImGui::EndCombo();
								//ImGui::PopFont();
							}
							ImGui::PopItemWidth();

							ImGui::SetWindowFontScale(1.0);
							ImGui::PopFont();

							ImGui::TextCenter("Text Color");
							bool open_popup = ImGui::ColorButton("##StoryboardWidgetTextColor", Storyboard.Nodes[nodeid].widget_font_color[iCurrentSelectedWidget], 0, ImVec2(w - 20.0, 0));
							if (open_popup)
								ImGui::OpenPopup("##StoryboardWidgetTextColor");
							if (ImGui::BeginPopup("##StoryboardWidgetTextColor", ImGuiWindowFlags_NoMove))
							{
								if (ImGui::ColorPicker4("##StoryboardPickerTextColor", (float*)&Storyboard.Nodes[nodeid].widget_font_color[iCurrentSelectedWidget], ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview))
								{
									//
								}
								ImGui::EndPopup();
							}
							//Add pencil
							ID3D11ShaderResourceView* lpTexture = GetImagePointerView(TOOL_PENCIL);
							if (lpTexture)
							{
								ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - (ImGui::GetFontSize() * 1.5f) - 3.0f };
								window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));
							}

							ImGui::TextCenter("Text Size");
							if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] > 3.5) Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = 3.5;
							ImGui::MaxSliderInputFloat("##WidgetTextSize", &Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget], 0.00f, 3.50f, "Set Text Font Size", 1.0, 100);
							if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] > 3.5) Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = 3.5;
							if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] <= 0) Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = 0.0001;
						}
					}

					if (iUserDefinedGlobal == 4) // needed for panel grid row and column
					{
						if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_TEXT
							&& Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_TEXTAREA)
						{
							LPSTR pTitle = "Text Offset";
							LPSTR pLabelX = "Offset X";
							LPSTR pLabelTipX = "Change Widget Text Offset X";
							LPSTR pLabelY = "Offset Y";
							LPSTR pLabelTipY = "Change Widget Text Offset Y";
							if (iUserDefinedGlobal == 4)
							{
								pTitle = "Panel Grid Size";
								pLabelX = "Columns";
								pLabelTipX = "Change the total number of columns";
								pLabelY = "Rows";
								pLabelTipY = "Change the total number of rows";
							}
							ImGui::TextCenter(pTitle);

							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, 3.0f));
							ImGui::Text(pLabelX);
							ImGui::SameLine();
							ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(0.0f, -3.0f));
							ImGui::PushItemWidth(w * 0.5 - (ImGui::GetFontSize() * 2.0) - 40 - scrollSizeX);
							if (ImGui::InputFloat("##StoryboardTextOffsetX", &Storyboard.widget_textoffset[nodeid][iCurrentSelectedWidget].x, 0.0f, 0.0f, "%.0f")) //"%.2f"
							{
								//
							}
							if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip(pLabelTipX);
							ImGui::PopItemWidth();
							ImGui::SameLine();
							ImGui::Text(pLabelY);
							ImGui::SameLine();
							ImGui::PushItemWidth(w * 0.5 - (ImGui::GetFontSize() * 2.0) - 40 - scrollSizeX);
							if (ImGui::InputFloat("##StoryboardTextOffsetY", &Storyboard.widget_textoffset[nodeid][iCurrentSelectedWidget].y, 0.0f, 0.0f, "%.0f")) //"%.2f"
							{
								//
							}
							if (!pref.iTurnOffEditboxTooltip && ImGui::IsItemHovered()) ImGui::SetTooltip(pLabelTipY);
							ImGui::PopItemWidth();
						}
					}
				}

				if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BUTTON 
				|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_PROGRESS 
				|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_SLIDER
				|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BAR
				|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_RADIOTYPE
				|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_TICKBOX)
				{
					ImGui::TextCenter(cstr(sButtonText+cstr(" Size")).Get());
					float fTmp = Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].x * 100.0f;
					//if (fTmp > 4.0) fTmp = 4.0;
					//if (fTmp <= 0.10) fTmp = 0.1000;
					if (ImGui::MaxSliderInputFloat("##WidgetButtonSize", &fTmp, 0, 100, "Set the size of this widget as a percentage of original size", 0, 100))
					{
						if (fTmp < 1) fTmp = 1;
						Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].x = fTmp / 100.0f;
						Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].y = fTmp / 100.0f;
					}

					int iButtons = 3;
					if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_PROGRESS 
						|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_SLIDER
						|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_BAR)
						iButtons = 2;

					//Button Image Regular
					for (int i = 0; i < iButtons; i++) //PE: Selected not really used yet, to enable it just set < 3 :)
					{
						if (i == 0) ImGui::TextCenter(cstr(sButtonText + cstr(" Image Regular")).Get());
						if (i == 1) ImGui::TextCenter(cstr(sButtonText + cstr(" Image Highlighted")).Get());
						if (i == 2) ImGui::TextCenter(cstr(sButtonText + cstr(" Image Selected")).Get());

						cstr UniqueRegularButtonSelect = "##StoryboardUniqueRegularButtonSelect";
						if (i == 1) UniqueRegularButtonSelect = "##StoryboardUniqueHighligtedButtonSelect";
						if (i == 2) UniqueRegularButtonSelect = "##StoryboardUniqueSelectedButtonSelect";

						if (iSelectedLibraryStingReturnID == window->GetID(UniqueRegularButtonSelect.Get()))
						{
							if (i == 0) strcpy(Storyboard.Nodes[nodeid].widget_normal_thumb[iCurrentSelectedWidget], sSelectedLibrarySting.Get());
							if (i == 1) strcpy(Storyboard.Nodes[nodeid].widget_highlight_thumb[iCurrentSelectedWidget], sSelectedLibrarySting.Get());
							if (i == 2) strcpy(Storyboard.Nodes[nodeid].widget_selected_thumb[iCurrentSelectedWidget], sSelectedLibrarySting.Get());
							iUpdateWidgetThumbNode = nodeid;
							iUpdateWidgetThumbButton = iCurrentSelectedWidget;
							sSelectedLibrarySting = "";
							iSelectedLibraryStingReturnID = -1; //disable.
							iSkipWidgetSelectionForFrames = 10; //No widget selection for 10 frames.
						}
						int iTextureID = Storyboard.Nodes[nodeid].widget_normal_thumb_id[iCurrentSelectedWidget];
						if (i == 1) iTextureID = Storyboard.Nodes[nodeid].widget_highlight_thumb_id[iCurrentSelectedWidget];
						if (i == 2) iTextureID = Storyboard.Nodes[nodeid].widget_selected_thumb_id[iCurrentSelectedWidget];

						ImVec2 ImageSize = ImVec2(w - 20.0 - ImGui::GetCurrentWindow()->ScrollbarSizes.x, ImGui::GetFontSize());
						ID3D11ShaderResourceView* lpTexture = GetImagePointerView(iTextureID);
						if (lpTexture)
						{
							float img_w = ImageWidth(iTextureID);
							float img_h = ImageHeight(iTextureID);
							ImageSize.y = img_h * (ImageSize.x / img_w);
						}
						ImVec2 vImagePos = ImGui::GetCursorPos();

						ImGui::Dummy(ImageSize);
						ImVec4 color = ImVec4(1.0, 1.0, 1.0, 1.0);
						ImVec4 back_color = ImVec4(0.2, 0.2, 0.2, 0.75);
						if (ImGui::IsItemHovered())
						{
							color.w = 0.75;
							if (!bWidgetMouseDraggin && ImGui::IsMouseReleased(0))
							{
								//Choose Button image
								sStartLibrarySearchString = "Buttons";
								bExternal_Entities_Window = true;
								iDisplayLibraryType = 2; //Image
								iLibraryStingReturnToID = window->GetID(UniqueRegularButtonSelect.Get());
							}
						}
						ImVec2 img_pos = ImGui::GetWindowPos() + vImagePos;
						img_pos.y -= ImGui::GetScrollY();

						window->DrawList->AddRectFilled(img_pos, img_pos + ImageSize, ImGui::GetColorU32(back_color));
						if (lpTexture)
						{
							window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImageSize, ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(color));
						}
						else
						{
							window->DrawList->AddRectFilled(img_pos, img_pos + ImageSize, ImGui::GetColorU32(color));
						}
						lpTexture = GetImagePointerView(TOOL_PENCIL); //Add pencil
						if (lpTexture)
						{
							ImVec2 vDrawPos = { ImGui::GetCursorScreenPos().x + (ImGui::GetContentRegionAvail().x - 30.0f) ,ImGui::GetCursorScreenPos().y - ImageSize.y - 3.0f };
							window->DrawList->AddImage((ImTextureID)lpTexture, vDrawPos, vDrawPos + ImVec2(16, 16), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1, 1, 1, 1)));
						}
					}
		
					if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_PROGRESS 
					&& Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_SLIDER
					&& Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] != STORYBOARD_WIDGET_BAR)
					{
						cstr cursound = Storyboard.Nodes[nodeid].widget_click_sound[iCurrentSelectedWidget];				
						cstr butsound = imgui_setpropertyfile2_v2(0, cursound.Get(), cstr(sButtonText + cstr(" Sound")).Get(), cstr(cstr("Select ")+sButtonText+cstr(" Image Regular")).Get(), "audiobank\\", false);
						if (butsound != cursound)
						{
							strcpy(Storyboard.Nodes[nodeid].widget_click_sound[iCurrentSelectedWidget], butsound.Get());
						}

						ImGui::TextCenter("Action");
						char ActionSelected[255];

						int iCurAction = Storyboard.Nodes[nodeid].widget_action[iCurrentSelectedWidget];
						if (iCurAction == STORYBOARD_ACTIONS_NONE) strcpy(ActionSelected, "None");
						if (iCurAction == STORYBOARD_ACTIONS_STARTGAME) strcpy(ActionSelected, "Start Game");
						if (iCurAction == STORYBOARD_ACTIONS_EXITGAME) strcpy(ActionSelected, "Exit Game");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREEN) strcpy(ActionSelected, "Go To Another Screen");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOLEVEL) strcpy(ActionSelected, "Go To Another Level");
						if (iCurAction == STORYBOARD_ACTIONS_CONTINUE) strcpy(ActionSelected, "Continue Game");
						if (iCurAction == STORYBOARD_ACTIONS_BACK) strcpy(ActionSelected, "Close Screen");
						if (iCurAction == STORYBOARD_ACTIONS_LEAVEGAME) strcpy(ActionSelected, "Leave Game");
						if (iCurAction == STORYBOARD_ACTIONS_RESUMEGAME) strcpy(ActionSelected, "Resume Game");
						if (iCurAction == STORYBOARD_ACTIONS_RETURNVALUETOLUA) strcpy(ActionSelected, "Return Button ID to Lua");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD2) strcpy(ActionSelected, "Go To HUD Screen 2");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD3) strcpy(ActionSelected, "Go To HUD Screen 3");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD4) strcpy(ActionSelected, "Go To HUD Screen 4");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD5) strcpy(ActionSelected, "Go To HUD Screen 5");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD6) strcpy(ActionSelected, "Go To HUD Screen 6");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD7) strcpy(ActionSelected, "Go To HUD Screen 7");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD8) strcpy(ActionSelected, "Go To HUD Screen 8");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD9) strcpy(ActionSelected, "Go To HUD Screen 9");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD10) strcpy(ActionSelected, "Go To HUD Screen 10");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD11) strcpy(ActionSelected, "Go To HUD Screen 11");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD12) strcpy(ActionSelected, "Go To HUD Screen 12");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD13) strcpy(ActionSelected, "Go To HUD Screen 13");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD14) strcpy(ActionSelected, "Go To HUD Screen 14");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD15) strcpy(ActionSelected, "Go To HUD Screen 15");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD16) strcpy(ActionSelected, "Go To HUD Screen 16");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD17) strcpy(ActionSelected, "Go To HUD Screen 17");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD18) strcpy(ActionSelected, "Go To HUD Screen 18");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD19) strcpy(ActionSelected, "Go To HUD Screen 19");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD20) strcpy(ActionSelected, "Go To HUD Screen 20");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD21) strcpy(ActionSelected, "Go To HUD Screen 21");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD22) strcpy(ActionSelected, "Go To HUD Screen 22");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD23) strcpy(ActionSelected, "Go To HUD Screen 23");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD24) strcpy(ActionSelected, "Go To HUD Screen 24");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD25) strcpy(ActionSelected, "Go To HUD Screen 25");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD26) strcpy(ActionSelected, "Go To HUD Screen 26");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD27) strcpy(ActionSelected, "Go To HUD Screen 27");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD28) strcpy(ActionSelected, "Go To HUD Screen 28");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD29) strcpy(ActionSelected, "Go To HUD Screen 29");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD30) strcpy(ActionSelected, "Go To HUD Screen 30");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD31) strcpy(ActionSelected, "Go To HUD Screen 31");
						if (iCurAction == STORYBOARD_ACTIONS_GOTOSCREENHUD32) strcpy(ActionSelected, "Go To HUD Screen 32");

						const char* actions_names[] = { "None", "Start Game", "Exit Game", "Go To Another Screen", "Go To Another Level", "Continue Game", "Close Screen", "Leave Game","Resume Game",
							"Return Button ID to Lua", 
							"Go To HUD Screen 2", "Go To HUD Screen 3", "Go To HUD Screen 4", "Go To HUD Screen 5",
							"Go To HUD Screen 6", "Go To HUD Screen 7", "Go To HUD Screen 8", "Go To HUD Screen 9", "Go To HUD Screen 10",
							"Go To HUD Screen 11", "Go To HUD Screen 12", "Go To HUD Screen 13", "Go To HUD Screen 14", "Go To HUD Screen 15",
							"Go To HUD Screen 16", "Go To HUD Screen 17", "Go To HUD Screen 18", "Go To HUD Screen 19", "Go To HUD Screen 20",
							"Go To HUD Screen 21", "Go To HUD Screen 22", "Go To HUD Screen 23", "Go To HUD Screen 24", "Go To HUD Screen 25",
							"Go To HUD Screen 26", "Go To HUD Screen 27", "Go To HUD Screen 28", "Go To HUD Screen 29", "Go To HUD Screen 30",
							"Go To HUD Screen 31", "Go To HUD Screen 32"
						};

						ImGui::PushItemWidth(-10);
						if (ImGui::BeginCombo("##StoryboardAction", ActionSelected)) // The second parameter is the label previewed before opening the combo.
						{
							for (int i = 0; i < IM_ARRAYSIZE(actions_names); i++)
							{
								bool bIsSelected = false;
								if (strcmp(actions_names[i], ActionSelected) == NULL) bIsSelected = true;
								int flag = 0;// ImGuiSelectableFlags_Disabled;
								if (bIsSelected) flag = 0;
								if (ImGui::Selectable(actions_names[i], bIsSelected, flag))
								{
									if (Storyboard.Nodes[nodeid].type == STORYBOARD_TYPE_HUD && i >= STORYBOARD_ACTIONS_STARTGAME && i <= STORYBOARD_ACTIONS_RESUMEGAME)
									{
										// HUD screens cannot use the screen-control-actions inside a game level
										strcpy(cTriggerMessage, "You can only use this storyboard action in non-HUD screens!");
										bTriggerMessage = true;
									}
									else
									{
										Storyboard.Nodes[nodeid].widget_action[iCurrentSelectedWidget] = i;
									}
								}
							}
							ImGui::EndCombo();
						}
						ImGui::PopItemWidth();
					}
				}

				if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_IMAGE
				|| Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_VIDEO)
				{
					LPSTR pLabel = "Image";
					LPSTR pLabelSelect = "Select Image";
					LPSTR pLabelHide = "Hide Image In Game";
					LPSTR pLabelSize = "Image Size";
					LPSTR pWidgetUnique = "##imgsize";
					LPSTR pSizeTip = "Set the size of this image as a percentage of original size";
					LPSTR pWidgetPathToFile = "imagebank\\HUD\\";
					char name[MAX_PATH];
					strcpy (name, Storyboard.Nodes[nodeid].widget_normal_thumb[iCurrentSelectedWidget]);
					bool bWidgetIsVideo = false;
					if (Storyboard.Nodes[nodeid].widget_type[iCurrentSelectedWidget] == STORYBOARD_WIDGET_VIDEO)
					{
						pLabel = "Video";
						pLabelSelect = "Video File";
						pLabelHide = "Hide Video In Game";
						pLabelSize = "Video Size";
						pWidgetUnique = "##vidsize";
						pSizeTip = "Set the size of this video as a percentage of original size";
						pWidgetPathToFile = "videobank\\";
						strcpy (name, Storyboard.Nodes[nodeid].widget_highlight_thumb[iCurrentSelectedWidget]);
						bWidgetIsVideo = true;
					}
					if (g_bSelectedMapImageTypeSpecialHelp == false)
					{
						cstr cNewImageOrVideo = imgui_setpropertyfile2_v2(0, name, pLabel, pLabelSelect, pWidgetPathToFile, false, "");
						if (cNewImageOrVideo.Len() > 0 && stricmp(name, cNewImageOrVideo.Get()) != NULL)
						{
							// Delete old image or video thumb and trigger reload of the newly chosen one
							DeleteImage(Storyboard.Nodes[nodeid].widget_normal_thumb_id[iCurrentSelectedWidget]);
							if (bWidgetIsVideo == true)
							{
								// ensure original video stored for later use
								strcpy(Storyboard.Nodes[nodeid].widget_normal_thumb[iCurrentSelectedWidget], cNewImageOrVideo.Get());
								strcpy(Storyboard.Nodes[nodeid].widget_highlight_thumb[iCurrentSelectedWidget], cNewImageOrVideo.Get());

								// video needs to grab (if any) the video thumbnail (generated in the video library browser)
								char pVideoThumb[MAX_PATH];
								strcpy(pVideoThumb, cNewImageOrVideo.Get());
								if (strnicmp(pVideoThumb, "videobank\\", strlen("videobank\\")) == NULL)
								{
									strcpy(pVideoThumb, cNewImageOrVideo.Get() + strlen("videobank\\"));
									int thumb_x = 512; int thumb_y = 288;
									CreateBackBufferCacheName(pVideoThumb, thumb_x, thumb_y);
									char pThumbPath[MAX_PATH];
									strcpy (pThumbPath, BackBufferCacheName.Get());
									LPSTR pRelativePart = BackBufferCacheName.Get() + strlen(g.fpscrootdir_s.Get()) + strlen("\\Files\\");
									if (pThumbPath[1] == ':')
									{
										// if absolute, replace with relative path
										strcpy (pVideoThumb, pRelativePart);
									}
									if (FileExist(pVideoThumb)==0)
									{
										// if video in root, add underscore to find correct thumb (poss. bug)
										strcpy(pVideoThumb, "thumbbank\\_");
										strcat (pVideoThumb, pRelativePart + strlen("thumbbank\\"));
									}
									if (FileExist(pVideoThumb))
									{
										strcpy(Storyboard.Nodes[nodeid].widget_normal_thumb[iCurrentSelectedWidget], pVideoThumb);
									}
								}
							}
							else
							{
								// can use image file directly
								strcpy(Storyboard.Nodes[nodeid].widget_normal_thumb[iCurrentSelectedWidget], cNewImageOrVideo.Get());
							}
							iUpdateWidgetThumbNode = iCurrentSelectedWidget;
							iUpdateWidgetThumbButton = iCurrentSelectedWidget;
						}
					}
					bool bHidingImageInGame = false;
					if (bWidgetIsVideo == false)
					{
						if (Storyboard.widget_ingamehidden[nodeid][iCurrentSelectedWidget] == 1) bHidingImageInGame = true;
						if (ImGui::Checkbox(pLabelHide, &bHidingImageInGame))
						{
							if (bHidingImageInGame == true)
								Storyboard.widget_ingamehidden[nodeid][iCurrentSelectedWidget] = 1;
							else
								Storyboard.widget_ingamehidden[nodeid][iCurrentSelectedWidget] = 0;
						}
					}
					if (bWidgetIsVideo == false)
					{
						// image has color
						ImGui::TextCenter("Image Color");
						bool open_popup = ImGui::ColorButton("##StoryboardWidgetImageColor", Storyboard.widget_colors[nodeid][iCurrentSelectedWidget], 0, ImVec2(w - 20.0, 0));
						if (open_popup)
							ImGui::OpenPopup("##StoryboardWidgetImageColor");
						if (ImGui::BeginPopup("##StoryboardWidgetImageColor", ImGuiWindowFlags_NoMove))
						{
							if (ImGui::ColorPicker4("##StoryboardPickerImageColor", (float*)&Storyboard.widget_colors[nodeid][iCurrentSelectedWidget], ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview))
							{
							}
							ImGui::EndPopup();
						}
					}
					else
					{
						// video has playback controls
						bool g_bVideoLooping = false;
						if (Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] != 0) g_bVideoLooping = true;
						if (ImGui::Checkbox("Loop Video Animation", &g_bVideoLooping))
						{
							Storyboard.Nodes[nodeid].widget_font_size[iCurrentSelectedWidget] = (int)g_bVideoLooping;
						}
					}

					ImGui::TextCenter(pLabelSize);
					float fTmp = Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].x * 100.0f;
					if( ImGui::MaxSliderInputFloat(pWidgetUnique, &fTmp, 0, 100, pSizeTip, 0, 100))
					{
						if (fTmp < 1) fTmp = 1;
						Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].y = fTmp / 100.0f;
						Storyboard.Nodes[nodeid].widget_size[iCurrentSelectedWidget].x = fTmp / 100.0f;
					}
				}

				// Display and allow editing of readouts
				if (strlen(Storyboard.widget_readout[nodeid][iCurrentSelectedWidget]) > 0)
				{
					ImGui::TextCenter("Readout");
					ImGui::PushItemWidth(-10);
					std::string readout = Storyboard.widget_readout[nodeid][iCurrentSelectedWidget];
					if (ImGui::BeginCombo("##readoutcombo", readout.c_str()))
					{
						ImGui::Selectable(readout.c_str(), true);
						ImGui::EndCombo();
					}
					ImGui::PopItemWidth();

					// moved enry of 'widget_label' down here to match readout selection
					if (iUserDefinedGlobal > 0)
					{
						if (widgetType != STORYBOARD_WIDGET_PROGRESS )
						{
							// label
							if( iUserDefinedGlobal==2 )
								ImGui::TextCenter("User Defined Global Names");
							else
								ImGui::TextCenter("User Defined Global Name");

							// one or two (single or pair handling)
							char storeFirstEntry[MAX_PATH];
							strcpy(storeFirstEntry, "");
							strcpy(storeFirstEntry, Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget]);
							char storeSecondEntry[MAX_PATH];
							strcpy(storeSecondEntry, "");
							char* pDelimit = strstr(storeFirstEntry, ";");
							if (pDelimit)
							{
								strcpy(storeSecondEntry, pDelimit + 1);
								*pDelimit = 0;
							}

							// field (use dropdown for common values)
							ImGui::PushItemWidth(-10);
							bool bShowCustomValueBox = false;
							std::string readout = Storyboard.widget_readout[nodeid][iCurrentSelectedWidget];
							if (stricmp(readout.c_str(), "User Defined Global") == NULL)
							{
								bool bKnownValue = false;
								const char* pSelectedComboItem = "";
								for (int n = 0; n <= g_gameGlobalListNodeId.size(); n++)
								{
									LPSTR pThisGlobItem = "";
									if (n < g_gameGlobalListNodeId.size())
									{
										int i = g_gameGlobalListIndex[n];
										int allhudscreensnodeid = g_gameGlobalListNodeId[n];
										pThisGlobItem = Storyboard.Nodes[allhudscreensnodeid].widget_label[i];
										if (stricmp(pThisGlobItem, storeFirstEntry) == NULL)
										{
											pSelectedComboItem = pThisGlobItem;
											bKnownValue = true;
											break;
										}
									}
								}
								if ( strlen(pSelectedComboItem) == 0 )
								{
									pSelectedComboItem = "Custom Value";
									bShowCustomValueBox = true;
								}
								if (ImGui::BeginCombo("##comboRPGGlobalKinds", pSelectedComboItem))
								{
									for (int n = 0; n <= g_gameGlobalListNodeId.size(); n++)
									{
										LPSTR pThisGlobItem = "";
										if (n < g_gameGlobalListNodeId.size())
										{
											int i = g_gameGlobalListIndex[n];
											int allhudscreensnodeid = g_gameGlobalListNodeId[n];
											pThisGlobItem = Storyboard.Nodes[allhudscreensnodeid].widget_label[i];
										}
										else
										{
											pThisGlobItem = "Custom Value";
										}
										bool bIsSelected = false;
										if (stricmp(pThisGlobItem, storeFirstEntry) == NULL) bIsSelected = true;
										if (ImGui::Selectable(pThisGlobItem, bIsSelected))
										{
											if (n < g_gameGlobalListNodeId.size())
											{
												strcpy(storeFirstEntry, pThisGlobItem);
											}
											else
											{
												if (bKnownValue == true) strcpy(storeFirstEntry, "");
											}
											g_bRefreshGlobalList = true;
											break;
										}
									}
									ImGui::EndCombo();
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify a user defined global value");
							}
							if (strcmp(readout.c_str(), "User Defined Global Text") == NULL)
							{
								const char* rpginventorykinds[] = { "prompt:main", "selected:title", "selected:description", "selected:cost", "selected:value", "selected:ingredients", "craft:title", "craft:ingredients", "Custom Value" };
								int rpginventorykinds_selection = -1;
								for (int n = 0; n <= IM_ARRAYSIZE(rpginventorykinds) - 2; n++)
								{
									if (stricmp(rpginventorykinds[n], storeFirstEntry) == NULL)
									{
										rpginventorykinds_selection = n;
										break;
									}
								}
								int ishowselectionincombo = rpginventorykinds_selection;
								if (ishowselectionincombo == -1) ishowselectionincombo = IM_ARRAYSIZE(rpginventorykinds) - 1;
								if (ImGui::Combo("##comboRPGInventoryKinds", &ishowselectionincombo, rpginventorykinds, IM_ARRAYSIZE(rpginventorykinds)))
								{
									if (ishowselectionincombo <= IM_ARRAYSIZE(rpginventorykinds) - 2)
									{
										strcpy (storeFirstEntry, rpginventorykinds[ishowselectionincombo]);
									}
									else
									{
										for (int n = 0; n <= IM_ARRAYSIZE(rpginventorykinds) - 2; n++)
										{
											if (stricmp(rpginventorykinds[n], storeFirstEntry) == NULL)
											{
												strcpy(storeFirstEntry, "");
												break;
											}
										}
										rpginventorykinds_selection = -1;
									}
								}
								if (rpginventorykinds_selection == -1)
								{
									bShowCustomValueBox = true;
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify the user global value used by this text");
							}
							if (strcmp(readout.c_str(), "User Defined Global Image") == NULL)
							{
								const char* rpginventorykinds[] = { "selected:image", "scrollbar:box", "scrollbar:handle", "map:window", "map:image", "map:player", "map:winzone", "map:character", "map:objective", "Custom Value" };
								int rpginventorykinds_selection = -1;
								for (int n = 0; n <= IM_ARRAYSIZE(rpginventorykinds) - 2; n++)
								{
									if (stricmp(rpginventorykinds[n], storeFirstEntry) == NULL)
									{
										rpginventorykinds_selection = n;
										break;
									}
								}
								int ishowselectionincombo = rpginventorykinds_selection;
								if (ishowselectionincombo == -1) ishowselectionincombo = IM_ARRAYSIZE(rpginventorykinds) - 1;
								if (ImGui::Combo("##comboRPGImageKinds", &ishowselectionincombo, rpginventorykinds, IM_ARRAYSIZE(rpginventorykinds)))
								{
									if (ishowselectionincombo <= IM_ARRAYSIZE(rpginventorykinds) - 2)
									{
										strcpy (storeFirstEntry, rpginventorykinds[ishowselectionincombo]);
									}
									else
									{
										for (int n = 0; n <= IM_ARRAYSIZE(rpginventorykinds) - 2; n++)
										{
											if (stricmp(rpginventorykinds[n], storeFirstEntry) == NULL)
											{
												strcpy(storeFirstEntry, "");
												break;
											}
										}
										rpginventorykinds_selection = -1;
									}
								}
								if (rpginventorykinds_selection == -1)
								{
									bShowCustomValueBox = true;
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify a user defined global value used by this image");

								// Extra help in screen editor
								g_bSelectedMapImageTypeSpecialHelp = false;
								if ( stricmp(storeFirstEntry,"map:image")==NULL )
								{
									ImGui::TextWrapped("NOTE: Map Image will be replaced with the Map Snaphot associated with each level of your game project");
									if (ImGui::IsItemHovered()) ImGui::SetTooltip("You can generate a map snapshot by using the dropdown menu for the level in the Storyboard Editor");
									g_bSelectedMapImageTypeSpecialHelp = true;
								}
							}
							if (strcmp(readout.c_str(), "User Defined Global Panel") == NULL)
							{
								const char* rpginventorykinds[] = { "inventory:player", "inventory:hotkeys", "inventory:container", "inventory:craft", "Custom Value" };
								int rpginventorykinds_selection = -1;
								for (int n = 0; n <= IM_ARRAYSIZE(rpginventorykinds) - 2; n++)
								{
									if (stricmp(rpginventorykinds[n], storeFirstEntry) == NULL)
									{
										rpginventorykinds_selection = n;
										break;
									}
								}
								int ishowselectionincombo = rpginventorykinds_selection;
								if (ishowselectionincombo == -1) ishowselectionincombo = IM_ARRAYSIZE(rpginventorykinds) - 1;
								if (ImGui::Combo("##comboRPGInventoryKinds", &ishowselectionincombo, rpginventorykinds, IM_ARRAYSIZE(rpginventorykinds)))
								{
									if (ishowselectionincombo <= IM_ARRAYSIZE(rpginventorykinds) - 2)
									{
										strcpy (storeFirstEntry, rpginventorykinds[ishowselectionincombo]);
									}
									else
									{
										for (int n = 0; n <= IM_ARRAYSIZE(rpginventorykinds) - 2; n++)
										{
											if (stricmp(rpginventorykinds[n], storeFirstEntry) == NULL)
											{
												strcpy(storeFirstEntry, "");
												break;
											}
										}
										rpginventorykinds_selection = -1;
									}
								}
								if (rpginventorykinds_selection==-1)
								{
									bShowCustomValueBox = true;
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify the user global value used by this panel");
							}
							ImGui::PopItemWidth();
							if (strcmp(readout.c_str(), "User Defined Global Statusbar") == NULL)
							{
								bShowCustomValueBox = true;
							}
							if (bShowCustomValueBox == true )
							{
								cstr UniqueTextFiledName = cstr("##WidgetTextStoryboardInput") + cstr(iCurrentSelectedWidget);
								ImGui::PushItemWidth(-10);
								static char tempinputFirstEntry[251];
								static int ilastSelectedWidget = -1;
								if (iCurrentSelectedWidget+(nodeid*1000) != ilastSelectedWidget)
								{
									ilastSelectedWidget = iCurrentSelectedWidget + (nodeid * 1000);
									strcpy(tempinputFirstEntry, storeFirstEntry);
								}
								if (ImGui::InputText(UniqueTextFiledName.Get(), tempinputFirstEntry, 250, ImGuiInputTextFlags_EnterReturnsTrue))
								{
									strcpy(storeFirstEntry, tempinputFirstEntry);
									g_bRefreshGlobalList = true;
								}
								if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
								ImGui::PopItemWidth();
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify a user defined global or one of the presets (Health Remaining, Ammo Remaining, Maximum Ammo, Lives Remaining)");
							}

							// globals pairs are used for things like status bars (current value var and max var)
							if (iUserDefinedGlobal == 2)
							{
								// ask for a second on its own
								cstr UniqueTextFiledNameSecond = cstr("##WidgetTextStoryboardInputSecond") + cstr(iCurrentSelectedWidget);
								ImGui::PushItemWidth(-10);
								if (ImGui::InputText(UniqueTextFiledNameSecond.Get(), storeSecondEntry, 250, ImGuiInputTextFlags_EnterReturnsTrue))
								{
									g_bRefreshGlobalList = true;
								}
								if (ImGui::IsItemHovered()) ImGui::SetTooltip("Specify a second user defined global or one of the presets (Maximum Health, Weapon Reload Quantity, Maximum Clipped Ammo)");
								if (ImGui::MaxIsItemFocused()) bImGuiGotFocus = true;
								ImGui::PopItemWidth();
							}

							// global pairs reconstruct first and second and store for later use
							strcpy(Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], storeFirstEntry);
							if (strlen(storeSecondEntry) > 0)
							{
								strcat(Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], ";");
								strcat(Storyboard.Nodes[nodeid].widget_label[iCurrentSelectedWidget], storeSecondEntry);
							}
						}
					}
				}
				ImGui::Indent(-10);
			}

			// from here, initial values can be set for all detected user global variables in this screen (nice place for them)
			cstr sUserGlobalLabel = "User Defined Global Settings";
			if (ImGui::StyleCollapsingHeader(sUserGlobalLabel.Get(), ImGuiTreeNodeFlags_DefaultOpen))
			{
				ImGui::Indent(10);
				// only for HUD screens
				if (g_bRefreshGlobalList == true)
				{
					g_gameGlobalListNodeId.clear();
					g_gameGlobalListIndex.clear();
					g_gameGlobalListValue.clear();
					for (int allhudscreensnodeid = 0; allhudscreensnodeid < STORYBOARD_MAXNODES; allhudscreensnodeid++)
					{
						if (strlen(Storyboard.Nodes[allhudscreensnodeid].lua_name) > 0 && strnicmp(Storyboard.Nodes[allhudscreensnodeid].lua_name, "hud", 3) == NULL)
						{
							for (int i = STORYBOARD_MAXWIDGETS; i >= 0; i--)
							{
								if (Storyboard.Nodes[allhudscreensnodeid].widget_type[i] == STORYBOARD_WIDGET_TEXT)
								{
									std::string readout = Storyboard.widget_readout[allhudscreensnodeid][i];
									if (stricmp(readout.c_str(), "User Defined Global") == NULL)
									{
										// only add unique ones to game global list
										LPSTR pNewName = Storyboard.Nodes[allhudscreensnodeid].widget_label[i];
										for (int n = 0; n < g_gameGlobalListNodeId.size(); n++)
										{
											int thisnodeid = g_gameGlobalListNodeId[n];
											int index = g_gameGlobalListIndex[n];
											LPSTR pThisName = Storyboard.Nodes[thisnodeid].widget_label[index];
											if (strcmp(pNewName, pThisName) == NULL)
											{
												// already exists
												pNewName = "";
												break;
											}
										}
										if (strlen(pNewName) > 0)
										{
											g_gameGlobalListNodeId.push_back(allhudscreensnodeid);
											g_gameGlobalListIndex.push_back(i);
											g_gameGlobalListValue.push_back(Storyboard.Nodes[allhudscreensnodeid].widget_initial_value[i]);
										}
									}
								}
							}
						}
					}
				}
				bool bChangedAGameGlobal = false;
				for (int n = 0; n < g_gameGlobalListNodeId.size(); n++)
				{
					int allhudscreensnodeid = g_gameGlobalListNodeId[n];
					int i = g_gameGlobalListIndex[n];
					ImGui::TextCenter(Storyboard.Nodes[allhudscreensnodeid].widget_label[i]);
					char pUDGVar[256];
					sprintf(pUDGVar, "##WidgetUDG%d-%d", allhudscreensnodeid, i);
					float fValue = g_gameGlobalListValue[n];
					ImGui::MaxSliderInputFloat(pUDGVar, &fValue, 0, 100, "Set Initial Value for this User Defined Global", 0, 100);
					if (fValue != g_gameGlobalListValue[n])
					{
						g_gameGlobalListValue[n] = fValue;
						bChangedAGameGlobal = true;
					}
				}
				if (g_bRefreshGlobalList == true)
				{
					if (bChangedAGameGlobal == true)
					{
						for (int allhudscreensnodeid = 0; allhudscreensnodeid < STORYBOARD_MAXNODES; allhudscreensnodeid++)
						{
							if (strlen(Storyboard.Nodes[allhudscreensnodeid].lua_name) > 0 && strnicmp(Storyboard.Nodes[allhudscreensnodeid].lua_name, "hud", 3) == NULL)
							{
								for (int i = STORYBOARD_MAXWIDGETS; i >= 0; i--)
								{
									if (Storyboard.Nodes[allhudscreensnodeid].widget_type[i] == STORYBOARD_WIDGET_TEXT)
									{
										std::string readout = Storyboard.widget_readout[allhudscreensnodeid][i];
										if (stricmp(readout.c_str(), "User Defined Global") == NULL)
										{
											// only add unique ones to game global list
											LPSTR pNewName = Storyboard.Nodes[allhudscreensnodeid].widget_label[i];
											for (int n = 0; n < g_gameGlobalListNodeId.size(); n++)
											{
												int thisnodeid = g_gameGlobalListNodeId[n];
												int index = g_gameGlobalListIndex[n];
												LPSTR pThisName = Storyboard.Nodes[thisnodeid].widget_label[index];
												if (strcmp(pNewName, pThisName) == NULL)
												{
													Storyboard.Nodes[allhudscreensnodeid].widget_initial_value[i] = g_gameGlobalListValue[n];
													break;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				g_bRefreshGlobalList = false;
				if (bChangedAGameGlobal == true)
				{
					// if modify a global, allow another refresh to place in initial_value
					g_bRefreshGlobalList = true;
				}
				ImGui::Indent(-10);
			}

			if (bReadOnly)
			{
				ImGui::PopItemFlag();
				ImGui::PopStyleVar();
			}

			if (ImGui::GetCurrentWindow()->ScrollbarSizes.x > 0) {
				//Hitting exactly at the botton could cause flicker, so add some additional lines when scrollbar on.
				ImGui::Text("");
				ImGui::Text("");
			}
			//ImGui::EndChild();
		}

		if ((!standalone && !bPreviewScreen) || (bPreviewScreen && !bPrevPreviewScreen))
		{
			ImGui::EndChild(); //"##SERightPanel"
		}

		if (!bPreviewScreen)
			ImGui::Columns(1);

		if (iQuitWindowLoop > 0)
		{
			if (iQuitWindowLoop == 1)
			{
				BackBufferSaveCacheName = "";
				BackBufferObjectID = 0;
				BackBufferImageID = 0;
				bLoopBackBuffer = false;
				BackBufferSnapShotMode = false;
				bSnapShotModeUse2D = false;
				bFullScreenBackbuffer = false;
				//Use Grab to get center of screen.
				if (BitmapExist(99))
				{
					ImRect rGrabMonitorArea = rMonitorArea;

					//PE: Widescreen - now use full backbuffer so everything fits.
					//ImRect rGrabMonitorArea = { 29.0,108.0,1597.0,990.0 };
					//float screen_ration_x = 1920.0 / ImGui::GetMainViewport()->Size.x;
					//float screen_ration_y = 1017.0 / ImGui::GetMainViewport()->Size.y;

					SetGrabImageMode(1);
					LPGGSURFACE	pTmpSurface = g_pGlob->pCurrentBitmapSurface;
					ID3D11Texture2D *pBackBuffer = NULL;
					pBackBuffer = (ID3D11Texture2D *)GetBitmapTexture2D(99);
					g_pGlob->pCurrentBitmapSurface = pBackBuffer;
					GGSURFACE_DESC ddsd;
					pBackBuffer->GetDesc(&ddsd);

					float grabx = rGrabMonitorArea.Max.x - rGrabMonitorArea.Min.x;
					float graby = rGrabMonitorArea.Max.y - rGrabMonitorArea.Min.y;
					//graby -= 10.0;

					//PE: Change to using vMonitorStart its already in pixels.
					float imgcx = vMonitorStart.x + 1.0; //Skip our padding line.
					float imgcy = vMonitorStart.y + 1.0; //Skip our padding line.

					if (graby > ddsd.Height)
						graby = ddsd.Height;
					if (grabx > ddsd.Width)
						grabx = ddsd.Width;

					if (imgcx + grabx > ddsd.Width) imgcx = ddsd.Width - grabx - 1.0; // check is >= so need -1.
					if (imgcy < 0) imgcy = 0;
					if (imgcx < 0) imgcx = 0;

					bool bValid = true;
					if (imgcx >= imgcx + grabx || imgcy >= imgcy + graby)
					{
						//PE: pBackBuffer->GetDesc failed ?
						if (ddsd.Width >= 1900 && ddsd.Height >= 1000)
						{
							imgcx = 30.0;
							imgcy = 98.0;
							grabx = 1567.0;
							graby = 872.0;
						}
						else
							bValid = false;
					}

					if (bValid)
					{
						//PE: We need a unique id for this STORYBOARD_THUMBS+400
						GrabImage(STORYBOARD_THUMBS + 400, imgcx, imgcy, imgcx + grabx, imgcy + graby, 3);
						SetGrabImageMode(0);
					}
					g_pGlob->pCurrentBitmapSurface = pTmpSurface;

					GG_SetWritablesToRoot(true);
					if (FileExist("thumbbank\\lastnewlevel.jpg")) DeleteAFile("thumbbank\\lastnewlevel.jpg");
					GG_SetWritablesToRoot(false);

					if (bValid)
					{
						if (ImageExist(STORYBOARD_THUMBS + 400))
						{
							char destination[MAX_PATH];
							strcpy(destination, "thumbbank\\lastnewlevel.jpg");
							GG_SetWritablesToRoot(true);
							GG_GetRealPath(destination, 1);
							GG_SetWritablesToRoot(false);
							//Need a no alpha save.
							extern bool g_bDontUseImageAlpha;
							g_bDontUseImageAlpha = true;
							SaveImage(destination, STORYBOARD_THUMBS + 400);
							g_bDontUseImageAlpha = false;
							DeleteImage(STORYBOARD_THUMBS + 400);
						}
					}
				}

				//Quit and get new thumb to correct node id.
				iWaitFor2DEditor = 5;
				iWaitFor2DEditorNode = nodeid;
				bScreen_Editor_Window = false;
				if (BitmapExist(99))
				{
					DeleteBitmapEx(99);
				}

				//PE: Change output link based on changes.
				setup_output_links(nodeid);
			}
			else
			{
				//Grab a thumb. need some frames.
				BackBufferIsGroup = false;
				BackBufferEntityID = 0;
				BackBufferObjectID = 0;
				BackBufferImageID = g.importermenuimageoffset + 50;
				//iLargePreviewImageID = BackBufferImageID;
				BackBufferSizeX = ImGui::GetMainViewport()->Size.x;
				BackBufferSizeY = ImGui::GetMainViewport()->Size.y;
				BackBufferZoom = 1.0f;
				BackBufferCamLeft = 0.0f;
				BackBufferCamUp = 0.0f;
				bRotateBackBuffer = false;
				bBackBufferAnimated = false;
				BackBufferSaveCacheName = ""; //No saving on tooltip images
				fLastRubberBandX1 = fLastRubberBandX2 = fLastRubberBandY1 = fLastRubberBandY2 = 0.0f;//Dont fit snapshot to rubber band.
				//Control camera snap shot.
				bLoopBackBuffer = true;
				bSnapShotModeUseCamera = true;
				BackBufferSnapShotMode = true;
				bSnapShotModeUse2D = true;
				bFullScreenBackbuffer = true;
			}

			if (iQuitWindowLoop == 4)
			{
				if (BitmapExist(99))
				{
					DeleteBitmapEx(99);
				}
			}

			iQuitWindowLoop--;
		}

		if (standalone)
		{
			ImGui::PopStyleColor();
			ImGui::PopStyleVar();   // pop window padding
			ImGui::PopStyleVar();   // pop frame padding
			ImGui::PopStyleVar();   // pop item padding
			ImGui::PopStyleVar();   // windows border
			ImGui::End();
		}

	}
	else
	{
		//Something wrong, close down window.
		bScreen_Editor_Window = false;
	}

	// Delete currently selected widget
	if (iCurrentSelectedWidget>=0 && bScreen_Editor_Window && !bPreviewScreen && !standalone)
	{
		extern ImRect g_rStealMonitorArea;
		ImVec2 mPos = ImGui::GetMousePos();
		if (mPos.x > g_rStealMonitorArea.Min.x && mPos.x < g_rStealMonitorArea.Max.x && mPos.y > g_rStealMonitorArea.Min.y && mPos.y < g_rStealMonitorArea.Max.y)
		{
			// only if within monitor area
			static bool bBlockUntilKeyReleased = false;
			constexpr int deleteKey = 46;
			if (ImGui::GetIO().KeysDown[deleteKey] && !bBlockUntilKeyReleased)
			{
				RemoveWidgetFromScreen(nodeid, iCurrentSelectedWidget);
				bBlockUntilKeyReleased = true;
			}
			else if (ImGui::GetIO().KeysDown[deleteKey] == false)
			{
				bBlockUntilKeyReleased = false;
			}
		}

		static bool bRMBMenu = false;
		if (ImGui::IsMouseReleased(0))
		{
			if (bRMBMenu)
			{
				ImGui::CloseCurrentPopup();
				bRMBMenu = false;
			}
		}
		if (ImGui::IsMouseClicked(1))
		{
			bRMBMenu = true;
			ImGui::OpenPopup("##rmbmenu");
		}

		static int iRightClickItem = -1;
		if (ImGui::BeginPopup("##rmbmenu", ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings))
		{
			//PE: When right click and popup open, widget is not hovered and iCurrentSelectedWidget is set to 0.
			if (iRightClickItem < 0)
				iRightClickItem = iCurrentSelectedWidget;
			if (ImGui::Selectable("Delete##rmbdelete"))
			{
				RemoveWidgetFromScreen(nodeid, iRightClickItem);
			}
			ImGui::Separator();
			if (ImGui::Selectable("Send to Back##rmbtoback"))
			{
				SendWidgetToBack(nodeid, iRightClickItem);
			}
			if (ImGui::Selectable("Send to Front##rmbtofront"))
			{
				SendWidgetToFront(nodeid, iRightClickItem);
			}
			ImGui::EndPopup();
		}
		else
		{
			iRightClickItem = -1;
		}
	}

	// Modal window, waits for user to press a key. The key that they press will be used to toggle the visibility of the current screen
	if (bScreenToggleKeyWindow)
	{
		bImGuiGotFocus = true;
		ImGui::SetNextWindowPosCenter(ImGuiCond_Always);
		ImGui::SetNextWindowSize(ImVec2(512, 256));
		ImGui::OpenPopup("##screenkeytogglepopup");
		ImGui::BeginPopupModal("##screenkeytogglepopup", 0, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse);

		ImGui::Text("");
		ImGui::Text("");
		ImGui::Text("");
		ImGui::Text("");
		ImGui::TextCenter("Press the key that you would like to make this screen appear in-game.");
		ImGui::Text("");
		ImGui::TextCenter("Press SPACEBAR to reset selection back to NONE.");

		ImGuiStyle& style = ImGui::GetStyle();
		ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(1.0f, 1.0f, 1.0f, 0.54f));
		t.inputsys.kscancode = ScanCode();
		if (t.inputsys.kscancode > 0)
		{
			if (t.inputsys.kscancode != 57)
			{
				// use that key code
				Storyboard.Nodes[nodeid].toggleKey = t.inputsys.kscancode;
			}
			else
			{
				// reset key toggle
				Storyboard.Nodes[nodeid].toggleKey = 0;
			}
			ImGui::CloseCurrentPopup();
			ResetStoryboardListenForKeys();
			bScreenToggleKeyWindow = false;
		}
		ImGui::PopStyleColor();
		ImGui::Text("");
		ImGui::EndPopup();
	}

	return iRet;
}

int autosave_storyboard_project(void)
{
	int iAction = 0;
	if (!Storyboard.iChanged) return iAction;
	if (!pref.iDisableProjectAutoSave && strlen(Storyboard.gamename) > 0)
	{
		save_storyboard(Storyboard.gamename, false);
	}
	else
	{
		if (strlen(Storyboard.gamename) > 0)
		{
			iAction = askBoxCancel(STORYBOARD_SAVE_MESSAGE, "Confirmation"); //1==Yes 2=Cancel 0=No
			if (iAction == 1)
			{
				save_storyboard(Storyboard.gamename, false);
			}
		}
	}
	return iAction;
}

int GetStoryboardCustomScreenNode(char *page)
{
	if( pestrcasestr(page, "custom") && strlen(page) <= 8 )
	{
		int iNode = FindLuaScreenNode(page);
		if (iNode >= 0 && strlen(Storyboard.gamename) > 0)
		{
			return(iNode);
		}
	}
	return -1;
}

void GetStoryboardCustomScreenNodeName(int iNode, char* pRealNameStr)
{
	strcpy(pRealNameStr, Storyboard.Nodes[iNode].lua_name);
	if (strnicmp(pRealNameStr + strlen(pRealNameStr) - 4, ".lua", 4) == NULL)
	{
		// chop any .lua extension
		pRealNameStr[strlen(pRealNameStr) - 4] = 0;
	}
}

bool bTempDisableRain = false;
bool bTempDisableSnow = false;

void update_per_frame_effects(void)
{
}

#ifdef WICKEDENGINE
#ifdef STANDALONENOTICE
void early_access_strandalone_welcome( void )
{
	void StartForceRender(void);
	bool quit = false;
	bool bBrowserStarted = false;
	image_setlegacyimageloading(true);
	LoadImage("editors\\uiv3\\standalone_ea-ea.png", SKYBOX_ICONS+99);
	image_setlegacyimageloading(false);

	while (!quit)
	{
		if (!bRenderTabTab && !bImGuiFrameState)
		{
			//We need a new frame.
			ImGui_ImplDX11_NewFrame();
			ImGui_ImplWin32_NewFrame();
			ImGui::NewFrame();
			bRenderTabTab = true;
			bBlockImGuiUntilNewFrame = false;
			extern bool bSpriteWinVisible;
			bSpriteWinVisible = false;
			bImGuiRenderWithNoCustomTextures = false;
		}
		//From lua, we need to update imgui mousepos ...
		int mclick = 0;
		ImGuiIO& io = ImGui::GetIO();
		io.MouseDown[0] = 0;
		io.MouseDown[1] = 0;
		io.MouseDown[2] = 0;
		io.MouseDown[3] = 0;

		mclick = MouseClick();

		if (mclick == 1) io.MouseDown[0] = 1;
		if (mclick == 2) io.MouseDown[1] = 1;
		if (mclick == 4) io.MouseDown[2] = 1;

		ImGuiViewport* viewport = ImGui::GetMainViewport();
		ImGui::SetNextWindowViewport(viewport->ID);
		ImVec2 viewPortPos = ImGui::GetMainViewport()->Pos;
		ImVec2 viewPortSize = ImGui::GetMainViewport()->Size;
		ImGui::SetNextWindowPos(viewPortPos, ImGuiCond_Always);
		ImGui::SetNextWindowSize(viewPortSize, ImGuiCond_Always);

		ImGui::Begin("##Early Access Version", &quit, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize);

		ImVec2 cpos = ImGui::GetCursorPos();
		float img_w = 1260;
		float img_h = 900;
		ImVec2 img_pos = ImVec2(0.0, 0.0);

		ID3D11ShaderResourceView* lpTexture = GetImagePointerView(SKYBOX_ICONS + 99);
		if (lpTexture)
		{
			//Support center,stretch,zoom
			//Storyboard.Nodes[nodeid].screen_backdrop_placement
			//Center;

			img_w = ImageWidth(SKYBOX_ICONS + 99);
			img_h = ImageHeight(SKYBOX_ICONS + 99);

			ImVec2 vSize = ImGui::GetMainViewport()->Size;

			if (img_w > vSize.x || img_h > vSize.y) {
				float fRatio = 1.0f / (img_w / img_h);
				img_w = vSize.x;
				img_h = vSize.x * fRatio;
				if (img_h > vSize.y) {
					float fRatio = 1.0f / (img_h / img_w);
					img_h = vSize.y;
					img_w = vSize.y * fRatio;
				}
			}
			img_pos = ImVec2(0.0, 0.0);
			img_pos.x += (vSize.x - img_w) * 0.5;
			img_pos.y += (vSize.y - img_h) * 0.5;
			ImGuiWindow* window = ImGui::GetCurrentWindow();
			window->DrawList->AddImage((ImTextureID)lpTexture, img_pos, img_pos + ImVec2(img_w, img_h), ImVec2(0, 0), ImVec2(1, 1), ImGui::GetColorU32(ImVec4(1.0, 1.0, 1.0, 1.0)));
			cpos = img_pos + ImVec2(0, img_h-260.0);
		}
		else
		{
			ImGui::Dummy(ImVec2(1250, 900));
		}
		ImGui::SetCursorPos(cpos);

		ImGui::SetNextWindowPos(img_pos + ImVec2(0, img_h - 280.0), ImGuiCond_Always);
		ImGui::BeginChild("##DummyEAwelcomechild", ImVec2(img_w-20,280.0), false, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoBackground);
		ImGui::Indent(20);
		ImGui::Text("");
		ImGui::SetWindowFontScale(1.3);
		//ImGui::TextWrapped("PLEASE NOTE\nThis game project has been exported from the Early Access version of GameGuru MAX and is for test purposes only. You should not have been charged to play this game and the quality of the game and performance does not reflect the final quality of GameGuru MAX games.");
		ImGui::TextWrapped("IMPORTANT - PLEASE NOTE!\nDuring the Early Access development phase of GameGuru MAX, all games saved as standalone are considered test games and must not be sold. The games will include a startup message informing users that the game has been made with an Early Access version. This restriction will be lifted once we leave Early Access.\n\nIf you develop a full game and would like to apply for it to be published before the full release of GameGuru MAX then please follow this LINK and fill out the short form. \n\nPlease ensure that anyone you share your standalone game with has a PC system that meets the minimum requirements of GameGuru MAX.");
		ImVec2 prevCursor = ImGui::GetCursorPos();
		ImGui::SetCursorPos(prevCursor + ImVec2(1006, -96));
		if (ImGui::HyberlinkButton("", ImVec2(ImGui::GetFontSize() * 2.2f, ImGui::GetFontSize() * 1.5f)))
		{
			ExecuteFile("https://www.game-guru.com/publish-request", 0, 0);
		}
		ImGui::SetCursorPos(prevCursor);
		ImGui::Text("");
		ImGui::SetWindowFontScale(1.6);
		float buttonwide = ImGui::GetContentRegionAvail().x*0.5 - 10.0f;
		if (ImGui::StyleButton("VISIT GAMEGURU MAX WEBSITE", ImVec2(buttonwide, 0)))
		{
			/*ExecuteFile("https://www.game-guru.com/max", "", "", 0);*/
			ExecuteFile("https://bit.ly/MAXWebsite", "", "", 0);
		
			Sleep(1000); //Give it time to startup.
			bBrowserStarted = true;
		}
		ImGui::SameLine();
		ImGui::SetCursorPos(ImGui::GetCursorPos() +ImVec2(10.0,0.0));
		if (ImGui::StyleButton("CONTINUE", ImVec2(buttonwide, 0)))
		{
			quit = true;
		}

		ImGui::SetWindowFontScale(1.0);
		ImGui::RenderMouseCursor(ImVec2(io.MousePos.x, io.MousePos.y), 1.0);
		ImGui::Indent(-20);
		ImGui::EndChild();
		ImGui::End();

		StartForceRender();
		if (bBrowserStarted) Sleep(15); //Hand over time to browser.
	}
	if (ImageExist(SKYBOX_ICONS + 99))
	{
		StartForceRender();
		DeleteImage(SKYBOX_ICONS + 99);
	}
	bBlockImGuiUntilNewFrame = true;

}
#endif
#endif

#endif


#endif

#ifdef WICKEDENGINE
void HandleObjectDeletion()
{
	//  delete selected entity via delete key
	bool bNoDelete = false;
	static bool bWaitOnDelRelease = false;
#ifdef WICKEDENGINE
	if (bWaitOnDelRelease && t.inputsys.kscancode == 211)
		bNoDelete = true;
	else
		bWaitOnDelRelease = false;
#endif

	if (!bNoDelete && t.onetimeentitypickup == 0)
	{
		if (t.gridentity != 0)
		{
			if (t.inputsys.kscancode == 211 || iExecuteCTRLkey == ImGuiKey_Delete)
			{
				t.inputsys.mclickreleasestate = 1;
				t.gridentitydelete = 1;
				t.selstage = 1;
				t.inputsys.kscancode = 0;
				t.widget.pickedObject = 0; //dont remove widget object.
				bWaitOnDelRelease = true;
			}
		}
		else
		{
			if (t.inputsys.kscancode == 211 || (t.widget.deletebuttonselected == 1 && t.inputsys.mclick == 0) || iExecuteCTRLkey == ImGuiKey_Delete)
			{
				t.widget.deletebuttonselected = 0;
				bool bContinueWithDelete = true;
				if (t.widget.pickedEntityIndex > 0)
				{
					// specifically avoid deleting child entities if highlighting a parent
					if (g.entityrubberbandlist.size() > 0)
					{
						bool bDisableRubberBandMoving = false;
						#ifdef WICKEDENGINE
						if (current_selected_group >= 0 && group_editing_on)
						{
							bDisableRubberBandMoving = true;
						}
						#endif
						if (!bDisableRubberBandMoving)
						{
							//LB: to ensure cannot delete objects that are part of a group, 
							// check if the group is a parent group (user can delete child groups okay)
							#ifdef WICKEDENGINE
							// before make final decision, see if a parent group can hand over control to one of its child groups
							if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
							{
								// this group is a parent, so see if there are any child groups
								int iLookForThisID = vEntityGroupList[current_selected_group][0].iGroupID;
								for (int gi = 0; gi < MAXGROUPSLISTS; gi++)
								{
									if (gi != current_selected_group && vEntityGroupList[gi].size() > 0)
									{
										if (vEntityGroupList[gi][0].iParentGroupID == iLookForThisID)
										{
											// found a child of this parent, switch roles (so parent can be deleted below)
											for (int n = 0; n < vEntityGroupList[gi].size(); n++)
											{
												// child becomes the parent
												vEntityGroupList[gi][n].iGroupID = iLookForThisID;
												vEntityGroupList[gi][n].iParentGroupID = -1;
											}
											for (int n = 0; n < vEntityGroupList[current_selected_group].size(); n++)
											{
												// parent becomes the child (temporarily so they can be deleted)
												vEntityGroupList[current_selected_group][n].iGroupID = -1;
												vEntityGroupList[current_selected_group][n].iParentGroupID = iLookForThisID;
											}
											// also, ensure the original parent group image survives, so copy just before deletions
											iEntityGroupListImage[gi] = iEntityGroupListImage[current_selected_group];
											// only need one child to become parent
											break;
										}
									}
								}
							}
							// prevent deleting them, and instead instruct user to ungroup the objects first
							if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iGroupID != -1)
							{
								// do not delete 'key' objects that are part of group
								strcpy(cTriggerMessage, "Cannot delete a parent group. First ungroup objects, then you can delete them all.");
								bTriggerMessage = true;
								bContinueWithDelete = false;
							}
							else
							#endif
							{
								#ifdef WICKEDENGINE
								// before delete, ensure child groups are ungrouped before the delete
								if (current_selected_group >= 0 && vEntityGroupList[current_selected_group][0].iParentGroupID != -1)
								{
									// pass flag to ensure rubber band list not cleared, so we can delete below
									UnGroupSelected(true);
								}
								#endif
								// delete all entities in rubber band highlight list
								gridedit_deleteentityrubberbandfrommap();
								gridedit_clearentityrubberbandlist();
								t.widget.pickedEntityIndex = 0;
							}
						}
					}
				}
				if (bContinueWithDelete == true)
				{
					if (t.widget.pickedObject > 0)
					{
						// delete a single entity selected by widget
						if (t.widget.pickedEntityIndex > 0)
						{
							t.tentitytoselect = t.widget.pickedEntityIndex;
#ifdef WICKEDENGINE
							DeleteEntityFromLists(t.tentitytoselect);
#endif
							gridedit_deleteentityfrommap();
						}
						t.widget.pickedObject = 0;
						widget_updatewidgetobject();
					}
					bWaitOnDelRelease = true;
					t.tentitytoselect = 0;
				}
			}
			if (t.inputsys.keyspace == 0) t.inputsys.spacekeynotreleased = 0;
			if (t.inputsys.keyspace == 1 && t.inputsys.rubberbandmode == 0 && t.inputsys.spacekeynotreleased == 0)
			{
				// end selection when press SPACE
				gridedit_clearentityrubberbandlist();
				t.widget.pickedEntityIndex = 0;
				if (t.widget.pickedObject > 0)
				{
					t.widget.pickedObject = 0;
					widget_updatewidgetobject();
				}
				t.tentitytoselect = 0;
			}
		}
	}
	else
	{
		if (t.inputsys.mclick == 0)  t.onetimeentitypickup = 0;
	}
}

void ToggleDPIAwareness(bool bDPIAware)
{
	// determine if on or off
	char pDPINotAware[256];
	if (bDPIAware == false)
		strcpy(pDPINotAware, "1");
	else
		strcpy(pDPINotAware, "0");

	// write into registry
	HKEY hKeyNames = 0;
	LPCSTR pSubKeyName = "Software\\GameGuruMAX";
	DWORD dwDisposition;
	DWORD Status = RegCreateKeyExA(HKEY_CURRENT_USER, pSubKeyName, 0L, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS | KEY_WRITE, NULL, &hKeyNames, &dwDisposition);
	if (Status == ERROR_SUCCESS)
	{
		if (dwDisposition == REG_OPENED_EXISTING_KEY)
		{
			RegCloseKey(hKeyNames);
			Status = RegOpenKeyExA(HKEY_CURRENT_USER, pSubKeyName, 0L, KEY_WRITE, &hKeyNames);
		}
	}
	if (hKeyNames != 0)
	{
		if (Status == ERROR_SUCCESS)
		{
			Status = RegSetValueExA(hKeyNames, "DPINotAware", 0, REG_SZ, (LPBYTE)pDPINotAware, (strlen(pDPINotAware) + 1) * sizeof(char));
		}
		RegCloseKey(hKeyNames);
	}
}

void ControlAdvancedSetting(int& setting, const char* tooltip, bool* bLargePreview)
{
	ImGui::Spacing();
	ImGui::Indent(-10);

	bool bState = setting;
	ImVec2 label_size = ImGui::CalcTextSize("View Advanced Settings...", NULL, true);

	// ZJ: The tooltip doesn't work without PushID?
	ImGui::PushID(10000);
	
	ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2((ImGui::GetContentRegionAvailWidth()*0.5) - (label_size.x*0.5) - (ImGui::GetFrameHeight()*0.5), 0.0f));
	if (ImGui::Checkbox("", &bState))
	{
		setting = bState;
	}
	
	char* action = "Show ";
	if (setting)
		action = "Hide ";
	char fullText[MAX_PATH];
	strcpy(fullText, action);
	strcpy(fullText + strlen(action), tooltip);

	if (ImGui::IsItemHovered()) ImGui::SetTooltip(fullText);
	ImGui::PopID();
	ImGui::SameLine();

	if (ImGui::HyberlinkButton("View Advanced Settings##2", ImVec2(label_size.x, 0)))
	{
		extern int iSetSettingsFocusTab;
		extern bool bPreferences_Window;
		iSetSettingsFocusTab = 2;
		bPreferences_Window = true;

		//This is a modal window, so we need to close it to see the settings window.
		if (bLargePreview)
		{
			*bLargePreview = false;
		}
	}

	ImGui::Spacing();
	ImGui::Indent(10);
}

void TestLevel_ToggleBoundary(bool _2d, bool _3d)
{
	if (t.game.gameisexe == 1)
	{
		_2d = false;
		_3d = false;
	}

	if (_2d) 
		ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;
	else 
		ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE;

	if(_3d)
		ggterrain_global_render_params2.flags2 |= GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;
	else 
		ggterrain_global_render_params2.flags2 &= ~GGTERRAIN_SHADER_FLAG2_SHOW_MAP_SIZE_3D;

}

void TestLevel_ToggleTreeVegWater(bool tree, bool veg, bool water, bool terrain)
{
	if (t.game.gameisexe == 0)
	{
		ggtrees_global_params.draw_enabled = tree;
		gggrass_global_params.draw_enabled = veg;
		t.gamevisuals.bWaterEnable = water;
		t.gamevisuals.bEndableTreeDrawing = tree;
		t.gamevisuals.bEndableGrassDrawing = veg;
		t.gamevisuals.bEndableTerrainDrawing = terrain;
	}
}

void LockSelectedObject(bool bLock, int iObjectLockedIndex)
{
	if (bLock)
	{
		int e = t.widget.pickedEntityIndex;
		t.entityelement[e].editorlock = 1 - t.entityelement[e].editorlock;
		sObject* pObject;
		if (t.entityelement[e].obj > 0) {
			pObject = g_ObjectList[t.entityelement[e].obj];
			if (pObject) {
				if (t.entityelement[e].editorlock)
				{
					sRubberBandType vEntityLockedItem;
					vEntityLockedItem.e = e;
					vEntityLockedList.push_back(vEntityLockedItem);
				}
				else {
					//Delete from list.
					for (int i = 0; i < vEntityLockedList.size(); i++)
					{
						if (vEntityLockedList[i].e == e) {
							vEntityLockedList.erase(vEntityLockedList.begin() + i);
							break;
						}
					}
					WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
				}
			}
		}
	}
	else
	{
		int e = t.widget.pickedEntityIndex;
		if (iObjectLockedIndex >= 0) {
			t.entityelement[e].editorlock = 0;
			sObject* pObject;
			if (t.entityelement[e].obj > 0) {
				pObject = g_ObjectList[t.entityelement[e].obj];
				if (pObject) {
					WickedCall_SetObjectRenderLayer(pObject, GGRENDERLAYERS_NORMAL);
				}
			}
			vEntityLockedList.erase(vEntityLockedList.begin() + iObjectLockedIndex);
		}
	}
}
#endif

void InjectIconToExe(char *icon, char *exe,int intresourcenumber)
{
	if (!icon || !exe) return;

	HANDLE hIcon = CreateFileA(icon,
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (!hIcon)
	{
		return;
	}

	LPBYTE lpBuf;
	DWORD dwFileSize, dwBytesRead;

	dwFileSize = GetFileSize(hIcon, NULL);
	lpBuf = (LPBYTE)malloc(dwFileSize);
	if (!lpBuf)
	{
		CloseHandle(hIcon);
		return;
	}

	ReadFile(hIcon, lpBuf, dwFileSize, &dwBytesRead, NULL);
	if (dwBytesRead != dwFileSize)
	{
		free(lpBuf);
		CloseHandle(hIcon);
		return;
	}

	CloseHandle(hIcon);


	HANDLE hUpdateRes;
	hUpdateRes = BeginUpdateResourceA(exe, FALSE);
	if (hUpdateRes == NULL)
	{
		free(lpBuf);
		return;
	}

	//Max english
	#define IDI_GAMEGURUMAX                 102
	if (!UpdateResource(hUpdateRes,
		RT_ICON,
		MAKEINTRESOURCE(intresourcenumber), //MAKEINTRESOURCE(IDI_GAMEGURUMAX),
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		lpBuf+22, dwBytesRead-22)) //PE: Test offset header 22
	{
		free(lpBuf);
		return;
	}

	#pragma pack(push, 1)
	struct myheader
	{
		WORD Reserved;
		WORD ResourceType;
		WORD ImageCount;

		BYTE Width;
		BYTE Height;
		BYTE Colors;
		BYTE Reserved2;
		WORD Planes;
		WORD BitsPerPixel;
		DWORD ImageSize;
		WORD ImageOffset;
	} myheader;
	#pragma pack(pop)
	myheader.Reserved = 0;
	myheader.ResourceType = 1;
	myheader.ImageCount = 1;
	myheader.Width = 0; //256
	myheader.Height = 0; //256
	myheader.Colors = 0;
	myheader.Reserved2 = 0;
	myheader.Planes = 1;
	myheader.BitsPerPixel = 32; //
	myheader.ImageSize = dwBytesRead - 22; //
	myheader.ImageOffset = 1; //

	BOOL b = UpdateResource(hUpdateRes, MAKEINTRESOURCE(RT_GROUP_ICON), MAKEINTRESOURCE(102), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), &myheader, sizeof(myheader));

	if (!EndUpdateResource(hUpdateRes, FALSE))
	{
		free(lpBuf);
		return;
	}

	free(lpBuf);
}

// We call this from when hot swapping entities, and when a smart object is being loaded to a level (see below 'entity_loadelementsdata' for handling of this)
void ReloadEntityIDInSitu ( int entIndex)
{
	// this entity to refreshload
	t.entid = entIndex;

	// Make a backup of the old parent entity, so that we can check what settings have been changed in the entityelements
	entityprofiletype entityBackup = t.entityprofile[entIndex];

	// delete parent entity object as we are going to reload it.
	int parentObj = g.entitybankoffset + entIndex;
	t.entobj = g.entitybankoffset + entIndex;
	if (ObjectExist(t.entobj) == 1) DeleteObject(t.entobj);

	// set entity name and reload it in
	t.entdir_s = "";
	//if (strnicmp(t.entitybank_s[entIndex].Get(), "projectbank", 11) != NULL) 
	t.entdir_s = "entitybank\\";
	t.ent_s = t.entitybank_s[entIndex];
	t.entpath_s = getpath(t.ent_s.Get());

	// need to detect and load 'groups'
	extern int g_iAbortedAsEntityIsGroupFileMode;
	g_iAbortedAsEntityIsGroupFileMode = 1;

	// find parent group ID so stub mode can update group data
	int iUniqueGroupID = 0;
	int iParentGroupIndex = -1;
	if (t.entityprofile[entIndex].model_s == "group" && t.entityprofile[entIndex].groupreference == 1)
	{
		cstr sLookFor = cstr("entitybank\\") + t.entitybank_s[entIndex];
		extern int GetGroupIndexFromName (cstr sLookFor);
		iParentGroupIndex = GetGroupIndexFromName(sLookFor);
		if (iParentGroupIndex >=0 && iParentGroupIndex < MAXGROUPSLISTS)
		{
			if (vEntityGroupList[iParentGroupIndex].size() > 0)
			{
				iUniqueGroupID = vEntityGroupList[iParentGroupIndex][0].iGroupID;
				g_iAbortedAsEntityIsGroupFileModeStubOnly = 2 + iParentGroupIndex;
			}
		}

		// delete the hidden elements of this parent group
		if(iUniqueGroupID>0)
		{ 
			for (int ee = 1; ee <= g.entityelementlist; ee++)
			{
				if (t.entityelement[ee].bankindex > 0)
				{
					if (t.entityelement[ee].y <= -48000.0f) // original smart object elements are buried deep and cloned, they do not count as part of level!
					{
						int thisGroupID = t.entityelement[ee].creationOfGroupID;
						if (thisGroupID > 0 && thisGroupID == iUniqueGroupID)
						{
							t.tentitytoselect = ee;
							entity_deleteentityfrommap();
							ee = 1;
						}
					}
				}
			}
		}
	}

	// now load the modified entity parent in
	g_iAbortedAsEntityIsGroupCreate = 1;
	entity_load();
	g_iAbortedAsEntityIsGroupCreate = 0;

	// ensures no new groups are created, just refreshed
	g_iAbortedAsEntityIsGroupFileModeStubOnly = 0;

	// if entity was a group/smart object
	bool bObjectIsASmartObject = false;
	if (t.entityprofile[entIndex].model_s == "group" && t.entityprofile[entIndex].groupreference == 1)
	{
		// populate with correct group IDs
		if (iParentGroupIndex >= 0 && iParentGroupIndex < MAXGROUPSLISTS)
		{
			for (int n = 0; n < vEntityGroupList[iParentGroupIndex].size(); n++)
			{
				int ee = vEntityGroupList[iParentGroupIndex][n].e;
				t.entityelement[ee].creationOfGroupID = iUniqueGroupID;
				vEntityGroupList[iParentGroupIndex][n].iGroupID = iUniqueGroupID;
			}
		}

		// now find all the children of this parent
		std::vector<sRubberBandType> childrenToRemake;
		childrenToRemake.clear();
		for (int iChildGroupIndex = 0; iChildGroupIndex < MAXGROUPSLISTS; iChildGroupIndex++)
		{
			if (vEntityGroupList[iChildGroupIndex].size() > 0)
			{
				int iThisChildsParentGroupID = vEntityGroupList[iChildGroupIndex][0].iParentGroupID;
				if (iThisChildsParentGroupID > 0 && iThisChildsParentGroupID == iUniqueGroupID)
				{
					// found a child of this changed parent group, collect significant data
					// get leading element of this child group to orient new replacement
					int iThisE = vEntityGroupList[iChildGroupIndex][0].e;
					sRubberBandType item;
					item.iGroupID = iChildGroupIndex;// WARN - just nicking this field for now, replaced with -1 below (we use it to remember the origial group list index)
					// clean quat data up
					if (t.entityelement[iThisE].quatmode > 1)
					{
						// can happen from prev corruption
						t.entityelement[iThisE].quatmode = 1;
					}
					if (t.entityelement[iThisE].quatmode == 1)
					{
						// normalize good quat in case of drift
						GGQUATERNION quatRot;
						quatRot.x = t.entityelement[iThisE].quatx;
						quatRot.y = t.entityelement[iThisE].quaty;
						quatRot.z = t.entityelement[iThisE].quatz;
						quatRot.w = t.entityelement[iThisE].quatw;
						GGQuaternionNormalize(&quatRot);
						t.entityelement[iThisE].quatx = quatRot.x;
						t.entityelement[iThisE].quaty = quatRot.y;
						t.entityelement[iThisE].quatz = quatRot.z;
						t.entityelement[iThisE].quatw = quatRot.w;
					}
					else
					{
						// create fresh quat
						entity_updatequatfromeuler(iThisE);
					}
					item.x = t.entityelement[iThisE].x;
					item.y = t.entityelement[iThisE].y;
					item.z = t.entityelement[iThisE].z;
					item.quatmode = t.entityelement[iThisE].quatmode;
					item.quatx = t.entityelement[iThisE].quatx;
					item.quaty = t.entityelement[iThisE].quaty;
					item.quatz = t.entityelement[iThisE].quatz;
					item.quatw = t.entityelement[iThisE].quatw;
					item.iParentGroupID = iUniqueGroupID;
					childrenToRemake.push_back(item);

					// record this groups logic connections safely before erase child elements
					DuplicateLogicConnectionsCopyOriginal (vEntityGroupList[iChildGroupIndex], iChildGroupIndex);

					// delete all the elements of this child group
					for (int eee = 1; eee <= g.entityelementlist; eee++)
					{
						if (t.entityelement[eee].bankindex > 0)
						{
							if (t.entityelement[eee].y > -48000.0f)
							{
								int thisGroupID = t.entityelement[eee].creationOfGroupID;
								if (thisGroupID > 0 && thisGroupID == iUniqueGroupID)
								{
									t.tentitytoselect = eee;
									g_UndoSysObjectIsBeingMoved = true; // preserve linkIDs to external entity elements!
									entity_deleteentityfrommap();
									g_UndoSysObjectIsBeingMoved = false;
									eee = 1;
								}
							}
						}
					}
				}
			}
		}

		// and replace them in the same places but with their new shape and elements
		if (childrenToRemake.size() > 0)
		{
			for (int i = 0; i < childrenToRemake.size(); i++)
			{
				// for each new child to create, make a duplicate of the parent
				bool bAttachToCursor = false;
				int iOriginalGroupIndexForChild = childrenToRemake[i].iGroupID;
				int iAnchorEntityIndex = DuplicateFromListToCursor(vEntityGroupList[iParentGroupIndex], false, iOriginalGroupIndexForChild, bAttachToCursor);

				// place entity elements into the level using same places as old ones
				if(vEntityGroupList[iOriginalGroupIndexForChild].size()>0)
				{ 
					// base vars used to find difference between child and original from grouplist
					float fBasePosX, fBasePosY, fBasePosZ;
					GGQUATERNION qBaseAngle;

					// remembered position
					fBasePosX = childrenToRemake[i].x - vEntityGroupList[iOriginalGroupIndexForChild][0].x;
					fBasePosY = childrenToRemake[i].y - vEntityGroupList[iOriginalGroupIndexForChild][0].y;
					fBasePosZ = childrenToRemake[i].z - vEntityGroupList[iOriginalGroupIndexForChild][0].z;

					// work out original quat angle
					if (vEntityGroupList[iOriginalGroupIndexForChild][0].quatmode == 0)
					{
						// one time fix if quat not calculated for this vEntityGroupList entry
						GGQUATERNION QuatAroundX, QuatAroundY, QuatAroundZ;
						GGQuaternionRotationAxis(&QuatAroundX, &GGVECTOR3(1, 0, 0), GGToRadian(vEntityGroupList[iOriginalGroupIndexForChild][0].rx));
						GGQuaternionRotationAxis(&QuatAroundY, &GGVECTOR3(0, 1, 0), GGToRadian(vEntityGroupList[iOriginalGroupIndexForChild][0].ry));
						GGQuaternionRotationAxis(&QuatAroundZ, &GGVECTOR3(0, 0, 1), GGToRadian(vEntityGroupList[iOriginalGroupIndexForChild][0].rz));
						GGQUATERNION quatNewOrientation = QuatAroundX * QuatAroundY * QuatAroundZ;
						vEntityGroupList[iOriginalGroupIndexForChild][0].quatmode = 1;
						vEntityGroupList[iOriginalGroupIndexForChild][0].quatx = quatNewOrientation.x;
						vEntityGroupList[iOriginalGroupIndexForChild][0].quaty = quatNewOrientation.y;
						vEntityGroupList[iOriginalGroupIndexForChild][0].quatz = quatNewOrientation.z;
						vEntityGroupList[iOriginalGroupIndexForChild][0].quatw = quatNewOrientation.w;
					}
					GGQUATERNION qInvOrigAngle;
					GGQUATERNION qOrigAngle = GGQUATERNION(vEntityGroupList[iOriginalGroupIndexForChild][0].quatx, vEntityGroupList[iOriginalGroupIndexForChild][0].quaty, vEntityGroupList[iOriginalGroupIndexForChild][0].quatz, vEntityGroupList[iOriginalGroupIndexForChild][0].quatw);
					GGQuaternionConjugate(&qInvOrigAngle, &qOrigAngle);

					// remembered angle (as above with pos, subtract original)
					int quatmode = childrenToRemake[i].quatmode;
					float quatx = childrenToRemake[i].quatx;
					float quaty = childrenToRemake[i].quaty;
					float quatz = childrenToRemake[i].quatz;
					float quatw = childrenToRemake[i].quatw;
					qBaseAngle = GGQUATERNION(quatx, quaty, quatz, quatw);
					GGQuaternionMultiply(&qBaseAngle, &qInvOrigAngle, &qBaseAngle);

					// go through all entity elements to set them in correct position and assign quats
					for (int n = 0; n < vEntityGroupList[iOriginalGroupIndexForChild].size(); n++)
					{
						// set start in correct position/rotation
						int ee = vEntityGroupList[iOriginalGroupIndexForChild][n].e;
						t.entityelement[ee].x = fBasePosX + vEntityGroupList[iOriginalGroupIndexForChild][n].x;
						t.entityelement[ee].y = fBasePosY + vEntityGroupList[iOriginalGroupIndexForChild][n].y;
						t.entityelement[ee].z = fBasePosZ + vEntityGroupList[iOriginalGroupIndexForChild][n].z;
						t.entityelement[ee].quatmode = vEntityGroupList[iOriginalGroupIndexForChild][n].quatmode;
						t.entityelement[ee].quatx = vEntityGroupList[iOriginalGroupIndexForChild][n].quatx;
						t.entityelement[ee].quaty = vEntityGroupList[iOriginalGroupIndexForChild][n].quaty;
						t.entityelement[ee].quatz = vEntityGroupList[iOriginalGroupIndexForChild][n].quatz;
						t.entityelement[ee].quatw = vEntityGroupList[iOriginalGroupIndexForChild][n].quatw;

						// and update to correct unique group ID
						t.entityelement[ee].creationOfGroupID = iUniqueGroupID;

						// ensure the object is updated, needed below
						PositionObject(t.entityelement[ee].obj, t.entityelement[ee].x, t.entityelement[ee].y, t.entityelement[ee].z);
					}

					// now rotate all the elements around the first object
					int iFirstE = vEntityGroupList[iOriginalGroupIndexForChild][0].e;
					int iActiveObj = t.entityelement[iFirstE].obj;
					if (ObjectExist(iActiveObj) == 1)
					{
						// rotation event
						GGQUATERNION quatRotationEvent = qBaseAngle;
						RotateObjectQuat(iActiveObj, quatx, quaty, quatz, quatw);
						SetStartPositionsForRubberBand(iActiveObj);
						RotateAndMoveRubberBand(iActiveObj, 0, 0, 0, quatRotationEvent);

						// ensure the root object (active object) also gets its rotation!
						t.entityelement[iFirstE].rx = ObjectAngleX(iActiveObj);
						t.entityelement[iFirstE].ry = ObjectAngleY(iActiveObj);
						t.entityelement[iFirstE].rz = ObjectAngleZ(iActiveObj);

						// update entity quat as the preferred source rotation
						entity_updatequatfromeuler(iFirstE);
					}
				}

				// and we have finished with this temp value
				childrenToRemake[i].iGroupID = -1;
			}
			childrenToRemake.clear();
		}
	}
	else
	{
		// The parent non-smart entity has now been reloaded, so we are free to also reload any entities that use its model
		for (int e = 1; e < t.entityelement.size(); e++)
		{
			if (t.entityelement[e].bankindex == entIndex)
			{
				// The model for this entity uses the model that we just reloaded, so we also need to reload this entities obj
				// we deliberately NOT change/reset the properties of this entity element as they are user-defined values
				// we only swap in the new model and textures as this is often what an artist is tweaking!
				t.e = e;
				t.tte = e;
				t.tupdatee = e;
				t.tentid = entIndex;
				t.tobj = t.entityelement[e].obj;
				entity_updateentityobj();
			}
		}
	}

	// as a final step, ensure all custom material settings are removed as the replaced object may not line up with old one
	for (int e = 1; e < t.entityelement.size(); e++)
	{
		if (t.entityelement[e].bankindex == entIndex)
		{
			t.entityelement[e].eleprof.bCustomWickedMaterialActive = false;
		}
	}
}

// Check if any files have been modified since we launched Max (note: this only checks files in MainEntityList) - any other files will not be detected.
void CheckExistingFilesModified(bool bResetTimeStamp)
{
	// Users can turn this feature off if it causes slowdowns.
	if (pref.iCheckFilesModifiedOnFocus == 0 || t.game.gameisexe == 1 || bImGuiInTestGame == true )
		return;

	// lists to monitor level media changes (cannot use folderfiles structure as DBOs are not listed)
	std::vector<int> currentLevelObjectID;
	std::vector<std::string> currentLevelFiles;
	std::vector<std::string> currentLevelFilesAbsolute;

	// static map for retaining timestamps of last collection
	static std::map<std::string, time_t> currentLevelTimeStamp;
	if (bResetTimeStamp == true) currentLevelTimeStamp.clear();

	// scan for all media to find FPEs used in current level
	extern cFolderItem MainEntityList;
	cFolderItem* pFolder = &MainEntityList;
	if (pFolder)
	{
		while (pFolder)
		{
			if (pFolder->m_pFirstFile)
			{
				char folderPath[MAX_PATH];
				strcpy(folderPath, pFolder->m_sFolderFullPath.Get());
				char folderRelPath[MAX_PATH];
				//PE: Crash here if folder only listing. 
				if(pFolder->m_iEntityOffset+1 < pFolder->m_sFolderFullPath.Len())
					strcpy(folderRelPath, pFolder->m_sFolderFullPath.Get() + pFolder->m_iEntityOffset + 1);
				else
					strcpy(folderRelPath, pFolder->m_sFolderFullPath.Get());
				cFolderItem::sFolderFiles* pFolderFile = pFolder->m_pFirstFile;
				pFolderFile = pFolder->m_pFirstFile->m_pNext;
				while (pFolderFile)
				{
					if (strcmp(pFolderFile->m_sName.Get() + strlen(pFolderFile->m_sName.Get()) - 3, "fpe") == 0)
					{
						// construct matching path and entity name
						char pSearchPattern[MAX_PATH];
						strcpy(pSearchPattern, folderRelPath);
						strcat(pSearchPattern, "\\");
						strcat(pSearchPattern, pFolderFile->m_sName.Get());

						// found an FPE, determine if in current level
						for (int entid = 0; entid < t.entitybank_s.size(); entid++)
						{
							if (stricmp(pSearchPattern, t.entitybank_s[entid].Get()) == NULL)
							{
								// add FPE for check
								char pFullFileAbsPath[MAX_PATH];
								strcpy(pFullFileAbsPath, folderPath);
								strcat(pFullFileAbsPath, "\\");
								strcat(pFullFileAbsPath, pFolderFile->m_sName.Get());
								if (FileExist(pFullFileAbsPath))
								{
									currentLevelFilesAbsolute.push_back(pFullFileAbsPath);
									char pFileToAdd[MAX_PATH];
									strcpy(pFileToAdd, folderRelPath);
									strcat(pFileToAdd, "\\");
									strcat(pFileToAdd, pFolderFile->m_sName.Get());
									currentLevelObjectID.push_back(entid); currentLevelFiles.push_back(pFileToAdd);

									// add model DBO inside FPE
									if (strlen(t.entityprofile[entid].model_s.Get()) > 0)
									{
										strcpy(pFileToAdd, folderRelPath);
										strcat(pFileToAdd, "\\");
										strcat(pFileToAdd, t.entityprofile[entid].model_s.Get());
										currentLevelObjectID.push_back(entid); currentLevelFiles.push_back(pFileToAdd);
										strcpy(pFullFileAbsPath, folderPath);
										strcat(pFullFileAbsPath, "\\");
										strcat(pFullFileAbsPath, t.entityprofile[entid].model_s.Get());
										currentLevelFilesAbsolute.push_back(pFullFileAbsPath);
									}

									// add any textures used by FPE
									if (strlen(t.entityprofile[entid].texd_s.Get()) > 0)
									{
										strcpy(pFileToAdd, folderRelPath);
										strcat(pFileToAdd, "\\");
										strcat(pFileToAdd, t.entityprofile[entid].texd_s.Get());
										currentLevelObjectID.push_back(entid); currentLevelFiles.push_back(pFileToAdd);
										strcpy(pFullFileAbsPath, folderPath);
										strcat(pFullFileAbsPath, "\\");
										strcat(pFullFileAbsPath, t.entityprofile[entid].texd_s.Get());
										currentLevelFilesAbsolute.push_back(pFullFileAbsPath);
									}

									// and include all textures referenced with new PBR texture sets
									for (int iAllObjectTexturesIndex = 0; iAllObjectTexturesIndex <= 5; iAllObjectTexturesIndex++)
									{
										for (int i = 0; i < MAXMESHMATERIALS; i++)
										{
											// work out pImgFileRef
											LPSTR pImgFileRef = "";
											if (iAllObjectTexturesIndex == 0) pImgFileRef = t.entityprofile[entid].WEMaterial.baseColorMapName[i].Get();
											if (iAllObjectTexturesIndex == 1) pImgFileRef = t.entityprofile[entid].WEMaterial.normalMapName[i].Get();
											if (iAllObjectTexturesIndex == 2) pImgFileRef = t.entityprofile[entid].WEMaterial.surfaceMapName[i].Get();
											if (iAllObjectTexturesIndex == 3) pImgFileRef = t.entityprofile[entid].WEMaterial.emissiveMapName[i].Get();
											if (iAllObjectTexturesIndex == 4) pImgFileRef = t.entityprofile[entid].WEMaterial.displacementMapName[i].Get();
											#ifndef DISABLEOCCLUSIONMAP
											if (iAllObjectTexturesIndex == 5) pImgFileRef = t.entityprofile[entid].WEMaterial.occlusionMapName[i].Get();
											#endif
											if (pImgFileRef && strlen(pImgFileRef) > 0)
											{
												// add DDS texture file
												strcpy(pFileToAdd, folderRelPath);
												strcat(pFileToAdd, "\\");
												strcat(pFileToAdd, pImgFileRef);
												currentLevelObjectID.push_back(entid); currentLevelFiles.push_back(pFileToAdd);
												strcpy(pFullFileAbsPath, folderPath);
												strcat(pFullFileAbsPath, "\\");
												strcat(pFullFileAbsPath, pImgFileRef);
												currentLevelFilesAbsolute.push_back(pFullFileAbsPath);
											}
										}
									}
								}
							}
						}
					}
					pFolderFile = pFolderFile->m_pNext;
				}
			}
			pFolder = pFolder->m_pNext;
		}
	}

	// special static map can track timestamp changes
	if (currentLevelTimeStamp.size() == 0)
	{
		for (int iIndex = 0; iIndex < currentLevelFilesAbsolute.size(); iIndex++)
		{
			LPSTR filePath = (LPSTR)currentLevelFilesAbsolute[iIndex].c_str();
			bool bFoundInMap = false;
			std::map<std::string, time_t>::iterator it = currentLevelTimeStamp.begin();
			while (it != currentLevelTimeStamp.end())
			{
				if (stricmp(filePath, it->first.c_str()) == NULL)
				{
					bFoundInMap = true;
					break;
				}
				it++;
			}
			if (bFoundInMap == false)
			{
				struct stat sb;
				stat(filePath, &sb);
				currentLevelTimeStamp.insert(std::make_pair(filePath, sb.st_mtime));
			}
		}
	}

	// scan all current level files, detect any changes
	std::vector<int> modifiedEntityObject;
	for (int iIndex = 0; iIndex < currentLevelFilesAbsolute.size(); iIndex++)
	{
		// Get the time that the file was last modified.
		struct stat sb;
		LPSTR pFileToCheck = (LPSTR)currentLevelFilesAbsolute[iIndex].c_str();
		if (stat(pFileToCheck, &sb) == 0)
		{
			bool bFoundInMap = false;
			std::map<std::string, time_t>::iterator it = currentLevelTimeStamp.find(pFileToCheck);
			if (it != currentLevelTimeStamp.end())
			{
				if (stricmp(pFileToCheck, it->first.c_str()) == NULL)
				{
					bFoundInMap = true;
					if (sb.st_mtime != it->second)
					{
						// This file has been modified. Add to list of modified files (we will update any entities using them later)
						it->second = sb.st_mtime;
						modifiedEntityObject.push_back(currentLevelObjectID[iIndex]);

						// can take extra actions for specific media to be updated
						if (stricmp(pFileToCheck + strlen(pFileToCheck) - 3, "dds") == NULL)
						{
							// textures will not update, they will reference previously loaded, so delete the image from that list
							char pImageFile[MAX_PATH];
							strcpy(pImageFile, "");
							LPSTR pFile = (LPSTR)currentLevelFiles[iIndex].c_str();
							//if (strnicmp(pFile, "projectbank", 11) != NULL) 
							strcat(pImageFile, "entitybank\\");
							strcat(pImageFile, pFile);
							WickedCall_DeleteImage(pImageFile);
						}
					}
				}
			}
			if (bFoundInMap == false)
			{
				// new file to add to timestamp map
				currentLevelTimeStamp.insert(std::make_pair(pFileToCheck, sb.st_mtime));
			}
		}
	}

	// Remove all duplicate entIDs and add to new sorted list
	std::vector<int> modifiedEntityObjectReduced;
	for (int i = 0; i < modifiedEntityObject.size(); i++)
	{
		int iUniqueEntityID = modifiedEntityObject[i];
		if (iUniqueEntityID > 0)
		{
			for (int i2 = 0; i2 < modifiedEntityObject.size(); i2++)
			{
				if (modifiedEntityObject[i2] == iUniqueEntityID)
				{
					modifiedEntityObject[i2] = 0;
					i = 0;
				}
			}
			modifiedEntityObjectReduced.push_back(iUniqueEntityID);
		}
	}

	// Update any entities that use the modified files
	for (auto& entIndex : modifiedEntityObjectReduced)
	{
		// update this entity
		ReloadEntityIDInSitu(entIndex);
	}

	// final prompt to inform user of the updated media
	if (modifiedEntityObjectReduced.size() > 0)
	{
		bTriggerMessage = true;
		sprintf(cTriggerMessage, "External media changes detected. %d items of media updated!", modifiedEntityObjectReduced.size());
		modifiedEntityObjectReduced.clear();
	}
}

//#pragma optimize("", off)
int DrawOccludedObjects(bool bDebug,bool bBox, int* iHiddenObjects, int* spot, int* point)
{
	int total = 0;
	if(iHiddenObjects)
		*iHiddenObjects = 0;
	if (point)
		*point = 0;
	if(spot)
		*spot = 0;
	for (t.e = 1; t.e <= g.entityelementlist; t.e++)
	{
		if (t.entityelement[t.e].obj > 0)
		{
			t.obj = t.entityelement[t.e].obj;
			sObject* pObject = g_ObjectList[t.obj];
			if (pObject)
			{
				if (pObject->bVisible)
				{
					for (int i = 0; i < pObject->iFrameCount; i++)
					{
						sFrame* pFrame = pObject->ppFrameList[i];
						if (pFrame && pFrame->pMesh)
						{
							uint64_t rootEntity = pFrame->wickedobjindex;
							ObjectComponent* object = wiScene::GetScene().objects.GetComponent(rootEntity);
							if (object)
							{
								if (object->IsOccluded() || object->IsCulled())
								{
									if(object->IsOccluded())
										total++;
									if (bDebug)
									{

										XMFLOAT3 center = object->center; // aabb.getCenter();
										void DrawDot(char* text, float x, float y, float z);

										if(t.entityelement[t.e].bankindex > 0 && t.entityprofile[t.entityelement[t.e].bankindex].ischaracter)
											DrawDot("*", center.x, center.y, center.z);
										else if(object->IsCulled())
											DrawDot(".", center.x, center.y, center.z);
										else
											DrawDot("-", center.x, center.y, center.z);
									}
								}
								else
								{
									if (bBox)
									{
										AABB* aabb = wiScene::GetScene().aabb_objects.GetComponent(rootEntity);
										if (aabb)
										{
											XMFLOAT4X4 hoverBox;
											XMStoreFloat4x4(&hoverBox, aabb->getAsBoxMatrix());
											wiRenderer::DrawBox(hoverBox, XMFLOAT4(1.0f, 1.0f, 0.0f, 1.0f));

											//PE: Expanded bounding box.
											/*
											XMMATRIX transform;
											const float expand = 2.5f;
											//extern wiScene::CameraComponent camera_previous;
											wiScene::CameraComponent& camera_previous = wiScene::GetCamera();
											XMMATRIX VP = camera_previous.GetViewProjection();
											XMFLOAT3 ext = aabb->getHalfWidth();
											ext.x++;
											ext.y++;
											ext.z++;
											XMMATRIX sca = XMMatrixScaling(ext.x * expand, ext.y * expand, ext.z * expand);
											XMFLOAT3 pos = aabb->getCenter();
											XMMATRIX tra = XMMatrixTranslation(pos.x, pos.y, pos.z);
											transform = (sca * tra); // *VP;
											XMStoreFloat4x4(&hoverBox, transform);
											wiRenderer::DrawBox(hoverBox, XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f));
											*/
										}
									}
								}
								//break;
							}
						}
					}
				}
				else
				{
					if (iHiddenObjects)
						*iHiddenObjects = *iHiddenObjects + 1;
				}
			}
		}
	}
	if (bDebug)
	{
		int lsize = wiScene::GetScene().lights.GetCount();
		for (int i = 0; i < lsize; i++)
		{
			LightComponent& light = wiScene::GetScene().lights[i];
			if (light.IsCastingShadow())
			{
				if (light.GetType() == ENTITY_TYPE_POINTLIGHT)
				{
					if (point)
						*point = *point + 1;
					AABB aabb = wiScene::GetScene().aabb_lights[i];
					XMFLOAT3 center = aabb.getCenter();
					void DrawDot(char* text, float x, float y, float z);
					if (light.history == 0)
					{
						DrawDot("p", center.x, center.y, center.z);
					}
					else
					{
						t.tdiffx_f = center.x - CameraPositionX();
						t.tdiffy_f = center.y - CameraPositionY();
						t.tdiffz_f = center.z - CameraPositionZ();
						float dist = Sqrt(abs(t.tdiffx_f * t.tdiffx_f) + abs(t.tdiffy_f * t.tdiffy_f) + abs(t.tdiffz_f * t.tdiffz_f));
						std::string sdist = "P: " + std::to_string((int)dist);
						DrawDot( (char *) sdist.c_str(), center.x, center.y, center.z);
					}
				}
				if (light.GetType() == ENTITY_TYPE_SPOTLIGHT)
				{
					if (spot)
						*spot = *spot + 1;
					AABB aabb = wiScene::GetScene().aabb_lights[i];
					XMFLOAT3 center = aabb.getCenter();
					void DrawDot(char* text, float x, float y, float z);
					if (light.history == 0)
					{
						DrawDot("s", center.x, center.y, center.z);
					}
					else
					{
						t.tdiffx_f = center.x - CameraPositionX();
						t.tdiffy_f = center.y - CameraPositionY();
						t.tdiffz_f = center.z - CameraPositionZ();
						float dist = Sqrt(abs(t.tdiffx_f * t.tdiffx_f) + abs(t.tdiffy_f * t.tdiffy_f) + abs(t.tdiffz_f * t.tdiffz_f));
						std::string sdist = "S: " + std::to_string((int)dist);
						DrawDot((char *)sdist.c_str(), center.x, center.y, center.z);
					}
				}
			}
		}
	}
	return total;
}
//#pragma optimize("", on)

void DrawDot(char* text, float x, float y, float z)
{
	ImGuiContext& g = *GImGui;
	ImGuiViewport* mainviewport = ImGui::GetMainViewport();
	ImDrawList* dl = ImGui::GetForegroundDrawList(mainviewport);
	if (dl)
	{
		float fontscale = 1.25;
		ImVec2 v2DPos = Convert3DTo2D(x, y, z);
		dl->AddText(g.Font, g.FontSize * fontscale, v2DPos, ImGui::GetColorU32(ImVec4(1.0, 1.0, 0.4, 1.0)), text); // ImGui::GetColorU32(ImGuiCol_Text)
	}

}

void tmpdebugfunc(void)
{
	ImGuiViewport* viewport = ImGui::GetMainViewport();
	ImVec2 window_pos = ImVec2((viewport->Pos.x + viewport->Size.x - 10.0f), (viewport->Pos.y + 10.0f));
	ImDrawList* draw = ImGui::GetForegroundDrawList();
	extern ImFont* customfont;
	if (draw && customfont)
	{
		extern bool bProfilerEnable;
		if (bProfilerEnable == false)
		{
			bProfilerEnable = true;
			wiProfiler::SetEnabled(true);
		}

		wiScene::Scene* pScene = &wiScene::GetScene();
		int iObjects = pScene->objects.GetCount();
		int iFrustumCulled = wiProfiler::GetFrustumCulled();
		int dc = wiProfiler::GetDrawCalls();
		int iHiddenObjects = 0;
		int spot = 0, point = 0;
		int occ = DrawOccludedObjects(true,false,&iHiddenObjects,&spot,&point);

		//ImGui::Text("DrawCalls: %d", dc);
		char memtmp[255];
		float wide = 200;// 160;
		sprintf(memtmp, "DC: %d OC: %d FC: %d T: %d", dc, occ, iFrustumCulled,iObjects);
		draw->AddText(customfont, 15, ImVec2(window_pos.x - wide, viewport->Pos.y + 23.0), IM_COL32(255, 255, 255, 255), memtmp);

		extern uint32_t iCulledPointShadows;
		int tpoint = WickedCall_GetCubeShadowLights(true);
		sprintf(memtmp, "T: %d PointShadows: %d", tpoint,iCulledPointShadows);
		draw->AddText(customfont, 15, ImVec2(window_pos.x - wide, viewport->Pos.y + 35.0), IM_COL32(255, 255, 255, 255), memtmp);

		extern uint32_t iCulledSpotShadows;
		int iSpot = WickedCall_GetSpotShadowLights(true);
		sprintf(memtmp, "T: %d SpotShadows: %d", iSpot, iCulledSpotShadows);
		draw->AddText(customfont, 15, ImVec2(window_pos.x - wide, viewport->Pos.y + 47.0), IM_COL32(255, 255, 255, 255), memtmp);

		//bool bEnableTerrainChunkCulling = true;
		//bool bEnablePointShadowCulling = true;
		//bool bEnableSpotShadowCulling = true;
		//bool bEnableObjectCulling = true;


	}
}
